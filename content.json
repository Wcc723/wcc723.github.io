{"meta":{"title":"卡斯伯 Blog - 前端，沒有極限","subtitle":null,"description":null,"author":"Wang Casper","url":"https://wcc723.github.io"},"pages":[{"title":"tags","date":"2016-10-11T08:21:43.000Z","updated":"2016-10-11T08:22:23.000Z","comments":true,"path":"tags/index.html","permalink":"https://wcc723.github.io/tags/index.html","excerpt":"","text":""},{"title":"卡斯伯 前端作品實戰直播班預約","date":"2021-09-12T07:28:32.000Z","updated":"2021-12-05T03:11:08.557Z","comments":true,"path":"about/hexschool-traning.html","permalink":"https://wcc723.github.io/about/hexschool-traning.html","excerpt":"","text":"Vue 3 作品實戰班課程說明求職缺少獨立的作品嗎？或是想更精進前端的作品！？「Vue 3 作品實戰班」不僅教你實戰技巧，更帶你完成獨一無二的網站作品！ 下次開課時間：2022 年 1 月 ～ 3 月 課程介紹頁面：https://hex.school/fPKVU 授課講師：卡斯伯 預計開放註冊時間：2021 年 11 月 課程包含哪些內容：Youtube 線上說明 課程包含哪些內容：圖文介紹版 學習目標： 學習實戰必備的 JS 技巧（資料處理、AJAX、ES6） 了解 Vue.js 使用方式（元件、生命週期、套件運用、Vue CLi） 完成獨立的面試作品 學員作品牆：https://works.hexschool.io/#/ 課程頁面 2021 完課學員心得： Iven Liu：自從出社會之後，就再也沒有人會向學校老師一樣，不藏私的把自己會的分享給你，真心的希望你學會、成長。但是在六角我看到了這塊，不論是老師、助教、同學，只要你有問題，每個人都是真心真意的幫助你，真心真意的希望你學會。 TSENG FU CHUN / 豆腐：介紹 this 的影音課程之後打算回頭再複習，因為老師真的講解的很清楚。 chiayu：目的就是希望每個學生都能有一個獨一無二的電商作品，老師和助教也都是花了很多心思在審閱我們的Code，真的是辛苦他們了 Tori：以前看不懂的邏輯和技巧，現在都可以很快地寫出來，並得到自己想要的結果 jarvis1993：如你缺少面試作品和想要學習變強的心，那我一定首推你六角學院的直播班！！不僅可讓你少花費不必要的費用和時間 Jemma：老師非常的有耐心，教學狀態是完全切入新手的視角在教，課程上的舉例讓我能完全融入並吸收，每一次的主要作業，老師跟助教都會親自做一遍給同學看 Jiang V：哪個單位課程會一直再加碼免費直播啦，而且都是兩小時在起跳的，真的好感謝六角讓我帶來自信，完全不怕作業寫不出來了~ Peggyted：覺得六角和別家不一樣的是，售後服務超好，絕對不會售後不理你 晃晃：基本上就是寫完就上線了，不然就是同事怕得罪人也不敢認真給建議，這個批改服務真的很棒。 2020 完課學員心得： Chloe：實作真的差很多，以前聽線上課程都不會練習到這麼徹底，就像老師說的，看看兩個月前的自己，我們現在強很多，傳值傳參考我們都分得清楚了，who is this? This is me. 也搞懂 this 是誰了 XD，CRUD api 的操作我們也會了。 Miko：最大也最意外的收穫，就是拆解程式流程的習慣。以往在寫程式的時候，只會在腦海裡大概規劃一下流程圖而已，幸好老師有加碼開課講解，不但仔細講解、引導大家作業的觀念，也在課程中示範拆解流程，跟著老師的腳步才發現原來好好的列出專案的流程，可以讓專案瞬間看起來簡化很多，可以更有條理的思考每一個步驟。 Ruta：如果你已經自學一年(或以上)但卻沒有踏實感或明顯成果，我非常推薦你來參加六角學院舉辦的直播班課程。兩個月結束後，會能很明顯感受到自己有所成長，甚至超過以前自己一年的學習成效。 Lois：還有一堆加碼加不停的東西，真的很物超所值，而且成長曲線真的遠遠打趴過去半年的自學，程度爆炸性增長，現在的我除了Vue框架的技巧以外，也已經不害怕看文件、願意挑戰使用各種套件、git也開始有點了解了，若你想快速提升自己的實力，這堂課真的很值得你報名！ ABow：比較兩個月前剛加入直播班，及兩個月後正在逐步完成最終作業的自己，我比較不害怕看 Vue 的程式碼，而且能理解別人為什麼要這樣寫。 YU：六角學院絕對是轉職路途中優美延綿的風景，但還是要繼續走下去，像是把後台做完才能繳交第八週作業 XDDD Siling：八週前的我還搞不清楚function(e)的這個e是啥東西，現在終於理解，並往前跨了一大步，雖然離可以行雲流水的用嘴寫程式還是有超大一段距離，但找到方向前進了，覺得很開心😀 Pandaa：有很多跟你一起努力的同學，這跟買課程回來自己學是很不一樣的，我以前買過的課程都沒有看完過，但是直播班真的會讓自己有動力去跟大家一起進步"},{"title":"關於卡斯伯","date":"2019-11-12T07:28:32.000Z","updated":"2019-11-12T07:29:03.877Z","comments":true,"path":"about/index.html","permalink":"https://wcc723.github.io/about/index.html","excerpt":"","text":"六角學院共同創辦人 個人粉絲專頁：https://www.facebook.com/WccCasper 本科技能為視覺設計，後來轉為前端工程師 學習經歷參考：https://wcc723.github.io/ironman/2019/09/19/became-a-webdesigner/ 專長為 Bootstrap、Sass、JavaScript、Vue.js … 相關線上課程可參考：https://www.hexschool.com/"}],"posts":[{"title":"一個工具，帶你完整認識 CSS Animation","slug":"css-animation","date":"2021-10-03T16:00:00.000Z","updated":"2021-10-04T08:03:42.353Z","comments":true,"path":"development/2021/10/04/css-animation/","link":"","permalink":"https://wcc723.github.io/development/2021/10/04/css-animation/","excerpt":"","text":"網頁上看到許多 CSS Animation 套效想要參考使用，但卻不知道其中的屬性各自代表什麼意思嗎？本篇將介紹 CSS Animation 的各項屬性運用技巧，並提供一個模擬工具，讓大家可以快速的了解每個屬性的意義。 建立第一個動畫在學習每一個屬性之前，首先先動手試試看讓一個元素套用動態的效果，在這之中我們需要先認識兩個語法 animation 及 @keyframe： @keyframes: 影格，就像是戲中每個角色在 特定時間點需要呈現的狀態 animation: 動畫，決定實際演出時的播放方式，包含速率、正反轉都可以調整 步驟一：建立 @keyframeCSS Animation 看起來主角應該是 animation 屬性，但實際決定元素是如何運作的是 @keyframes，顧名思義是「影格」的意思，用來決定每個階段元素所套用的樣式。 而它的結構比較不一樣，看起來會比較像是 @media query，會包含以下的語法： 使用 @keyframes 定義，後面包含其自訂名稱 使用 form...to、% 等各種方式定義每個階段的影格變化 在 &#123; ... &#125; 中定義元素在該影格所套用的樣式 撰寫結構如下： /* 使用 `@keyframes` 定義，後面包含其自訂名稱 */ @keyframes rotate-keyframe &#123; /* 定義每個階段的影格變化 */ from &#123; /* 定義元素在該影格所套用的樣式 */ transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; &#125; from...to 是只有頭尾的撰寫方式，如果要加入更多階段的影格樣式，可以使用 %，寫法概念如下： /* 使用 `@keyframes` 定義，後面包含其自訂名稱 */ @keyframes rotate-keyframe &#123; /* 定義每個階段的影格變化 */ 0% &#123; /* 定義元素在該影格所套用的樣式 */ transform: rotate(0deg); &#125; 50% &#123; transform: rotate(180deg); &#125; 100% &#123; transform: rotate(360deg); &#125; &#125; 步驟二：套用 animation 並載入影格實作中會建議先準備好 @keyframes，才能確保 animation 是可以運作的，套用時請注意： animation 需要對應一個 @keyframes 的名稱 至少要包含兩個屬性才能運作 - animation-name(@keyframes 名稱)、animation-duration (動畫持續時間) .box &#123; height: 100px; width: 100px; display: inline-block; background-color: orange; &#125; .rotate &#123; animation-name: rotate-keyframe; /* 套用的 keyframe */ animation-duration: 3s; /* 動畫持續時間 */ animation-iteration-count: infinite; /* 動畫播放次數 */ animation-timing-function: linear; /* 影片加速速率 */ &#125; @keyframes rotate-keyframe &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; &#125; &lt;div class=&quot;box rotate&quot;&gt;&lt;/div&gt; 透過以上的程式碼，就可以做出以下的旋轉方塊效果。 .box { height: 100px; width: 100px; display: inline-block; background-color: orange; } .rotate { animation-name: rotate-keyframe; animation-duration: 3s; animation-iteration-count: infinite; animation-timing-function: linear; } .move { animation-name: move-object; animation-duration: 1.5s; animation-iteration-count: infinite; animation-timing-function: linear; } @keyframes rotate-keyframe { from { transform: rotate(0deg); } to { transform: rotate(360deg); } } @keyframes move-object { 0% { transform: translateX(0); } 100% { transform: translateX(200%); } } 認識每一個 animation 屬性相信透過以上流程，就大致知道如何產生一個動畫效果，趁著有點熟悉的狀態下，持續學習完 Animation 的各項常用屬性吧。 animation-name：必要屬性決定動畫所套用的 @keyframes 其值必定會是自訂的 keyframes 名稱，如果 CSS 中沒有 keyframes 將無法運作。 animation-duration：必要屬性決定動畫演示一次的時間長短，撰寫時務必加入單位（s 秒、ms 毫秒…），寫法參考如下 animation-duration: 3s; animation-duration: 240ms; animation-iteration-count ⭐⭐⭐動畫播放次數，可以填入數值（整數，或是包含小數點均可），或者可以使用 infinite 表示無限次重複播放。 animation-iteration-count: infinite; animation-iteration-count: 1; animation-iteration-count: 2.5; animation-timing-function ⭐⭐⭐動畫效果轉換的速率，如果善加運用可以讓元素動態更具有生命力，animation 的運用好壞將與此屬性有極大的關係。套用的值非常靈活，包含： 各種 Timing Function 例如：ease、ease-in、ease-in-out、linear… 使用階段的方式定義，如：steps(8, end)（套用八個階段完成影格 使用貝茲曲線定義動態轉換效果，如：cubic-bezier(0.1, 0.7, 1.0, 0.1)，會建議直接使用工具 產生貝茲數值。 寫法參考如下： animation-timing-function: ease; animation-timing-function: ease-in; animation-timing-function: ease-out; animation-timing-function: linear; /* 線性的速率 */ animation-timing-function: steps(5, end); /* 階段性的轉換 */ animation-timing-function: cubic-bezier(.4,.94,.56,1.59); /* 自訂義貝茲轉換速率 */ 套用 cubic-bezier 甚至可以讓元素會有反彈的感覺 animation-direction ⭐⭐動畫播放正向或是反向播放，也可以設定為單數次正向播放、雙數次為反向的運行狀態。 animation-direction: normal; /* 正向播放 */ animation-direction: reverse; /* 反向播放 */ animation-direction: alternate; /* 單數次為正向播放，雙數次為反向播放 */ animation-direction: alternate-revers; /* 與前者相反，雙數次為正向播放，單數次為反向播放 */ alternate 簡單來說就是一次正向、一次反向的播放方式 animation-play-state ⭐決定當前的動畫是否暫停，包含 running、paused 的屬性。 animation-play-state: running; animation-play-state: paused; animation-fill-mode ⭐定義動畫在播放完成的停留呈現狀態。 animation-fill-mode: forwards; /* 停留在結束的狀態 */ animation-fill-mode: backwards; /* 停留在剛開始的狀態 */ animation-fill-mode: both; /* 依據開始或結束決定呈現的狀態 */ animation-delay ⭐第一次播放動畫時所延遲的時間 animation-delay: 0; animation-delay: 3s; 動手試試看 CSS Animation看完本篇文章，相信對於 CSS Animation 有基本的認識，接下來就直接動手玩玩看，了解 CSS Animation 的魅力吧 {{ ani.name.replace('animation-', '')}} ({{ ani.description }}) 不設定 {{ item }} 運作時所套用的 CSS 程式碼 .animation &#123; &#123;&#123; key &#125;&#125;: &#123;&#123; item &#125;&#125;;&#125; @keyframes rotate-keyframe &#123; from &#123; transform: rotate(0deg); &#125; to &#123; transform: rotate(360deg); &#125; &#125; @keyframes move-object &#123; 0% &#123; transform: translateX(0); &#125; 100% &#123; transform: translateX(200%); &#125; &#125; const { reactive, ref } = Vue; const app = Vue.createApp({ setup() { const animationStyle = reactive({ animationName: { name: 'animation-name', description: '*動畫所套用的 keyframe 名稱', properties: [ 'rotate-keyframe', 'move-object', ] }, animationDuration: { name: 'animation-duration', description: '*動畫持續時間', properties: [ '1s', '3s', '500ms', 'alternate-reverse', ] }, animationIterationCount: { name: 'animation-iteration-count', description: '*動畫播放次數', properties: [ '1', '3', '1.5', 'infinite', ] }, animationTimingFunction: { name: 'animation-timing-function', description: '動畫轉換時的加速曲線', properties: [ 'ease', 'ease-in', 'ease-out', 'linear', 'steps(5, end)', 'cubic-bezier(.4,.94,.56,1.59)' ] }, animationDirection: { name: 'animation-direction', description: '動畫向前，或是反轉播放', properties: [ 'normal', 'reverse', 'alternate', 'alternate-reverse', ] }, animationPlayState: { name: 'animation-play-state', description: '動畫播放的狀態', properties: [ 'running', 'paused', ] }, animationFillMode: { name: 'animation-fill-mode', description: '定義播放以外的時間的呈現狀態', properties: [ 'none', 'forwards', 'backwards', 'both', ] }, animationDelay: { name: 'animation-delay', description: '第一次播放動畫延遲時間', properties: [ '0', '1s', '2s', 'initial', ] }, }); const selectProperties = reactive({ 'animation-name': 'rotate-keyframe', 'animation-duration': '3s', 'animation-iteration-count': 'infinite', 'animation-timing-function': 'linear', }); return { animationStyle, selectProperties } } }).mount('#app'); 延伸閱讀如果要在實戰中套用 Animation 的效果，非常推薦直接使用 「Animate.css」，包含相當多種動態轉場效果，就算是一般的網站宣傳頁面，都可以輕易地將動態套用至元素上喔 延伸資源： Animate.css：https://animate.style/","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Mac OSX 截圖全說明（單一視窗、全螢幕、重設截圖路徑、Touch Bar）","slug":"mac-osx-screen-capture","date":"2021-09-27T16:00:00.000Z","updated":"2021-09-28T08:07:39.054Z","comments":true,"path":"development/2021/09/28/mac-osx-screen-capture/","link":"","permalink":"https://wcc723.github.io/development/2021/09/28/mac-osx-screen-capture/","excerpt":"","text":"Mac OSX 的內建截圖熱鍵相當好用，雖然看起來熱鍵組合很多，但每一個鍵都有它的組合意義，在此先附上完整的熱鍵組合表。 Mac OSX 截圖熱鍵全表，使用方法可參考下方文章說明 組合規則首先，要使用截圖一率會使用 command + shift 加上特定數字鍵作為開始，而這些數字鍵分別代表： command + shift + 3：立即全螢幕截圖 command + shift + 4：局部或視窗截圖，點擊後會出現區域截圖的游標，使用滑鼠圈選後會截圖 command + shift + 5：開啟截圖應用程式（可調整設定或使用所有的截圖功能） command + shift + 6：立即 Touch Bar 截圖 基本全螢幕截圖 預設的截圖會儲存於桌面上 儲存於剪貼簿 control而上述的基本截圖後會立即儲存新檔案，而新增的檔案會儲存於桌面上（後續文章會說明如何調整儲存位置）。 如果不要新增檔案可以同時按下 control 鍵，截圖的內容將不會產生新檔案，而是暫存於剪貼簿內，可以使用 command + v 貼在任何文件上。 command + shift + control + 3：立即全螢幕截圖，並暫存於剪貼簿 command + shift + control + 4：局部或視窗截圖，點擊後會出現區域截圖的游標，使用滑鼠圈選後會截圖，並暫存於剪貼簿 command + shift + control + 6：立即 Touch Bar 截圖，並暫存於剪貼簿 局部或視窗進階截圖方法當按下 command + shift + 4 時會出現十字游標，此時可以圈選任何區域進行截圖。 當需要使用視窗方式截圖時，則可以再按下 space 空白鍵，游標會轉為 的符號，在任何的視窗按下滑鼠左鍵即可進行截圖，此截圖亦可搭配前述介紹的 control 決定儲存新檔或是暫存於剪貼簿內。 command + shift + 4 後按下 space：進行視窗截圖 command + shift + control + 4 後按下 space：進行視窗截圖，並暫存於剪貼簿 視窗截圖，會包含大範圍的陰影 預設的視窗截圖會包含很深的陰影樣式，如果僅想要純粹的視窗截圖，可以在截圖的同時按下 option，就可以去除多餘的陰影樣式。 command + shift + 4 後按下 space，搭配 option 按下左鍵：進行視窗截圖並去除陰影 command + shift + control + 4 後按下 space，搭配 option 按下左鍵：進行視窗截圖並去除陰影，同時暫存於剪貼簿 如果要去除截圖的陰影，可以在點擊時加上 option 鍵 Touch Bar 截圖Touch Bar 截圖方式與全螢幕相同，按下 command + shift + 6 就會立即截圖。 當把 Touch Bar 改為 F1… 等按鍵，你會發現另一個新天地（終於不用擔心誤觸了!? 調整截圖路徑立即儲存的方式很好用，但如果都儲存在桌面上，很容易造成桌面的凌亂，而我會習慣在桌面另外開一個資料夾專門存放截圖的圖檔，流程如下： 建立預期儲存截圖的資料夾 按下 command + shift + 5 開啟截圖 APP 選擇 選項 &gt; 其它位置，接下來對應到剛剛建立的資料夾即可 截圖 APP 包含所有的截圖功能，也可自訂圖片的儲存位置 我會在桌面上建立一個資料夾存放所有截圖的圖檔 調整截圖熱鍵如果你想要調整截圖的熱鍵，也可以到 「系統偏好設定 &gt; 鍵盤 &gt; 快捷鍵 &gt; 截圖」內找到相關的設定喔 重新設定截圖熱鍵","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://wcc723.github.io/tags/mac/"},{"name":"osx","slug":"osx","permalink":"https://wcc723.github.io/tags/osx/"}]},{"title":"CSS 變數必學知識 - 宣告、繼承及 Bootstrap 中的運用技巧","slug":"css-variables-bootstrap","date":"2021-09-21T16:00:00.000Z","updated":"2021-09-23T03:37:07.427Z","comments":true,"path":"development/2021/09/22/css-variables-bootstrap/","link":"","permalink":"https://wcc723.github.io/development/2021/09/22/css-variables-bootstrap/","excerpt":"","text":"在 Bootstrap 5 以後，大量導入 “CSS Variable” 的技巧，透過變數可以大幅增加 CSS 的可運用性，讓同一段程式碼透過修改變數的形式，大幅增加 CSS 的可用性，本篇將介紹 CSS 基本運用方式，以及在 Bootstrap 5 中如何運用此技巧來豐富性其用途。 CSS 變數基礎運用方式使用 CSS 變數時，一定會先定義其值，預設的情況下會在最外層的元素中定義變數以及值。 以下範例來說，就在根元素 :root 定義了 --casper-color 的變數，而後方的 #00cc99 將是他的值。 :root &#123; --casper-color: #00cc99; &#125; 在此也簡單說明定義變數的規則： 可以定義在任何元素上，而 :root 表示的是根元素 定義的變數會使用 -- 在最前方，其後的名稱是自定義的 : 後方則是變數值，值沒有特別的限制，大多都是與 CSS 值一致 當變數定義完以後，就可以呼叫此變數來運用它，以下範例就是直接取用剛剛所定義的色彩。.box &#123; background-color: var(--casper-color); &#125; 取值時的規則如下： 會使用 var 在變數的最前方 使用 () 包覆住變數 接下來就會套用變數所定義的值 接下來運行的結果如下，.box 元素套用了 :root 所定義的變數。 接下來看看實際的範例，最外層定義了 --casper-color 變數，然後內層的 .box 取用其值套用在背景色上。 :root { --casper-color: #00cc99; } .box { height: 100px; width: 100px; background-color: var(--casper-color); } 變數的繼承特性相對於 JavaScript 來說，CSS 運行時並不會改變其值，而既然它稱為 “變數” 但值不會改變該如何運用呢？ 而 CSS 變數具有一個 “繼承特性”，換個簡單的說法就是它具有 “作用域的特性”。 以剛剛上述的程式碼來說，最外層定義了 --casper-color 變數，那麼內層所有元素都可以取用此變數的值。但如果在其 :root 的內層補上其它的同名變數，則會使用內層的變數值。 示意圖：內層取值時，會直接繼承最接近層級所定義的變數，當沒有任何可取用的值時，則使用根元素所定義的變數。 案例：如果在中間補一層 .local，那麼在其內部取值時，則會取用到 .local 的變數，而不是 :root。:root &#123; --casper-color: #00cc99; &#125; .local &#123; --casper-color: orange; &#125; .box &#123; background-color: var(--casper-color); &#125; 運行結果：以下範例只有新增 .local 的變數，其餘程式碼與上段一樣，但在此的 .box 已被套用成橘色。 .local { --casper-color: orange; } 繼承規則與 CSS 權重概念一致，基本原則如下： 內層優於外層 當 Class 繼承變數為同層時，以權重高的為主 使用不同的 class 定義不同的區域變數透過區域變數的概念，取值的程式碼都可以不需要做調整，只要調整區域中的變數就可以不斷的改變內層的呈現。 以此範例來說，.box 的 CSS 與一開始所定義的無異，但卻能產生出多種變化的色彩。.local-purple &#123; --casper-color: purple; &#125; .local-cyan &#123; --casper-color: cyan; &#125; Bootstrap 5 的變數運用概念在 Bootstrap 5 中的 :root 就有定義了許多可用的情境色彩（文件連結），當我們利用 Bootstrap 時，需要撰寫額外的元件時就可以直接取用這些變數的色彩。 除此之外，許多的元件、功能性模組都有額外定義的變數，例如格線系統中的 .row 就定義了 --bs-gutter-x 作為格線系統中的間隔值。 當要調整格線之間的間隔時，可以在外層 .row 加上 gx-1 ，而此 class 僅只有調整 --bs-gutter-x 的變數值，並沒有其它的樣式在內。 雖然沒有賦予其它的樣式，但是在內層的 col-* 就會繼承新覆蓋的值，透過這樣的方式，僅需要短短 3 行變數調整程式碼，就可以產生出不同間距的格線系統。 原始碼如下： &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;box w-auto&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;box w-auto&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;row gx-1&quot;&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;box w-auto&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;box w-auto&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 其它範例除了格線系統以外，Bootstrap 亦將變數用在許多地方，在 Helpers 內的 Ratios(比例) 中，也是透過變數的技巧來調整不同的比例。 其中的 ratio-16x9 就是修改 --bs-aspect-ratio，其內層的元素套用此比例完成比例挑整樣式。 原始碼如下： &lt;div class=&quot;ratio ratio-16x9&quot;&gt; &lt;iframe src=&quot;https://www.youtube.com/embed/XAdIuuU_90g?rel=0&quot; title=&quot;YouTube video&quot; allowfullscreen&gt;&lt;/iframe&gt; &lt;/div&gt; 除此之外，還可以直接使寫入其它變數值於 style 內，讓 CSS 的變數可用性大幅上升，以下範例來說就將 --bs-aspect-ratio 改為 100%，就可以將內嵌的影片比例給改為 1:1。 套用方式，將變數改為 100%。style=&quot;--bs-aspect-ratio: 100%;&quot; 結語相對於 Bootstrap 4 來說，我認為 v5 真正發揮特色的地方在於 “變數”。 雖然 Sass 可以透過簡短的語法產生大量的 CSS 程式碼，但這也意味著 CSS 檔案會不斷地擴增。因此許多設計概念在 v4 都受到了限制，例如：不同間距的 gutter（v4 只有三種，而這三種已經讓 Bootstrap 額外佔用許多容量）。 到了 v5 以後，除了原有的 Sass 之外，更靈活運用原生的 CSS 變數技巧，這些用法甚至會讓人感覺到「哇～原來變數可以這樣玩」。以格線系統來說，每次新增一種新的 gutter 僅需要增加 3 行 CSS（沒錯，包含 ClassName 就三行；至多不需要超過 5 行） 傳統的 CSS，至少要 60 行以上才能達到此效果，而 CSS 變數的 3 行影響到： 12 欄 5 種中斷點的欄線 外層 .row 的設計 當然，變數實際運用不僅如此，如果是搭配 JavaScript 更能做出許多變化，而除了本篇所介紹的方法外，你還有看過哪些方法呢？","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"履歷避雷技巧 - 技能描述篇","slug":"resume-skills","date":"2021-09-16T16:00:00.000Z","updated":"2021-09-17T07:19:31.429Z","comments":true,"path":"development/2021/09/17/resume-skills/","link":"","permalink":"https://wcc723.github.io/development/2021/09/17/resume-skills/","excerpt":"","text":"履歷中的「技能」描述是個人專業技能的主述，徵才單位會透過其內容理解求職者的能力，更重要的是透過字詞中分析對於技能的掌握深度，如果沒有善加利用，可能會造成： 資深開發者：但沒有透過履歷展現出應有的深度 新手開發者：錯誤的內容呈現，導致連面試的機會都沒有 本篇僅針對履歷中的「技能」描述進行分析，包含許多案例分享，這些範例均已被做適當的調整，所以與原始履歷有些出入。 為什麼有這篇文章除了教授學員技能，我們也會針對完成特定階段的學員給予求職上的建議，而在輔導的過程中會發現其中幾點是學員的常見問題，這些問題直接影響求職過程中是否可以順利拿到面試門票的關鍵。 而這些問題，也並非三兩行就可以說明清楚，畢竟不可能用一套 SOP 完成所有人的履歷，每個人都是獨立的個體，都有各自的特色，所以本篇將會提供避免犯的錯誤，以及幾種不同型式的撰寫方式，讓求職者可以選擇適合自己的技能呈現手法。 技巧一：絕不能犯的錯誤首先，履歷跟書信往來都包含著一些禁忌，這些禁忌只要犯了在觀者心中就會大幅度扣分，而這些禁忌也不限於只要在「技能」描述區塊才有，請在所有履歷中都避免犯這些錯誤。 目標職位就是技能描述的核心近期因為斜槓很流行，許多社會新鮮人因為缺乏經驗，也就只好把自己的各項長歪的技能通通的加入到履歷之中。但對於徵才公司來說，他們要的是可以解決問題的能力，對於那些次要、不專精的技能不感興趣。 當履歷版面，次要技能佔用超過主要求職技能，大多會給人以下的感受 「不專精」 「對於核心技能掌握不足」 示意：技能太雜，不清楚預期求職的職務為何，也會讓人感覺到不專精 因此，履歷的前方都會建議補上「目標職位」，接下來整份的履歷內容也請依據目標職位為主進行規劃，與其不相關的內容減少版位，並請放在次要的位置（履歷的最後方）。 錯字無論是正式的書信或者是履歷中的錯字都是不可犯的，尤其是在技能的描述上，錯字會讓人感覺： 「是否不熟悉此技能」 「個性粗心大意」 「無法放心將工作工作委任此人」 只有尊重自己的人，才會受到別人的尊重，履歷中的技術用詞當有錯字存在，也等同於不尊重自己的專業技能。如果說技能描述缺乏重點，頂多則是沒有面試的機會，但是錯字直接會留下糟糕的印象；因此這屬於必要注意事項最重要的一項，請避免犯下此類錯誤。 示意：錯字會讓人感覺到不細心（包含大小寫） 常見的技術錯字案例： jquery、JQuery：大小寫運用不正確，正確為「jQuery」 javascript：大小寫運用不正確，正確為「JavaScript」 github、Github：產品名稱大小寫錯誤，正確為「GitHub」 PH：預期撰寫 Photoshop，但使用錯誤的縮寫字母 Google Analytcs：產品技術字母拼錯 另外在中英文字運用上，如果不熟悉文字運用規則可參考 中文文案排版指北，常見的基本知識點包含： 中英文字中保留空白 中文字中使用全形標點符號 英文、數字正確的使用半型 使用良好的排版增加閱讀性具有美感的人，無論在作品上或是面試上都會有加分的效果，在履歷中亦是如此；相對實際的作品來說，履歷到不用排到特別的具有美感，只要符合「對齊」以及「一致性」的基本原則就可以。 以下範例來說，就可以調整為： 統一置左 內文文字統一大小（中間的內文文字偏大） - 與右方文字統一保留一個空白字元 而此部分可以說明的細節非常多，請謹記至少維持「對齊」以及「一致性」這兩個基本原則，只要不符合這兩個原則都可能會造成排版上的混亂。 技巧二：撰寫技巧優劣分析技能描述目標是讓對方瞭解「技能掌握的深度」。 描述方式：技能描述目標是讓對方瞭解「技能掌握的深度」，因此適當的提供描述內容自然能展現出深度；而描述方式也是一門學問，在此區分為兩大類： 列出技能的細節 描述實際運用的情境 描述方式一：列出技能的細節這類型專注在技能本身的敘述上，說明掌握技術特定的「關鍵知識點」，在撰寫履歷上是屬於安全牌的撰寫方式。 這類型在撰寫時，需要注意專有名詞的運用，撰寫前可多參考官方文件或各種網路資源，避免錯誤的用詞或描述方式，例如在過去我曾經收過的履歷中的描述寫到： 熟悉 JavaScript ES6 語言（ES6 不是一個獨立的語言，算是 ECMAScript 的一個版本號） 描述方式二：描述實際運用的情境公司徵才目標就是徵選可以解決問題的人才，因此在技能描述中如果可以帶入「你使用這個技術做什麼」，自然也會更有說服力。 範例：使用 Nuxt 開發 SSR 網站，並補充是為了符合 SEO 需求，更能讓人感受是有使用經驗，而不是僅有皮毛知識 當公司有整合測試、部署上的問題時，此 DevOps 的相關用詞也能吸引徵才公司的注意 說明實際運用的情境固然是好方法，但在履歷表空間有限的情況下，每一字、一詞都需要警慎的修飾，否則沒有達到目標以外，甚至可能會影響整體的排版形式。 排版分類方式在過去，技能豐富度還沒有現在那麼複雜的情況下，大多都會使用標籤式的方式標住所掌握的技能，這種方式雖然看起來技能數量很多，但對於徵才單位來說就很難快速知道你所精通的類別為何。 範例：此技能列表中不清楚是前端、後端還是設計師。 因此，適當的技能分類可讓觀者知道求職者的技能發展方向。而中文的的每段文字較短，所以時常會使用三、四欄式的方式呈現分類技能。 適當的分類，三欄式排版中還可以加入一些文字描述 或者將技能群組化標示，也能了解此開發者是偏向前端或後端（通常由左至右表示精通程度，因此本履歷感受上會偏向後端） 如果是單一分類描述較長，或預期使用較多的技能標籤做陳列時，改為單欄式由上而下也是個方法，相對來說這種排版形式比較不會受到限制（字數、分類數量等等），但要注意整體版面的安排，避免出現過多空白。 許多制式的履歷表也是提供由上而下單欄式的排版形式 數值標示因為技能描述是由求職者自行撰寫，許多技能本身大多也沒有一個衡量標準（如 TOEIC 分數可作為英文指標，但許多技術能力並沒有此數值指標），觀者很難從主述中衡量所掌握的「深度」。 雖說如此，還是有辦法透過一些方式來使用數值呈現技術掌握能力。 數值標示一：標示出年資這是一個非常有效的方法，因為年資直接說明了你使用此技術有多少的時間，兩年資歷的普遍來說自然比只有一年資歷的有更深的掌握程度。 直接標示使用該技術的運用年份，快速讓人知道並非泛泛之輩 此開發者在特定技術標上不同色彩的使用年份 但如果僅有 “基礎技能” 標示過長的時間，代表長時間技能沒有成長，如：網頁切版技能掌握了 5 年以上，卻沒有其它更新的技能，就會讓人感覺長時間沒有學習新知識。 數值標示二：使用計量表呈現這是許多新人會使用的技巧，將技能標示不同的數值（1 ~ 5 分）來表示對於特定技能的掌握度。 此技巧是屬於極端的兩面刃，在人資或非技術相關的領域中，可能會得到不錯的回應，因為無論是否熟知技術，都能略微了解你具備哪些能力以及真正精通的是哪些；但在技術圈中，這是一個極不受歡迎的標示方式，因為標示分數的依據無法衡量，面試者的 5 分不代表一位高階技術主管的 5 分。 範例：使用 0 ~ 5 分標示掌握的深度 會被挑戰的問題：所以說 HTML5 有 4 分的掌握度代表精通 80% 的 Web API 嗎？ 如果你還是新手開發者，此種手法可以讓人資或非相關領域的人員認識你，並且這類型在排版也增添豐富性。但如果是具有經歷的開發者，就不太建議持續使用此方式來求職，畢竟觀看履歷都會是以專才的技術人員/主管為主，容易被挑戰各種認知上的問題。 後記本篇是專注於介紹履歷中的「技能描述」，關於履歷還有哪些內容是有興趣的呢？歡迎在底下留言，以後會找機會一一補充相關內容喔～ .article img { border: orange 1px solid; }","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"履歷","slug":"履歷","permalink":"https://wcc723.github.io/tags/%E5%B1%A5%E6%AD%B7/"}]},{"title":"JavaScript Console 運用技巧 - 8 招讓你除錯更高效","slug":"js-console","date":"2021-09-13T16:00:00.000Z","updated":"2021-09-14T08:15:50.328Z","comments":true,"path":"development/2021/09/14/js-console/","link":"","permalink":"https://wcc723.github.io/development/2021/09/14/js-console/","excerpt":"","text":"寫 JavaScript 需要檢視運作是否正確時候，都會使用 console.log 來檢視輸出或運算的值，而 console 的運用技巧不僅僅只有將值呈現在開發的 Console 介面中。本篇就來介紹許多 console 語法的實戰運用方法吧！ 首先，在此先準備一份等等會用到的物件及陣列作為以下範例使用：const Ming = &#123; name: &#x27;小明&#x27;, age: 15, favorite: &#x27;鍋燒意麵&#x27; &#125; const Jay = &#123; name: &#x27;杰倫&#x27;, age: 16, favorite: &#x27;炒麵&#x27; &#125; const Auntie = &#123; name: &#x27;漂亮阿姨&#x27;, age: 21, favorite: &#x27;蘿蔔糕&#x27; &#125; const people = [Ming, Jay, Auntie]; 為 console.log 的程式碼上色有在 Facebook 頁面中開啟過開發者工具嗎？如果有，相信你對於以下這張圖並不陌生。 Console 中的文字並非只有固定的色彩，它與網頁中的文字一樣，都可以透過 CSS 的語法來調整其色彩，只要在 log 的文字前方先加入 %c 後，在 , 後方的參數就能夠傳入 CSS 語法做為參數，並且調整 Console 中呈現的文字樣式。 console.log(`%c $&#123;Ming.name&#125; 有瑟瑟的顏色`, &#x27;color: orange; font-size: 24px&#x27;); console.table()：使用表格的方式陳列陣列的資訊當要呈現資料於 Console 介面中，做常見的方式就是使用 log 的方法：&#x27;😴 基本用法&#x27; console.log(Ming); console.log(Jay); console.log(Auntie); console.log(people); 當然，這樣的用法絕對沒有問題，透過此方法可以將值一一陳列出來，不過當這些數值是 “具有關聯性” 時，一般的 log 就無法比較兩者之間的關係。 console.table() 針對物件之間有相同的屬性名稱時，就能夠輕易的比較相同屬性之間的關係。console.table([Ming, Jay, Auntie]); console.table(people); 除此之外，表格上方的標頭還可以點選作為排序使用，如果拿到一個 JSON 想比對其中的值，還要轉貼到 Excel 或是 sort() 語法安排，不如直接改用 table() 進行比較吧。 Your browser does not support the video tag. console.group()：群組化大量的 log 資訊使用 log() 觀看迴圈值是合情合理的，不過當陣列的長度有上百筆時，Console 介面中的資料還真會滾到令人厭世。 for (let index = 0; index &lt; people.length; index++) &#123; const element = people[index]; console.log(element); &#125; 在迴圈中使用 console.log() 會一一呈現資料，數量一多看起來就會顯的很吃力 使用 console.group()、console.groupEnd() 設置群組的起訖，在 Console 的介面中就能方便的收合群組內容。 console.group(&#x27;迴圈群組&#x27;); for (let index = 0; index &lt; people.length; index++) &#123; const element = people[index]; console.log(element); &#125; console.groupEnd(); console.group(/* 群組名稱 */)可以傳入 “群組名稱” 做為參數，作為在 Console 介面中辨識群組的顯示名稱，在介面中的群組名稱也會以粗體名稱，並且可以點擊箭頭符號收合群組內容。 console.time()：開發者最愛斤斤計較那 1ms 的效能了每當寫出神邏輯的時候，都會擔心電腦效能跟不上自己的思維，這時候就可以使用 time() 追蹤片段程式碼所處理的時間差，得知自己是不是該換台電腦解決問題。 &#x27;🤩 時間追蹤&#x27;; console.time(&#x27;迴圈處理時間&#x27;); for (let index = 0; index &lt; people.length; index++) &#123; const element = people[index]; console.log(element); &#125; console.timeEnd(&#x27;迴圈處理時間&#x27;); 在起訖中分別加入 time() 以及 timeEnd()，執行程式碼後就可以獲得處理的結果。 console.dir()：以物件的形式呈現資料// HTML &lt;p&gt;推薦的 Console 語法&lt;/p&gt; const p = document.querySelector(&#x27;p&#x27;); console.log(p); 當使用 console.log() 查看 DOM 元素，並想了解其中可用的方法或屬性時…，它可能會出現如下帶點失望的標籤，並且心裡默罵： 要這個幹嘛啦 要知道的是物件屬性、屬性！ 這時候需要的是 console.dir()，你會發現另一個新世界，原本的 DOM 元素被改為物件的形式呈現，你可以輕鬆展開此物件，並檢視裡面有哪些可用屬性。 const p = document.querySelector(&#x27;p&#x27;); console.dir(p); 展開的 P 元素，包含其中所有的屬性（這在操作 DOM 時極為好用） console.error()寫程式有錯誤是難免的，但是如果是錯誤，卻沒有明確的提示導致沒有被發現問題，就失去提示的意義了，如果想讓 Console 的內容更加醒目，可以使用 console.error() 使訊息在 Console 介面中以錯誤的形式呈現。 console.error(`$&#123;Ming.name&#125; 你完蛋了`); 當運用在一般文字訊息上時，也可以展開訊息並說明錯誤來源自哪一段程式碼。 在 AJAX 的未確認狀態中，也會使用 console.error 來呈現錯誤的回饋訊息，以下範例刻意將 API 路徑調整成錯誤的，並透過 console.error() 來將錯誤的資訊呈現在 Console 介面中 &#x27;🤩 Error&#x27;; axios.get(&#x27;https://randomuser.me/apis&#x27;) .then((res) =&gt; console.log(res)) .catch((error) =&gt; &#123; console.error(&#x27;待誌大條啦: &#x27;, error.response) &#125;) console.warn()錯誤太突兀了嗎？如果是自行開發的函式庫，已經透過各種形式避免程式碼出錯，但還是想把有錯誤的訊息給予開發者知道，那麼則可以使用 console.warn()。 &#x27;🤩 Warning&#x27;; /*** * 超精美函式庫 💖 * @param &#123;number&#125; num 純數值 * @param &#123;string&#125; text 請傳入字串 */ function superMagicLibrary(num, text) &#123; if (typeof num !== &#x27;number&#x27;) &#123; console.warn(&#x27;尊重一下好嗎，請傳入純數值&#x27;) &#125; &#125; superMagicLibrary(&#x27;字串&#x27;); 函式庫中大多會避免已知的錯誤，如果要友善的給予回饋，可以使用 warn() 代替 error() 提醒開發者更好的做法 :D。 console.clear()如果覺得 Console 介面已經充滿了許多不必要的資訊，想要專注於當前開發的程式碼，那麼可以加入 console.clear()。 畫面中會出現 Console was cleared 的字眼 此語法亦可在 Console 介面中直接輸入，會直接清除當下的所有資訊內容。 Your browser does not support the video tag. 不過請慎用此方法，如果隨意插入 console.clear() 在不同的檔案中，不知情的夥伴一定會在開發中卡很久，可能發生的情境有…： 奇怪，我寫的 Code 怎麼都沒顯示在 Console 編譯器壞了嗎？怎麼好像沒有運作 我的 Chrome 怪怪的 還有哪些方法你也常用，但沒有介紹到的呢？歡迎在底下留言區留言喔 :D","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"CSS 選取器(基本篇) - CSS Selector","slug":"css-selector","date":"2021-09-10T16:00:00.000Z","updated":"2021-09-11T10:59:45.942Z","comments":true,"path":"development/2021/09/11/css-selector/","link":"","permalink":"https://wcc723.github.io/development/2021/09/11/css-selector/","excerpt":"","text":"一個開發者對於畫面的掌控度高不高，完全都可以取決於「CSS 選取器」掌握度，無論是基本的 CSS 到 jQuery 甚至是原生的 JavaScript 都是使用 CSS 選取器。另外如果要寫道後端測試、爬蟲，也是持續使用這看似基礎的觀念，本篇將會循序漸進介紹各種選取器，讓大家從基礎開始學習此知識。 元素選取器 類別選取 id 選取 屬性選取 而選取器是選取 HTML 元素的語法，它並不會限制只運用在 CSS 上（雖然普遍稱為 CSS Selector）。 元素選取器 最基本的 HTML 標籤選取，可以直接選取畫面上所有 “同類型的元素”，屬於比較廣泛的選取器。 以下範例來說就直接選取了 a 標籤，並將它改為了紅色。 這是 Apple 官網連結 .demo-1 a { background-color: red; } &lt;a href=&quot;https://www.apple.com/&quot; target=&quot;_blank&quot;&gt;這是 Apple 官網連結&lt;/a&gt; a &#123; background-color: red; &#125; 元素選取 - 實戰說明因為它是屬於廣泛的選取器，雖然可一次選擇非常大量的元素；雖然這是優點但也同時是缺點，大量的選取可能會影響到其它不需要被選取的項目，為了避免影響後續維護或開發，此選取器大多都是利用在： 開頭的 CSS Reset，範例：https://meyerweb.com/eric/tools/css/reset/ 限定範圍的標籤，例如：部落格主要文章中的段落 p 標籤 類別選取 類別選取是樣式套用 “最實用” 的選取器，它具有以下的特性： 可重複利用（套用在多個標籤上） 可重複套用（可多個類別套用在同一個標籤上） 適當的權重 以下建立了 .a-link 的類別，並套用在 a 標籤上使其背景色調整為黃色。 這是 Apple 官網連結 .demo-1 .a-link { background-color: yellow; } &lt;a href=&quot;https://www.apple.com/&quot; class=&quot;a-link&quot; target=&quot;_blank&quot;&gt;這是 Apple 官網連結&lt;/a&gt; .a-link &#123; background-color: yellow; &#125; 類別選取 - 多個類別重複套用 類別選取兩個特性： 可重複利用（套用在多個標籤上） 可重複套用（可多個類別套用在同一個標籤上） 其中的 “可重複套用” 是許多新手會忽略的用法，使用方式就是定義兩個樣式並套用在同一個元素上。 這是 Apple 官網連結 .demo-1 .a-link { background-color: yellow; } .demo-1 .a-link-color { color: black; } &lt;a href=&quot;https://www.apple.com/&quot; class=&quot;a-link a-link-color&quot; target=&quot;_blank&quot;&gt;這是 Apple 官網連結&lt;/a&gt; .a-link &#123; background-color: yellow; &#125; .a-link-color &#123; color: black; &#125; 類別選取 - 實戰說明它具有非常多的優勢，讓許多框架、設計模式都是基於 class 為基礎進行設計，例如： OOCSS 的設計模式，參考文 Bootstrap 最流行的前端開發工具 以 Utilities 為單位的 CSS 框架 所以運用上請把握一個原則，這是 CSS 樣式表運用 “最為廣泛的選取器”（沒有之一），如果是作為樣式使用： 請使用 class 取代 id 如果可以套用 class 時，請不要直接使用元素或其它選取器 ID 選取 在一個 HTML 頁面中原則上僅會有一個 id，如果出現兩個以上時，部分瀏覽器則會跳出錯誤的提示，建議調整頁面上重複定義 id 的元素。 Id 選取在應用上特性： 具有唯一性：畫面上僅會有一個該名稱 id 較高的樣式權重：如果與 class 的樣式有衝突時，會以 id 為主 以下範例就選取了 id a-link，要特別注意一個 id 在頁面中原則上只會有一個。 這是 Apple 官網連結 #a-link { background-color: pink; } .b-link { background: blue; } &lt;a href=&quot;https://www.apple.com/&quot; id=&quot;a-link&quot; class=&quot;b-link&quot; target=&quot;_blank&quot;&gt;這是 Apple 官網連結&lt;/a&gt; #a-link &#123; background-color: pink; &#125; .b-link &#123; background: blue; &#125; id 選取 - 實戰說明它具有高權重、不可重複、頁面唯一的特性，讓樣式無法多次的運用，並且可能造成管理上的問題；因此，實戰開發中不會使用 “id 選取器” 作為樣式的選取（注意：千萬不要這麼做）。 不過這樣的特性卻很適合作為樣式以外的用途，例如： input 與 label 標籤的對應 頁面元素的絕對選取（頁面上只會有一個），在 JS、後端爬蟲、測試中相當好用 屬性選取相對於以上的選取器來說，這是相對少見但也是更為靈活的選取器，無論在樣式或任何情境都相當好用，在受到限制的情境中常常會有意想不到的用途，例如： 標籤的屬性必須為特定屬性值，如：&lt;input type=&quot;checkbox&quot;&gt; HTML 的結構已經確立無法改變時，如：已經完成頁面，需要進行爬蟲或測試使用 屬性選取可運用的組合也相當多樣，基本上只要 HTML 元素中有任何一些不同，都可作為屬性選取器的選取方式。 以下將一一的介紹屬性選取的各種手法： 包含特定 “屬性” 的選取 “屬性及值” 完全符合 屬性值 “包含特定字串” ”結尾值“ 包含特定文字 屬性選取 實戰操作 包含特定 “屬性” 的選取 只要元素中包含特定「屬性」皆可選取，以下範例來說其中一個 a 標籤缺少了 href 屬性，因此將不會被套用紅色的樣式，所以此方法也可以過濾出標籤中是否有正確包含特定屬性。 Apple 官網連結 Google 連結缺少 href .demo-2 [href] { color: red; } &lt;a href=&quot;https://www.apple.com/&quot; target=&quot;_blank&quot;&gt;Apple 官網連結&lt;/a&gt; &lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt; &lt;a target=&quot;_blank&quot;&gt;連結缺少 href&lt;/a&gt; [href] &#123; color: red; &#125; “屬性及值” 完全符合 接下來就是屬性選取慢慢進入進階的流程，當屬性內的值完全符合時，可以選取此元素。 Apple 官網連結 Google .demo-3 [href=\"https://www.apple.com/\"] { color: red; } &lt;a href=&quot;https://www.apple.com/&quot; target=&quot;_blank&quot;&gt;Apple 官網連結&lt;/a&gt; &lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt; [href=&quot;https://www.apple.com/&quot;] &#123; color: red; &#125; 屬性值 ”包含特定字串“ ”包含特定字串“ 開始的運用變化就越來越多，以此範例就可以判斷標籤內的連結目標為何。 Apple 官網連結 Google .demo-4 [href*=\"google\"] { color: red; } &lt;a href=&quot;https://www.apple.com/&quot; target=&quot;_blank&quot;&gt;Apple 官網連結&lt;/a&gt; &lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt; [href*=&quot;google&quot;] &#123; color: red; &#125; “開頭值” 包含特定文字除了判斷部分字詞以外，還可以從前到後、前後至前的選取形式。 Apple 官網連結 Google .demo-5 [href^=\"https\"] { color: red; } &lt;a href=&quot;https://www.apple.com/&quot; target=&quot;_blank&quot;&gt;Apple 官網連結&lt;/a&gt; &lt;a href=&quot;http://www.google.com/&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt; [href^=&quot;https&quot;] &#123; color: red; &#125; ”結尾值“ 包含特定文字此範例為結尾值的選取形式，就可以進行從後至前的選取。 Apple 官網連結 Google .demo-6 [href$=\"/tw/\"] { color: red; } &lt;a href=&quot;https://www.apple.com/tw/&quot; target=&quot;_blank&quot;&gt;Apple 官網連結&lt;/a&gt; &lt;a href=&quot;http://www.google.com/&quot; target=&quot;_blank&quot;&gt;Google&lt;/a&gt; [href$=&quot;/tw/&quot;] &#123; color: red; &#125; 屬性選取 實戰操作 屬性選取在實戰中應用非常廣，最常見的案例之一就是判斷 input 的 type 類行為和，透過此方式避免選取到錯誤類型的 input（如果把 input 樣式套用在 checkbox 上就會顯得非常不適切）。 .demo-7 input[type=\"checkbox\"] { appearance: none; border: 1px solid red; width: 1rem; height: 1rem; } .demo-7 input[type=\"checkbox\"]:checked { background: red; } &lt;input type=&quot;checkbox&quot;&gt; input[type=&quot;checkbox&quot;] &#123; appearance: none; border: 1px solid red; width: 1rem; height: 1rem; &#125; input[type=&quot;checkbox&quot;]:checked &#123; background: red; &#125; 除此之外，CSS 的選取方式不限制僅能使用 CSS，因此無論是 jQuery、JavaScript 都可以使用此方式進行選取，以上述範例中的連結選取，都可以改用 JS 來進行處理，在現實的開發中就可以用來： 當開發受到限制，不可調整 HTML 原始碼時，可使用 JS 置換內容 Node.js 爬蟲開發 Chrome 插件（擷取網頁內的資訊） CSS Selector 實戰練習最後，提供一個練習題目讓大家動手試試看，透過下方的 input 輸入選取器語法，試著選擇以下卡片中的特定元素吧！（被選取的元素會以紅色外框呈現） 挑戰題目： 選取 https 開頭的 a 標籤 選取 /tw 結尾的 a 標籤 選取左邊的圖片 同時選取 input 及 textarea 僅選取 checkbox 選取 textarea 對應的 label 這些題目，你可以完成幾題呢？ 輸入你認為正確的 Selector Facebook Google Apple Email address Example textarea Checkbox Radio .outline { outline: solid red 2px; } .card-bg { height: 200px; background-position: center center; background-size: cover; } const selectorPractice = document.querySelector('#selectorPractice'); const preBlock = document.querySelector('#preBlock'); let preDom = []; selectorPractice.addEventListener('keyup', selectorFn); function selectorFn() { const value = selectorPractice.value; const selectDom = document.querySelectorAll(`#demo ${value}`); preBlock.textContent = `document.querySelectorAll(${value});`; if (selectDom) { if (preDom) { console.log(preDom); preDom.forEach(element => { element.classList.remove('outline'); }) } selectDom.forEach(element => { element.classList.add('outline'); }); preDom = selectDom; } } selectorFn();","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Vue 3 新手夏令營","slug":"vue-summer-camp","date":"2021-07-06T16:00:00.000Z","updated":"2021-07-07T07:38:13.567Z","comments":true,"path":"development/2021/07/07/vue-summer-camp/","link":"","permalink":"https://wcc723.github.io/development/2021/07/07/vue-summer-camp/","excerpt":"","text":"現在前端所需技能越來越深，而三大框架雖然資源豐富，但對於新手來說卻也不知道如何入門，因此我們舉辦「Vue 3 夏令營」，讓更多的前端同好可以認識這門框架～ 這個活動適合哪些人呢？ 對於 JavaScript 有基礎掌握度 對於 Vue 2 或其它框架有基本認識，想學習 Vue 3 的開發者 想從基礎學習 Vue 3 的開發者 如果你不確定自己的基礎是否可以學習 Vue 3，可以先觀看此影片，本影片內容是在直播介紹 JavaScript 中「ES6 Let 與 Const」的語法觀念，如果你能瞭解直播課程上所介紹的內容，將可來參與本次活動。 課程大綱第一堂：7/14 Vue 起手式 起手式中將帶大家認識 Vue JS 的基本運作，以及 JavaScript 中的常見基本知識，而這些知識將有助於接下來的學習及實戰開發。 第二堂：7/21 Vue 與指令 Vue 是一個關注點分離的框架，開發者將專注於 JavaScript 的資料處理，並透過指令的形式將資料呈現於畫面上。 第三堂：7/28 Options API 當學習到 Options API 以後，已經可以開始嘗試各種應用開發，在此你將可以學會各種資料操作的技巧。 第四堂：8/4 Composition API Composition API 是 Vue 3 中一個相當大的新功能，開發將超出原有 Vue 的限制，提供更大的變化及運用。 活動時間 報名時間：即日起開始報名， 活動開始時間：7/14 ~ 8/4 內容包含「每週一場直播」、「每日任務」、「週間挑戰作業」 直播參與小獎勵 🎁為鼓勵參與直播，參與三次直播並完成報到者，將可抽額外實體獎品！ 獎項如下： 最大獎 1 名：米家無線吸塵器 mini 貳獎 2 名：小米手環 5 三獎 3 名： 小米體重計 加碼獎 5 名：Udemy 自選課程（390 元內） 如果獎品不足，主辦單位將會以同價位品項作為替代。 新手如何加入 ✋任務一：加入 Discord 並自我介紹 讓學習一加一大於二，他人的問題也許是你接下來會遇到的問題，從互動中尋找自己還缺少的問題點，甚至會遇到你未來的合作夥伴喔。 流程： 點擊 連結 加入六角學院 Discord 加入 vue-夏令營公開頻道 自我介紹一下，讓其他同學認識你吧範例：大家好，我是 卡斯伯，過去是設計師，現在想趁著 Vue 夏令營打好框架基礎。 Discord 說明文件 任務二：Vue 新手夏令營 課程文件 雖然是開放的夏令營活動，但本學院的資源都相當豐富，建議先打開，並存到你的個人最愛連結中，以便未來方便查找。 活動文件連結 任務三：訂閱六角行事曆、Youtube 頻道 活動將會在線上舉行，建議訂閱 活動行事曆 及 Youtube 頻道，避免遺漏掉重要的課程喔。 這個活動是否需要費用不需要，這個活動完全免費 常見問題Q: 一定要加入 Discord 嗎？ Discord 主要提供 每日挑戰、主線回饋及學員助教討論，接下來如果有額外的加碼內容也僅會在 Discord 中公告，如果要確保獲得完整學習體驗，建議加入 Discord 一同學習。 Q: 課程是以 Vue 2 還是 Vue 3 為主呢？ 本活動均是以最新版 Vue 3 為主。 Q: 我完全不會寫網頁，可以參加此活動嗎？ 建議至少有撰寫 JavaScript 經驗在參加比較好。 Q: 參與過程的小作業，如果做不出來怎麼辦？ 我們會提供範例解答及 Discord 志工討論。 Q: 錄影檔案會公開嗎？ 會的，錄影完全公開 Q: 我想領直播參與小獎勵，也有參與直播，卻忘記報到可以補嗎？ 不能喔～，請確保活動期間有報到成功，預期不接受補報 Q: 上完之後有興趣，是否有更深入的內容呢？ 有的，依據不同學習體驗可參考以下方案： 如果你想要自行安排學習時間 參考 「Vue 3 實戰影音」 如果想再時間內大幅提升能力，並且大量練習 JavaScript 及 Vue.js。 從 JS 基礎開始培養「JavaScript 工程師養成直播班」（預約中：10 ~ 11 月開班） 完成實戰必備作品「Vue 作品實戰直播班」（預約中：2022 1~2 月開班）","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://wcc723.github.io/tags/vue/"}]},{"title":"為什麼選擇使用 Mac 來進行開發","slug":"why-use-mac","date":"2021-06-13T16:00:00.000Z","updated":"2021-07-07T03:23:33.555Z","comments":true,"path":"life/2021/06/14/why-use-mac/","link":"","permalink":"https://wcc723.github.io/life/2021/06/14/why-use-mac/","excerpt":"","text":"我在求學過程中以及剛開始接觸開發跟許多人都一樣，是使用 Windows 作為剛開始起手的作業系統。 但現在，我主力的開發環境轉移到了 Mac OS 至今已經約有六、七年以上的時間，而這些轉移的心得也跟大家分享一下。 也先說明一下，正式進入職場以前接觸 Mac 的時間不算長，只有在職業學校中使用 Mac 操作繪圖軟體的經驗，之後很長的一段時間都沒有接觸過相關作業系統。 第一份工作，Mac 主機搭配 Windows 作業系統第一間公司老闆很重視設計，因此每個網頁設計師都會配有一台 iMac，但也因為公司內部主要是開發政府專案（.NET 後端為主力），加上當時在職設計師們普遍比較習慣使用 Windows，所以 Mac 都是使用雙系統，並且以 Windows 作為主力。 雖然主機與系統不搭，但可以感受到 iMac 主機在開發上的許多優點，例如： 系統相當穩定（傳說中最穩定的 Windows 就是搭配 Mac 主機） 螢幕畫面優美，不需要外接螢幕就有很棒的顯示 設計時會覺得自己整個高格調了起來 也因為如此，覺得如果 Windows 都有不錯的表現的話，那麼如果直接使用更相符合硬體的系統不就更棒嗎？接下來，開始嘗試切換到 Mac 雙系統的另一面：Mac OS（過去稱為 OS X），憑藉的很久以前的經驗開始摸索 Mac 的使用方式。 如果要說實話，Mac OS 的流暢度其實並不會高於雙系統下的 Windows，甚至有些操作如 Adobe 的繪圖軟體，Mac 那個彩色圈圈的讀取時間體感上是略高於 Windows。但就算如此，還是會更想在 Mac 上進行開發，因為 Mac OS 所自帶的高格調，就會讓自己覺得自己的等待是值得的（對，沒錯，就是這樣的錯覺）。 高格調的感受 Windows 筆電小故事工作一年以後購買了第一台工作用的筆電，當時因為預算上的限制，所以購買了兩萬多左右的 14” Windows 筆電（cpu、記憶體 在當時規格都不錯的主機），紅色的外殼就讓我們等等稱它為小紅，而這樣看似購買 CP 值較高的解決方案，但卻造成更多的浪費。主要原因如下： 螢幕色偏嚴重：這是最受不了的，螢幕色偏很嚴重對於設計師執行就有很大的扣分；除此之外，就算有品質不錯的設計作品，拿出去展示也無法真實呈現這是一個好作品。 螢幕閃爍：螢幕的品質就被挑出了兩項，除了色偏以外，閃爍容易造成眼睛疲勞，一般使用大概一小時就會極感不適。 重量：雖然只有 14”，但裡面通包了許多看似「高規格」的項目，因此重量超過 2kg。 效能：看起來 CPU、記憶體都很夠力，但實際運作卻不太行；主要原因是因為筆電為求尺寸、穩定性，所以硬碟轉速只有 5400 轉，對於長期使用桌電的我來說卻忽略到此項目。 另外提到一件打擊更大的事情，當時因為是一個前端的菜鳥，想要多增加前端技術的認識，因此很熱衷於參與各項 Conference，記得當時的是參加 Web Conference，很早就提著小紅筆電到現場找個有插座的座位坐下，這台筆電的變壓器相當大，除了有一個大屁股外，中間還有一個鉛筆盒般的塊狀物（這兩段加起來是 Macbook 變壓器的兩倍大）。 等到更接近會議開始時，望向周圍都是清一色的蘋果符號，蘋果的輕巧加上高續航力，畫面開的瞬間就顯得我的小紅黯然失色。雖然很清楚該把重點放在研討會的本身，所以盡全力的使用小紅紀錄筆記，但也持續觀察 Macbook 與 Windows 筆電的差異，不斷的被 Macbook 的優雅給吸引。 在當時的 Windows 筆電都還是以 HD 為主時，Macbook 已經轉為使用 SSD，並且移除了光碟機、沒什麼用的插巢（例如 VGA），所以使得 Macbook 可以相對市面上的主機輕巧很多，並且可維持良好的效能。 而這台小紅的不便性，讓我用不了太多次就將它給收藏起來，只有在緊急的狀況才會拿出來使用，大多情況下他都屬於被冷凍的狀態。 想追求高 CP 值的 Windows 筆電，實際卻沒有辦法省到半毛錢 第一次自己購買 Mac，更高的掌握度後來隨著能力上升，薪資也不斷的成長，所以投資自己的腦袋同時也投資了一台自己的設備 Macbook 14”，這也是自己購買的第一台 Mac 主機。 除了 Macbook 以外，自己平常還會有一台 Windows 主機。使用 Mac 很長一段時間以後，那樣高格調的感覺慢慢消失，對我來說就是一台工作機。不過這台工作機不便裝任何遊戲或任何娛樂項目在內，因此使用 Mac 很容易進入「心流」的模式，常常都是尿憋不住才會強迫自己離開座位去上廁所。 在當時，Mac 更大的優勢是安裝各種開發環境是相對容易的，各種主流的開源技術，都是從 Mac OS 優先上線（unix like），等到用戶量足夠以後再提供更多的解決方案至 Windows 系統上，當時常見的服務如： 設計：Sketch、Affinity 系列軟體，就連 Adobe XD 推出時，Mac OS 版本的功能也比 Windows 多 好用的工具：太多惹 軟體開發：系統內建 git、brew、Ruby 環境（直接影響到 Sass 開發）… 因此，有屬於自己的 Mac 時，就可以放膽的安裝各種系統在內，不需要花上更多的時間去研究環境，導致自己的學習成長緩慢。因此，擁有自己的 Mac 不僅是工作上的優化，更能加速自身的學習效率。 擁有自己的專屬工作機，掌握各種進階的開發環境 現在對於 Mac 的看法現在的其它作業系統，已經沒有前面所列的各項問題，例如： 許多軟體在多個平台都可運作 市場普遍的顯示裝置品質都大為提升（別買太便宜的，都有不差的品質） 開發環境建置越來越簡單 前端開發已不再依賴於 Ruby，已經轉為以 Node.js 為主（沒有作業系統的限制） 但 Mac 的優勢依然存在，由於獨特的硬體生態系，讓整個工作流程達到了一體化，例如： 強大的備份機制（Time Machine）：讓 Macbook 出門就被車輾過，都能透過買一台新的快速還原。 多裝置同步：Mac、iPhone、iPad 各項資源互相傳遞更容易，例如：Mac 開發的網頁用手機可以立刻打開、iPhone 截圖可以直接用 Mac 打開。 團隊協作檔案互傳：在公司內，我們均是以 Macbook 為主，因此檔案互傳都可以透過 Airdrop 傳送，更可避免雲端資安問題。 便宜的雲端服務 iCloud：相對大部分的雲端儲存空間來說是相當便宜的，而且對於蘋果所有裝置支援度都極高。 M1 看起來很香，但我還沒有 T_T 曾經有一次錄音結束，稍作休息回來正要剪輯影片的時候，居然檔案損毀、檔案損毀、檔案損毀…，立馬翻開 Time Machine 歷史記錄，剛好在休息片刻的同時已經備份完畢，所以可以還原到前一個階段，無痛繼續開始剪輯。 也不得不說，這是蘋果厲害的地方，他創建了一個生態系，讓你慢慢地投入少數的幾個裝置，然後欲罷不能的購買更多的裝置；當所有的裝置有更好的串聯體驗以後，往後的裝置更新、替換，都會使用蘋果生態系作為選擇。 至於，Mac 沒有缺點嗎？當然也是有，而且還一大堆，但畢竟沒有最完美的系統，只有當下最合適的選擇，改天我們再來抱怨 Mac 那些爛地方吧。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://wcc723.github.io/tags/mac/"}]},{"title":"Mac 擷取系統音效 - 直播、錄影均適用","slug":"mac-reacord-by-soundflower","date":"2021-06-12T16:00:00.000Z","updated":"2021-06-13T03:35:21.801Z","comments":true,"path":"life/2021/06/13/mac-reacord-by-soundflower/","link":"","permalink":"https://wcc723.github.io/life/2021/06/13/mac-reacord-by-soundflower/","excerpt":"","text":"直播遊戲或是錄影希望搭配系統的聲音，如果沒有另外進行設定，就只能透過麥克風接收系統所播放的聲音，這樣的品質對於聽眾來說真的不太好，且如果太大聲也會影響直播者 / 錄影者的思緒。 因此，本篇介紹如何使用「軟體」的方式擷取系統的聲音，如果直播或錄影工具可接收多個收音裝置，將可使用系統的聲音進行錄影 / 直播，本篇所介紹的直播工具為 OBS，也是許多值播主所使用的軟體。 請注意，本篇不支援「M1」的作業系統。 第一步：安裝 Soundflower先安裝 SoundFlower 音效擷取工具，雖然它是 2014 的軟體，但到目前的 Intel Mac 主機均能正常運作。 請注意，它目前並不支援「M1」的作業系統。 打開下載的壓縮檔以後，可以看到 Soundflower.pkg，如果直接點擊兩下會無法安裝。 請使用右鍵 &gt; 選擇打開的方式開啟來開啟這份安裝檔。 接下來選擇左方的打開，就可以開始進入安裝的流程。 安裝完 SoundFlower 以後，可以看到聲音的項目下增加了 SoundFlower(2ch)、SoundFlower(64ch)，到這個步驟就算是已經完成了（如果沒有，可以重開機試試看）。 第二步：OBS 設定回到 OBS，進入「設定 &gt; 音效」內可以選擇 SoundFlower(64)（如下圖的選擇方式），他會擷取系統的音效，而 麥克風 / 輔助音效可以選擇另一個麥克風，讓擷取聲音的同時也可以播放麥克風的聲音。 可以看到，音效混音器增加了一個「擷取音效輸出」，如果要調整直播時的錄製聲音大小，一樣可以透過鍵盤上的聲音調整（如果沒有正確切換，也可以將目前的播放器改為 SoundFlower(64)）。 這麼做會只能透過 OBS 直播時，觀眾可聽到聲音但直播主聽不到，如果是播放音樂的話，直播 / 錄影也難以了解目前所播放的進度。 擷取 + 播放一起共存打開「音訊 MIDI 設定」，可以在畫面左下 + 號找到「製作多重輸出裝置」。 下拉選單可以找到「製作多重輸出裝置」。 選擇後加入「Macbook 揚聲器」及「SoundFlower(64ch)」，然後主裝置選擇 SoundFlower(64ch)，設定方式如下圖。揚聲器可以選擇外接的耳機，但 AirPods 設定上經常失敗；另外每次調整設定都可能導致擷取出現錯誤，會建議直接刪除重做一個新的「多重輸出裝置」。 這段設定完，回到系統偏好設定 -&gt; 聲音 -&gt; 輸出 -&gt; 選擇「多重輸出裝置」 如下圖，選擇「多重輸出裝置」。接下來回到 OBS 應該就能正確運作了（OBS 設定不需要另外調整）。 接下來會有另一個問題：「多重輸出裝置」難以調整每個輸出裝置的聲音大小。因此，可以回到前面的「音訊 MIDI 設定」，進入輸出的裝置調整單獨的音量（SoundFlower 也可獨立設定）。 接下來預計就可以設定出以麥克風音效為主，擷取音效為輔的設定。以 OBS 聲音的介面來說，目前測試麥克風可以到黃色的區塊（到紅色可能會破音或太大聲），而擷取的音效輸出上可以依據需求調整，如果要作為背景的音效建議可以低於 -35 左右的刻度。 以上，祝大家錄影、直播順利～","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"mac","slug":"mac","permalink":"https://wcc723.github.io/tags/mac/"}]},{"title":"NODE.JS 開 API 不求人 - 教學影片","slug":"node-js-live","date":"2021-06-02T16:00:00.000Z","updated":"2021-06-03T11:48:56.551Z","comments":true,"path":"development/2021/06/03/node-js-live/","link":"","permalink":"https://wcc723.github.io/development/2021/06/03/node-js-live/","excerpt":"","text":"直播主題：NODE.JS 開 API 不求人活動時間時間：5/19 晚間八點直播位置：六角學院 Youtube 頻道 本次直播內容包含： API 的運作原理 建立 CRUD 的 API 範例 前端與後端的 API 串接示範 共筆文件：共筆文件 影片 講者：卡斯伯六角學院共同創辦人從設計轉行前端的工程師 粉絲頁：https://www.facebook.com/WccCasper 部落格：https://wcc723.github.io/","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"node.js","slug":"node-js","permalink":"https://wcc723.github.io/tags/node-js/"}]},{"title":"VSCode Prettier 整合 ESLint 自動排版","slug":"vscode-eslint-prettier","date":"2021-04-10T16:00:00.000Z","updated":"2021-04-11T05:19:07.055Z","comments":true,"path":"development/2021/04/11/vscode-eslint-prettier/","link":"","permalink":"https://wcc723.github.io/development/2021/04/11/vscode-eslint-prettier/","excerpt":"","text":"VSCode 中有一個非常不錯的格式化工具，可以透過一個按鍵將雜亂的程式碼排列的整整齊齊，無論是 HTML、CSS、JavaScript 均可以套用\b。而此工具稱為 “Prettier”，在 VSCode 中也是屬於預設工具，除了預設選項外也能有許多的客製化調整。 而我們在開發的過程中，為了確保團隊的開發風格一致，JS 部分通常也會導入 ESLint 來統一撰寫風格。 但是，ESlint 與 Prettier 先前是兩者不相容的，雖然 Prettier 可以將程式碼一鍵格式化，但預設的格式是與 ESLint 並不一致，所以許多專案甚至乾脆的關閉 Prettier 這樣好用的工具。 不過這個問題在近期獲得了解決，現在可以透過套件讓 Prettier 直接載入 ESLint 設定檔，讓整份文件不僅符合團隊風格，更可透過一個按鍵快速格式化！ 環境準備要整合 Prettier 與 ESLint 需要以下幾個步驟： 專案加入 ESLint VSCode 安裝 “Prettier ESLint” 專案中加入「prettier」及「prettier-eslint」 步驟一：專案須先導入 ESLint本篇介紹 Prettier 與 ESLint 的整合，因此 ESLint 的設定檔案是必要的，各大框架都有導入 ESLint 的流程，或是可參考「透過 ESLint 學習 JavaScript ES6」來安裝 ESLint 至你的開發環境中。 步驟二：VSCode 安裝 Prettier ESLint 延伸模組此套件可以讓 VSCode 中的 Prettier 套件使用 ESLint 的設定檔案，直接在 VSCode 模組搜尋安裝即可。 延伸模組說明：https://marketplace.visualstudio.com/items?itemName=rvest.vs-code-prettier-eslint 步驟三：專案中加入「prettier」及「prettier-eslint」至上「步驟二」以後，可以試著跳過此流程直接跳下一段落試試看，許多框架會直接引入此套件，因此在框架所產生的環境已可直接使用 ESLint 結合 Prettier。 但如果還是無法運作，可以在專案中安裝這兩個套件。官方文檔有說明這是必要的，而你可以選擇安裝在全域或是在此專案中。npm i prettier prettier-eslint --save-dev 使用 Prettier 一鍵符合 ESLint 格式吧接下來，打開雜亂無章的 Code，此範例是使用 ESLint Airbnb 的規範，調整以前以此段程式碼中在 Airbnb 的規範會跳出 4 ~ 5 個提示。 按下 ctrl + shift + p，如果是 Mac 使用者則是 cmd + shift + p，可以看到以下的介面後輸入「format」，可選擇文件格式化方式（format Document…）。 選擇 Prettier ESLint，或者你也可以選則「設定預設格式」，將預設指向 Prettier ESLint。 最後，按下 alt + shfit + f，Mac 使用者則是 option + shift + f，就能看到剛剛那份程式碼轉為符合 ESLint 的格式囉～ 以這段程式碼說就調整了以下格式： 移除首行多餘的程式碼 將 var 改為使用 const 宣告物件的後方補上了分號 雙引號改為了單引號 程式碼最後補上了一行空白行 而這僅在短短一個熱鍵中就完成了，並解決過去要花上許多時間調整 ESLint 錯誤的問題。 文章發佈於：卡斯伯 Blog","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://wcc723.github.io/tags/vue/"}]},{"title":"Vue3 中使用 Event Bus","slug":"vue-3-mitt","date":"2020-12-14T16:00:00.000Z","updated":"2020-12-15T07:14:43.077Z","comments":true,"path":"development/2020/12/15/vue-3-mitt/","link":"","permalink":"https://wcc723.github.io/development/2020/12/15/vue-3-mitt/","excerpt":"","text":"Vue 2 中要進行跨元件通訊，除了 Vuex 以外的另一個常見手法是 Event Bus，對於小型專案來說 Event Bus 相當方便，僅需要 $on、$emit 兩個語法就能進行跨元件通訊。而 Vue 3 中移除了 $on、$off 等語法，因此 Event Bus 也等同於被移除。 在 Vue 3 的官方文件中也有提如果有類似的功能需求，可以參考相關的套件 mitt 或 tiny-emitter，兩者運作上差異不大，在此就針對 mitt 來進行介紹。 mittmitt 套件可用於 Vue 3，但不僅限於在 Vue 應用中使用，當有跨模組的溝通功能時都可以引用此套件，優點是寫法及運用上都會與 Vue 2 的 Event bus 相當接近（而且不需要在 Vue 的 Prototype 上加入額外的方法）。 mitt: https://github.com/developit/mitt 可愛的拳頭 範例程式碼： 匯入 mitt 的元件並調用它。 const emitter = mitt(); 建立 HTML 結構，並且加入兩個元件，本範例中會將 component-a 的資料傳送至 component-b。 &lt;div id=&quot;app&quot;&gt; &lt;component-a&gt;&lt;/component-a&gt; &lt;hr&gt; &lt;component-b&gt;&lt;/component-b&gt; &lt;/div&gt; 元件 component-a，會使用 emitter.emit 的方法推送資料至另一個元件上。 app.component(&#x27;component-a&#x27;, &#123; data() &#123; return &#123; text: &#x27;這有一段話&#x27; &#125; &#125;, template: `&lt;div&gt;&#123;&#123; text &#125;&#125; &lt;button type=&quot;button&quot; @click=&quot;pushData&quot;&gt;發送至另一個元件&lt;/button&gt;&lt;/div&gt;`, methods: &#123; pushData() &#123; emitter.emit(&#x27;getData&#x27;, this.text); &#125; &#125; &#125;); 在 component-b 製作監聽，使用 emitter.on 接收來自於 component-a 的資料。 app.component(&#x27;component-b&#x27;, &#123; data() &#123; return &#123; text: &#x27;原始資料&#x27; &#125; &#125;, template: `&lt;div&gt;&#123;&#123; text &#125;&#125;&lt;/div&gt;`, created() &#123; emitter.on(&#x27;getData&#x27;, (msg) =&gt; &#123; this.text = msg; &#125;); &#125; &#125;); 完整範例 See the Pen Vue 3.x 使用 Event Bus by Wcc723 (@Wcc723) on CodePen. 可點擊畫面中的 「發送至另一個元件」，component-a 的 text 將會透過事件 getData 傳遞至 component-b。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"vue","slug":"vue","permalink":"https://wcc723.github.io/tags/vue/"}]},{"title":"12 個前端愛用的 VSCode 擴充套件","slug":"vscode-extension","date":"2020-12-12T16:00:00.000Z","updated":"2020-12-13T01:19:24.197Z","comments":true,"path":"development/2020/12/13/vscode-extension/","link":"","permalink":"https://wcc723.github.io/development/2020/12/13/vscode-extension/","excerpt":"","text":"工欲善其事，缺乏好工具必定壞脾氣。 身為一名工程師，將文字編輯器打造出具個人風格也是理所當然的。VSCode 是現在主流的文字編輯器，也因為使用者相當多，沒有特別打理的情況不乏會有撞衫的情況： 「你也是用 VSCode 喔」「我也是耶…」（不知怎麼往下接） 為了避免尷尬情境，並且突顯自己的高尚，將 VSCode 安裝一堆套件，讓它每次展示就像一款從未現身於世面的工具；在社群中將不會有撞衫感，更能顯示自身的獨特品味！ 錯誤：「你的 VSCode 怎麼有彩虹線條？」正確：「天啊，你的程式碼怎麼沒有彩虹線條？」 Better Comment註解都灰灰的看不清楚嗎？ Better Comment 能夠將你的註解加入不同的色彩，並且可以依據不同的關鍵詞進行 Highlight，讓註解的說明更容易被辨識。 注意：實戰中過多的 TODO 代表不重要。 套件網址：https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments 私心推薦：⭐⭐⭐ Bracket Pair Colorizer每次都找不到大小括號的結尾在哪嗎？ Bracket Pair Colorizer 協助大中小括號（&#123;&#125;、[]、()）一一的獨立補上不同色彩，讓你在撰寫程式碼時可以專注在邏輯處理上，不必為了尋找結尾而耗去大量精力。 如果安裝此套件還是找不到結尾，代表你的程式碼真的太亂惹。套件網址：https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer 私心推薦：⭐⭐⭐⭐ indent-rainbow找不到大小括號就算了，連 103 行與 127 行的縮排也都對不上！ 在撰寫 HTML 時，良好的縮排是好的習慣，不過隨著結構越複雜的情況下，常常會對不上不同行數的縮排。indent-rainbow 為 VSCode 的縮排補上彩虹般的色彩，讓你可以輕鬆地用顏色進行配對。 使用縮排進行結尾的工具或語言更能體驗到它的美好 套件網址：https://marketplace.visualstudio.com/items?itemName=oderwat.indent-rainbow 私心推薦：⭐⭐⭐⭐ Prettier對於程式碼整齊有強迫症，每次都要耗去許多時間嗎？ Prettier 可透過熱鍵的方式，針對整個檔案進行重新排版，讓你不需要自己手動一一對齊，甚至有機會找到你失散已久的結尾喔 :D Your browser does not support the video tag. 不過有時候，你必須把它關掉自己手動對齊（眼神死） 套件網址：https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode 私心推薦：⭐⭐⭐⭐ Import Cost身為一個專業的開發者，應該要能精確的掌握外部資源的大小。 Import Cost 可以計算 @import 或 require 的外部資源尺寸，包含原始尺寸及 Gzip 均有提供。 別只注意到你的 JS 尺寸，結果頁面中隨便一張圖就比原始碼大 套件網址：https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost 私心推薦：⭐⭐⭐ VSCode 中文化沒中文就是看不懂辣～ VSCode 為國際知名大廠微軟大大所開發，因此包含各種語系檔案也是理所當然的，而語系檔案並非直接附加在 VSCode 上，需要另外透過套件的形式另行安裝。 安裝教學：https://wcc723.github.io/development/2019/12/01/vscode-chinese/ 套件網址：https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant 私心推薦：⭐⭐⭐⭐ CodeSpellChecker看到過去拼錯的變數名稱很糗嗎？ CodeSpellChecker 針對程式碼的英文拼字進行偵測，避免把 start 拼成了 strat；老手一瞬間成了新手！CodeSpellChecker 還支援各種連接形式， _、-、大小駝峰通通都可做拼字檢查～。 看到別人拼錯，儘早提醒他是維持雙方關係的好方法 套件網址：https://marketplace.visualstudio.com/items?itemName=MS-CEINTL.vscode-language-pack-zh-hant 私心推薦：⭐⭐⭐⭐⭐ Live Server確保本地開發與運行環境一致，使用 Web Server 是好方法。 如果是在具有後端的環境下，如 PHP、.NET 開發都是包含 Web Server，但有時僅是製作小工具，如果還要開啟後端環境就太麻煩了，Live Server 這個套件能夠讓你一鍵秒開 Web Server，不需再花費許多時間在環境上。 Your browser does not support the video tag. Live Server 開服務像免費一樣，常常會不知道開到第幾 port 惹套件網址：https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer 私心推薦：⭐⭐⭐⭐⭐ dash什麼方式搜尋文件最潮呢？ 透過 dash 只需要一鍵就能將程式碼中的片段說明文件調出，支援各種網路上可搜尋到的大部分文檔，讓你不需透過瀏覽器就能掌握各式語言，付費版本更是 0 等待。還在花時間查文檔嗎？dash 絕對讓你在查詢文件上潮到爆～ Your browser does not support the video tag. 說實在，都拼不出來了怎麼使用此功能. 套件網址：https://marketplace.visualstudio.com/items?itemName=deerawan.vscode-dash 私心推薦：⭐⭐⭐ PDF Preview, Excel Viewer, SVG Viewer我要住在 VSCode 啦～～ 網路下載的、客戶寄來的、同事分享的，每一個檔案格式都不一樣，開啟一堆應用程式就煩躁嗎？你可以試試以下套件，讓你一個 VSCode 就能預覽所有文件，輕鬆開關不佔用你的應用程式列。 看起來簡單，但真的很實用的系列 套件網址： Excel Viewer: https://marketplace.visualstudio.com/items?itemName=GrapeCity.gc-excelviewer PDF Viewer: https://marketplace.visualstudio.com/items?itemName=analytic-signal.preview-pdf SVG Viewer: https://marketplace.visualstudio.com/items?itemName=cssho.vscode-svgviewer 私心推薦：⭐⭐⭐⭐ favorites前後端程式碼混在一起，老是找不到自己寫的檔案嗎？ favorites 能夠讓將專案中的特定檔案、資料夾存到我的最愛，往後需要存取時不需要一層一層的尋找。 雖然 cmd + p 可以很快切到指定檔案，但是金魚腦不一定記得檔名啊～ 套件網址：https://marketplace.visualstudio.com/items?itemName=howardzuo.vscode-favorites 私心推薦：⭐⭐⭐⭐ Polacode佛要金裝、人要衣裝，程式碼貼文前也需要個好框框。 Polacode 可以依據你的編輯器主題、Highlight 色彩、字體、縮放尺寸快速產生用於貼文的圖片，如果你是經常活躍於網路社群的開發者，那麼此工具則不可錯過！ 在 Instagram 上，有露臉的照片比不露臉的照片更能獲得更多關注；有外框的程式碼也能受到更多人的閱讀（毫無證據的推論）。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wcc723.github.io/tags/vscode/"}]},{"title":"Async function / Await 深度介紹","slug":"async-await","date":"2020-10-15T16:00:00.000Z","updated":"2020-10-19T01:59:31.610Z","comments":true,"path":"development/2020/10/16/async-await/","link":"","permalink":"https://wcc723.github.io/development/2020/10/16/async-await/","excerpt":"","text":"非同步在前端的做法不斷的在進行優化調整，先前介紹過 Promise 可以解決非同步過度巢狀的問題，而本篇要介紹的 async function（非同步函式） 及 await 則可以將非同步的程式碼寫成類似同步的形式。 Promise 與 async, awaitPromise 本篇不會詳細介紹，如果不熟悉可以先查看 本篇 文章，Promise 與非同步函式兩者是密不可分的，雖然 async function 易讀性優於 Promise，但請先確保對於 Promise 有一定理解再來使用非同步函式。 本篇先建立一個基於 Promise 的函式，以下的範例都會不斷呼叫此函式來進行撰寫。/** * 範例 Promise 函式 * * @param &#123;Number&#125; num 數值：作為判斷非同步成功與否的條件 * @param &#123;Number&#125; [time=500] 數值：非同步所執行的時間長度 * @returns 如果 num 為真則套用 resolve；失敗則套用 reject */ function promiseFn(num, time = 500) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; num ? resolve(`$&#123;num&#125;, 成功`) : reject(&#x27;失敗&#x27;); &#125;, time); &#125;); &#125; promise 函式呼叫時可以使用 then 來接收 resolve 的結果，當要串接兩個 promise 函式時可以使用 return 來做 “鏈接”。 promiseFn(1) .then(res =&gt; &#123; console.log(res); // 1, 成功 return promiseFn(2); // 鏈接第二次的 Promise 方法 &#125;) .then(res =&gt; &#123; console.log(res); // 2, 成功 &#125;); 基於 Promise 的方法相當單純，就是不斷的呼叫 Promise 函式以及使用 then 來進行鏈接，Promise 可以解決過巢及串接 callback function 語法不一致等問題，但它依然在 JS 的同步語言中插入了一段非同步的片段。 Async function 及 Awaitasync function 可以用來定義一個非同步函式，讓這個函式本體是屬於非同步，但其內部以“同步的方式運行非同步”程式碼。 await 則是可以暫停非同步函式的運行（中止 Promise 的運行），直到非同步進入 resolve 或 reject，當接收完回傳值後繼續非同步函式的運行。 Promise 的回傳狀態，需要進入 resolve 或 reject 後，非同步函式才會繼續運行 上述以 promise、then 寫法的程式碼，以 async 函式改寫方式如下： 定義非同步函式（async function） 透過 await 暫停 promiseFn，直到回傳後再繼續向下 async function getData() &#123; const data1 = await promiseFn(1); // 因為 await，promise 函式被中止直到回傳 const data2 = await promiseFn(2); console.log(data1, data2); // 1, 成功 2, 成功 &#125; getData(); 以上這段程式碼的結果與使用 then 是一致的，但就結構上更加平整，在 getData 這個函式中都是以 “同步“ 的方式運行，不會產生同步、非同步程式碼混合的狀況。 無論是不是 Promise，大家都是同步程式碼逐行執行。 Async / Await 語法解析Async / Await 目的是讓程式碼的結構變得更加簡潔、易懂，所以運用上也如上述一樣單純（如果沒有 “錯誤”，它確實很單純），本段則額外補充說明這兩者新加入的語法是如何在 JS 中運作的。 async function 非同步函式async function 的用法相當特別，用此語法所宣告的函式，可在其內以“同步的方式運行非同步”程式碼；但就名稱上 async 是稱為非同步，那麼它的 非同步 又存在哪呢？ async function asyncFn() &#123; return &#x27;a&#x27;; &#125; console.log(asyncFn()); 非同步 稱的就是 async function 所定義的函式本體，當使用 console.log 查看 async function 那麼將可以得到與 Promise 結構相似的函式，該函式是以非同步的方式運行，無法直接使用 console.log 取得其值。 在 Promise 中，如果要取得 resolve 的結果會使用 then，而 async function 也是相同使用 then()。 asyncFn().then(r =&gt; &#123; console.log(r) &#125;); 雖說如此，實戰中不太會這麼做，回到目的性來說：「async function 是讓函式內的語法同步執行」。也因為 async function 與一般函式定義的不同，所以請避免將所有的 function 前方都補上 async，這會產生運行及概念上不同的函式。 Await 運算子await 是屬於一元運算子，它會直接回傳後方表達式的值；但如果是 Promise 時則會 “等待” resovle 的結果並回傳。 雖然是運算子，但是在原始碼中直接運行 await 則會出現錯誤，它只能在 async function 中運行，所以 async/await 基本上是一體的，不會單獨出現。await 1; // Uncaught SyntaxError: await is only valid in async function 比較神奇的是 await expression 卻可以直接在 Chrome console 中運行。 await 可以直接回傳後方的表達式，或者將非同步函式中的 Promise 暫停，如以下範例的 await promiseFn(2) 會 “等待” resolve 結果回傳後，在賦予至 data2 才會回傳。async function getData() &#123; const data1 = await 1; const data2 = await promiseFn(2); console.log(data1, data2); // 1 &quot;2, 成功&quot; &#125; getData(); 使用 try…catch 進行錯誤的處理前面幾段都僅有提到 resolve 的結果，但實際上程式碼的運行不會都只有成功，在 Promise 定義也就包含了 resolve 及 reject 的回傳，而調用 Promise 的方法時也就可以使用 then 及 catch 來接收成功及失敗的結果。 then、catch 範例程式碼，如果運行正確則會繼續往下運行，當遭遇失敗則會跳到 catch 的流程。promiseFn(1) .then(res =&gt; &#123; console.log(res); return promiseFn(0); &#125;) .then(res =&gt; &#123; console.log(res) &#125;) .catch(err =&gt; &#123; console.log(err) &#125;); 相對來說 Promise 的成功、失敗流程的混合撰寫，容易在維護上難以除錯。 重要：當使用 async/await 時，因為該片段程式碼已轉為同步的形式，如果遇到錯誤沒有進行例外處理，則會造成後續的程式碼無法繼續運行。 async function getData2() &#123; const data1 = await promiseFn(1); const data2 = await promiseFn(0); // Uncaught (in promise) 失敗 console.log(data1, data2); &#125; getData2(); 此段程式碼會直接中止，不會出現 console.log 的結果。 async/await 錯誤流程可以使用 try...catch 陳述式管理流程，將原有的程式碼直接置入於 try 流程內，當遇到例外的錯誤時則撰寫在 catch 區塊內。 以下範例來說 try 內的程式碼與原本介紹的一般流程是相同的，僅不過加入了 catch 來處理 reject 的錯誤流程。這樣的結構下，就可以將程式碼區分為成功、錯誤兩個流程，閱讀上也會更加容易。async function getData2() &#123; try &#123; // 專注在成功 const data1 = await promiseFn(1); const data2 = await promiseFn(0); console.log(data1, data2); &#125; catch (err) &#123; // 專注在錯誤 console.log(&#x27;catch&#x27;, err); &#125; &#125; getData2(); 圖解概念：正常流程與錯誤流程分離，且一般流程中還可維持同步執行的特色，避免巢狀的程式碼。 執行順序的技巧Promise 是透過鏈接及 Promise 的方法（Promise.all, Promise.race）來達到不同的執行順序方法。async/await 則讓非同步有了同步的寫法，因此許多原有的 JS 語法都可以一起搭配做使用，如迴圈、判斷式都是可利用的技巧，在了解這段以前，需要先知道非同步主要有兩個時間點： 送出 “請求” 的時間 取得 “回應” 的時間 依據這段概念，又可以區分成： 請求依序發出：一個一個往下執行 請求平行發出：全部的請求一起發出 回應依序列出：依據請求發出的順序，依序列出資源 回應統一列出：不管什麼時候取得都統一列出 請求依序發出時：下一個請求必須等待前一個取得回應後才能繼續動作 請求為平行發出時：無論先後順序都將同時發出請求。 Promise.all 平行執行，統一列出回應資訊Promise.all() 是 Promise 物件下的方法，此方法可傳入一個陣列，陣列包含多個 promise，Promise.all()可以統一發出所有陣列內的請求，並取得所有回應時統一回傳，async/await 可搭配此語法得到一次性的所有回應。async function promiseAll() &#123; const data = await Promise.all([promiseFn(1, 3000), promiseFn(2)]); console.log(data) &#125; promiseAll(); // [&quot;1, 成功&quot;, &quot;2, 成功&quot;] 取得結果與送出的陣列順序相同。 依序發出請求的方式for...loop 是可以被中斷的迴圈形式（使用 break 中斷），所以其實可以理解他是屬於依序執行的陳述式，當 for 內包含 await 時就必須等待 await 取得回應後才能執行下一個迴圈。 本範例中先建立一個陣列 arrayData，其中包含數值及執行時間。const arrayData = [&#123;num: 1, time: 500&#125;, &#123;num: 2, time: 3000&#125;, &#123;num: 3, time: 1500&#125;, &#123;num: 4, time: 1000&#125; ]; 透過 for...loop 的迴圈形式依序執行 promiseFn 並帶入陣列內的資訊，待前一個執行完畢後才會進入下一個迴圈，待陣列內容執行完畢後則會列出所有的回應結果。async function seriesFn() &#123; const data = []; // 依序執行 for (let i = 0; i &lt; arrayData.length; i++) &#123; const item = arrayData[i]; data.push(await promiseFn(item.num, item.time)); console.log(item.num, &#x27;執行完畢&#x27;) &#125; console.log(data); // [&quot;1, 成功&quot;, &quot;2, 成功&quot;, &quot;3, 成功&quot;, &quot;4, 成功&quot;] &#125; seriesFn(); 執行順序影片 平行執行、依序列出相對於 for...loop 來說 forEach 無法被中斷，並且會幾乎同時運行所有的迴圈內容。 本範例是使用 map 取代 forEach 的方法（兩者概念是接近的）。雖然請求幾乎在同一個時間執行，但執行的時間順序是不確定的，還是會等待執行完成後才統一列出。async function parallelFn() &#123; const data = arrayData.map(async item =&gt; &#123; const res = await promiseFn(item.num, item.time); // 此行的 await 不會暫停函式運行 return res; &#125;) console.log(data); for (const res of data) &#123; console.log(await res); &#125; &#125; parallelFn();map 會在執行時就取得結果，此時 data 內的 promise 是尚未 resolve 的狀態，因此需要在後續使用 for...of 等待回應的內容。 時間順序上分別為 500, 3000, 1500, 1000，其中第二個所花的時間較長，因此在第二個執行完成後，剩下以後也會統一列出。 async/await 搭配 fetchfetch 也是基於 Promise 的 Web API，因此它也同樣能夠使用 async/await 來進行改寫，fetch 與一般 AJAX 套件比較不同之處是在 JSON 回傳後，必須在使用 json() 的方法將資料輸出成 JSON 格式（相關介紹可以參考：MDN Fetch）。 當使用 Promise then 時，則會使用 return 來呼叫 json() 方法（箭頭函式縮寫，所以省略了 return）， fetch(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;) // 取得遠端資源，並透過 return 方式回傳鏈接 .then(response =&gt; response.json()) // 接收 `response.json()` 轉換的結果 .then(json =&gt; console.log(json)); 透過 async 改寫範例如下，結構上更為平整易於閱讀。(async ()=&gt; &#123; // 取得遠端資源 const res = await fetch(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;); // 使用 response.json() 將資源轉為 JSON 格式 const json = await res.json(); console.log(json); &#125;)(); 參考資源： Google 開發者文件：https://developers.google.com/web/fundamentals/primers/async-functions MDN Async/Await：https://developer.mozilla.org/zh-CN/docs/learn/JavaScript/%E5%BC%82%E6%AD%A5/Async_await","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"async","slug":"async","permalink":"https://wcc723.github.io/tags/async/"},{"name":"await","slug":"await","permalink":"https://wcc723.github.io/tags/await/"}]},{"title":"VSCode JS 註解就是你的文件","slug":"vscode-intellisense","date":"2020-10-12T16:00:00.000Z","updated":"2021-07-09T11:50:02.190Z","comments":true,"path":"development/2020/10/13/vscode-intellisense/","link":"","permalink":"https://wcc723.github.io/development/2020/10/13/vscode-intellisense/","excerpt":"","text":"在使用文字編輯器時，你是否有以下狀況呢？ 搞不懂，為什麼文字編輯器總是沒跳提示 函式庫沒有安裝插件就不知道如何輸入 同事或過去自己寫的函式不知道在寫什麼，都要花上許多時間去理解 想要為函式補充註解，但不知道如何著手 那麼你可以試著使用 VSCode，強大的 Intellisense 搞定所有函式提示！ 函式的提示使用 Sublime Text 或 Atom 時，當載入外部的套件需要加上文字提示時，就需要另外安裝相應的套件；而 VSCode 本身的 Intellisense 就有提供強大的提示功能，不安裝額外套件的情況下就能提供許多的提示。 以 jQuery 來說，只要外部資源載入的情況下，不需要另外安裝其它 jQuery 相關插件就能夠獲得程式碼的提示。 首先，先將 jQuery 載入到網頁內（需要完整版的 jQuery 才能有此功能）。&lt;script src=&quot;https://code.jquery.com/jquery-3.5.1.js&quot;&gt;&lt;/script&gt; 輸入 $. 的情況就會列出 jQuery 的所有方法，開發者可以直接使用上下按鍵進行選擇，所有的方法也有提供相對應的說明（如文中是 jQuery 的 get 方法，作用是發出 GET 請求）。 $() 選取器內，也會提示是需要帶入選取器的表達式。 鏈接的方法在運用上也是沒有問題的，以下選擇一個 DOM 元素後，加入 . 也會列出更多相應的方法。 自訂你的文件既然 jQuery 的提示不安裝套件就能運作，那麼是否自訂的函式也有此功能呢？ 當然有的，官方文件 中對此也有完整的說明，介紹該如何自訂屬於自己的提示文件。以下我們就手把手來為函式加入說明文件吧。 以下是 JS 文件的範例，文件的規範可參考，如果直接看範例可能會不知如何著手，而 VSCode 對此其實有很完整的支援，不需要自行建構這些文件格式。/** * 這是相加的功能 * * @param &#123;Number&#125; a 數值 1 * @param &#123;Number&#125; b 數值 2 * @returns &#123;Number&#125; 相加後的數值 */ function add(a, b) &#123; return a + b; &#125; 首先，需要一段範例程式碼，以下是簡單的相加函式。function add(a, b) &#123; return a + b; &#125; 接下來在函式的前方連續輸入 /** 就會直接出現文件的樣板，文件的樣板會自動帶入該函式的參數、回傳欄位，接下來只要專注在文檔撰寫即可。 接下來就可在產生的模板中輸入相對應的說明文檔： 撰寫範例，撰寫中 VSCode 也會跳出提示（型別提示），也特別注意此段註解必須相鄰於函式才可運作。/** * 這是相加的功能 * * @param &#123;Number&#125; a 數值 1 * @param &#123;Number&#125; b 數值 2 * @returns 相加後的數值 */ function add(a, b) &#123; return a + b; &#125; 實際演示，在後方程式碼輸入 add 則會出現 Intellisense 的提示，提示內容就是剛剛所撰寫的文檔（相信自己寫一次以後，也更能看懂函式庫的文件說明）。 add() 括號內也會分別帶出兩個參數的說明。 add() 第二個參數說明。 import/export 的外部資源也能運作Intellisense 可以直接偵測與本文件中有哪些相依的檔案，因此外部匯入的檔案依然可運作，以下將程式碼改用 export default 的方式進行匯出。export default &#123; /** * 這是相加的功能 * * @param &#123;Number&#125; a 數值 1 * @param &#123;Number&#125; b 數值 2 * @returns &#123;Number&#125; 相加後的數值 */ add(a, b) &#123; return a + b; &#125;, &#125;; 接下來在另一個檔案中匯入該檔案，圖片中可看到 Intellisense 的功能可以正常運作。 結語VSCode Intellisense 的效能優於許多文字編輯器，且不需要安裝套件就可直接載入函式庫的說明，函式庫的方法新增、調整也不用擔心，因為文檔是隨著載入的函式庫進行運作。 除此之外在多人協作時，也可透過註解的形式加入特定函式的說明文檔，讓其他協作的開發者能夠輕鬆上手。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"}]},{"title":"純 CSS 毛玻璃特效 - backdrop-filter 屬性介紹","slug":"frosted-glass","date":"2020-10-11T16:00:00.000Z","updated":"2020-10-12T02:34:44.564Z","comments":true,"path":"development/2020/10/12/frosted-glass/","link":"","permalink":"https://wcc723.github.io/development/2020/10/12/frosted-glass/","excerpt":"","text":"幾年前的 iOS、MacOS 更新以後，毛玻璃視覺效果越來越受到許多人喜愛，在使用毛玻璃以前，背景與主要的畫面區塊的風格整合是一件麻煩的事情，除了畫面的協調性外，還要維持資訊的傳達性。而毛玻璃可以讓背景的畫面霧化，凸顯上層的主要資訊，並讓背景與整體不致於產生衝突感。 網頁在套用毛玻璃的特效流程近年有大幅的簡化，過去在線上有介紹過 純 CSS 的毛玻璃的技法，是透過多層的偽元素搭配 filter 的模糊效果完成，開發的程式碼繁雜，運作上也有許多的限制。不過在 2019 推出了新的 CSS 語法，毛玻璃的特效僅需要一個短短屬性就可達成，讓我們一起來看看怎麼做吧。 .demo { padding: 30px } .box { height: 400px !important; width: 100% !important; display: flex; justify-content: center; align-items: center; color: white; border: 1px solid rgba(255, 255, 255, .15); } .object-cover { object-fit: cover; } .background-cover { background-position: center center; background-size: cover; } .object-bottom { object-position: right bottom; } 這是本文會使用到的圖片，圖片來自於 Unsplash，如果失連歡迎與我聯絡。 偽元素 + Filter 的做法在新的語法推出以前，純 CSS 製作毛玻璃特效僅有此方法，原理： 將上層區塊中加入一個與背景相同的圖片 上層區塊內的圖片尺寸需超過該區塊 將區塊內的圖片轉為模糊 原始碼及說明：.filter.box &#123; position: relative; /* 裁切多餘區域 */ overflow: hidden; /* 加入 z-index，區塊內的文字才能正確顯示 */ z-index: 1; &#125; .filter.box:after&#123; content: &quot;&quot;; background-position: center center; background-size: cover; position: absolute; /* 圖片需超過外層的區塊 */ top: -30px; bottom: -30px; left: -30px; right: -30px; background-image: url(https://images.unsplash.com/photo-1602251627070-6a9bab4e420e?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1355&amp;q=80); /* 加入模糊 */ filter: blur(5px); z-index: -1; &#125; .filter.box { position: relative; overflow: hidden; z-index: 1; } .filter.box:after{ content: \"\"; background-position: center center; background-size: cover; position: absolute; top: -30px; bottom: -30px; left: -30px; right: -30px; background-image: url(https://images.unsplash.com/photo-1602251627070-6a9bab4e420e?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1355&q=80); filter: blur(5px); z-index: -1; } 實際運作範例： 毛玻璃特效 by filter 這個手法兩層的圖片必須完全相同，所以作為背景的區塊無法有任何的其它元素。 backdrop-filter，一行就能搞定在 Chrome 76 版加入的新屬性 backdrop-filter，此屬性能夠將區塊內的背景統一加入特效，此語法就不需要用到偽元素，僅需要短短的一行即可搞定。 範例程式碼（就這樣而已）：.backdrop-blur &#123; backdrop-filter: blur(5px); &#125; 實際範例，不管背景圖如何，區塊內的 backdrop-filter 都能夠將背景加入特效。 .backdrop-blur { backdrop-filter: blur(5px); } 毛玻璃特效 by backdrop-filter backdrop-filter 具有許多特點，除了能夠將圖片加上特效外，更嚴格來說它是將整個區塊的下層加上特效，只要在套用的區塊下都能運作。以下範例來說，於底部加上了一段文字，在 hover 後的視覺效果也能套用 backdrop-filter 的特效（在此使用 invert）。 &lt;style&gt; .backdrop-invert &#123; transition: 1s all; &#125; .backdrop-invert:hover &#123; background-color: rgba(0, 0, 0, .25); backdrop-filter: invert(80%); &#125; .absolute { position: absolute; color: white; text-align: center; left: 0; right: 0; } .backdrop-invert { transition: 1s all; } .backdrop-invert:hover { background-color: rgba(0, 0, 0, .25); backdrop-filter: invert(80%); } 底層有其它的文字 請用滑鼠 Hover 過此區塊 更多 backdrop-filterbackdrop-filter 除了毛玻璃以外，亦有包含非常多的特效（就如同 Photoshop 一樣），語法列表如下： blur: 模糊（毛玻璃就是你～） brightness: 明度 contrast: 對比度 drop-shadow: 陰影 grayscale: 灰階 hue-rotate: 色相 invert: 反轉 opacity: 透明度 sepia: 棕褐色 saturate: 飽和度 這裡也提供簡單的工具，便於大家瀏覽所有的特效效果。 特效選單： -- 請選擇特效 -- 模糊 blur 明度 brightness 對比度 contrast 陰影 drop-shadow 灰階 grayscale 色相 hue-rotate 反轉 invert 透明度 opacity 棕褐色 sepia 飽和度 saturate 底層有其它的文字 目前套用的效果為：無 const customBackdrop = document.querySelector('#custom-backdrop'); const backdropSelect = document.querySelector('#backdrop-filter'); const backdropText = document.querySelector('#backdrop-text') let backdrop = ''; backdropSelect.addEventListener('change', function() { const style = this.value; console.log(style); customBackdrop.style.backdropFilter = style; backdropText.innerText = style; });","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"scss","slug":"scss","permalink":"https://wcc723.github.io/tags/scss/"}]},{"title":"新手前端也不該犯的錯：圖片變形","slug":"img-cover","date":"2020-10-10T16:00:00.000Z","updated":"2020-10-11T01:43:12.822Z","comments":true,"path":"development/2020/10/11/img-cover/","link":"","permalink":"https://wcc723.github.io/development/2020/10/11/img-cover/","excerpt":"","text":"網頁常見錯誤的之一：圖片比例變形 當網頁有此錯誤時，會大大的降低網頁的畫面水平，如果是作為一個求職作品，也會被貼上 “不細心” 的標籤，本篇介紹幾種簡單的方式來解決此問題。 以下是原始圖片（圖片來自於 Unsplash，如果失連歡迎與我聯絡）。 .box { height: 400px !important; width: 100% !important; } .object-cover { object-fit: cover; } .background-cover { background-position: center center; background-size: cover; } .object-bottom { object-position: right bottom; } 常見的錯誤就是將 img 標籤限制了高度，卻又設定了 100% 寬度，導致圖片的比例變形（下圖會隨著不同裝置有不同的比例問題，本文在桌面版可以看到最明顯的錯誤）。 使用背景圖這是相對支援度較高的做法，將 img 中的圖片改為使用 background-image 來呈現，並使用 background-size: cover; 的方式來限制顯示區域，同時也可搭配 background-position 來調整圖片的顯示位置。 原始碼參考如下，可搭配 background-position 來調整背景圖的位置（預設是圖片的左上方）；簡單易用，且有不錯的瀏覽器相容性。 .background-cover &#123; background-position: center center; background-size: cover; &#125; background-size: cover; 可以讓背景圖盡可能覆蓋整個區域，此做法也會裁切掉部分圖片，因此要特別注意到保留的區塊是否為圖片的主題；如果圖片主題被裁切可試著改變 background-position 屬性；當無法正確呈現主題會建議替換其它圖片，或採用其它的排版方式。 圖片裁切概念，會盡可能將圖片覆蓋整個區域，超出區域的部分將會被裁切。 使用 img 標籤搭配 object-fit此作法概念與上述相同，但可保留 img 的特性（可以加上 alt 以及較好的 SEO）。 object-fit 是決定圖片填滿方式的屬性，用法與 background-size 相當類似，僅不過是套用上 img 專屬的屬性。另外，它不支援 IE11。 .object-cover &#123; object-fit: cover; &#125; 預設來說它的定位是在圖片的正中央，定位也可透過 object-position 來進行調整。 .object-bottom &#123; object-position: right bottom; &#125; 過去，大多會推薦使用 background-size 來解決圖片比例變形的問題，因為很難預期觀看者是否會使用 IE11 來檢視你的網頁，隨著微軟公布不再支援 IE11，開發者可以盡情地開始使用 object-fit 屬性了。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"scss","slug":"scss","permalink":"https://wcc723.github.io/tags/scss/"}]},{"title":"Bootstrap 5 格線的運作原理","slug":"bootstrap-5-grid-whats-new","date":"2020-10-09T16:00:00.000Z","updated":"2020-10-10T01:27:18.558Z","comments":true,"path":"development/2020/10/10/bootstrap-5-grid-whats-new/","link":"","permalink":"https://wcc723.github.io/development/2020/10/10/bootstrap-5-grid-whats-new/","excerpt":"","text":".box { height: 100px; background-color: #69F0AE; display: flex; justify-content: center; align-items: center; } Bootstrap 4 中我經常會建議學員不要自行調整水平間距，因為在不熟悉的情況下這可能會造成許多額外的問題，常見的情況有： 整體的格線風格不一致 格線左右無法對齊 可能會產生水平捲軸 這些錯誤容易被細心的使用者發現，對整體的網站造成不好的印象。而這個問題在 Bootstrap 5 獲得了改善，並且有大幅度的優化（僅產生少量的 CSS 就能達到數十種變化），如果熟悉自行編譯的方式，甚至可以自訂網站合適的間距，就讓我們來看看 BS5 的格線概念吧！ 可自行調整的間距（gutters）Bootstrap 4 中主要是透過 .row, form-row 以及加入 no-gutters 來控制格線的間距，在這幾個搭配下主要會產生三種間距的距離，分別是 30px、10px、0px，在大部分情境這幾種就已經足夠使用，但偏偏網站開發就是需要那些不足夠的部分。 Bootstrap 5 加入新的 Gutters 概念，是使用 g*-* 來設定格線的間距（文檔可參考），其中： 前者的 *：標示 x 軸或 y 軸的水平或垂直空間，也可以省略表示 “垂直及水平”。 後者的 *：標示 0 ~ 5 的數值表示距離，數值越大間距越大。 g*-* 只需要加入到格線中的 .row 層級，其內部的 .col-* 不需要另外的調整就可以運作；也因為新的 Gutters 概念，原有的 .no-gutters 及 .form-row 在第五版都被移除了，接下來就透過實際案例來介紹運用方法吧。 開始前，先定義一個方塊作為內容，高度 100px、寬度不限，接下來由格線決定的方塊的寬度、位置，方塊的原始碼及實際呈現如下。 .box &#123; height: 100px; background-color: #69F0AE; display: flex; justify-content: center; align-items: center; &#125; 等等會一直看到這個方塊，此方塊所代表的就是內容。 過去，會定義 .row &gt; .col-* 的格線結構，Bootstrap 5 中只需要將上述的 g*-* 加入到 .row 即可，以下範例中就加入了水平(x)的間距，分別是 5 以及 1 兩種不同尺寸。 &lt;div class=&quot;row gx-5&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;row gx-1&quot;&gt; &lt;div class=&quot;col&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;col&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 使用 gx-* 所加入的間距不會像過去一樣影響格線的運作，並且能夠與不使用格線的物件左右對齊。 沒有使用格線的物件 使用 gx-5 的區塊 使用 gx-1 的區塊 Bootstrap 5 如何實作這個概念？套用了 g*-* 概念以後，Bootstrap 會不會變得很肥大？ 在原有的 CSS 概念中，如果要調整外層、內層的樣式時，就需要每個元素都設定樣式才可運作，在此同時操作了 .row 及 .col-*，尤其是 .col-* 又有數十種變化型，一一套用的情況下檔案不就肥死。 Bootstrap 5 在此巧妙了使用變數的技巧，透過變數的階層控制，就不需要一一覆蓋所有的樣式。 在此提供另一個範例程式碼來進行介紹： 外層由 .casper, .ming 來設定變數值。 內層直接使用 var(--bg-color) 取得外層的變數。 .casper &#123; --bg-color: orange; &#125; .ming &#123; --bg-color: skyblue; &#125; .custom-box .box &#123; background-color: var(--bg-color); &#125; 這種方式內層就不需要一一定義，僅需要調整外層的變數值即可套用至內層，當需要調整的樣式較多時就可使用此技巧。 .casper { --bg-color: orange; } .ming { --bg-color: skyblue; } .custom-box .box { background-color: var(--bg-color); } 原始的 .box 外層為 .casper 的 box 外層為 .ming 的 box Gutters 更多的延伸運用既然有了變數的加持，再多的間距也不用太擔心，因此 Bootstrap 5 所提供的預設間距變化型分別如下： 方向性的調整： x：水平空間 y：垂直空間 ：不填值的上右下左四個方向 距離的調整： 0：沒有間距 1 ~ 5：由小至大的不同距離 所以除了水平空間外，也可以統一為了所有元素加入垂直空間，參考如下： &lt;div class=&quot;row gy-2&quot;&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; 透過此方式就不需要為內層的元素一一加上 .my-2（用過 Bootstrap 4 相信都能理解這是一件麻煩的事情）。 或者，可以直接為垂直、水平加入相同的間距。 &lt;div class=&quot;row g-2&quot;&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;box&quot;&gt;&lt;/div&gt; &lt;/div&gt; ... &lt;/div&gt; 在過去要達到垂直、水平間距相同是相對麻煩的事情，但現在版本就簡單許多囉。 如果只需要格線但不要間距，就可套用 g-0 移除所有的間距。 &lt;div class=&quot;row g-0 border&quot;&gt; &lt;div class=&quot;col-sm-6 col-md-8&quot;&gt;&lt;/div&gt; ... &lt;/div&gt; 在此版本也移除了 no-gutters，直接使用 g-0 這個神奇的 className 進行取代。 .border .box { border: 1px solid #4bc187; } 1 2 如果想要更多的間距怎麼辦Bootstrap 4 以後都很強調自己是可以被客製的，在官方的文檔中也有提供調整 Gutters 的說明文件，如果覺得這些 Gutters 太多、太少、間距不夠大，都可以隨意地增減。 $grid-gutter-width: 1.5rem; $gutters: ( 0: 0, 1: $spacer * .25, 2: $spacer * .5, 3: $spacer, 4: $spacer * 1.5, 5: $spacer * 3, ); 如果對於客製化 Bootstrap 有興趣，也可以參考本篇文章。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"scss","slug":"scss","permalink":"https://wcc723.github.io/tags/scss/"}]},{"title":"怎樣也不會失手的 Bootstrap 格線運用技巧","slug":"bootstrap-grid","date":"2020-10-08T16:00:00.000Z","updated":"2020-10-09T06:17:59.366Z","comments":true,"path":"development/2020/10/09/bootstrap-grid/","link":"","permalink":"https://wcc723.github.io/development/2020/10/09/bootstrap-grid/","excerpt":"","text":".box { height: 100px; background-color: #69F0AE; } .form-row>.col, .form-row>[class*=col-] { padding-right: 5px; padding-left: 5px; } .form-row { display: -ms-flexbox; display: flex; -ms-flex-wrap: wrap; flex-wrap: wrap; margin-right: -5px; margin-left: -5px; } Bootstrap 令人稱羨的其中之一就是它的格線系統，不僅易用且符合網頁視覺設計概念。雖說如此，在官網文件 落落長的文件還是令許多開發者不知如何快速上手，本篇介紹幾個核心小撇步，讓開發者僅需要記得一個口訣，就能輕鬆上手 Bootstrap 的格線系統。 Bootstrap 格線設計概念Bootstrap 設計上都是遵循 OOCSS 的概念（關於 OOCSS 可參考），格線在此是套用其中的 容器與內容 的概念。格線表示為容器，而網頁所呈現的資訊就稱為內容。 在這個概念下，格線所代表的容器將會決定定位、寬度大小，內容不會有自己的寬度，都是由容器決定 因此我們先定義一個方塊作為內容，高度 100px、寬度不限，接下來由格線決定的方塊的寬度、位置。 .box &#123; height: 100px; background-color: #69F0AE; &#125; 等等會一直看到這個方塊，此方塊所代表的就是內容。 簡單的口訣許多開發者再運用 Bootstrap 時會犯了許多錯誤，如： 格線內物件與非格線內容無法正確對齊 格線的間距不一致 產生額外的水平捲軸 引起這些錯誤的問題非常多，一一舉例說明將會佔去許多篇幅，因此請先謹記兩個要點即可： .row 的內層必定為 .col .col 的外層必定為 .row .row 的內層必定為 .colBootstrap 使用 .row 作為水平列的定義，它會包覆著不同數量的欄線 .col，作為水平列的 .row 有包含許多樣式（如：flex、負值的 margin），這些樣式必須搭配 .container 及 .col 進行修正。因此，如果在 .row 內置入非 .col 的物件就可能會出錯。 所以第一點，請先記得：.row 的內層必定為 .col 正確範例：.row 的內層僅會使用 .col，不會有其它的。&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;格線內的 .box &lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;格線內的 .box &lt;/div&gt;&lt;/div&gt; &lt;/div&gt; 正確的套用情況下，不管有無使用格線，左右邊線的對齊都是一致的。 沒有套用任何格線的 .box 格線內的 .box 格線內的 .box 錯誤範例當 .row 的內層套用了其它元素，有無套用格線系統的元素左右將無法正確對齊。&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;box&quot; style=&quot;width: 100%&quot;&gt;其它的元素會超出格線範圍，並且預設必須加入寬度才能顯示&lt;/div&gt; &lt;/div&gt; 不正確的套用情況下，.row 內的元素無法與外部元素左右邊線對齊。 沒有套用任何格線的 .box 其它的元素會超出格線範圍，並且預設必須加入寬度才能顯示 .col 的外層必定為 .row由於 .col 會修正 .row 的部分樣式，因此 .col 獨立出現時，為了修正 .row 的額外 padding 就會使得物件無法對齊。 正確範例：.col-* 的外層必定會有 .row。&lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-12&quot;&gt;&lt;div class=&quot;box&quot;&gt;格線內的 .box &lt;/div&gt;&lt;/div&gt; &lt;/div&gt; 無論多少數量的 .col-*，只要外層具有 .row 就會正確對齊。 沒有套用任何格線的 .box 格線內的 .box 錯誤範例：.col-* 必定在 .row 的內側，不可獨立出現&lt;div class=&quot;box&quot;&gt;格線內的 .box &lt;/div&gt; &lt;div class=&quot;col-12&quot;&gt;&lt;div class=&quot;box&quot;&gt;格線內的 .box &lt;/div&gt;&lt;/div&gt; 獨立出現的 .col-* 無法與其它元素正確對齊，它會加入額外的 padding。 沒有套用任何格線的 .box 格線內的 .box 相同口訣、延伸運用這兩句話看起來有很多的限制，但其實又具有很高的彈性，像是 .row 的內層必定為 .col，但只要內層是 .col 即可，沒有數量上的限制，並且 .col 的內層並沒有任何的限制。因此本段提供許多不同的變化型給大家做參考。 .row 的內層必定為 .col .col 的外層必定為 .row .row, .form-rowBootstrap 4 另外有推出 .form-row 的選項（參考文件），這會產生間距較小的格線，雖然預設規劃是給予表單使用，但它也同樣很適合用在僅需要小間距的排版。 .form-row 一樣可以把它當作是 .row 的孿生兄弟，它僅是有較小的間距，其餘的概念都是與 .row 完全相同，因此他一樣符合相同的概念，內部僅能有 .col-* 的元素。 &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;hr&gt; &lt;div class=&quot;form-row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 正確的套用下，左右邊線也是可以完全對齊的。 巢狀.col 的內部依然可以有 .row，並且有獨立的欄線，它會用內層有限的空間持續進行格線分割。 &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;div class=&quot;col-6&quot;&gt;&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 就算使用多層分割，間距、對齊都會是一致的，如果使用另一個類似概念的單層結構也是能夠完全對齊。 使用巢狀 單層格線 最後，請別忘了 container前面有提到 .row 會產生額外的負值 margin，當如果 .row 是直接置於最外層時會讓網頁產生水平捲軸，請避免網頁產生不必要的水平捲軸，這會使開發者看起來就像新手一樣。 如果要避免此問題，請維持一個 .container 或 container-fluid 在外層（無論你有多少個 .row，都僅需要一個在最外層） &lt;div class=&quot;container&quot;&gt;&lt;!-- 請維持一個 container 在最外層 --&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-8&quot;&gt; &lt;div class=&quot;row&quot;&gt; &lt;div class=&quot;col-4&quot;&gt;&lt;/div&gt; &lt;div class=&quot;col-4&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 如果網頁有多個區塊，則可以在每個區塊都有獨立的 .container，不一定只用一個 container 包覆全網站。如以下範例有多個區塊時，也可以有各自的 container 或 container-fluid，讓每個區塊的容器有更多的變化。 &lt;section class=&quot;container&quot;&gt; ... &lt;/section&gt; &lt;section class=&quot;container-fluid&quot;&gt; ... &lt;/section&gt; &lt;section class=&quot;container&quot;&gt; ... &lt;/section&gt; 結語Bootstrap 格線是很棒的格線工具，無論是在切版或網頁設計得格線教學，我都很推薦使用 Bootstrap 的概念，它是目前可行性優及泛用性廣的格線系統，但也為了達到此概念，其中加入了許多 “HACK” 讓這個格線能夠具有許多特性（如：負值的 margin 是為了多列呈現，在 Bootstrap 2 時的格線就不能換列）。 也因為這些 “HACK” 我們在使用 Bootstrap 格線需要更加小心，如果沒有正確對齊會造成畫面無法對齊，開發者也會花上許多時間為了修正這些沒對齊的項目，並產生許多不必要的樣式。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"scss","slug":"scss","permalink":"https://wcc723.github.io/tags/scss/"}]},{"title":"手把手自訂你的 Bootstrap 樣式","slug":"custom-bootstrap-style","date":"2020-10-07T16:00:00.000Z","updated":"2020-10-08T03:35:50.151Z","comments":true,"path":"development/2020/10/08/custom-bootstrap-style/","link":"","permalink":"https://wcc723.github.io/development/2020/10/08/custom-bootstrap-style/","excerpt":"","text":"Bootstrap 在第四版以後在介紹文檔，說明自己是一個函式庫而不是框架。樣式的框架代表載入後都是基於此架構開發，無論是否喜歡特定的內容，都需要先全盤接受後再自行調整；而函式庫代表你可以選用自己喜歡的部份，並且調整成合適的樣式，相對於框架來說有更高的彈性。 本篇將會依據 Bootstrap 文檔及實戰的經驗，與大家分享開發中常用的客製化技巧，讓大家可以輕鬆的客製 Bootstrap 樣式。 對於客製化，你也可能會想問到： Q: 為什麼要客製化？客製化可以使 Bootstrap 更符合專案的風格樣式。 Q: 用覆蓋不行嗎？一定要客製化嗎？就經驗上來說，覆蓋通常會缺少許多的狀態，如按鈕的 hover, active, focus 等等，並且容易使樣式缺少一致性。 Q: 編譯？Bootstrap 不是 CSS 嗎？Bootstrap 的 .css 檔案是編譯後的結果，它原始檔案是屬於 .scss 的結構，本文只會針對其中的變數檔案進行介紹，不需要會 .scss 也可以進行調整喔。 Q: 客製化環境是不是很複雜，如果沒有 gulp、webpack 使用經驗是否就無法？不會，本章節介紹的方式僅需要使用 VSCode 即可（有安裝 Node.js 更好，但不強制）。 建立環境本範例會使用 VSCode 及其相關套件，相關連結可參考： VSCode：主要的文字編輯器 LiveSass complier：這是用來編譯 Bootstrap scss 的工具 一分鐘，將你的 VSCode 官方中文化，英文版用不慣嗎？試試看這個方法 確保已經安裝好 VSCode 及 LiveSass complier 就準備繼續往下進行囉，接下來依據以下步驟建立專案： 創建專案資料夾於 VSCode 中（這會影響套件是否能正確編譯） 建立以下檔案分別是 index.html 及 all.scss（建議在另一個資料夾內） 下載 Bootstrap 原始碼在準備編譯以前，需要先將 Bootstrap 載入至電腦內，載入的方式有兩種： 使用 npm 下載（推薦 直接到 GitHub 下載 方法一：使用 npm 下載只要在 node.js 環境中輸入以下程式碼即可： npm install bootstrap 接下來在專案內會增加 node_modules/bootstrap 的資料夾，並且內部包含 Bootstrap 的原始碼，其中的 scss 資料夾就是本次編譯會使用到的內容。 方法二：直接下載先進入 Bootstrap 官方的 Github 儲存庫，進入後先調整 tags 進入指定的版本，本範例是以 Bootstrap 4.5.x 為主（第四版以後差異不大）， 接下來下載原始檔案，並且將 scss 資料夾移至剛剛所建立的專案資料夾內。 開始準備編譯接下來環境準備差不多，已經可以開始準備進行編譯，而本範例中的編譯會參考 官方文件 及自己實戰上的經驗，為了讓客製化更為便利、快速，所以我將官方的方法略作調整，讓變數的查找上更為便利。 步驟一：複製 _variables.scss 變數在 node_modules/bootstrap 資料夾內可以找到 scss 資料夾（如果是自行下載也可依據置放的路徑進行尋找），該資料夾內可以找到 _variables.scss 的檔案： 先找到 _variables.scss 的檔案 將檔案複製到 stylesheets 資料夾內 說明：這個步驟是避免直接調整外部原始資源，開發的檔案總是會與外部資源分開管理。 步驟二：將變數、Bootstrap 資源引入打開一開始建立的 all.scss 檔案，依序置入以下程式碼，其中 /node_modules/bootstrap/ 的路徑請依據你的專案進行配置，如果是自行下載結構上可能略有不同。 // Required @import &quot;../node_modules/bootstrap/scss/functions&quot;; // 必要的方法 @import &quot;helpers/variables&quot;; // 自行定義的變數路徑 @import &quot;../node_modules/bootstrap/scss/mixins&quot;; @import &quot;../node_modules/bootstrap/scss/bootstrap&quot;; // Bootstrap 完整原始碼 這段資源的載入順序是來自於官方文件，文件中是依序載入官方的資源後另外進行客製，本範例則是將_variables.scss 的變數進行替換。 相對於逐一客製，直接調整 _variables.scss 是更為便捷的 步驟三：開始編譯你的 Bootstrap環境都準備完成以後就可以開始進行編譯，VSCode 下方有 LiveSass complier 套件的編譯工具，在畫面的右下角可找到 Watch Sass 的字眼，按下後即可進行編譯。 編譯成功後可在 stylesheets 資料夾內找到 all.css 的檔案。 打開 all.css 檔案，請先確保該檔案的上方可看到 Bootstrap 的字眼，其中也會包含所引入的版本號。 接下來，將 index.html 引入 all.css ，到此步驟環境就算是建立完成，你的頁面已經可以開始使用 Bootstrap 惹。 &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;stylesheets/all.css&quot;&gt; &lt;/head&gt; 步驟四：客製化你的樣式回到 _variables.scss 的檔案內，可以看到非常多的樣式變數，別看到這麼多的變數就感到緊張，如果你熟悉 Bootstrap ，會發現這些變數名稱與 Bootstrap 的元件名稱（或樣式）是一致的。 其中，可以找到 $theme-colors 的變數名稱，這是 Bootstrap 所有主題的色彩，你可以任意替換其中的顏色，甚至是增加色彩都是沒有問題的，以此範例中我們調整部分色彩以及加入一個色彩。$theme-colors: map-merge( ( &quot;primary&quot;: orange, // 替換的色彩 &quot;secondary&quot;: $secondary, &quot;success&quot;: $success, &quot;info&quot;: $info, &quot;warning&quot;: $warning, &quot;danger&quot;: $danger, &quot;light&quot;: $light, &quot;dark&quot;: $dark, &quot;hex&quot;: #69F0AE // 新增的色彩，並使用 hex 這個變數 ), $theme-colors ); 只要維持 Watch Sass 開啟的狀態，儲存檔案後 Live Sass 都會自動進行編譯。最後，在 HTML 檔案中可以測試所有的主體色就能看到替換後的結果，以此範例來說，按鈕的色彩就進行了替換及新增。&lt;button class=&quot;btn btn-primary&quot;&gt;Primary Button&lt;/button&gt; &lt;button class=&quot;btn btn-hex&quot;&gt;Hex Button&lt;/button&gt; 結語Bootstrap 是令人又愛又恨的樣式庫，透過它能夠快速的建立一個網站，因為這個優點，全球有近千萬的網站都使用 Bootstrap，許多網站都使用的情況下，此樣式更容易被人記住，也因此會產生「你的網站很 Bootstrap」、「這個樣式缺少變化」的感覺。 所以，會建議使用 Bootstrap 時多利用客製化的方式，讓你的網站不會顯得那麼 “Bootstrap”，讓這個函式庫不僅加速你的開發，更能增添許多豐富性。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"scss","slug":"scss","permalink":"https://wcc723.github.io/tags/scss/"}]},{"title":"JS - for 迴圈與 forEach 有什麼不同","slug":"js-for-loop-vs-for-each","date":"2020-10-04T16:00:00.000Z","updated":"2020-10-05T06:23:35.428Z","comments":true,"path":"development/2020/10/05/js-for-loop-vs-for-each/","link":"","permalink":"https://wcc723.github.io/development/2020/10/05/js-for-loop-vs-for-each/","excerpt":"","text":"過去，當有一個陣列的內容需要依序取值時，都會使用 for... 迴圈(for loop)的形式將值一一取出，原始碼的結構如下：var array = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;漂亮阿姨&#x27;, &#x27;小美&#x27;] for (var i = 0; i &lt; array.length; i++) &#123; const item = array[i]; console.log(i, item); &#125; 現在，陣列執行迴圈不像過去那麼麻煩，陣列的原型中增加了許多方法可以直接運用（陣列方法可參考），其中的 forEach 基本上可以達到 for... 迴圈的所有需求（基本上用了 forEach 不太會再去使用 for loop）。 相同的結果，使用 forEach 後更容易被閱讀、理解。array.forEach(function(item, i) &#123; console.log(i, item) &#125;); 不過實際上這兩者還是略有差異，本篇就來介紹 for 迴圈與 forEach 的那些小差別。 for loop 可能會產生全域變數因為 JS 作用域是屬於函式作用域，而 for loop 在執行時使用 var 所建立的變數是屬於在區塊 &#123;&#125; 內，因此 for loop 運行時所定義的變數很常會是建立在 全域 的環境下。 以下範例來說，下列變數 i 就屬於全域的變數。for (var i = 0; i &lt; array.length; i++) &#123; const item = array[i]; console.log(i, item); &#125; console.log(i); // 4 相對來說 forEach 使用 callback function 就不容易踩到這個雷，不過 for loop 依然可以使用 ES6 的 let, const 來解決作用域的問題。 目前主流的文字編輯器，輸入 for 後預設都會使用 let 來定義索引 i 的變數。for (let i = 0; i &lt; array.length; i++) &#123; const item = array[i]; console.log(i, item); &#125; console.log(i) // 無法取得 i for 可以被中斷雖然 for loop 目前的使用率較不如 forEach，不過它可中斷運行的方式在 forEach 中是沒有的，如果迴圈中有必要停止運行，就可以使用 for loop 搭配 break。 for (let i = 0; i &lt; array.length; i++) &#123; const item = array[i]; if (i === 2) &#123; // 執行到索引 2 就會被中斷 break; &#125; console.log(i, item); &#125; 執行到索引 2 就會被中斷，中斷後的迴圈將不會繼續運行。 並非所有陣列都能使用 forEachJavaScript 中的陣列依據原型的不同，也有另一種分支稱為類陣列（array-like），類陣列中的原型方法與一般定義的陣列就有所不同，其中的方法就可能不包含 forEach。 函式中的 arguments 就屬於類陣列，它的方法就不包含 forEach 的方法，因此它無法直接運行 forEach。function fn() &#123; console.log(arguments); // for loop 可以正常運行 for (let i = 0; i &lt; arguments.length; i++) &#123; const item = arguments[i]; console.log(i, item); &#125; // 錯誤：Uncaught TypeError: arguments.forEach is not a function arguments.forEach(item =&gt; &#123; console.log(item); &#125;); &#125; fn(&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;漂亮阿姨&#x27;, &#x27;小美&#x27;); 純陣列的原型中可以找到 forEach 的方法。 arguments 類陣列中不包含 forEach 或任何的陣列方法。 類陣列可以直接使用 for loop 來運行它，如果要使用 forEach 的陣列方法也是可行，只要將類陣列透過 ES6 的 “展開” 語法轉換為純陣列即可（[...]）。 如以下程式碼中就透過展開將 arguments 轉變為純陣列 arg，那麼 arg 變數就可以使用 forEach 的陣列方法。function fn() &#123; const arg = [...arguments]; arg.forEach(item =&gt; console.log(item)) &#125; fn(&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;漂亮阿姨&#x27;, &#x27;小美&#x27;); 你是屬於 forEach 還是 for...loop 派呢？歡迎留言討論看看喔。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JS 常見陣列方法 [push(), unshift(), pop(), shift(), splice(), reverse(), concat(), include(), indexOf(), join()]","slug":"js-array-methods","date":"2020-10-03T16:00:00.000Z","updated":"2020-10-04T11:54:31.274Z","comments":true,"path":"development/2020/10/04/js-array-methods/","link":"","permalink":"https://wcc723.github.io/development/2020/10/04/js-array-methods/","excerpt":"","text":"本篇陣列方法是延伸過去寫的 JavaScript 陣列處理方法，目前的框架主流觀念都是「關注點分離」，框架主要都是負責畫面上的渲染；資料面完全交由給原生的 JS 處理，因此，對於資料處理的語法就需要有更高的掌握度。 熟悉陣列的方法，自然對於處理資料上會更得心應手，而先前的「陣列處理方法」是著重在迴圈的運用，而本篇則是介紹其餘常用的部分，本篇所會介紹的方法包含： push() unshift() pop() shift() splice() reverse() concat() include() indexOf() join() 初始資料本篇的篇幅較長，因此就不會將初始得陣列附在每個段落上，而所有範例都可以在 Chrome Console 上運行，如果遇到錯誤可先確認變數是否有宣告成陣列。var array = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;漂亮阿姨&#x27;, &#x27;小美&#x27;] Array.prototype.push()當需要在陣列的尾端新增一個值，你可以使用 push()。 array.push(&#x27;老媽&#x27;); console.log(array); // [&quot;小明&quot;, &quot;杰倫&quot;, &quot;漂亮阿姨&quot;, &quot;小美&quot;, &quot;老媽&quot;] 額外說明：.push() 運行時也會回傳值，回傳結果為 “陣列長度”。 Array.prototype.unshift()相反的，如果需要加入在第一個則可以使用 unshift()。 array.unshift(&#x27;老媽&#x27;); console.log(array); // [&quot;老媽&quot;, &quot;小明&quot;, &quot;杰倫&quot;, &quot;漂亮阿姨&quot;, &quot;小美&quot;] 額外說明： unshift()一樣會回傳 “陣列長度”，概念上與 push() 是相同的。 Array.prototype.shift()shift() 則可以移除第一個陣列值。array.shift(); console.log(array); // [&quot;杰倫&quot;, &quot;漂亮阿姨&quot;, &quot;小美&quot;] 呼叫此方法不僅會移除陣列值，同時會將移除得陣列值進行回傳。console.log(array.shift()); // 小明 Array.prototype.pop()pop() 則是移除最後一個陣列值。array.pop(); console.log(array); // [&quot;小明&quot;, &quot;杰倫&quot;, &quot;漂亮阿姨&quot;] 與 shift() 相同，pop() 也會回傳被移除的值。console.log(array.shift()); // 小明 Array.prototype.splice()splice() 可以移除指定位置、指定數量的陣列值，語法參考如下：splice(索引位置, 數量) 以下範例來說就刪除了索引位置為 1（&#39;杰倫&#39;），並且刪除數量 1 的陣列值，因此結果就只有刪除 &#39;杰倫&#39;。array.splice(1, 1); console.log(array); // [&quot;小明&quot;, &quot;漂亮阿姨&quot;, &quot;小美&quot;] 以下範例則是刪除索引位置為 2（&#39;漂亮阿姨&#39;），並且刪除數量 2 的陣列值，因此結果就刪除了 &#39;漂亮阿姨&#39; 及 &#39;小美&#39;array.splice(2, 2); console.log(array); // [&quot;小明&quot;, &quot;杰倫&quot;] 額外說明：splice 也會回傳值，回傳結果為陣列的本身。 Array.prototype.reverse()就如同字面上的意思，reverse() 會反轉陣列的本身。 array.reverse(); console.log(array); // [&quot;小美&quot;, &quot;漂亮阿姨&quot;, &quot;杰倫&quot;, &quot;小明&quot;] 額外說明：回傳結果一樣為陣列的本身。 Array.prototype.concat()concat 與上述的不同，呼叫此語法時並不會直接操作原有的陣列。 concat 是用於串接兩個陣列，串接的結果會透過回傳值取得，並不會套用至原有的陣列。 var newArray = array.concat([&#x27;老爸&#x27;, &#x27;老媽&#x27;]); console.log(newArray); // [&quot;小明&quot;, &quot;杰倫&quot;, &quot;漂亮阿姨&quot;, &quot;小美&quot;, &quot;老爸&quot;, &quot;老媽&quot;] array 依然是 [&quot;小明&quot;, &quot;杰倫&quot;, &quot;漂亮阿姨&quot;, &quot;小美&quot;] Array.prototype.include()include 可以用來檢查陣列中是否包含特定值，結果會透過回傳的方式取得。 console.log(array.includes(&#x27;漂亮阿姨&#x27;)); // true console.log(array.includes(&#x27;阿明&#x27;)); // false Array.prototype.indexOf()與 include() 運作上相當類似，僅不過 include() 是回傳 true、false，而 indexOf 則是回傳該值的索引位置。 console.log(array.indexOf(&#x27;漂亮阿姨&#x27;)); // 2 console.log(array.indexOf(&#x27;阿明&#x27;)); // -1 額外說明：當值如果不存在於陣列中，則會回傳 -1 Array.prototype.join()可以將陣列中的值轉變為字串，並且加入特定字元作為值相間的符號。 console.log(array.join(&#x27;, &#x27;)); // 小明, 杰倫, 漂亮阿姨, 小美 簡單的語法，但是搭配 ES6 中的 Template literal 可以用極短的程式碼組合出複雜的字串結構。 var newHTML = `&lt;ul&gt;$&#123; array.map((item)=&gt; ` &lt;li&gt;$&#123;item&#125;&lt;/li&gt;`).join(&#x27; &#x27;)&#125; &lt;/ul&gt;`; console.log(newHTML); 輸出的 HTML 結構：&lt;ul&gt; &lt;li&gt;小明&lt;/li&gt; &lt;li&gt;杰倫&lt;/li&gt; &lt;li&gt;漂亮阿姨&lt;/li&gt; &lt;li&gt;小美&lt;/li&gt; &lt;/ul&gt; 結語JS 的語法非常多，但不必要求記住這些語法，只需要有概括的理解，待需要用時直接查詢即可。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"AJAX 完整解說系列：輕鬆搞懂 HTTP 狀態碼（HTTP Status Code）","slug":"about-ajax-4","date":"2020-10-02T16:00:00.000Z","updated":"2020-10-04T01:46:44.479Z","comments":true,"path":"development/2020/10/03/about-ajax-4/","link":"","permalink":"https://wcc723.github.io/development/2020/10/03/about-ajax-4/","excerpt":"","text":"AJAX 是前端與後端的介接，當跨越不同的環境時，所有的狀態會越來越難預期，接著就可能會發生錯誤，造成的錯誤狀態可能會如下： 流程與設計不同 資料格式不符合 連線失敗、網路不穩定 程式碼上的錯誤（這就不是本章節要討論的） 錯誤在開發的過程中是非常常見的，只不過我們在開發的過程中容易「忽視錯誤」僅以「最完美個過程」進行開發，這樣的結果會導致使用者不知道正遭遇在錯誤的狀態中而苦苦等待，所以錯誤一定要給予正確的回饋。 再給予回饋以前，新手則需要了解「有哪些地方可能出錯」、「錯誤回饋有哪些」，本篇就透過 Chrome 開發者工具呈現常見的錯誤，讓大家可以先依循找出錯誤，再將錯誤的資訊回饋給予用戶。 AJAX 運行中錯誤的可能性相當多，前端、後端在介接的過程中雙方都有可能會出錯。但與後端確認前，前端可以先試著依據本篇所列出的方法，一一確認可能出錯的環節，當無法排除再與後端溝通討論錯誤的可能性。 HTTP 狀態碼（HTTP Status）HTTP 狀態碼是優先確認 AJAX 成功與否的方式，它將成功、錯誤透過數字進行不同的分類，讓開發者可以優先專注在可能出錯的環節，完整的文章可以參考 MDN，本篇則是列出常見的狀態碼。 打開 Chrome &gt; DevTools &gt; Network 可以看到 XHR 行為中都會帶有 Status 的欄位。 依據狀態碼的數值範圍可區分為以下五類： 100 ~ 199：資訊回應 *200 ~ 299：成功回應 300 ~ 399：重新導向，轉址的方法 *400 ~ 499：用戶端的錯誤 *500 ~ 599：伺服器端錯誤 其中帶有 * 的則是 AJAX 中常見的錯誤碼，以下列出前端開發者常會看到的狀態碼及錯誤的解決方式。 200 ~ 299：成功回應200 0K：恭喜你，這次的請求沒有什麼問題201 Created：資源已經被創建，POST、PUT 後可能會收到這樣的回應。 400 ~ 499：用戶端的錯誤這類型的請求大多可以收到回應（除了 404），有些可直接依據回應內容了解問題點，由前端直接排除即可。 401, 403：未取得授權、沒有權限訪問該 API，請先檢視該 API 的授權方式。404：找不到資源，通常是路徑錯誤，大多是前端的路徑輸入錯誤。422：請求是正確的，但可能不符合操作流程（大多可從後端的回應中找到問題）。429：請求次數過多，你被後端封鎖了，請過一段時間再試試看。 500 ~ 599：伺服器端錯誤這類型不一定能收到回應，因為後端伺服器出現錯誤。 500：後端不可預期的錯誤，請直接與後端聯絡503：後端無法正確處理該請求， 請跟老闆要求更好的機器（Ｘ） ，請跟後端確認當前伺服器狀態。 ResponseAJAX 中只要有 HTTP 狀態碼回應就是好的開始（除了 404 以外），在 Chrome DevTools 中也可以觀察到 HTTP 狀態碼是 2 開頭的則會判斷為成功（黑色文字），當如果是 4, 5 開頭的則會判斷為失敗（紅色文字）。 而 5 開頭的不一定能夠由前端能夠解決，但如果是 4 開頭可以試著從後端所回應的內容進行判斷，了解哪部分的環節出現問題再進行重新調整，以下透過「六角學院」的課程 API 給予大家進行參考部分情境及除錯方法。 範例程式碼：https://codepen.io/Wcc723/pen/VwaOXdw?editors=0010 原始碼可參考如下，而本範例是使用基於 Promise 的 axios 套件，依據 Promise 的規則 then 是成功的流程，catch 則是失敗的流程，兩者在本範例中接有透過 console.log 呈現錯誤內容。function addToCart() &#123; axios.post(path, data) // AJAX 成功的流程 .then(res =&gt; &#123; console.log(res.data); showText(res.data, &#x27;POST&#x27;); &#125;) // AJAX 失敗的流程 .catch(error =&gt; &#123; console.log(error.response); showText(error.response, &#x27;POST 失敗&#x27;); &#125;); &#125; 422 流程錯誤在上述範例中，連續選擇 “新增兩次”，就會出現 422 的錯誤，打開 Chrome Devtools &gt; Console 就可以看到以下資訊，如果有在 .catch 內加入 console.log() 就可以看到回傳的錯誤訊息（該商品已放入購物車當中。），或者也可直接點擊該網址查看回應的錯誤。 Network 中可以看到狀態碼為 422，好在是前端可以解決的問題。 在 Preview 的分頁可以看到後端所回傳的訊息，此訊息會與 .catch 所看到的節果一致，這僅是流程上的錯誤，將此訊息告知使用者即可。 401 未授權接下來可以將原始碼中的路徑改為如下，此 API 是後台的的訂單列表，必須取得授權才能繼續進行。 const path = `https://course-ec-api.hexschool.io/api/$&#123;uuid&#125;/admin/ec/orders`; 相同的流程下可以看到 Unauthenticated. 身份未驗證的提示，出現此錯誤請先依據 API 文件完成驗證流程；使用者端可導回登入、註冊頁面，請使用者重新驗證。 與後端的配合隨著網頁應用越來越複雜，職務的分工也越來越多元，這樣的情況下不同領域的隔閡也會越加明顯，因此在開發過程中溝通就非常的重要。 不過 “溝通” 並不是遇到問題就立即就開始建立溝通，而是需要有適當的準備，以本篇介紹的除錯概念來說，就是希望再與後端建立溝通以前，先了解問題點可能在哪，如果正確的方式都無法正確串接，再將遇到的問題與後端詢問。避免落入還沒有準備好就發問的狀態，這會讓雙方的關係產生不信任，對於長期的專案合作將有不良的影響。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"AJAX 完整解說系列：使用 Chrome Devtools 檢視請求及回應","slug":"about-ajax-3","date":"2020-10-01T16:00:00.000Z","updated":"2020-10-02T01:52:23.747Z","comments":true,"path":"development/2020/10/02/about-ajax-3/","link":"","permalink":"https://wcc723.github.io/development/2020/10/02/about-ajax-3/","excerpt":"","text":"從上一篇內容我們介紹到 AJAX 都是由瀏覽器發出請求，伺服器則會依據請求的內容進行回應。所以在這之中的 “請求”、“回應” 都會夾帶著不同資源，供瀏覽器及伺服器進行辨識及運用，所以此篇就針對瀏覽器與伺服器溝通的內容進行說明，帶大家更深入的認識 AJAX。 發出請求到回應的過程示意圖 注意：本篇以 “成功” 的請求為主，失敗不在本篇的介紹重點。 所有的資訊都在 Chrome Network本篇接續上篇的範例程式碼，使用的資源及範例程式碼如下： API 來源：https://jsonplaceholder.typicode.com axios cdn：https://cdnjs.cloudflare.com/ajax/libs/axios/0.20.0/axios.min.js 原始碼：axios.get(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;) .then((res) =&gt; &#123; console.log(res); &#125;); 範例程式碼：https://codepen.io/Wcc723/pen/YzqMpNR?editors=1010 先打開 Chrome 開發者工具 &gt; Network本次的主角是 Chrome 開發者工具中的 Network，它會列出所有網頁對伺服器的請求，而我們這次的重點是 XHR（XMLHttpRequest，可參考），使用 Network 工具的流程重點： 一定要先開啟該分頁，並維持紀錄的狀態（recording） 重新整理網頁 打開過濾器，並選擇 XHR 的過濾選項 重新整理網頁後，如果是成功的狀態會以白色底呈現，失敗的回應則會是紅色狀態，一開始進入本介面會覺得資訊量龐大，下圖標示了資源欄位的說明，而第一次進入本頁面請專注在「你預期發出的請求上」，請先避免被過多的資訊所干擾（那些都很重要，但不是當下需要了解的）。 當找到所發出的資源回應後，也就可以試著慢慢理解它包含哪些內容，點擊它繼續下一步吧！ 接下來會看到以下幾個大項目： Headers：請求及回應的標頭，這些標頭就如同我們發實體信件時，信封袋上所寫的內容，必須要明確的標註住址、收件人、電話等等資訊，才能確保信件能正確寄達，Headers 所挾帶就是這些資訊，不管是瀏覽器、伺服器都會有一份 Preview, Response：這兩者資訊是相同的，也就是伺服器回傳的資料，Preview 僅是 Response 的 “好讀版”。 Timing：本次請求至回應所耗費的時間。 Cookie：本次請求、回應相關的 Cookie 內容。 Headers標頭在 AJAX 中是非常重要的項目，就如同我們寄信時，信封袋上的資訊正確與否，將會影響信件是否正確寄達，而標頭的內容資訊相當多，本篇僅會介紹其中常見的問題。 General請求的描述，在請求發出時所套用的相關資訊（並非夾帶內容，而是接口的描述）。 Request URL: 請求路徑，也就是 API 的路徑。 Request Method: 請求方法，請特別注意方法與路徑是對應的，如果請求出現錯誤，很多時候是這兩者沒有對應。 Status Code: 狀態碼，後續章節會有詳細介紹 本篇列出前端常見的 Headers，欲參考完整的 Headers 可見 MDN：https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers Request Headers請求表頭，請求的表頭內容必須是伺服器能夠接收的格式、內容，就如同寄信到政府單位時，處、室及職稱都必須完全正確，收發室才能接收這封信件。伺服器運作時也有相同的機制，只不過現在大多的工具都會避免前後端開發時產生不必要的錯誤，所以僅有利用在必要的驗證上。 accept: 提供給後端了解前端所能接受的資料類型，就像是 word 副檔名一樣，如果格式不正確會難以解析。 user-agent: 發出請求的瀏覽器資訊，後端也常會透過此資訊來判斷瀏覽器的裝置為何（行動版、桌面版），藉此給予不同的回應。 cookie: 瀏覽器端紀錄的資訊，大多用來儲存具有時限的個人資訊，如驗證資料、網頁瀏覽紀錄。 authorization: 驗證資訊，當發出的請求需要另外進行驗證（如後端資料）時，則可透過此參數夾帶驗證資料。 Response Headers回應表頭，由伺服器回傳至瀏覽器端的表頭，為了確保信件能正確寄回，所以回應也具有類似的表頭，但由於是由後端傳給予前端，資訊也與請求的大不相同。 content-type: 資料的格式類型，依據請求的需求後端所回傳的格式，現在大多是使用 application/json，AJAX 套件會協助此部分不需另外處理。 set-cookie: 後端寫入瀏覽器端的 cookie 資訊。 status: 狀態碼，常見狀態碼在後續章節會介紹到。 access-control-****: 跨域資源，內容非常多包含：資源來源、是否允許跨域存取、跨域認證等等的描述，完整說明可參考。 Request Payload、Query String Parameters當請求時需要帶入更多資源，如上傳資料、取得特定索引時，就會利用到 Request Payload、Query String Parameters。 POST、PATCH、PUT 請求需要將資源網後端傳送時就會用到 Request Payload。 當 GET 請求多筆資料GET 通常不會夾帶資源傳送至後端，但需要從多筆資源加入篩選條件就會用到 Query 參數，如：一次取得多數的的頁面但僅需要取得第一頁時，就會帶入 page=1 的 Query String Parameters。 Preview, Response相對於 Headers 來說其它幾個內容就單純許多，Preview, Response 這兩者內容完全相同，只不過 Preview 是經過 format 美化的版本，兩者可以隨時切換檢視，只要能從中取得所要資訊即可。 兩者內容是相同的，Preview 是相對易讀的版本 TimingTiming 是網頁開啟後，從發出請求直到回應內容完全接受的時間軸，一般會看到的圖片結構如下： Connection Start: 發出請求一直到伺服器前的狀態（伺服器還沒接收到請求），這段通常與用戶所使用的網路服務、電信商有比較大的關係。Request/Response: 伺服器接收到請求。Request sent: 請求發出Waiting (TTFB): 伺服器接收到第一個字節直到伺服器產生回應的時間，這段取決於伺服器的距離、處理效能等等。Content Download: 資源下載的所花費時間，取決於用戶、伺服器兩者的頻寬、距離等因素。 Cookies伺服器儲存於瀏覽器的小片段資訊，此分頁中可以看到伺服器對於瀏覽器端進行了哪些 Cookie 儲存，Cookie 常見的屬性如下：Name: Cookie 的名稱Value: Cookie 的值Domain: Cookie 所１屬的網域Expires: Cookie 的到期日（時間到後會自動移除） 結語雖然 AJAX 在程式碼上僅會看到短短的兩三行程式碼，但其實在背後有大量的資訊持續在運行，當能夠了解這些資訊，在除錯上也能夠更佳順利。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"AJAX 完整解說系列：新增、更新、刪除（POST/PATCH/DELETE）","slug":"about-ajax-2","date":"2020-09-30T16:00:00.000Z","updated":"2020-10-01T02:08:30.783Z","comments":true,"path":"development/2020/10/01/about-ajax-2/","link":"","permalink":"https://wcc723.github.io/development/2020/10/01/about-ajax-2/","excerpt":"","text":"AJAX 除了 GET 以外，其它幾個常見的請求方法通常都會對資料庫進行操作，尤其是 POST、PUT、PATCH 在發出請求的同時還會有附加資源傳送至伺服器。 雖然相對於 GET 來說僅是多增加了 “資料”，但這個步驟卻讓許多新進的開發者困擾不已，可能是對於 JSON 結構不熟悉、或是對於 API 文件不清楚，這都可能造成請求的失敗，所以本篇帶大家從文件開始到發送，完整說明一次帶有資料的請求是如何發送的。 無論你是新手或是老手在進行 AJAX 前，都建議先別急著動手做，先從文件終將必要資訊一一條列準備後再開始進行。 JSON 與文件JSON（JavaScript Object Notation）原名是 JavaScript 的物件標示法，所以結構上是與 JS 中的物件接近（AJAX 套件通常也會協助處理，使其結構一致）。也因此，前端只要清楚如何將文件中 JSON 欄位內容以物件的方式正確建構即可。 以下使用六角直播課程中的新建購物車的文件。此段流程中會選擇一個品項並加入購物車，如果成功則會順利加入；已經加入購物車的品項則無法再次加入購物車。 流程中會使用到兩個資訊，一則是個人 UUID（可以想像是哪一個商店）以及品項的 ID（產品編號），本次會用到的資訊如下：uuid = &#x27;86bfd5d2-b7d3-4a55-93e6-ef6299ba4c1c&#x27; product = &#x27;mRdI2EbpTVMguM0jbqvlP6h6b007ySFLYLxyqO0qTWtXASP0sJJ7JlrpO9avHqWt &#x27; 在文件中可以先查找出以下資訊： 請求的路徑與方法：這兩者需要完全對應才可發送 網址上的參數（不一定需要）：此參數直接附加在 “網址上”，通常是用來作為索引 主要的參數：這是傳送資源主要參考的區塊，需逐一暸解每個參數得名稱、型別、是否必要及內容。 依據文件的內容，分別可整理出路徑方法及物件，程式碼的呈現如下： var uuid = &#x27;86bfd5d2-b7d3-4a55-93e6-ef6299ba4c1c&#x27;; // 商店 UUID var path = `https://course-ec-api.hexschool.io/api/$&#123;uuid&#125;/ec/shopping`; // 將 UUID 作為網址上的參數 依據文件將 UUID 加入至路徑中 var data = &#123; product: &#x27;...&#x27;, // 來自於產品的 ID quantity: 1 &#125; 依據文件分別列出 product 及 quantity 屬性，並帶入符合型別的值 實際發送本範例所使用的 AJAX 套件為 AXIOS：https://github.com/axios/axiosPromise 語法的介紹文：https://wcc723.github.io/development/2020/02/16/all-new-promise/ 將上述的資源準備好以後，接下來的流程也會更加順利，這些方法與 GET 最大的不同則是： 請求方法改為 post 路徑後方加上資料內容 失敗的回應接收（GET 也並非不會失敗，所有的請求對於失敗都需要有正確的處置，這留到後面的章節進行解說） 完整的程式碼如下：var uuid = &#x27;86bfd5d2-b7d3-4a55-93e6-ef6299ba4c1c&#x27;; var path = `https://course-ec-api.hexschool.io/api/$&#123;uuid&#125;/ec/shopping`; var data = &#123; product: &#x27;mRdI2EbpTVMguM0jbqvlP6h6b007ySFLYLxyqO0qTWtXASP0sJJ7JlrpO9avHqWt&#x27;, quantity: 1, &#125; axios.post(path, data) .then(res =&gt; &#123; console.log(res); &#125;) .catch(error =&gt; &#123; console.log(error.response); &#125;); 在此也附上完整的取得、新增、編輯、刪除等行為的範例程式碼，大家可以動動手，對取得、新增、更新、刪除進行操作。 See the Pen AJAX CRUD by Wcc723 (@Wcc723) on CodePen. 此範例請注意有些行為可能會出現錯誤回饋，這些錯誤回饋是正常的現象，當操作流程不符合後端規範時則會給予錯誤回饋，常見的錯誤如下： 品項僅能新增一次，再次新增則會回應錯誤 購物車必須有該品項才能更新，否則會回應錯誤 如果無法新增，可以使用刪除品項即可再次新增 *如果此範例運作上有其它錯誤，歡迎透過粉絲頁私訊給我（可能該產品品項被移除，需要重新調整） 發送後，也可以在 Chrome 的 Network 中找到發送的資源內容，在 Network &gt; 指定的請求上 &gt; Headers &gt; Request Payload 即可看到。 下個章節會介紹關於 Network 的細節 結語無論你是新手或是老手在進行 AJAX 前，都建議先別急著動手做，試著依據文件所述將資料、方法、路徑一一整理出來後再進行發送，這樣可以避免「怎麼樣發送都出現錯誤」的狀況喔～。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"AJAX 完整解說系列：基礎觀念","slug":"about-ajax","date":"2020-09-29T16:00:00.000Z","updated":"2020-09-30T08:54:47.252Z","comments":true,"path":"development/2020/09/30/about-ajax/","link":"","permalink":"https://wcc723.github.io/development/2020/09/30/about-ajax/","excerpt":"","text":"AJAX 全名是「Asynchronous JavaScript and XML」，在網頁上的功能主要是用於網頁前端與後端伺服器溝通的技術，也如同名稱一樣是透過 JavaScript 的非同步技術，在前端工程師中算是一個挑戰門檻，如果沒有此技能則難與不同領域開發者溝通，也因此在前端求職市場中趨近於基本必備技能。 相對於其它觀念來說，AJAX 因為需要與後端伺服器介接，許多開發者因為沒有此資源，也找尋不到合適的練習資源，所以難以透過網路文章、自行練習習得此技能，本篇則透過網路免費資源、六角課程資源與大家分享 AJAX 的實戰觀念。 本系列會分成三篇： 基礎觀念 AJAX 到底夾帶了哪些資料 實戰除錯 AJAX 圖解說明AJAX 網路上的文章非常多，本系列不會過多著墨在程式碼上的說明，主要原因是大多教學都是以 XHR 開始進行教學，對於基礎觀念來說非常不錯，但實戰中基本上不會看到 XHR 的字眼，也不會利用這個語法進行串接，而是依據不同的工具、框架選用合適的 AJAX 非同步套件進行運用。 首先必須知道 AJAX 整體是由哪幾個部分組成的，這幾個角色中絕少不了前端網頁、後端伺服器以及不一定出場的資料庫。在這之中網頁僅需要與伺服器溝通，資料庫會由伺服器搞定，網頁前端可以佔不需要理會資料庫。 除了前後端的實體以外，在進行 AJAX 之前再來認識幾個專有名詞，分別是 API、請求、回應。 API 接口：所有的 AJAX 都會有對應的 API 接口，API 的接口就是一段網址，不同的網址也對應不同的「HTTP 請求方法」（請求方法會在後面的段落進行介紹），請求方法必須與網址完全對應才可運作。 API 接口就如同點餐的櫃檯，依據用戶想要點的品項、餐點選擇不同的櫃檯。 網頁端請求AJAX 會統一由網頁端發出請求（無論是為了新增資源或取得資源都一律由網頁端發起），依據不同的接口、請求方法進行請求，而伺服器會依據請求的方法、內容來進行回應。 請求就如同點餐的顧客，會先說明想要什麼樣的餐點、客製化需求、詢問品項細節等抖。 伺服器回應當收到請求後，伺服器會依據請求的方法、內容與資料庫取得資源並統整過濾後進行回應。 回應是櫃台服務員對於顧客端的回應，如：點餐內容可被接受則加入購物車，如果點餐錯誤則給予顧客適當的回報。 所有的 AJAX 行為都是由網頁端先發出，透過 API 的接口對後端進行請求，而後端會針對請求的內容進行回應，運作上可參考下圖： 關於 HTTP 請求方法所有的 API 都有對應的 HTTP 請求方法（request methods），方法與 API 完全一致時，後端才能依據請求回應資源；反之，方法與 API 無法對應時就會出現錯誤（404 找不到路徑）。 常見的請求方法如下： GET：請求特定的資源，不會提交任何資源，伺服器僅會依據條件進行回應。 POST：提交特定的資源，通常會用來新增資源或是用以改變狀態使用（登入、註冊等等）。 -&gt; 伺服器會回應新增或改變狀態的結果。 PUT：取代指定的資源，通常用於完整更新。 -&gt; 伺服器會回應更新的結果。 PATCH：更新指定資源，通常用於部分資源更新。 -&gt; 伺服器會回應更新的結果。 DELETE：刪除特定的資源。 -&gt; 伺服器會回應刪除的結果。 HTTP 的方法雖然很多，每個方法功能也略有不同，但在此不需要熟記，API 的文件中大多都會詳述可用的方法，僅需要從字面概略了解其用途即可。 實際來發送一個請求試試看吧如同本文一開始所述，AJAX 雖然教學資源很多，但實際可用於練習的環境並不多，而本文章是使用 jsonplaceholder 服務進行介紹，此服務有以下特點： 具有公開 API 說明文件：https://jsonplaceholder.typicode.com/guide/ 包含所有常見的 API 及 HTTP 方法（新增、修改、刪除皆有） 提供範例程式碼 雖然看似非常完整，但最美中不足：實際資料無法被更動（新增、修改、刪除無法作用，僅會回傳成功），所以在練習上會難以體驗到自己資料被寫入資料庫的成就 :( 但就練習上來說，此 API 已經可作為基礎 AJAX 練習使用。 接下來，我們會使用 axios 以 Promise 為基礎的 AJAX 套件，因為 AJAX 屬於非同步行為，在 ES6 以後都會建議以 Promise 的語法進行串接，如果對於 Promise 有興趣可參考此 文章。 接下來我們就準備好要發出請求的資源： API 來源：https://jsonplaceholder.typicode.com axios cdn：https://cdnjs.cloudflare.com/ajax/libs/axios/0.20.0/axios.min.js 那麼，就開始著手來發出請求吧。axios.get(&#x27;https://jsonplaceholder.typicode.com/posts/1&#x27;) .then((res) =&gt; &#123; console.log(res); &#125;); 寫完惹。 雖然本系列文章很長，但其實 AJAX 複雜的並非是程式碼本身，而是其背後運作的原理，在上述的程式碼中就完整包含了： HTTP 請求方法：get API 路徑：https://jsonplaceholder.typicode.com/posts/1 伺服器回應：.then((res) =&gt; &#123; /* ... */ &#125;) 範例程式碼：https://codepen.io/Wcc723/pen/YzqMpNR?editors=1010 接下來於 Chrome Console 中就能看到回傳的結果，結果展開的內容大致如下： Object &gt; config: &#123;url: &quot;https://jsonplaceholder.typicode.com/posts/1&quot;, method: &quot;get&quot;, headers: &#123;…&#125;, transformRequest: Array(1), transformResponse: Array(1), …&#125; data: &#123;userId: 1, id: 1, title: &quot;sunt aut facere repellat provident occaecati excepturi optio reprehenderit&quot;, body: &quot;quia et suscipit↵suscipit recusandae consequuntur …strum rerum est autem sunt rem eveniet architecto&quot;&#125; headers: &#123;cache-control: &quot;max-age=43200&quot;, content-type: &quot;application/json; charset=utf-8&quot;, expires: &quot;-1&quot;, pragma: &quot;no-cache&quot;&#125; request: XMLHttpRequest &#123;readyState: 4, timeout: 0, withCredentials: false, upload: XMLHttpRequestUpload, onreadystatechange: ƒ, …&#125; status: 200 statusText: &quot;&quot; __proto__: Object 已經有了基礎觀念後，接下來要繼續了解更深入 AJAX 觀念，讓我們繼續往下吧～","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"箭頭函式常見陷阱題","slug":"arrow-homework","date":"2020-09-28T16:00:00.000Z","updated":"2020-09-29T02:44:01.266Z","comments":true,"path":"development/2020/09/29/arrow-homework/","link":"","permalink":"https://wcc723.github.io/development/2020/09/29/arrow-homework/","excerpt":"","text":"JavaScript ES6 以後加入了 ”箭頭函式“，就外觀看來它就像是一個縮寫，也因此許多新手會認為它是屬於傳統函式的縮寫形式；但其實不然，箭頭函式與傳統函式大不同，本篇僅列出最常見的 this 差異，並透過大量的範例題，並透過範例的方式讓新手避免踩到箭頭函式最常見的雷。 傳統函式的 this 問題JS 中很常利用物件、方法的形式來建構組件，在物件中的方法也可透過 this 來取得物件中的其它屬性。 不過傳統函式中 this 的指向是隨著呼叫的方式不同而定，以下方的範例來說預期會一一列出 “XXX 是小明的朋友”，但因爲列出陣列是使用 forEach 方法，其中包含了一個 callback function，所以指向也因此有所變化。 const Ming = &#123; myName: &#x27;小明&#x27;, friends: [&#x27;漂亮阿姨&#x27;, &#x27;杰倫&#x27;, &#x27;小美&#x27;], getFriends() &#123; this.friends.forEach(function(friend) &#123; console.log(`$&#123;friend&#125; 是 $&#123;this.myName&#125; 的朋友`); &#125;); &#125; &#125; Ming.getFriends(); this 的指向因為外層的 callback function 而轉為 全域，所以最終的都列出 undefined 的結果。 漂亮阿姨 是 undefined 的朋友 杰倫 是 undefined 的朋友 小美 是 undefined 的朋友 箭頭函式的解決辦法箭頭函式最大的特點就是沒有自己的 this，因此當箭頭函式中出現了 this，它則會指向外層的作用域所對應的 this。 以下範例來 this.myName 的值就能夠正確指向此物件，迴圈的值也會如預期產生。const Ming = &#123; myName: &#x27;小明&#x27;, friends: [&#x27;漂亮阿姨&#x27;, &#x27;杰倫&#x27;, &#x27;小美&#x27;], getFriends() &#123; this.friends.forEach(friend =&gt; &#123; console.log(`$&#123;friend&#125; 是 $&#123;this.myName&#125; 的朋友`); &#125;); &#125; &#125; Ming.getFriends(); 重點：因為箭頭函式沒有自己的 this，所以要找到箭頭函式的 this 指向時，可直接參考其外層作用域的 this 指向。關於 this 的指向可參考 this 與物件的關係。 透過箭頭函式可不需要調整太多結構，就能使 this 的指向符合預期。漂亮阿姨 是 小明 的朋友 杰倫 是 小明 的朋友 小美 是 小明 的朋友 箭頭函式的相關測驗只有看介紹，難以確定觀念是否正確，所以以下補上相關題目給大家練習練習。 首先，外層都會先宣告 myName = &#39;全域&#39;，所以以下題目需了解最終 this 是指向全域或區域的變數。var myName = &#x27;全域&#x27;; 題目 1以下的結果為： 小明 全域var Ming = &#123; myName: &#x27;小明&#x27;, fn() &#123; setTimeout(() =&gt; &#123; console.log(this.myName); &#125;, 0); &#125; &#125;; Ming.fn(); ........這題結構與一開始所介紹的其實是相同的，請記得箭頭函式沒有自己的 this，請向外層作用域尋找，因此會找到 fn() 這個傳統函式，在對應到 Ming.fn()，所以 this 會指向 Ming，結果為 1. 小明。 題目 2以下的結果為： 小明 全域var Ming = &#123; myName: &#x27;小明&#x27;, fn:() =&gt; &#123; console.log(this.myName); &#125; &#125;; Ming.fn(); .........實戰中，如果物件內的方法會用到 this，都會避免將該方法使用箭頭函式來建立，因為此時的 this 指向是外層的作用域，相對來說外層的作用域將更難以確立。 在此外層的作用域是直接對應全域，所以此題的結果為 2. 全域。 題目 3以下的結果為： 小明 全域var Ming = &#123; myName: &#x27;小明&#x27;, family: &#123; myName: &#x27;小明家&#x27;, fn: ()=&gt; &#123; console.log(this.myName); &#125; &#125; &#125;; Ming.family.fn(); .........此題的概念與上一題相同，雖然物件有多個層級，但在此也是直接查找最外層的最用域 this 指向，因此答案依然為 2. 全域。 題目 4以下的結果為： 小明 全域 立即函式作用域(function () &#123; var myName = &#x27;立即函式作用域&#x27;; var Ming = &#123; myName: &#x27;小明&#x27;, fn:() =&gt; &#123; console.log(this.myName); &#125; &#125;; Ming.fn(); &#125;)(); ..........這題是陷阱題，立即函式屬於 simple call，this 是指向全域。(function () &#123; console.log(this === window); // 立即函式的 this 與全域相同 &#125;)(); 因此本題的答案依然為 2. 全域。 題目 5以下的結果為： 小明 全域var Ming = &#123; myName: &#x27;小明&#x27;, family: &#123; myName: &#x27;小明家&#x27;, fn: ()=&gt; &#123; (function() &#123; console.log(this.myName); &#125;)(); &#125; &#125; &#125;; Ming.family.fn(); .........如果這題會錯可能是題目做太多被搞混了，請仔細思考一下這題的 this 由誰而定。 本題的 this 是由立即函式決定，因此是指向 2. 全域。 結語實戰中通常也不會那麼的複雜，只要清楚箭頭沒有自己的 this，外層的作用域 this 是什麼，它就是什麼。 為了避免箭頭函式在實戰中出錯，可以有以下幾個方法： 物件內的屬性方法避免使用箭頭函式定義 箭頭函式外層的函式越單純越好，避免過度巢狀 當使用箭頭函式，請先確認外層的 this 指向 只要搞懂箭頭函式的 this，也就盡情的使用箭頭函式，並嘗試使用其縮寫來大幅減少程式碼喔。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"透過練習題，摸熟 This 的運作","slug":"this-homework","date":"2020-09-27T16:00:00.000Z","updated":"2020-09-28T02:52:36.812Z","comments":true,"path":"development/2020/09/28/this-homework/","link":"","permalink":"https://wcc723.github.io/development/2020/09/28/this-homework/","excerpt":"","text":"JavaScript 的 this 會隨著調用的方式不同影響其指向的不同（ES6 的箭頭函式定義也會影響指向），網路上已經提供相當多的資源介紹 this 指向的觀念，本篇只著重在最常運用的物件方法調用做介紹，並且透過練習題的方式，帶大家一步一步認識 this 的指向。 關於「物件方法調用」可以查看本文章：https://wcc723.github.io/javascript/2019/03/18/JS-THIS/ 物件的方法調用（As an object method）當函式是使用傳統的定義方式時（function 而不是 ()=&gt;），並且只有在物件下調用時，請謹記以下這張圖的概念：如果是在物件下調用方法，this 會指向前一個物件；如果不是，大多情況會指向 window，指向 window 的 this 實戰中也不太會去用它，所以請避免調用指向 window 的 this。 一開始，先使用傳統函式定義 getName 的函式，以及定義一個 myName 的全域變數，等等我們會不斷地使用此函式及變數。 等等的題目都會詢問 console.log(this.myName) 的結果為何： 如果是全域，結果會顯示 “全域” 如果是物件，則會是物件定義的 myName function getName() &#123; console.log(this.myName); &#125; var myName = &#x27;全域&#x27;; 好的，讓我們開始練習吧。 題目 1：請問，以下的 getName 執行結果為： &#39;全域&#39; &#39;小明&#39;function getName() &#123; console.log(this.myName); &#125; var myName = &#x27;全域&#x27;; // 主要程式碼 var Ming = &#123; myName: &#x27;小明&#x27;, getName: getName &#125;; Ming.getName(); .......本題答案為 2. &#39;小明&#39;，請謹記一個概念，傳統函式如何定義不會影響 this 的指向，會影響指向的只有調用方式，在此是在 Ming 下調用 getName 的方法，因此 this 會指向 Ming。 題目 2：請問，以下的 getName 執行結果為： &#39;全域&#39; &#39;小明&#39;var Ming = &#123; myName: &#x27;小明&#x27;, getName: function() &#123; console.log(this.myName); &#125; &#125;; Ming.getName(); .......這題將 getName 函式直接定義在 Ming 的物件下，概念也與先前相同，不管如何定義，直接看是如何調用，所以本題結果依然是 2. &#39;小明&#39;。 題目 3：請問，以下的 getName 執行結果為： &#39;全域&#39; &#39;小明&#39;function getName() &#123; console.log(this.myName); &#125; var myName = &#x27;全域&#x27;; // 主要程式碼 var Ming = &#123; myName: &#x27;小明&#x27;, fn: function() &#123; getName(); &#125; &#125;; Ming.fn(); .......這題在外層調用 fn() 方法，內部再 “直接呼叫 getName 函式”，所以 函式的 this 是直接由 getName(); 這個調用方式而定（請注意，在此調用的前方沒有任何的物件），這種調用方式會稱為 “simple call”（簡易呼叫），this 的指向為 window，結果會是 1. &#39;全域&#39;。 題目 4：請問，以下的 getName 執行結果為： &#39;全域&#39; &#39;小明&#39; &#39;小明家&#39;function getName() &#123; console.log(this.myName); &#125; var myName = &#x27;全域&#x27;; // 主要程式碼 var Ming = &#123; myName: &#x27;小明&#x27;, family: &#123; myName: &#x27;小明家&#x27;, getName: getName &#125; &#125;; Ming.family.getName(); .......本題又回到 “物件的方法調用”，只要檢視 getName 調用時前方的物件為何就可確認 this 的指向（family 物件），因此 this 指向為 family 結果為 3. &#39;小明家&#39;。 題目 5：請問，以下的執行結果為： &#39;全域&#39; &#39;小明&#39;var myName = &#x27;全域&#x27;; // 主要程式碼 var Ming = &#123; myName: &#x27;小明&#x27;, fn: function() &#123; setTimeout(function() &#123; console.log(this.myName); &#125;, 0); &#125; &#125;; Ming.fn(); .......本題的結果為：1. &#39;全域&#39;這題算是許多新手會遇到的錯誤，在物件內呼叫時如果出現立即函式、回呼函式（callback function）結果會有什麼變化？絕大數的情況下這類型都會指向 window，所以不建議在此類型下直接調用 this。 延伸說明：callback function 指向不是全域的情況大多情況下 callback function 的 this 都會指向全域，但如果回呼函式的調用是在物件下，也會同樣會改變 this 的指向。不過這種情況相當少見，還是會建議避免在回呼函式中使用 this。var myName = &#x27;全域&#x27;; function fn(cb) &#123; var obj = &#123; myName: &#x27;fn 內的物件&#x27;, cb &#125; obj.cb(); &#125; fn(function() &#123; console.log(this.myName); &#125;); 題目 6：延伸題目，箭頭函式的指向請問，以下的執行結果為： &#39;全域&#39; &#39;小明&#39; &#39;小明家&#39;var myName = &#x27;全域&#x27;; // 主要程式碼 var Ming = &#123; myName: &#x27;小明&#x27;, family: &#123; myName: &#x27;小明家&#x27;, fn: function() &#123; setTimeout(() =&gt; &#123; console.log(this.myName); &#125;, 0); &#125; &#125; &#125;; Ming.family.fn(); ....... 本題結果為：3. &#39;小明家&#39;當遇到箭頭函式時，我會跟大家記住一句話：「箭頭函式沒有自己的 this」，因此其指向會是對應外層作用域的 this。 本題的箭頭函式外層為 fn 函式，該函式的 this 指向 family，所以箭頭函式的 this 也同樣指向 family。而接下來我們也會繼續介紹關於「箭頭函式」的 this 喔。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"學好 this 前，先搞清楚 this 做什麼","slug":"why-this","date":"2020-09-26T16:00:00.000Z","updated":"2020-09-27T01:45:55.343Z","comments":true,"path":"development/2020/09/27/why-this/","link":"","permalink":"https://wcc723.github.io/development/2020/09/27/why-this/","excerpt":"","text":"過去到現在寫了很多 this 相關的文章，如果沒有實際運用過 this 的開發者可能會有疑惑「this 是不是只有在面試考題用到？」、「this 在實戰中會用到嗎？」、「為什麼要學 this？」。 其實 this 在實戰中的應用非常廣，已經有接觸框架的開發者對此較不陌生，基本上所有的檔案都會存在 this，而本篇也就針對 this 的應用情境進行介紹。 沒有使用元件的開發過去框架尚未盛行以前，開發上都是平鋪直述的概念在進行，當有一個需求如下時： 建立資料 將資料取出並繪製於畫面上 function displayData(data, target) &#123; console.log(data.string); console.log(`將 $&#123; data.string &#125; 繪製於 $&#123; target &#125; 上`) &#125; var someData = &#123; string: &#x27;用在卡片上的資料&#x27;, target: &#x27;卡片&#x27; &#125; displayData(someData, &#x27;卡片&#x27;); 透過這樣的方式，我們定義了 資料、目標位置、渲染用的函式，此階段中沒有元件的概念，彼此之間再結構上沒有任何關聯性，當程式碼較少時相當好閱讀，但在日趨複雜的情況就可能會有以下的狀況： 函式與資料分離，函式的方法不一定能夠物件內資料 網站越來越複雜時，資料與函式可能散落在不同處 函式命名可能會產生衝突 導入物件的概念接下來導入物件的概念以後，可以將方法與資料整合在一起，這樣就可以解決上述所列出的問題，不僅可以避免資料與方法分離的狀況，命名上也可以更為簡易。 var card = &#123; data: &#x27;卡片上的資料&#x27;, target: &#x27;卡片&#x27;, render: function() &#123; console.log(`這個是 $&#123;this.data&#125;，可以繪製於 $&#123;this.target&#125;`); // 這個元件是 卡片上的資料，可以繪製於 卡片 &#125;, trigger: function() &#123; this.render(); &#125; &#125; card.trigger(); 當透過物件的形式進行開發時，就需要使用 this 來取得或呼叫物件中彼此之間的方法與資料。如果對於 this 觀念想補強可參考此文章。 額外問題：偏不使用 this，改用 card 不行嗎？這也是同學們常見的問題，在此範例中物件內的 this 等同於 card 物件，所以將上述程式碼中的 this 均替換為 card 也是可以運作的。 var card = &#123; data: &#x27;卡片上的資料&#x27;, target: &#x27;卡片&#x27;, render: function () &#123; console.log(`這個是 $&#123;card.data&#125;，可以繪製於 $&#123;card.target&#125;`); // 這個元件是 卡片上的資料，可以繪製於 卡片 &#125;, trigger: function () &#123; card.render(); &#125;, &#125;; card.trigger(); 不過實戰中，以物件的方式建構元件時，會盡可能地增加其使用性，所以 card 在原始碼中並不會是唯一的存在，可能會有更多的相同或類似的結構來作為運用。 如以下的物件可以延伸自 card 元件，如果使用同樣的名稱就會導致運作上的錯誤，維持 this 將是最好的做法。 var navbar = &#123; data: &#x27;導覽列的資料&#x27;, target: &#x27;導覽列&#x27;, render: function() &#123; console.log(`這個是 $&#123;this.data&#125;，可以繪製於 $&#123;this.target&#125;`) &#125;, trigger: function() &#123; this.render(); &#125; &#125; navbar.trigger(); 而實際上是如何建立兩個接近結構的元件呢？ 以目前來說兩者的結構是接近的，只有 data 的內容是不同的，這段在實戰中大多都是藉由 “框架” 的特性來完成，以下會繼續介紹框架是如何做到這樣的結構，並且如何管理物件中相同的方法。 框架、原型與 this為了讓各個物件中會重複使用的方法統一管理，並且讓其又能定義屬於各自的方法，框架中大多會使用 JavaScript 中的一特性 “Prototype” 來進行管理，關於 Prototype 的觀念本篇不會多加敘述，如需了解可參考： 原型繼承：https://wcc723.github.io/javascript/2017/12/17/javascript-prototype/ 建構函式：https://wcc723.github.io/javascript/2017/12/18/javascript-constructor/ 透過原型可以將物件中的方法集中定義，並且使兩者均可透過 this.render() 的方式呼叫此方法。 需要定義原型，則必須運用到 “建構函式”，以下提供的建構函式範例可用來建立如上結構的物件，並且將 render 的方法預先定義為原型，而建構函式在此的目的為： 定義物件的結構（方法會先放在 methods 內，此結構與 Vue 是接近的） 將共用的方法使用原型來定義 function Component(obj) &#123; var vm = this; // 取出 methods 屬性內的物件，定義為各自的方法 var methods = Object.keys(obj.methods); if (methods.length) &#123; methods.forEach(function(key) &#123; vm[key] = obj.methods[key]; &#125;); &#125; vm.data = obj.data; vm.target = obj.target; &#125; Component.prototype.render = function() &#123; console.log(`這個是 $&#123;this.data&#125;，可以繪製於 $&#123;this.target&#125;`); &#125; 接下來，就可以透過上方定義的建構函式來建立相同的物件。var navbar = new Component(&#123; data: &#x27;導覽列的資料&#x27;, target: &#x27;導覽列&#x27;, methods: &#123; trigger: function() &#123; this.render(); &#125; &#125; &#125;); navbar.trigger(); // 這個是 導覽列的資料，可以繪製於 導覽列 此結構透過 Chrome Console 可看到類似於先前所列的結構，僅不過將 render 改為在原型內，呼叫方式也一樣是使用 this。 var card = new Component(&#123; data: &#x27;卡片的資料&#x27;, target: &#x27;卡片&#x27;, methods: &#123; trigger: function() &#123; console.log(`$&#123;this.data&#125; 在這`); // 卡片的資料 在這 &#125; &#125; &#125;); card.trigger(); 透過建構函式就可不斷建立相同結構的物件，也可定義屬於各自的資料、方法，而物件之中都依然是使用 this 來進行該物件內的所有資料、方法的調用。也因此 this 是一個取得本地元件屬性的方法，如果搞清楚為何使用，也能夠發現其實它並沒有那麼複雜（觀念非常多，但實戰中只會用到一招而已）。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"閉包，原來這就是閉包啊！","slug":"js-closure","date":"2020-09-25T16:00:00.000Z","updated":"2020-09-26T01:29:40.488Z","comments":true,"path":"development/2020/09/26/js-closure/","link":"","permalink":"https://wcc723.github.io/development/2020/09/26/js-closure/","excerpt":"","text":"閉包，是一個 JavaScript 很常聽到的觀念，雖然會在不知不覺應用到閉包的基本概念，進階的用法在實戰中不一定很常用到，但這卻是面試中非常常見的問題，主要原因是它牽扯到許多的觀念，如詞法作用域、記憶體等觀念。 原來這就是閉包：詞法作用域許多閉包文章都會提到「詞法作用域」的觀念，此觀念主要是說明 JavaScript 的作用域範圍由程式碼所定，所以程式碼在撰寫完成的同時，就已經先確立了作用域，運行的過程中都不會改變其作用域，範例程式碼如下： function fn1() &#123; console.log(a); &#125; function fn2() &#123; var a = 1; fn1(); &#125; fn2(); 上方兩個函式的作用域完全獨立，不會因為運行的過程讓函式可存取領一個函式的變數。 雖然變數的作用域是獨立的，但函式內的函式則可以取用外層作用域的變數。 如以下範例：addString 函式內並沒有 name 的變數，因此他會從外層尋找，在外層的 sayHi 函式則可以找到 name 變數。 function sayHi() &#123; var name = &#x27;小明&#x27;; function addString() &#123; // 內部函式、閉包 console.log(`$&#123;name&#125; 你好`); // 取用外層的變數 &#125; addString(); &#125; sayHi(); 在巢狀函式中，如果內層的函式沒有可以取用的特定變數則會向外查找，此時內部的函式就可以稱為閉包。 內層函式取用外層函式的變數，就這樣而已？當然不止，這個概念可以有非常多延伸的變化。 私有變數：把內層的函式丟出來前幾篇文章有提到「記憶體釋放」的觀念，當函式中的變數無法再被參考時，該變數所佔用的記憶體就會被釋放掉，而閉包的技巧正好可以維持記憶體的參考。 可參考以下範例，此範例中（可搭配下方的圖片一起參考）： sayHi 函式中傳入 name 的參數，此參數的作用域在 sayHi 函式中，當此變數無法再次被存取就會被釋放。 內層函式 addString 存取 name 變數，由於該函式內沒有此變數因此向外層查找到 sayHi 函式的 name 變數 addString 沒有在 sayHi 函式內運行，而是透過 return 傳出到 mingSayHi 的變數上（小明說你好）。 當運行 mingSayHi 時： 會運行內層的 addString 函式，並且嘗試存取 name 變數… 重點：name 變數因為還會持續維持參考，所以不會被釋放記憶體，因此成為了 mingSayHi 函式的私有變數（僅存與此函式中，無法透過其它方式調整）function sayHi(name) &#123; function addString() &#123; console.log(`$&#123;name&#125; 你好`) &#125; return addString; &#125; var mingSayHi = sayHi(&#x27;小明&#x27;); mingSayHi(); 圖解概念： addString 函式可以存取 sayHi 函式的變數 addString 沒有直接運行，而是將 addString 函式回傳並儲存於外部的變數 mingSayHi 上 外部變數 mingSayHi 是一個函式變數，當運行時可以存取 sayHi 的變數，此時的 name 變數為 mingSayHi 的私有變數。 閉包是內部的函式可以取用外部作用域變數的概念，單就此概念來說僅是函式及詞法作用域的關係，但如果將內層的函式向外傳出，使其保留了原始函式結構中的作用域使其產生私有變數，更能凸顯閉包的價值。 延伸說明在這個結構中出現了兩層函式，第一次呼叫時會運行 sayHi 函式，第二次呼叫則會運行內部回傳的 addString 函式；除了上述介紹私有變數時將回傳函式儲存於 mingSayHi 外，也可直接使用兩個括號來執行內部的函式。 sayHi(&#x27;杰倫&#x27;)(); // 杰倫 你好 呼叫流程如下 第一個 (&#39;杰倫&#39;)：運行 sayHi，並傳入 ‘杰倫’ 第二個 ()：運行 addString，直接回傳 ‘杰倫 你好’ 實戰案例模擬事件：用戶有一個錢包存有 1000 元，這個錢包會因為不斷的購買品項而減少費用，每次所減少的費用都不大相同。 下方建立了包含閉包特性的函式： balance 中儲存了一個私有變數，這個私有變數不會與其它函式共用 每次呼叫此函式皆會扣除費用並且回傳出目前的金額 function buyItem() &#123; var myMoney = 1000; return function (price) &#123; // 這個閉包目前會被重複呼叫 myMoney = myMoney - price; // myMoney 第一次由外部傳入，接下來在這個 function 內不斷更新 return myMoney; &#125; &#125; var mingMoney = buyItem(); // 存取內部函式的變數 mingMoney(100); // 900 mingMoney(100); // 800 mingMoney(100); // 700 模擬事件更新：用戶不僅一名，會有另外一名共同使用此方法，但兩者的金錢不能混合計算。 在上方所建立包含私有變數的函式中就可以解決此問題，可使用另一個變數來建立一個新函式，兩個函式會擁有各自的私有變數。 var jayMoney = buyItem(); // 存取內部函式的變數 jayMoney(50); // 950 jayMoney(100); // 850 jayMoney(500); // 350 mingMoney(100); // 600，mingMoney 與上方的 jayMoney 變數不會共用 除了單一的方法匯出以外，閉包另有私有方法（可參考 MDN 文件）。 閉包，除了是面試常見的考題外，實戰中也有私有變數的優點（函式的作用域內，外部無法取得函式內的變數）。因此，無論匯出的是哪一種方法，閉包的優點是變數僅存在於函式之中，如果匯出的方法沒有提供原始值，將無法用任何方式取得原始變數，如果需要刻意隱藏變數值，避免用戶透過其他工具或方式取得，閉包也會是一個好方法。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"Chrome Console 中的 undefined 到底是哪來的？","slug":"chrome-console","date":"2020-09-24T16:00:00.000Z","updated":"2020-09-25T03:02:26.411Z","comments":true,"path":"development/2020/09/25/chrome-console/","link":"","permalink":"https://wcc723.github.io/development/2020/09/25/chrome-console/","excerpt":"","text":"教學的過程中，有許多學員會盡可能的搞懂程式碼運行過程中的各種結果，其中一個比較特別的案例就是想搞懂為什麼 Chrome Console 下方的 &lt;· 會回傳 undefined。 範例程式碼：var a = 1 本篇屬於不知道也不會怎樣的冷知識，但如果了解，你則會更清楚 JS 中的表達式觀念。 說明：本篇所介紹的環境都是在 Chrome Console 的直接輸入直接運行，並非透過原始碼運行的結果。 Console 回傳的結果與表達式有關如果要清楚的預測 Chrome Console 中所出現的值，就一定要搞清楚「表達式」的概念，前幾篇的文章有提到表達式的特徵就是 “一定會回傳值”，Chrome Console 中輸入程式碼後的下一行呈現的正是回傳結果。 如果想多認識表達式，可參考本文：https://wcc723.github.io/development/2020/09/17/js-expression/ 純值任何的純值都可以視為 「表達式」，因此輸入純值運行後的下一行回傳的結果就是該值。 1 // 這行就只有數字 1 陳述式與表達式不同的「陳述式」最大的特徵是 “不會回傳值”，因此陳述式輸入在 Chrome Console 後會帶出的是 undefined 的結果。 var 屬於宣告陳述式，因此不會回傳任何的結果。 var a = 1; 一樣的概念，if 是屬於陳述式，因此執行結果為 undefined。 if (a === 1) &#123; &#125; = 是屬於運算子，運算子同樣屬於表達式，因此會回傳一個值，結果會不同於上方的 var 的宣告陳述式。 a = 1; 多行程式碼當 Chrome Console 中輸入多行的程式碼時，回傳的值會是以程式碼中「排列最後方的表達式」為主，因此： 當有多個表達式，會回傳最後一個表達式 如果最後一個是陳述式，則會跳過僅回傳表達式 a === 1; a = 2; // 回傳此表達式結果 var a = 1; // 此為陳述式，因此跳過 函式函式運行是屬於表達式的一種，因此 &lt;· 會帶出函式中 return 的值。 function fn() &#123; return &#x27;function&#x27;; &#125; fn(); 如果函式中沒有 return 一個指定的結果，函式運行依然是屬於表達式，它則會帶入 undefined（未定義）的值。 function fn1() &#123; &#125; fn1(); // 沒有指定回傳值，則會回傳 undefined consoleconsole.log 語法會直接在 Chrome Console 中印出指定表達式的結果，與直接輸入在 Chrome Console 中的回傳不同，在呈現的結果前方不會有 &lt;· 符號，僅會以空白的方式呈現。 console.log(1) 要特別注意的是 console.log() 是運行一個函式，運行函式也會回傳一個結果，只不過 console.log運行時並沒有帶入回傳值，因此在下圖中最後一行 &lt;· 的後方會回傳 undefined。 問：下圖中的 function1、&quot;function2&quot; 兩行文字分別是什麼原因出現的呢？ function fn2() &#123; console.log(&#x27;function1&#x27;) return &#x27;function2&#x27; &#125; fn2() ......... function1: console.log() 執行呈現的結果 function2: 運行 fn2() 所回傳的結果","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JavaScript 一級函式 （First Class Functions）","slug":"first-class-function","date":"2020-09-23T16:00:00.000Z","updated":"2020-09-24T01:49:14.699Z","comments":true,"path":"development/2020/09/24/first-class-function/","link":"","permalink":"https://wcc723.github.io/development/2020/09/24/first-class-function/","excerpt":"","text":"本篇重點是要介紹參數與函式的關係（尤其是常令人搞混的 callback function），但這個觀念又會扯到另一個常見的專有名詞（一級函式），因此在本篇就統一介紹。 一級函式一級函式並非是 JavaScript 專有的特性，只要該語言的「函式可被視為與其它變數一樣時」，就可以稱為該語言有一級函式的特性。 functions in that language are treated like any other variable 這些 JavaScript 的函式就具有以下特性： 將函式指定到一個變數 函式可作為參數來傳遞 函式也可以被回傳（return） 函式也是物件的物件（傳參考特性、具有屬性） 範例：將函式指定到一個變數，這是函式表達式，建立匿名函式後指定到變數 callSomeone 上。var callSomeone = function(name) &#123; console.log(`呼叫 $&#123;name&#125;`); &#125; callSomeone(&#x27;小明&#x27;); 函式作為參數來傳遞 - 回呼函式 Callback function因為一級函式的特性，函式可被視為變數一樣隨意使用，當然作為參數的傳遞也是沒有問題的。所以在呼叫變數時，也一樣可以將函式作為參數傳遞，而這也被稱為 callback function（函式傳入另一個函式後被呼叫）。 以下範例就是將函式作為參數傳遞入另一個函式，由於函式本身結構就比較複雜，加上傳遞的過程可以改變名稱，因此會讓新手常常在查看程式碼中感到混亂。function sayHi(fn) &#123; fn(&#x27;小明&#x27;); &#125; sayHi(function(name) &#123; console.log(name + &#x27; 您好&#x27;); &#125;); 接下來，我們透過圖片加上文字說明解釋這段問題： 呼叫 sayHi 函式同時傳入一個函式（在此我們先稱它為 函式Ｂ） 函式Ｂ 參數傳入後名稱是由函式定義名稱，因此傳入的參數名稱改為 fn 在 sayHi 函式內呼叫 fn 參數（原本的 函式Ｂ） 呼叫 fn 參數時，傳入 ‘小明’ 作為參數傳遞至 函式Ｂ 如果你接觸 JavaScript 還不是很久，或者是常常被 callback function 搞混，試著用以下的方法： 從定義的函式開始找 callback 及參數名稱，callback 常用的名稱會如 cb、callback、fn。 -&gt; 本範例中使用 fn 的名稱。 接下來請專注在傳入的參數結構上（像是上方範例中的 函式Ｂ），此函式是否有接收其它參數，如何運作等等。 -&gt; 外部傳入的參數另有接收 name 的參數。 接下來思考兩個重點： callback function 在函式中的哪裡被呼叫，並且傳入了哪些參數。 -&gt; 第一行就被呼叫，並且傳入 &#39;小明&#39; 作為參數。 外部傳入的函式接收了參數做哪些事。 -&gt; 直接使用 console.log() 呈現值。 接下來，大家可以拆解看到的 callback function 或者用此觀念撰寫一個 callback function 將更能熟悉此觀念。 使用函式變數來傳遞Callback function 除了直接在參數中撰寫一個函式外，也可以直接透過函式變數來傳遞（前面提到一級函式的特性，函式也可以指定到一個變數上）。 如以下範例：callSomeone 函式可以視為一個變數，並且透過參數的方式來進行傳遞。function callSomeone(name) &#123; console.log(name + &#x27; 您好&#x27;); &#125; function functionB(fn) &#123; fn(&#x27;小明&#x27;); &#125; functionB(callSomeone) 可試著用前面的拆解方式來了解此段是如何運作的 Callback function 可以用來做什麼？在 ES6 中的 Promise 語法還未能使用前，就很常使用 callback function 來接收非同步的資料（當資料取得後，繼續執行其它的函式）。 以下範例是使用 setTimeout 取代 Ajax，當一秒時間過去以後，才能繼續執行 callback 的程式碼內容。function callSomeone(callback) &#123; setTimeout(() =&gt; &#123; callback(&#x27;非同步完成&#x27;) &#125;, 1000); &#125; callSomeone(function(done) &#123; console.log(done); &#125;); 回傳一個函式 - 高階函式 Higher-Order Function當函式可以回傳一個函式時，就可稱為高階函式（Higher-Order Function），JavaScript 中的函式因為沒有太多限制，就算作為變數回傳也是沒有問題的。 以下範例中的函式會在回傳另一個函式，因此在呼叫 method 時，此函式具有以下特性： 這是一個新的函式，同時保有 method 的作用域（可呼叫 method 的參數及變數） 可以建立多個新函式，並且賦予到不同的變數上 這些建立的新函式彼此並無關聯 在此就建立了 num1、num2 兩個新函式，兩者都可以再次被呼叫。function method(num) &#123; return function() &#123; return `這是來自於編號 $&#123;num&#125; 的方法`; &#125; &#125; var num1 = method(1); console.log(num1()); // 這是來自於編號 1 的方法 var num2 = method(2); console.log(num2()); // 這是來自於編號 2 的方法 除了將回傳函式賦予到一個變數上以外，還可以直接使用雙括號 ()() 的方式直接運行，這種運行方式運行後將會直接釋放記憶體。 console.log(method(3)()); 因為 JavaScript 函式的隨性（？）造就了此語言更多的彈性，這些專有名詞看似很複雜，但別忘了專有名詞只是方便說明一個特性，實際運行還是要看大家所轉寫的程式，並不會因為了解這些專有名詞寫的程式就跑得更起勁。 另外，高階函式的觀念已經很接近 “閉包”，接下來整合這幾個篇章重新再介紹一次閉包給大家認識。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JS 記憶體釋放機制及驗證","slug":"js-object","date":"2020-09-22T16:00:00.000Z","updated":"2020-09-23T06:38:23.104Z","comments":true,"path":"development/2020/09/23/js-object/","link":"","permalink":"https://wcc723.github.io/development/2020/09/23/js-object/","excerpt":"","text":"作用域JavaScript 的變數有作用域的範圍，意思是指「宣告的變數有作用的區域限制」，如果超出了作用域則變數無法再被取得，這樣的做法優點為： 可以避免所有變數轉為全域變數 有效限制變數的作用區域 而變數作用域也會依據宣告的方式不同，產生不同的作用域： 未宣告：全域變數 var 宣告：作用域在 函式 中 let、const 宣告：作用域在 &#123;&#125; 中 var 宣告的變數函式內宣告的變數作用域就會限制在該函式的執行堆疊中，因此外部會無法直接取得該作用域內的變數。以下範例來說 fn 函式內的變數在全域環境終究無法查看值。 function fn() &#123; var a = 1; &#125; fn(); console.log(a); // 無法取得 fn 函式內的 a 變數 因此，會很常見使用 “立即函式” 來限制變數的作用域，主要是避免全域變數的產生。 (function() &#123; var b = 1; &#125;)(); console.log(b); // 無法取得 fn 函式內的 b 變數 let、const 宣告的變數ES6 以後所新增的 let、const 作用域則與過去不同，改用 &#123;&#125; 作為作用域限制的方式，這讓 for 迴圈及部分的語法避免產生多餘變數來影響作用域（案例參考）。 與 var 不同的是 const 所定義的變數作用域限制在 &#123;&#125; 之中。因此此範例中的變數 c 可在外部取得值，d 則無法取得。&#123; var c = 1; const d = 1; &#125; console.log(c); // 1 console.log(d); // Uncaught ReferenceError: d is not defined，無法取得 d 的變數 記憶體與釋放機制每當我們新增一個變數則會產生一個記憶體位置來除存值，以便於接下來程式運作時可以反覆的使用同一個值。 如以下範例中，就會開啟一個 a 的空間來儲存數字 1 的值。var a = 1 流程如下： 產生一個記憶體空間來存放 a 變數，此時還沒有賦予值（概念可參考：Hoisting）。 為 a 指派一個值。 因此所有的變數都會佔用記憶體空間，除此之外物件、陣列的屬性以及函式參數也會使用相同的概念進行佔用。呼叫一個函式時，每一個函式作用域也都會反覆的進行記憶體佔用。隨著應用程式越來越複雜的情況下，如果持續佔用記憶體沒有適當的釋放，那麼系統可能會無法負荷。 JavaScript 引擎具有記憶體回收的機制，會釋放不再使用的變數記憶體，基本概念為：「沒有任何的參考指向它」時則會釋放記憶體。 MDN：collectible if there are zero references pointing to it. 記憶體釋放的驗證本段使用一個範例來說明及驗證記憶體釋放的機制，首先，我們使用一段函式來產生非常長的字串，長字串會佔用大量的記憶體空間。 randomString 函式呼叫後會回傳很長的字串：function randomString(length) &#123; var result = &#x27;&#x27;; var characters = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789&#x27;; var charactersLength = characters.length; for (var i = 0; i &lt; length; i++) &#123; result += characters.charAt(Math.floor(Math.random() * charactersLength)); &#125; return result; &#125; 案例一：使變數維持可參考的狀態（不會釋放記憶體）案例一：定義一個全域變數 demoData，此變數會持續維持可被參考的狀態。var demoData = []; // 全域變數 function getData() &#123; for (let i = 0; i &lt; 1000; i++) &#123; demoData.push(randomString(5000)) &#125; &#125; getData() console.log(demoData); // 可參考 demoData 值 執行此段範例以後，進入 Chrome 中的 Memory 分頁，此功能可以擷取當下網頁應用程式所佔用的記憶體狀況。接下來按下 “Take snapshot”。 可以看到目前執行完此範例的當下佔用了 6.2MB 的記憶體空間（注意：任何瀏覽器環境、插件都會影響佔用的記憶體狀況）。 案例一：使變數無法再次被參考（執行後釋放記憶體）案例二：將變數限制作用域，使變數無法再被外部參考。 此段程式碼中依然會執行此函式，也會將值加入變數中，但外部無法再次參考 demoData 的值。function getData() &#123; var demoData = []; // 區域變數 for (var i = 0; i &lt; 1000; i++) &#123; demoData.push(randomString(5000)) &#125; &#125; getData(); 接下來回到 Memory 分頁按下 “Take snapshot” 重新取得記憶體的狀態，接下來會得到與上方不同的結果，此次僅占用 1.2MB 的記憶體（其中 5MB 被釋放掉了） 結語以目前範例，我們得知了作用域以及記憶體之間的關係，而記憶體管理也是前端工程師必要學習的一環（除了掌控用量，還要在必要時保留不被釋放），往後的章節還會介紹到如何透過保留函式記憶體的特性，建構特有的函式設計模式。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"呼叫函式時，到底有多少個參數 / 變數可供使用？","slug":"js-function","date":"2020-09-21T16:00:00.000Z","updated":"2020-09-22T06:01:47.238Z","comments":true,"path":"development/2020/09/22/js-function/","link":"","permalink":"https://wcc723.github.io/development/2020/09/22/js-function/","excerpt":"","text":"建立一個函式並呼叫時我們可以傳入一些參數，或者在這個參數中引用全域的變數，不過一個被呼叫的函式中究竟有多少可取用的變數或參數呢？ 函式中的可用變數本篇會著重在參數的介紹，但一個函式中到底有哪些參數及變數呢？ 以下透過一段範例程式碼來檢驗呼叫函式會有哪些變數 / 參數，在此可以透過「無痕模式」直接運行此段程式碼（無痕模式較能避免瀏覽器插件影響運行）。 注意：此段是針對傳統函式的說明，箭頭函式的運行變數與傳統函式不同，在此不討論。var globalVariable = &#x27;全域變數&#x27;; var obj = &#123; aFunction: function (para) &#123; var localVariables = &#x27;區域變數&#x27;; console.log(para, localVariables, arguments, this, globalVariable); // 包含傳入的參數 &#125; &#125; obj.aFunction(&#x27;一段描述&#x27;, 2, 3); 運行時，可切換到「Source」分頁，並使用 Chrome 的 JavaScript 除錯模式來進行驗證（除錯模式的教學）。 接下來進入到 aFunction 的函式中時，可以切換到 console.log(...) 這行停下來，畫面結果如下： 接下來會看到 Scope 表示目前函式的作用域，此作用域可呼叫的變數也會依序列出，在此可以看到的變數 / 參數會包含： para: 呼叫時傳入的參數。 arguments: 傳統函式預設會帶入的外部參數，此參數來自於外部所傳入的參數，就算函式本身未帶入在此也可以取值，本文後方會有更詳細的介紹。 this: 函式運行時帶入的變數，如何呼叫函式將會影響它的指向，之後會有獨立篇章進行介紹。 localVariables: 區域變數，僅有在此函式內的作用域可進行呼叫。 Global: 全域變數 上述五個變數中，前面兩者就屬於呼叫時傳入的變數，本篇也會著重在這兩點的特點進行介紹。 參數的特性參數是由呼叫函式時所傳入的變數，相對於其它程式語言來說 JS 傳遞參數限制更少，任何的值都可以作為參數使用，也因為如此新手或從其它程式語言轉過來的會有許多不熟悉的地方，以下列出常見的問題： 參數的名稱於函式內定義這段是在授課中常見的問題，剛接觸程式語言的新手常常會被參數的名稱搞混，誤以為呼叫時的名稱就是函式內運作的名稱，如以下範例來說請問值為？ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, undefined &#39;d&#39;, &#39;c&#39;, &#39;b&#39;, &#39;a&#39; function callMore(d, c, b, a) &#123; console.log(d, c, b, a); &#125; var a = &#x27;a&#x27;; var b = &#x27;b&#x27;; var c = &#x27;c&#x27;; callMore(a, b, c); 正確來說，函式參數的名稱是在定義函式就已經確定了，如下圖：參數取值是依序帶入，並「不會受到呼叫名稱的影響」。 簡單的結論： 參數名稱不會受到呼叫名稱影響 如果遇到有宣告但沒有傳入值則會是 undefined 如果未定義，但有更多的傳入則需要使用其它方式取值 ES6 的參數預設值如果已經定義了參數，但卻沒有傳入則會以 undefined 呈現，遇到這樣的情況程式碼就必須加入許多的除錯機制，避免 undefined 造成了語法錯誤，使函式沒有辦法依預期的狀況執行。 ES6 中新增了「參數預設值」可預先給予特定參數預設值，除了避免 undefined 所造成的錯誤外，更可以增加函式運用的彈性。 以下範例透過簡單的語法就可加上「參數預設值」，當外部沒有傳入值時則會使用預設值；反之，如果有傳入值則使用外部的傳入的值。function getMoney(money = 1000) &#123; console.log(`我有 $&#123; money &#125;`); // 我有 1000 &#125; getMoney(); // 不需要傳入參數 arguments如果無法確認傳入的參數數量該怎麼辦呢？ 這是專案開發比較少見的情況，但在製作框架、函式庫卻非常的常見，就如同前段所提「如果未定義，但有更多的傳入則需要使用其它方式取值」，會用到的就是本段所介紹的 arguments 參數（ES6 有更棒的方法）。 function callMore(d, c, b, a) &#123; // 注意：在此並沒有使用到定義的 d, c, b, a 參數 console.log(arguments); &#125; var a = &#x27;a&#x27;; var b = &#x27;b&#x27;; var c = &#x27;c&#x27;; callMore(a, b, c); 任何的傳統函式都有 arguments 參數（注意：箭頭函式沒有此參數），不需要另外定義即可直接呼叫，且作用域僅限於本函式中。 arguments 結構上是屬於類陣列，其中會包含呼叫所傳入的所有值，在未確認傳入的參數數量時，是一個不錯的作法。 ES6 的其餘參數因為 arguments 有些許的缺點，如： 結構屬於類陣列，無法直接使用大部分的陣列方法 與已經定義的參數內容重疊，無法僅運用額外傳入的參數 因此在 ES6 後新增了「其餘參數」的語法，可在定義參數時直接傳入剩餘未定的變數內容，語法範例如下： const callMore = (a, ...args) =&gt; &#123; console.log(args); &#125; var a = &#x27;a&#x27;; var b = &#x27;b&#x27;; var c = &#x27;c&#x27;; callMore(a, b, c); 結果類似以上範例，但會是純陣列的方式呈現，並且僅會取得未定義的參數內容（a 會被跳過）。另外，箭頭函式是可以使用其餘參數的。 函式也可作為參數最後則是新手的夢魘，函式除了可以傳入純值、陣列、物件以外，還可以傳入「物件」作為參數，讓函式運作上更加豐富且…複雜（新手常常會不知道傳來傳去是傳到哪裡去）。 如以下範例來說，呼叫了 functionB 時，還可以傳入另一個函式作為參數，此手法我們則稱為 callback function。function functionB(fn) &#123; fn(&#x27;小明&#x27;); &#125; functionB(function(name) &#123; console.log(name + &#x27; 您好&#x27;); &#125;); 可以試著看看其中的參數是如何傳遞的 由於 JavaScript 是非常具有彈性的，因此可將「函式」作為參數作為參數傳遞，這樣的特性也稱為「一級函式」（First-class Function），在後續的文章也會更深入的介紹。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"讓我們一起到達終點！超過 60% 完課率的直播課程 - JavaScript 作品實戰直播班","slug":"javascript-training-1st","date":"2020-09-21T16:00:00.000Z","updated":"2020-09-22T06:29:48.979Z","comments":true,"path":"development/2020/09/22/javascript-training-1st/","link":"","permalink":"https://wcc723.github.io/development/2020/09/22/javascript-training-1st/","excerpt":"","text":"2020 年 9 月 20 日是 「JavaScript 作品實戰直播班」開班滿三個月的時間，也同時是本課程最後一天的繳交期限，同學們在家中努力趕工最終作品，而我在電腦前準備這份心得。 昨天，還收到學員的感謝訊息，提到透過這次的直播班的作品以及履歷健檢服務順利找到工作，我也訝異有同學這麼早就能順利求職，畢竟直播班還未正式結束，許多同學還在家中趕作業啊～ 這次的直播班經歷不少波折，洧杰提到：「第一次上線的教學特別重要，會影響未來的成效」，過程中也是盡可能優化內容，當然也很開心招收到大量的優秀學生，讓我第一次經營直播班就達到超過 63% 的完課率。 數據分享：作業繳交率達到 63%在課程開始前定下本課程的重要指標： 整體課程的作業繳交率 最終作業的完成率 尤其是最終作業的完成率是更為重要的，是除了技術以外真正能夠讓學員感受到價值的項目，更是未來直播班招生時的主要指標；就以 「Vue 出一個電商」的課程來說，平均每個學員需要花一個月左右的時間完成作品，加上來會的溝通討論，則需要多花上二至三週的時間，直播班需經歷兩個月的主線外加只有一個月的實作時間，預期最終的達成率將會受到很大的挑戰。 這段時間的持續修正也有達到目標，當前線上課程普遍完課率低下的環境，我們則是透過大量的互動及持續優化讓整體完課率達到的了 63％。 課程連結：JavaScript 作品實戰直播班課程時間：2020/6/19 ~ 8/7作業繳交期限：9/19 （三個月） 完成報到人數 234 人 整體作業繳交份數 1185 份（共八週） 整體作業繳交率 63.3% 整體課程報到 1303 次（共八週） 整體報到率 69% 繳交份數最高的一週：第二週 課程 API 串接 - 206 份（88.03%） 最終作業繳交份數 76 份 站在六角的基礎上，推出更完善的直播課程推出「JavaScript 作品實戰班」（以下簡稱：JS 班）之前，我們的洧杰老師在這之前已經運行過一個完整直播課程：「網頁切版直播班」（以下簡稱切版班）。 洧杰在運行切版班之前，已經有經營過實體教學、線上教學，切版班開始之前也請教許多教育前輩（可參考本文），讓切版班在第一次運行就得到好的成績。 因此在 JS 班開始前，我也就以助教身份開始從切版班學習該如何規劃一個完整的線上直播課程。所以從課程文件、課程規劃、活動內容、體驗流程許多部分都是以切版班進行優化改進而來。 除此之外，為了讓課程的內容及課綱更符合直播班的步調，於課前幾個月就反覆重新規劃了整體課綱，並於 “火箭隊培訓營” 進行試教，透過試教的回饋再次進行課綱調整，每門課程從初版至正式課程至少經歷過三次的調整。 其中較大的改變：在影音課程中的 “觀念” 介紹大多都是透過優美的簡報進行展示，講師依據簡報的內容進行說明。不過在實際的直播授課過程中，簡報教學相對枯燥，主要原因是簡報內容算是單方面的知識傳授，就算內容再豐富也會缺少互動。 所以 JS 班就捨棄了大部分簡報內容（前幾週做的直接放棄），改為直接在螢幕上進行手繪，透過手繪並解說的方式，學員們可以在繪圖的過程中發問，並且隨時依據反饋調整說明方式，讓教學的內容更不枯燥（而且就實驗上來說，簡報的吸收也不如手繪）。 學員心得： 冠逸：老師會用比較淺顯易懂的方式讓我們了解觀念，之前自己有去讀過 Vue.js 的文件，其實有些地方真的很生硬，都要來回看過好幾次才能了解。 一個直播班，到底包含多少內容直播班對於學員來說是長達一季時間的修煉場，更是講師的精神時光屋。 直播班一開始所鎖定的學員是「六角學員（上過 JS 學徒試煉）」及「具備 JavaScript 基礎能力」的開發者，因此在開始時會提供一個簡單的問卷，確認學員是否具有基本的開發能力（也因為這個問卷，讓許多新手怯步，讓招收學生的速度較為緩慢）。 相對於傳統的實體課程來說，除了一開始的購買訊息及課前通知以外，較少會與學員們會有深度的互動，由於 JS 相對於基礎課程來說，如果沒有先掌握學員的整體能力，可能上課上到一半時會有許多學員登出的狀況（聽不懂就直接下線），長達八週的課程內容更是一大挑戰，對於完課率將會有很大得衝擊。因此，在註冊後的隔天我們就會開始進行第一次的接觸「引導學員們加入 Slack 頻道」。 接下來會希望同學們進行基本的自我介紹，透過自我介紹後也會了解每個學員的基本能力。 完成了報到以後，學員將會陸續開啟以下的服務： 每日任務 新手任務 分組活動 Slack 討論服務 作業批改服務 線上發表會 作品牆 履歷健檢 除此之外還有包含課程應有的內容： 主線任務 額外的主線加碼 課程 API 設計觀念課程 額外課前內容 這些內容大部分都是在一開始就已經規劃到課程內，但也有部分是在課程的進行中依據學員的回饋，或是觀察課程內的數據變化進行調整才加入進去。這同時是直播課程的優勢，可獲得回饋的方式同時結合了實體課程、線上影音課程以及直播課程獨有的方式在收取回饋，因此也能更靈活調整課程內容。 學員心得： JIN：我個人覺得自學一年都未必能夠達到直播班8週的技術水平 每日任務課前的兩週時間我們提前停止了 JavaScript 直播班的招生，比預期減少了數十位名額，主要原因也是為了提前提升所有學員的 JS 能力，並且不希望學員是在開課後才發現這門課程並不是自己所預期。所以開始舉辦每日任務的活動，此活動的主旨如下： 提前認識這門課程的講師與助教，課前建立弱連結 每天只需要花 5 ~ 10 分鐘可以練習一個觀念 了解整體學員的技術水平 提供片段的提示，讓學員們自行尋找答案 活動每天會在 Slack 上公告，並且透過 HackMD 提交答案，同學們除了撰寫自己的回覆外，也可以看看同學們怎麼做。當然，大家都是抱著學習心來上這門課程，所以也不需要擔心同學們互相抄襲（就算抄襲也沒關係，至少也認識了不同的寫法）。 題目範例： 每日任務開始一週以後，除了慢慢提升問題的難度，以及透過各種私訊發現了一些問題： 部分學員想等到課程開始，再完成報到手續 部分學員加入了 Slack，但沒有開啟此服務 有三分之一的學員覺得每日任務太難 前兩個問題就透過各種方式與學員們聯絡，包含 Email、電話、LINE 的方式提醒學員們可以加入此活動；部分學員覺得太困難的情況，我們則另外開立了「新手組」來進行不同的訓練。 學員心得： Johlmike：「習慣養成的關鍵不在於執行時間長短、而是執行頻率」，每天持續地執行才是養成習慣的關鍵，而六角學院確實地幫了我這一把。 JIN：讓我印象最深刻的是初期的JS任務，那時還沒有教到箭頭函式，然後我寫了15行的code才完成所需的功能。後來聽老師說有人只用了一行就完成，好勝心強的我就覺得別人做得到的話我一定也可以，所以就開始詢問老師這是怎麼做到的，老師當下給了我一些關鍵字(例如: arrow function)，然後我就開始查找跟練習，最後將代碼精簡到只剩下4行，完成的當下真的覺得超有成就感。 Yukun：尤其是 Vue 的 emit 和 props 上完課後，搭配每日任務又更加深我的印象，比以前自己看影片時還來的知道如何使用他們。 Chloe：開始上課前，老師提供很多預習的教材，還有每日任務，新手任務，真的天天都有在進步。 新手任務新手組的訓練與每日任務不同，每日任務會著重在不同的 JS 知識學習，每一個或許不會花太多時間，但沒有一定基礎會覺得難以理解，如：表達式、ES6 語法、callback function 等等；新手任務則是著重在基礎的語法反覆練習，不求複雜，只要求用現有的知識完成小作品。 新手組是獨立的組別並且有獨立的 Slack 頻道，任何學員都可自願加入此組別，我會在此公佈新的題目以及適當的鼓勵，讓同學們有意願並相信自己能夠完成實戰班的挑戰。在本直播班中有 69 名學員加入了新手組，並且最早完成最終作業挑戰的亦是新手組的同學。 新手組題目共有五題連續觀念題，除了文字題目以外，並另有提供影片說明該題目的解題重點以及起手式的原始碼，讓學員們可以透過基礎的語法完成不同的題組。 分組活動分組活動延續自「網頁切版直播班」，會將學員依據職能特性區分成不同組別，組別拆分如下： 全職鬥士 - 全職學習者 轉職忍者 - 目標是轉職的開發者 斜槓鍊金 - 已經有其它技能，想額外專研前端技能者 設計魔劍 - 本身是設計師，想額外掌握前端技能者 軟工盾坦 - 本身已經是工程師，想專精前端技能者 學生劍士 - 還是學生 分組活動的目的是為了： 發揮同儕的壓力，增加學習的動力 學習主線以外的技能：如 git、gh-pages 與同組的學員們打好關係：透過活動增加互動性，讓接下來有議題時也勇於討論。 在分組後也陸續帶上一些活動，讓學員們開始熟悉彼此，以每日任務來說就是以團隊為單位統一繳交，因為同學們背景接近，所以繳交的程度差異不會過大（前期可以避免學員有過大的壓力）。課程開始後會維持一週一個團隊任務的方式產生交流，任務內容就以主線外知識為主，偶爾會參雜交流性質的活動，如：「分享自己常用的筆記工具」。 額外透露，完課率的高低與組別有很大的關係，整體看起來會是「有求職意願」的組別效益最好，如果是跨領域學習或是本身沒有相關背景投入會較為困難，會有這樣的結果也是不難理解，因為本課程是以求職為導向，並且是較為專精的課程，自然會有就業需求及前端知識者才有動力達成。 學員心得： Hung Jason：最大的優勢在於不像一般的網路課程，是一個人學習，有非常多的人和你一起同時在學，也會有組員可以彼此詢問；也不像實體課程，若這週進度跟不上可能會後面都不會了，在這若有跟不上的，可隨時詢問，老師、助教都會在第一時間處理你的問題，這是實體課程所所沒有的。 Jerry Huang：別忘記你的隊友們，前面除了選職業，再來就是分組了，你的組員們會是你最好討論的朋友，藉由這八週的課程也讓我認識了不少人，至少會讓我覺得我不是孤單一個人，之於你 RPG 遊戲要打 BOSS 需要組隊一樣。 Ruta：在這邊也很感謝轉職忍者 2 組的同學們，不僅每週的小組討論很歡樂，在頻道上也常常互相解惑 &amp; 哭笑表符吶喊，更要大大感謝 Wendy 不厭其煩地幫忙。在學習的路上，有懂你辛苦的人跟你一起前進，感覺真的很好 : ) Slack 討論就問卷上的收集來說，這是滿意度最高的服務，學習的過程中有任何問題直接敲助教 / 講師，通常來說都會在一小時左右的時間獲得回覆（如果是晚上十點以後則會在隔天獲得回覆），從小到大都不一定有這麼好的學習服務啊…。 Slack 討論主要分為兩大面向，一則是團體方面的討論，進入本直播班完成報到手續以後，就會加入「js作品實戰班-2020夏季」的頻道，學員們可以在這個頻道發問，教學團隊也會透過此頻道說明課程的內容即將主辦的活動；除了主頻道以外，另外每個小組也會有屬於該組的分組頻道，該頻道講師 / 助教就不會介入，同學們可以自行討論相關的議題。 另外還有私訊的服務，如果在學習的過程中有遇到任何的問題，都可以透過私訊的服務直接詢問講師 / 助教。當然也會有些學員會另外提出實戰中或是設計上的問題，只要問題能夠清楚描述，我們都會盡全力的回覆學員問題。當然，對於講師 / 助教們來說，除了回覆問題以外，更開心的是能收到來自學員們的鼓勵。 學員的鼓勵 完成最終作業的心得 學員心得： Chen：直播班比線上課程互動更好，而且有問題就能馬上獲得回覆，每週的作業任務也讓我慢慢進步。也很喜歡直播班的上課氣氛，真的很歡樂~ Kuohua：直播的互動我也很喜歡，一直以為上課只是靜靜的聽老師所教的內容，然而直播的方式卻很有互動性，學員可以透過聊天群互動與回答問題，老師上到一半也會停下來看學員所提出的問題，比起自己看影片反而直播更有學習的動力。 Yukun：Slack 可以看到大家都在努力，說不定會覺得自己不能那麼廢而上進XD，另外也把問題丟到上面，助教回覆的都蠻快的，但我覺得六角學院不管哪裡回答問題都蠻快的XD Siling：在這裡問老師、助教們不用擔心被白眼，有時思緒卡住，或是Google一小時了還是沒答案時，有人可以問，真的是非常感動的一件事 QQ JIN：老師也希望我們每天能夠給1~3個人的作業回饋，透過你自己的分享或是其他學員的分享，分享的人能夠將內容內化，而被分享的人能夠學習到新的知識。 作業批改服務六角最令人稱羨的不外乎是作業批改服務，在直播班的期間每天都有大量的作業需要批改，六日過後更是會有報復性的繳交。除了講師及六角本身就有的兩名固定助教外，我們也另外招募遠端助教來批改學員的作業。 作業是正常上班日才有批改，平均每位助教每日需批改 3 ~ 5 份的作業，確保除了假日以外學員可以在兩天內收到作業的回覆。 作業設計上是具有連貫性的，每週會有一個主題需要製作，從第二週至第八週結束最終可以完成完整的前端作品。每一週的難度也有不同的設計，從 Lv1 至 Lv3 不等，課程介紹的內容可以完成 Lv1 ~ Lv2，Lv3 則需要參考更多的資料才能完成。雖然如此，許多學員也會試著挑戰 Lv3 來充實自我。 學員回饋： Johlmike：我很喜歡做作業，但我更喜歡看別人的作業，破百位同學所繳交的作業根本是靈感庫，面試成品當然不能也不建議抄同學的，不過在參考同學們作業的排版、文案後，總是能激發右腦貧乏的我不少靈感，甚至有些業界同學們的程式碼更是值得學習 Vic：感謝六角學院的卡斯伯老師授課與助教每周的作業批改，看到那第八周長到不行的建議回覆，就能知道直播班對於每個學員，都希望寫出具有一定水準的作品。 Aiden：因為有問題就上 slack 發問，老師、助教、同學們一定給你問到會為止。甚至可以參考其他同學教的作業，助教的範例檔，不怕你抄，就怕你連抄都不想抄。只要能把別人寫的東西看懂，融會貫通，那就抄的有價值。 最終作業的批改每週的作業會交由不同的助教批改，批改會著重於程式碼的觀念及邏輯，但到了最終作業時除了原有的程式碼審核，更會加入「視覺畫面」的檢視。 在第七週的主線課程中，會請俊儀老師來介紹網頁設計的基本概念，如果同學們沒有設計基礎，依然可以了解「哪些設計問題是需要注意被注意」，避免程式碼有好品質，卻在畫面上吸引不了人的窘境。 因此最終作業學生繳交作業時，除了會安排程式碼的助教批改外，也可以選擇要哪種等級的設計檢核。提交時可選擇專精於 UI 設計的俊儀老師，或是由我這位設計背景但轉為前端的工程師批改，無論是選擇哪位講師，設計上都會針對： 整體設計風格：包含色彩、字體、格線、排版一致性、作品完整性 細節設計：包含特定頁面、區塊給予建議 行動版：目前網站決離不開行動版的網頁設計，因此 RWD 也是檢視的重點之一 使用者體驗：為了讓網站更具有實戰臨場感，我們也會檢視學員們的作品使其符合主流的使用者體驗 每一份最終作業每次都需要花上設計、前端助教各 30 ~ 40 分鐘的時間（總合約 1 小時左右的批改時間），每份作業來回會需要花上 3 至 5 次才會批改通過，也因為如此，同學們在製作這份最終作業後會在實戰層面有大幅度的成長。 線上發表會線上發表會是六角系列直播課程首創的內容，主要原因是在於「Vue 出一個電商」的影音課程中，收到了許多品質優秀的作品，會想透過發表會的形式來用於： 增加同學彼此之間的弱連結 讓未完成作品的學員可以了解作業有哪些呈現形式 提升學員對於作品的信心，讓實際求職時更能清楚描述自己的作品 雖然本課程有提供分組，上課過程中同學也會透過文字聊天，但實際上本課程學員之間還是屬於陌生的，因為沒有見過面也沒有聽過彼此的聲音。在本次的發表會除了有許多令人驚嘆的作品外，同學們也提到 「原來 XX 的聲音是這樣啊」～ 「我們這組的同學都會彼此激勵，所以就一起報名了線上發表會」 許多平時幽默的同學在發表會中也會感受到他的緊張，也有平時未發言的學員在介紹自己作品時充滿了自信與幽默，這個過程都讓彼此之間拉近了距離。 學員心得： ABow：令人驚訝的是，發表會上的 13 個報名者中，竟然有 4 位是同組的組員，能跟戰友一起站上發表會舞台，真的很開心且驕傲！ Siling：發表的同學可以模擬未來在面試時介紹自己作品的樣子，而當聽眾的同學(像我，還沒開始做最終作業😂)，也從中獲得了很多同學設計的理念及技法 履歷健檢許多開發者都有不錯的能力，但在求職上卻不一定很順利，常常投遞了數十封都沒有收到回應，以為是不是市場出現了問題，但其實只是履歷的規劃上出了小問題。 因此在直播班中只要完成了最終作業，都會提供履歷健檢的服務，讓學員更清楚如何規劃屬於自己的履歷，讓實力不會被埋沒，讓求職的過程不是只有被公司選擇，更能夠選擇自己理想的工作。 主線課程我在經營課程都是維持一個信念「讓大家做出一個作品」，希望大家最後獲得的不是只有作業或練習，而是獨一無二的作品。所以在「Vue 出一個電商」的課程中除了提供作業練習外，也提供了可高度客製的教學 API，同學可自由使用獨立的 API 及資料庫串接內容，藉此完成獨立的作品。 其中也會具有許多風險，如： 完課率降低（難度提升） 缺少美感的練習，同學會不知如何經營最終作品 影音課程溝通不足的情況下，學員會不知如何著手 雖然在「Vue 出一個電商」算是我們一個指標性的課程，許多學員在完成最終作業後都可順利找到工作，而過程中也收到了許多不同回饋，因此在直播班中也重新規劃了課綱，保留最核心的「做出一個作品」概念外，亦也加入非常多的內容來增加課程豐富度。 課程大綱規劃： 第 1 ~ 2 週：重點 JavaScript 觀念介紹，如：this、物件參考、Promise、常用的 ES6 觀念等等。 第 3 ~ 6 週：Vue 的核心內容介紹，包含：基礎指令、元件、生命週期、套件、Vue Cli、Vue Router 等等 第 7 週：設計觀念介紹，讓大家使用基本觀念製作出不難看的作品 第 8 週：觀念整合，總複習並示範如何透過本次課程所學完成最終作品 課綱介紹：https://www.hexschool.com/courses/js-training-1st.html 在高密度的訓練下，同學們的學習壓力也會不斷提升，課程中也會鼓勵感到挫折的同學們，在覺得困難的同時先回頭看看自己在這段時間學習了多少，在到達第三週時，大多數同學已經學會了： This Promise Ajax 陣列方法及 forEach 箭頭函式 物件參考 … 在學習以後，更重要的是不斷練習，隨著時間的推進，偶爾也會回頭練習其中的部分觀念，他們會發現過去很困難的部分，現在看起卻是輕而易舉，因為學習的當下總是痛苦、難以理解，但反覆的練習後自然駕輕就熟，對於掌控 JavaScript 也會更具有信心。 同學心得： Miko：直播課最大的特點就是即時的互動與回饋，在每一週課程中，老師在講解觀念的同時，也會準備練習題，透過練習題的方式帶領我們一起思考 額外主線加碼課程前三週都相當順利，課程報到及作業繳交量都非常穩定，而到了第四週以後開始略有下滑，尤其是在作業繳交上有明顯下降的趨勢（前三週隔週上課前可以有 70 ~ 80 份的作業繳交，第四週僅有 20 ~ 30 份），因此開始在 Slack 頻道詢問了解學員的狀況，也會透過私訊詢問還未繳交的學員問題（私訊學員更會透露自己的狀況），在廣泛收集資訊以後大致可歸納以下原因： 元件在 Vue.js 中難度提升太高，尤其加入了 emit、props 等觀念 每週觀念都是獨立的，不知如何進行整合 所以課程後來決定進行「額外主線加碼」，主要是針對課程作業上的解說，但如果都只是解說，也會造成學員上只有照抄沒有練習的機會。因此，雖然課程是以引導的方式，說明製作上可用哪部分的觀念，由學員回答後再填寫至程式碼上，透過引導、回答，學員們不僅知道怎麼做，還知道為什麼。 學員心得： Kuohau：第四周的元件化，使用到 props、emit，又讓我對 Vue 感到生疏，畢竟是第一次用框架，對元件的瞭解還不夠深入，在挫折滿滿的時候，老師彷彿聽見聲音般，不僅額外開了課程，又錄影片加深我們的印象。怎麼會這麼佛心！！ Manlu Tseng：知道賺錢不容易，看到提供的這些活動，都會想說六角開直播班真會賺錢嗎(x)，除了技術上的支援輔導，還像小精靈一樣完成學生的心願，還開了許願牆欸，裡面又是滿滿的資源了。 Qingyu：我最喜歡的是在限定時間內完成某某階段就能得到加碼獎的部分了，因為我發現我會為了加碼而加速我的進步速度，有獎盃解鎖的感覺，然後get就會很有成就感。 課程 API前端開發者一個明顯的門檻在於是否「具有串接遠端資料」的經驗，許多學習資源雖然都有介紹到 Ajax，但大多都僅限於 GET 取得資料，無論是公開資料或是免費的開源隨機資料，這在練習上受到很大的侷限。以一個在實戰中的 Ajax 中就可能包以下問題： GET、POST、DELETE、PATCH 等不同的方法需要練習 登入、授權等驗證方式 資料格式處理 遠端請求的錯誤閱讀及排除 所以本課程延續「Vue 出一個電商」課程的經驗，重新開發了課程專屬 API，在這個 API 中同學們可以： 練習實戰常見的 HTTP 方法 學會如何排除錯誤（不止教你怎麼做，還帶你認識如何排除錯誤） 將後端回饋訊息提供在畫面上，增加使用者體驗 經營屬於自己的資料內容 學員們可以建立自己的商店、品項、定價等等的，另外本次還有提供 “擴充欄位”，學員可自由新增自己想要的內容，讓每個作品從畫面至內容都是完全獨一無二的。 同學心得： listennn：支線任務讓你練習如何串接 api 與處理從後端拿到的資料，加深你對非同步的實作方法！ Lois：最大最大的賣點就是有提供後端API練習！(非常神之好)，有整份完整的API文件可以使用，其中還包含了需要驗證的後台API，若有額外需求也可以跟老師和助教討論。 YU：沒想到六角學院竟然準備了商品資料的 API，不但能練習串接，也讓所有資料可以呈現於專案中 設計觀念課程本課程完成一個完整作品為目標，完整作品包含： 可進行完整瀏覽的網站 不會讓人感覺像是 “作業” 的練習（網站中包含文案、描述、圖片皆需要經營） 具標準美感的設計 包含基本的使用者體驗 如果作為一個完整的作品，僅注重程式碼、畫面、文案等等是不足夠的，所有的條件必須同時經營，才能成為一個夠具水準的 “作品”。但並非所有的學員都均具有設計背景，或是對於網站規劃有足夠的經驗，因此進行最終作業前額外加入了「設計觀念課程」，引導學員在規劃最終作業時，目標是做出一個具水準的作品。 設計課程內容包含： 基本設計準則（如何讓非美術相關背景製作出不難看的設計） 主題發想技巧 學員的主題建議 設計細節說明：文字、版型、色彩、頁面規劃 課程中針對表單的細節調整說明 學員作品將會同時兼具開發、設計、使用者體驗 學員心得： 冠逸：請俊儀老師來跟我們講解設計，從對比、重複、對齊、相近這四個設計準則，再講到主題發想，有很多細節是自己沒有注意過的，除了畫面美觀之外也考慮了使用者的使用狀況。 額外課前內容學習，如果僅透過單一次的吸收是明顯不足夠的，尤其是在接觸一個新的知識、陌生的框架時，光是要認識這些新詞彙就會耗去許多心力，如果還要同時了解如何運作更是困難。因此課程在部分章節額外規劃了「課前內容」，目的是讓學員： 在課前對於框架有基本的認識，別到直播中才一次看到許多的新詞彙。 增加額外的每日任務，針對當週直播有再次的知識吸收（謎之音：相信同學有了課前文件也不一定有時間看，所以透過小遊戲讓大家認識）。 課程中主要介紹課前內容的運作及觀念，在此才真正開始學習新內容。 透過作業再次反覆練習，確保學員可以真正學會。 課前著重於認識，不再深度的理解，文件中有許多範例可動手操作，不需要重頭自行輸入。 課程中實際講解觀念，並一次打通課前預習的所有觀念。 完課率如何增加的完課率經營除了主要的內容外，直播課程中還用了以下幾種 “手段” 來增加完課率： 關懷：提前增加整體完課率 補救：避免讓學員的挫折影響結果 獎勵：期限前再推一把 關懷 - 提前增加整體完課率因為直播課程的作業是具有連貫性的，為了確保學員中斷繳交，導致後續的作業進度趕不上。 所以在特定的週數中（尤其是關鍵章節，如 API 串接），會請助教一一聯絡尚未繳交的學員，詢問其作業的繳交狀況以及了解目前遭遇的問題。在學員群組中還流傳著以下這張圖： 學員們在前面幾週學員意願最高，隨著課程越來越困難，自然就會有更多的學員放棄，因此維持整體的繳交率是相當重要的事情。前期小小推一把及關懷，學員就會給予承諾並完成作業，這也是所有手段中成本最低的方法（只需要一一聯絡），但僅在前期意願高較為有效，後期則需要不同的方式來增加完課率。 補救 - 避免讓學員的挫折影響結果前幾週的完課率相當高，每週結束後都可以很順利的達到 70 ~ 80 份的作業繳交數量，一直到最後來說前三週都數據也都是最好的。 接下來到第四週以後繳交率突然暴跌，直到隔週上課前繳交的數量都沒有突破 50 份，雖然有預期會遇到繳交率下降的情況，但總認為會再更後面的週數才會遇到此問題。 接下來就透過私訊、投票的方式瞭解學員們所遇到的狀況，比較特別的是 “學員不一定清楚自己的問題”，而且在公眾投票時所得到的結果也會與私訊不同，因此我們就集結兩種取得的回饋，重新規劃了額外的教學內容。 本次額外的教學內容上線以後，繳交率有大幅度的提升，第四週作業在最後期限時也拉到了 70% 以上的作業繳交率。 獎勵 - 期限前再推一把隨著影音課程越來越盛行，購買一門課程的成本也相較於過去越來越低，許多人買影音課程就像買 Steam 遊戲一樣放著沒去使用。也因為取得成本的下降，加上觀看影片沒有任何急迫性，所以人們買了許多服務沒有去使用。 直播班相較於一般影音課程價格較為昂貴，另外有時間的限制，所以能有更高的完課率。但畢竟完成一個完整的作業需要相當長的時間，當逼近截止的時間發現自己還有很長的路要走也會導致放棄，因此在結束前一個月的時間我們陸續規劃了許多「獎勵活動」來刺激第六週的完課率，目的是讓學員的心態上有 “剩下的路不遠了”、“再堅持一下就能達到” 的感受。 「菁英班」是屬於進階的內容，因此會要求學員們完成作業才能取得觀看權限，而這也是加碼內容中學員感到最有價值的部分。到了繳交期限前 20 天，前六週的繳交數量都已經超過了 120 份。 後記專業知識是一個技能，而教學也是屬於一個技能，一個具有豐富經驗的開發者不一定具有良好的教學技能。經營六角這段時間，我們很清楚學員的痛點，更清楚如何將複雜的技術知識簡化，避免艱澀難懂的詞彙搞得新手頭昏腦脹。我們的理念是：「線上帶你學到會」，會透過循序漸進進行教學，結合六角特有的社群交流讓學員在學習上不會感到孤單，讓更多人透過線上的方式達到自己心目中的目標。 身處一個浪潮之中體驗到教育的規模變化，從過去由講師對學員的 1 對多教學，轉變為由助教、講師、學員們之間多對多的交流。也感謝洧杰規劃的教學架構「只要人數更多，就越能達到 *N 的吸收效果」，讓學習體驗從 1 ＊ N 進化成 N ＊ N。所以這次的教學不只是我傳授一個職業技能給予學員，助教、學員的反饋也加速我在此領域的成長；也因為如此，更有把握讓下一次的直播班有更好的成績，如果你對於 JavaScript 前端直播班有興趣，也歡迎訂閱通知，讓我們再次加速成長～ JavaScript 作品直播班訂閱通知：https://rpg.hexschool.com/line/webhook第二屆預期時間：2021 年 4 ~ 6 月開始上課 六角直播班特色包含： 超高互動：透過 Slack 的互動，同學們互相交流，遠端學習也不會感到孤單。 高度回饋：超過 1250 份作業繳交，所有作業都能收到回饋，確保學習狀況。 極豐富的內容：表訂 8 堂直播課，實際加碼超過 16 堂，豐富學習資源讓學員不想鬆懈 實戰作品：提供電商 API，帶你體驗實戰流程 就業導向：學員回報 - 課後一個月內透過課堂作品找到前端工作！ 更多學員心得 Chloe：實作真的差很多，以前聽線上課程都不會練習到這麼徹底，就像老師說的，看看兩個月前的自己，我們現在強很多，傳值傳參考我們都分得清楚了，who is this? This is me. 也搞懂 this 是誰了 XD，CRUD api 的操作我們也會了。 Miko：最大也最意外的收穫，就是拆解程式流程的習慣。以往在寫程式的時候，只會在腦海裡大概規劃一下流程圖而已，幸好老師有加碼開課講解，不但仔細講解、引導大家作業的觀念，也在課程中示範拆解流程，跟著老師的腳步才發現原來好好的列出專案的流程，可以讓專案瞬間看起來簡化很多，可以更有條理的思考每一個步驟。 Ruta：如果你已經自學一年(或以上)但卻沒有踏實感或明顯成果，我非常推薦你來參加六角學院舉辦的直播班課程。兩個月結束後，會能很明顯感受到自己有所成長，甚至超過以前自己一年的學習成效 Lois：還有一堆加碼加不停的東西，真的很物超所值，而且成長曲線真的遠遠打趴過去半年的自學，程度爆炸性增長，現在的我除了Vue框架的技巧以外，也已經不害怕看文件、願意挑戰使用各種套件、git也開始有點了解了，若你想快速提升自己的實力，這堂課真的很值得你報名！ ABow：比較兩個月前剛加入直播班，及兩個月後正在逐步完成最終作業的自己，我比較不害怕看 Vue 的程式碼，而且能理解別人為什麼要這樣寫。 YU：六角學院絕對是轉職路途中優美延綿的風景，但還是要繼續走下去，像是把後台做完才能繳交第八週作業 XDDD Siling：八週前的我還搞不清楚function(e)的這個e是啥東西，現在終於理解，並往前跨了一大步，雖然離可以行雲流水的用嘴寫程式還是有超大一段距離，但找到方向前進了，覺得很開心😀 Pandaa：有很多跟你一起努力的同學，這跟買課程回來自己學是很不一樣的，我以前買過的課程都沒有看完過，但是直播班真的會讓自己有動力去跟大家一起進步","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"courses","slug":"courses","permalink":"https://wcc723.github.io/tags/courses/"}]},{"title":"JS 物件名詞解釋及常見觀念問題","slug":"js-object","date":"2020-09-20T16:00:00.000Z","updated":"2020-09-21T06:44:45.500Z","comments":true,"path":"development/2020/09/21/js-object/","link":"","permalink":"https://wcc723.github.io/development/2020/09/21/js-object/","excerpt":"","text":"接下來來到 JavaScript 另一個坑「物件」。 物件的定義方法差在哪？JavaScript 定義物件的方式主要有兩種形式： var a = &#123;&#125;：&#123;&#125; 稱為物件實字，是相對簡短且易讀的建立方式。 var b = new Object();：使用 Object 建構函式產生物件。 這兩種建立方式就結果而言並無差別，但普遍來說會更推薦使用「物件實字」，主要原因如下： 相對於建構式來說更為簡短 物件實字易讀性佳 效能優於建構函式，可參考相關 討論 1、討論 2 避免無關緊要的錯誤（下方補充） 在實戰上，也不太會使用 new Object() 來建立一個物件，這個方法則只會在學習原型、建構式時才會用到，如果還未接觸到此部分的開發者，可先把它放在一旁。而這兩種建立方式各有些微的事項需要注意。 物件實字物件實字的定義方式不太會出錯，只不過物件實字與陳述式中的 &#123;&#125; 的符號是相同的，所以在撰寫時需要注意所使用的是 陳述式 或 建構函式。 以下為 “物件實字”，可視為一個物件、表達式的結果。&#123; name: &#x27;小明&#x27; &#125; 以下為 “區塊語法”，可視為一個陳述式（實戰中較少單獨使用，但可配合 let、const 限制作用域），結構上與物件相當類似，請避免搞混。 &#123; const name = &#x27;小明&#x27; &#125; 延伸問題思考：區塊語法是否可以作為表達式運用？ 物件建構式new Object 預期會回傳一個新的物件，但如果傳入的結構並非為物件，依然可以正確運行，僅不過回傳的結果可能會不如預期，如以下範例會回傳一個「物件型別」的數字 1。var num = new Object(1); console.log(typeof num); // object console.log(num + 1); // 2 console.log(num == 1); // true console.log(num === 1); // false 物件內的屬性、方法物件的名稱定義可以看到許多不同的說法，在此透過 MDN 及原文來加以介紹，物件建立後會使用一個 &#123;&#125; 包覆著屬性（property），每一個屬性包含著「名稱」（name）及「值」（value）。 &#123; name: value // 名稱：值 &#125; 一個屬性可以賦予純值、物件、陣列等等，依據開發的需求我們也同樣會賦予函式，而這類型的屬性則會稱為「方法」（methods） var person = &#123; name: &#x27;小明&#x27;, // 屬性 run: function() &#123; // 函式則稱為方法 console.log(&#x27;跑&#x27;); &#125; &#125;; 物件取值方法物件取值方式常見為點記號（Dot notation），這是精簡、好閱讀的取值方式，也算是最常運用的取值方法。以上述的程式碼來說，當取得 name 值時的點記號可以寫為： console.log(person.name); 另一種方式是常被新手忽略的「括弧記法」（Bracket notation），寫法結構類似於一個陣列的取值方式，寫法如下： console.log(person[&#x27;name&#x27;]); // 取值 person[&#x27;run&#x27;](); // 呼叫函式 相對於點記號來說，[] 看似結構複雜難以閱讀，但它也能突破許多取值上的限制，以下皆為點記號無法運行的方式，如： 特殊字元的賦值、取值 person[1] = &#x27;數字 1&#x27;; person[&#x27;my-name&#x27;] = &#x27;小明&#x27;; console.log(person[1]); console.log(person[&#x27;my-name&#x27;]); 使用變數進行操作 var num = 1; console.log(person[num]); 當可以使用變數存取物件值時，如欲屬性名稱不確定時，可以搭配 Object.keys 列出所有的屬性名稱，並且依序取出所有的物件值，方法如下： var person = &#123; name: &#x27;小明&#x27;, // 屬性 run: function() &#123; // 函式則稱為方法 console.log(&#x27;跑&#x27;); &#125; &#125;; var keys = Object.keys(person); // keys 為 [&#x27;name&#x27;, &#x27;run&#x27;] keys.forEach(function(name) &#123; console.log(person[name]); // 分別結果為 &#x27;小明&#x27; 及 &#x27;run&#x27; 的方法 &#125;); 何時使用物件、何時使用陣列物件與陣列同時都可以包含許多資訊，因此會難以分辨在定義時該使用陣列或是物件，以簡單的定義來說： 物件可用來定義單一複雜的資訊 陣列可用來定義重複的多數結構 以汽車的資訊來說，一台車可能同時具有許多複雜的資訊，如品牌、色彩、價格、馬力、性能…，這些資訊並不重複且僅賦予在同一台車內，概念如下： var car = &#123; brand: &#x27;BMW&#x27;, color: &#x27;white&#x27;, price: 1630000 &#125;; 當定義了一台汽車以後，也可以使用同樣的概念定義更多的汽車，汽車成為複數時，則會是多台重複結構的汽車，這時就可以改用陣列來儲存這些資訊： var cars = [&#123; brand: &#x27;BMW&#x27;, color: &#x27;black&#x27;, price: 2630000 &#125;,&#123; brand: &#x27;Ferrari&#x27;, color: &#x27;red&#x27;, price: 16300000 &#125;,&#123; brand: &#x27;Toyota&#x27;, color: &#x27;white&#x27;, price: 6300000 &#125;];","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JS 加不加分號差在哪？","slug":"js-semi","date":"2020-09-19T16:00:00.000Z","updated":"2020-09-20T01:52:16.269Z","comments":true,"path":"development/2020/09/20/js-semi/","link":"","permalink":"https://wcc723.github.io/development/2020/09/20/js-semi/","excerpt":"","text":"這個議題許多論壇、文件都有討論，在 ESlint 的規範中也可從加不加分號區分為兩大派系，至於加不加分號關鍵點則需要了解分號對於 JavaScript 的影響，開始之前可以先看看以下題目。 下方程式碼的運行預期為： 宣告 a 的值為 1 執行立即函式 於 console 中呈現 2 請問這段程式碼運行是否正確？var a = 1 (function() &#123; console.log(2) &#125;)() ....如果你嘗試運行這段程式碼，則會出現此錯誤：Uncaught TypeError: 1 is not a function 什麼？ 1 is not a function ？我們沒有打算運行數字 1，為何要說數字 1 不是函式，這種錯誤很難查找到原因，常常會在錯誤的行數上打轉。這個錯誤主要原因是上述程式碼運行時被視為同一行，概念如下： var a = 1(function() &#123; /* */ &#125;)() 因此立即函式的 () 附加在 1 上，這是一個呼叫函式的語法，所以會造成 1 is not a function 的錯誤，如果要避免此錯誤就需要使用分號將其隔開： var a = 1 // 用分號隔開就對了 ;(function() &#123; console.log(2) &#125;)() ASI 自動加入分號ASI 是 「Automatic Semicolon Insertion」的縮寫，部分的斷行程式碼運行時會自動插入分號，這個機制可以部分程式碼如果沒有加入分號也能正確運行，如以下範例： var b = 1 ++b console.log(&#x27;b&#x27;, b) 此範例中，由於 ++ 是屬於一元表達式，它在僅能在表達式的左方或右方置入運算元，如果沒有 ASI 的機制程式碼會轉為「var b = 1 ++ b」 的錯誤結構。不過好在有 ASI，實際運行時他會被加入分號如下，也就不會出現如上的錯誤。 var b = 1; ++b; console.log(&#x27;b&#x27;, b); // 2 return 與分號的關係再來看一個有感的片段，以下程式碼中在 return 的後方空一行後再回傳值，請問運行結果是什麼呢？ function fn() &#123; return &#x27;小明&#x27; &#125; console.log(fn()) 這段程式碼因為 ASI 的修正，return 後方會被加上一個分號，也因為如此 return 與預期回傳的值被分了開來，所以 return 的內容為空值，最終函式也僅能接收到 undefined 的結果。 function fn() &#123; return; &#x27;小明&#x27;; &#125; console.log(fn()); // undefined 所以，分號到底要怎麼處理呢？ASI 是出自於善意，用來修正沒有加入分號的片段程式碼，但偏偏有些地方沒有發揮其用途（如本篇一開始所介紹到的立即函式），導致程式碼出現了錯誤；甚至有些程式碼不會出錯，但會讓你的程式碼運行結果不如預期。 要解決 ASI 的問題，解決方式如下： 無論如何都加入分號，自行決定程式碼的分段 謹記「不會」自動加入分號的規則，當不會自動插入分號時則手動加入 不會自動加入分號的規則以下整理各種「不會」自動加入分號的規則： 新的一行是 (、[、/ 開始，這類型通常會直接出現「Uncaught TypeError」導致程式碼無法運行（其後方的程式碼也會無法運作）。 var a = 1 var b = a (a + b).toString() var a = 1 [1,2,3].forEach(bar) (function() &#123; &#125;)() (function() &#123; &#125;)() var a = 1 var b = a /test/.test(b) 新的一行以 +、-、*、% 作開始，這類型大多會影響運算結果，建議合併為一行撰寫（+ 與 ++ 結果是不同的）。 var a = 2 var b = a +a 新的一行以 ,、. 作開始，這類型在實戰中很常會運用，主要是避免程式碼過長所加入的分段，並不會影響運行，多加善用可使程式碼更易於閱讀。 var a = 2 var b = a .toString() console.log(typeof b) var a = 1 ,b = 2 // b 一樣會 var 被宣告 因此，遇到以上的標點符號前方加入分號也是解決辦法 如果需要加入分號的狀況，除了在語句的末端加入分號外，也可將分號改在「不會自動加入分號」的最前方，如 () 本身不會自動加入分號，當有此需求時可以將 ; 加入至前方（ESLint Standard JS 規範就選擇此方法避免錯誤）。// 執行錯誤 (function() &#123; &#125;)() (function() &#123; &#125;)() // 正確 ;(function() &#123; &#125;)() ;(function() &#123; &#125;)() 結語不加入分號可以讓程式碼看起來更乾淨、精簡（對於習慣加入分號的開發者不這麼認為就是了），且在大部分正確的分段下並不會出現錯誤，僅有少部分的語句會出現執行上的錯誤（很少，大多都可避免），因此許多開發者也會選擇不加入分號，而我過去也是屬於這類型規範的愛好者。 不過在教學上，我會更傾向選擇嚴格的規範提供範例給學員，所以近幾年開發都轉為選用加入分號的規則。至於選擇何種，只要清楚運行上的限制，只要團隊允許都是好的方法。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"開發總是沒問題，上線老是各種錯","slug":"js-expression-3","date":"2020-09-18T16:00:00.000Z","updated":"2020-09-19T02:09:28.177Z","comments":true,"path":"development/2020/09/19/js-expression-3/","link":"","permalink":"https://wcc723.github.io/development/2020/09/19/js-expression-3/","excerpt":"","text":"不果是新手或老手都可能遇過這樣的狀況，程式碼在測試時運作上看起來都很正常，雖然有一些些地方還不是很熟悉，不過打從心裡認定它是正確的，但麻煩卻上線後才發現出錯，仔細檢查也看不出任何問題，殊不知是表達式的觀念錯誤。 程式碼的問題千萬種，本篇就持續在「表達式的觀念」挑出常見的問題，看看是否大家有遇到類似的狀況勒。 連續賦值這麼屌，為何文件都說這不好連續賦值（chain variable assignments）的結構如下：var a = b = 1; 以上這段程式碼中最常見的問題為，a 的值是來自於？ 1 先賦予至 b，b 再將值賦予至 a 1 同時賦予至 a 與 b （賦予兩次）........以上兩者皆錯， 正確來說 1 的值來自於 b = 1 的回傳值，這時候你一定會想這什麼鬼，什麼叫做 b = 1 的回傳值，請再次回想表達式的特點「會回傳一個值」，= 屬於運算子的其中一種，它除了會賦予值以外也會同時回傳一個值。 透過幾段程式碼來驗證這個觀念： 1 先賦予至 b，b 再將值賦予至 a這個邏輯的概念 b 會先取得 1 的值，並且 b 的值會轉為 1 再傳給 a，以下的範例程式碼用另一個邏輯呈現如下： 使 b 的值無法被賦予為 1 a 與 b 的值最終不相同 範例中會使用到 defineProperty 的方法，並且調整 writable 的屬性讓值無法寫入，透過此方法 b 的值會被固定為 2 無法再被寫入。 Object.defineProperty(window, &#x27;b&#x27;, &#123; value: 2, writable: false &#125;); b = 3; console.log(&#x27;b&#x27;, b); // b 永遠為 2，無法再次被賦予值 var a = b = 1; console.log(&#x27;a&#x27;, a); // 1 console.log(&#x27;b&#x27;, b); // 2 console.log(a === b); // false 程式碼執行結果如下： b 值始終為 2 a 值被賦予為 1 a 與 b 不相等 所以結論，a 的值並不是來自於 b。 1 同時會賦予兩次這個邏輯中 1 會將值賦予給 a 與 b，這個概念為數字 1 會被取值兩次，因此我們透過一個方法來記錄最右側的值被取得的次數。 在此我們會使用到 get 的方法來進行紀錄，當變數每次被取值時，會記錄次數乙次。 範例程式碼 1：驗證當每次被取值時 num 數值會增加 1，範例中被取值了兩次，因此結果為 2。var objWithGetter = &#123; num: 0, get variable() &#123; this.num = this.num + 1; return &#x27;variable&#x27; &#125; &#125; var a = objWithGetter.variable; var b = objWithGetter.variable; console.log(objWithGetter.num); // 當變數被取得時， num 的值會增加 1，在此被取得兩次，所以結果為 2 範例程式碼 2：當連續賦值的時候，最終的結果也僅會有一次。var objWithGetter = &#123; num: 0, get variable() &#123; this.num = this.num + 1; return &#x27;variable&#x27; &#125; &#125; var a = b = objWithGetter.variable; console.log(objWithGetter.num); // 1 因此，在連續賦值的概念下中，兩個變數會被視為完全獨立的存在，在一些特殊情況時可能會有出乎意料的情況，就以 ESLint 的說明來說，最常見的即為在函式中使用連續賦值，導致其中轉為全域變數影響其它程式碼的運作。 (function() &#123; var a = b = 1; &#125;)(); console.log(b); // b 沒有被宣告，屬於全域屬性 // console.log(a); // 立即函式內的區域變數 ESLint 文件：https://eslint.org/docs/rules/no-multi-assign Chaining the assignment of variables can lead to unexpected results and be difficult to read.連續賦值可能導致不可預期的結果，以及難以被閱讀 Airbnb ESLint 文件：https://github.com/airbnb/javascript#variables--no-chain-assignment Why? Chaining variable assignments creates implicit global variables.為何不使用連續賦值？這會產生全域變數 不管輸入什麼，判斷式的結果總為 true請檢視以下程式碼，請問其中的 console.log 是否會執行呢？var a = false; if (a = true) &#123; console.log(&#x27;請問此段是否會執行&#x27;); &#125; .......答案：這段程式碼 “會” 執行。 這段程式碼是新手常見的錯誤，就是將 if 中的判斷式寫成了 = 賦值，再來回顧一下 if 判斷式的結構。 if (condition) statement1 [else statement2] 其中的 condition 可以使用任何的表達式進行替代，而 = 不僅是 JS 中用來賦予值的語法，同時也是屬於運算子的其中一種，所以在此它不僅會賦予值，同時還會回傳一個結果，以此段程式碼來說，就發生了以下狀況： a 的值與原始不同，在此被賦予成 false = 表達式會賦予值，同時會回傳一個值，在此總是會回傳 true（無論是否有成功賦予） 所以當下次的判斷式不如預期，除了檢查來源值以外，也要同時檢查其中的判斷式（表達式）結構是否符合預期喔。 ++1 還是 1++，兩個到底有什麼差var num = 1; console.log(++num); console.log(num++); console.log(num); 請檢視以上程式碼，請問過程中的 num 的值分別為？ 1, 2, 3 2, 2, 3 2, 2, 2........++ 是屬於一元運算子，所以前後只需要一個運算元即可運行，兩者的結果都會使變數值增加，但其中的過程卻大不同。 運算元 運算子 num++ 運算子 運算元 ++1 觀念變數也是屬於表達式，因此會先回傳變數值後再進行運算。所以過程會先回傳原始值，最終再將 num 值增加 1。num++ 運算子屬於表達式，因此 ++1 會直接進行運算後回傳，因此會直接得到 2 的結果。++num 所以執行上還是回到了表達式的概念，如果熟悉回傳的時機點將會更容易看出以下題目的結果，請問 a 值為？ 1 2var b = 1; var a = b++; console.log(a); 回到初始的題目我們可以給予以下結論： 無論是哪一種結果是不變的 但過程會有很大的差異，如果過程中需要賦予值到其它變數，則會影響其它變數所接收的值。 var num = 1; console.log(++num); // 回傳先 ++ 後的結果 console.log(num++); // 先回傳 num，再進行 ++ console.log(num); 結論JS 的知識分為應用及基礎兩大區塊，好的應用知識能夠增加開發效率，基礎知識則是能夠增加除錯的能量，兩者在實戰中缺一不可。再快的速度遇到錯誤無法排除，也是會耗去大量時間找問題；只有基礎知識缺乏應用技巧，技能也淪為紙上功夫。最好還是相輔相成，以對等的知識量進行成長，能夠獲得最有效的開發能力。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JavaScript 利用表達式優化你的程式碼","slug":"js-expression-2","date":"2020-09-17T16:00:00.000Z","updated":"2020-09-18T02:20:45.875Z","comments":true,"path":"development/2020/09/18/js-expression-2/","link":"","permalink":"https://wcc723.github.io/development/2020/09/18/js-expression-2/","excerpt":"","text":"上一節介紹了表達式的基本概念「回傳結果」，那麼接下來你一定會想了解有哪些地方可以用到表達式，本篇就列出 JS 語法與常見框架的表達式運用，熟悉以後將會大幅增加 JS 語法的變化性。 運算子運算子依據運算元數量，可分為一元、二元甚至是三元運算子，而運算元本身也是屬於表達式，以我們常見的 === 來說就屬於二元運算子。 運算元1 運算子 運算元2 此範例中的前後 1 皆是運算元，運算元本身也是屬於表達式，並且此運算子最終會回傳一個 true 的結果，請記住這個概念，我們延伸介紹幾個不同的運算子運用。1 === 1; 邏輯運算子 ||、&amp;&amp;邏輯運算子包含 &amp;&amp;、||、!，在語法的概念上稱為 and、or、not，常見情境是用來作為判斷語句使用（condition），不過在文件中的描述卻不僅於此，以 &amp;&amp; 來說，文件上的敘述為： 假如 運算式1 可以被轉換成 false的話，回傳 運算式1；否則，回傳 運算式2。 因此，&amp;&amp;只有在 兩個運算元都是True 時才會回傳 True，否則回傳 false。 expr1 &amp;&amp; expr2 常見的情況下，我們預期兩者都為 “真” 時，取得 “true” 的結果。 console.log(false &amp;&amp; true); // 只要其一為假值，就會回傳假值 不過運算元也是表達式，因此我們可以替換成任何表達式也可運行，以此範例來說我們取得的值並非為 true，而是後者 &#39;杰倫&#39;。console.log(&#x27;小明&#x27; &amp;&amp; &#x27;杰倫&#x27;); 然後勒？哪邊可以用到這個概念與 &amp;&amp; 相對應的是 ||，在文件上的說明為： 假如 運算式1 可以被轉換成 true 的話，回傳 運算式1； 否則，回傳 運算式2。 因此，||在 兩個運算元有任一個是True 時就會回傳 True，否則回傳 false。 假定情境，我跟老媽去餐廳用餐，我和老媽都搶著付錢，但其中一人其實沒有錢，在此就可使用 || 來判斷有錢者的值為何。var myPay = 0; var momPay = 1000; console.log(myPay || momPay); // 1000 實戰中更常見 “傳入值不確定是否為真值” ，有可能為 undefined、null、0…，不過在執行上為了避免出錯，我們強制需付予一個值時，可使用以下方法： var unconfirmed = undefined; // 變數 a 無法確認來源值 var defaultValue = unconfirmed || 1000; // 來源值為假值則賦予 1000，如果是真值則套用來源值 console.log(defaultValue); // 1000 三元運算子 / 條件運算子三元運算子的介紹：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Conditional_Operator 「三元運算子 / 條件運算子」是唯一用到三個運算元的運算子，它的結構如下：condition ? exprIfTrue : exprIfFalse 範例如下，當年齡大於 18 則會取得 ‘成年’ 的結果，如果否定則回傳 ‘未成年’。var myAge = 22; console.log(myAge &gt;= 18 ? &#x27;成年&#x27; : &#x27;未成年&#x27;); 而運算元本身就是屬於表達式，我們可以在這判斷式、前後運算元替換任何的表達式來運行它，也因為如此三元運算子還經常作為 if () &#123; ... &#125; 的縮寫。 if () &#123; ... &#125; 是很易讀的判斷式，但如果僅做簡單判斷時，則會顯得過於攏長。// 宣告函式1, 2 function fn1() &#123; return &#x27;函式1&#x27; &#125; function fn2() &#123; return &#x27;函式2&#x27; &#125; var variable = false; // 當變數為真值時，執行 fn1，如果為假值則執行 fn2 if (variable) &#123; console.log(fn1()); // 不執行 &#125; else &#123; console.log(fn2()); // &#x27;函式2&#x27; &#125; 如果改為三元運算子則可改寫成如下，當變數為真時執行並回傳 fn1()，如果為假時執行並回傳 fn2() ：console.log(variable ? fn1() : fn2()); 透過此方式可以將多行的 if () &#123; ... &#125; 判斷式縮減成一行，除了行數減少外，還可以同時回傳值（運算子最終也會回傳值），因此許多進階的開發者都會使用三元運算子取代單純的 if () &#123; ... &#125; 判斷式。 框架運用目前的主流框架都是屬於畫面與 JS 邏輯分離（關注點分離），而在邏輯資料傳回畫面時的片段程式碼，大多都可利用表達式的方式撰寫，以 Vue 來說就明確說明可多利用表達式的特性，參考文件。 可利用的表達式範例：&#123;&#123; number + 1 &#125;&#125; &#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125; &#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125; &lt;div v-bind:id=&quot;&#x27;list-&#x27; + id&quot;&gt;&lt;/div&gt; 但如果使用的是陳述式則會無情地對你噴出錯誤：&lt;!-- this is a statement, not an expression: --&gt; &#123;&#123; var a = 1 &#125;&#125; &lt;!-- flow control won&#x27;t work either, use ternary expressions --&gt; &#123;&#123; if (ok) &#123; return message &#125; &#125;&#125; 可開啟以下連結，並使用 Chrome Console 除錯：https://codepen.io/Wcc723/pen/RwarveQ 程式碼如下： &lt;div id=&quot;app&quot;&gt; &#123;&#123; num === 1&#125;&#125; &lt;br&gt; &#123;&#123; num === 1 ? &#x27;數字 1&#x27;: &#x27;不是數字 1&#x27;&#125;&#125; &lt;br&gt; &lt;!-- `=` 也屬於運算子，這樣寫也是通的 --&gt; &#123;&#123; num2 = 1 &#125;&#125; &lt;!-- 但下面這行是陳述式，所以會噴錯 --&gt; &lt;!-- &#123;&#123; var num2 = 1 &#125;&#125; --&gt; &lt;/div&gt; 本篇介紹表達式的常用情境，以及程式碼可以怎麼拆以及如何運用，下一篇則會繼續介紹表達式中常會引發的額外錯誤。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JavaScript 表達式觀念及運用 - JS Expression","slug":"js-expression","date":"2020-09-16T16:00:00.000Z","updated":"2020-09-17T01:41:18.433Z","comments":true,"path":"development/2020/09/17/js-expression/","link":"","permalink":"https://wcc723.github.io/development/2020/09/17/js-expression/","excerpt":"","text":"JavaScript 分為兩大的語句類型，就像是我們日常語言中的動詞、名詞、連接詞等概念，但在 JS 中僅分為兩大類型，分別為「陳述式」及「表達式」，其中表達式更為重要，如果能夠熟練表達式更能解決許多開發上的問題，也更能活用各種語法。 JavaScript 中的表達式原文為 「Expression」，翻譯上常見的有表達式、表示式、運算式等等。 表達式與陳述式的差異表達式及陳述式在各文件上都有概略提到，但通常不會讓人覺得是重要的篇章，所以快速略過。不過在 JavaScript 的運用中，如果熟練「表達式」的觀念，將能增加許多運用的技巧且能避免許多不必要的錯誤。 陳述式：會執行一些程式碼，可能是幾個單詞或是一個片段（但不會是單一個字母），但最大的特徵是不會回傳結果。 表達式：最大的特徵在於會回傳結果。 陳述式 Statement陳述式有幾大分類，如： 宣告（var、function） 流程控制（block、if…else） 迴圈（for、for…in） 其它（import, export） 完整分類可參考 MDN 陳述式可能是幾個單詞或是一個片段（但不會是單一個字母），其中也會混合到表達式的詞彙，所以當我們撰寫一段程式碼如下即可稱為陳述式（注意：是 var a ，而不是 var 也不是 a），用此語法即可宣告一個變數。 var a; 相同的道理，如果我們僅有使用 &#123;&#125; 這個意思是「物件」，這不會是一個陳述式，必須在其中加入一些片段程式碼才會是陳述式，結構如下： &#123; console.log(a); &#125; 陳述式先了解至此即可，我們先來看表達式。 表達式 Expression表達式的特點就是會回傳一個結果，所以任何可回傳結果都可稱為表達式（這句話看起來就是一段廢話，但實際運作時卻常常讓人有錯誤的判斷）。常見如下： 純值 變數 運算子 執行函式 正規表達式 函式表達式 … 表達式的重點在於「回傳結果」，因此是否能夠回傳結果就能判斷該語句或詞是否為表達式，我們用數字 1 來解釋什麼是回傳結果。 1 直接打開你的 Chrome 的開發者工具，將上面的數字 1 貼到開發者工具內後按下 Enter，你會看到兩個數字 1 分別如下顯示： 因此在這之中數字 1 就是表達式（是的，單一個純值就是表達式），接下來加入一些運算子增加這段程式的複雜度，使用兩個數字 1 來進行比對。 1 === 1 接下來會得到 true 的結果，所以 1 === 1 是屬於表達式。 相同的概念，如果定義了一個函式並運行它，那麼運行所回傳的結果也會稱為表達式。 // 函式陳述式宣告一個函式 function fn() &#123; return 1; &#125;; // 呼叫函式 fn(); 容易搞混的地方“式” 這個字在中文通常表示為一段文字，所以我們常會誤解表達式、陳述式代表的是一個完整片段；而實際運作上陳述式大多是一個片段或詞彙沒錯，但表達式可以獨立出現，也可與陳述式混合使用。 以下片段程式碼整體來說是屬於陳述式（運作上不會回傳結果），但其中會夾雜許多表達式的語句。if (a) &#123; fn(); // 函式呼叫後會回傳結果，因此也屬於表達式 &#125; 圖解案例： 當然，還有多個表達式混合的概念，如運算子本身就是由多個表達式組成，常見的「二元運算子」，就是由一個運算子加上前後的運算元所組成，而運算元也是屬於表達式的一種。關於運算子可參考。 運算元1 運算子 運算元2 範例如下：1 === 1; 所以在此範例中，也可以將運算元替換成 “呼叫函式” 或 “任何的表達式”。function fn() &#123; return 1; &#125;; fn() === fn(); 哪邊可以看到表達式相對於死板板的陳述式來說，表達式相當靈活且無所不在，當我們在查找文件中都可看到相對應的蹤影，在此先記得 “expression” 這個單字。 記得：你可以將文件中的 expression 語句替換成任何喜歡的表達式來執行，但絕不能替換成陳述式（statement）。 案例：if 陳述式文件：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else 文件中說明 if 陳述式中的結構如下：if (condition) statement1 [else statement2] 其中包含了 condition(條件式) 及 statement(陳述式) 這兩個語句，再往下可以看到針對這兩個語句的說明。 condition: An expression that is considered to be either truthy or falsy.判斷式：一個表達式，它的值會被判定為真值或假值。 因此 if 後方的條件式可以使用任何的表達式進行替代，因此可以如下的方式替換（替換成呼叫函式、各種運算子都是沒有問題的）。 if (1 + 1) &#123; console.log(&#x27;1 + 1 為真值&#x27;) &#125; 只要把握此原則就可以進行任何的替換，但絕對不能替換成陳述式，陳述式則會出現語法上的錯誤。if (var a = 1) &#123; // ... &#125; 結語表達式在 JavaScript 是看似簡單的觀念，但了解以後可以更靈活運用許多語法，除此之外有許多的設計模式及觀念，也都是必須靈活運用表達式才可達成。 本篇附上幾個題目，大家可試著猜看看該片段程式碼屬於 “陳述式” 或 “表達式” 喔 題目 1：var object; 題目 2：new Object(1);","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"JavaScript 開發中常見錯誤解決辦法","slug":"chrome-js-alert","date":"2020-09-15T16:00:00.000Z","updated":"2020-09-16T03:25:46.038Z","comments":true,"path":"development/2020/09/16/chrome-js-alert/","link":"","permalink":"https://wcc723.github.io/development/2020/09/16/chrome-js-alert/","excerpt":"","text":"身為一個開發者，當然都會了解經驗越多，除錯上會更為容易，這種事情你我都清楚。但對於一個新手來就是缺少錯誤上的經驗，所以當遇到紅字時會不知如何著手。 這一系列的文章是專門給剛入門新手的前端開發者觀看的，盡可能用白話的方式，並且提供簡單的範例程式碼以供驗證。 Chrome 開發者工具的常見錯誤排解Chrome 開發者工具的 Console 相當好用，最常使用的不外乎是透過console.log 呈現出變數或運算的結果，如果符合預期則皆大歡喜。 但最討厭的則是出現紅色文字，看似帶有威脅的語氣說「你出錯了！」，對於新手來說不僅是一種挫折，紅字上的錯誤也不知如何著手排除的情況下，也只能反覆地檢視自己原始碼，看看是不是有奇怪的地方，但就算停在了錯誤地方也往往不知是什麼意思，也會因此花上許多時間在除錯上。 本篇就來介紹 Chrome 開發者工具的常見錯誤回饋及排除技巧，讓你下次不再需要為了滿滿的紅字感到挫折，更能從中學習如何快速搜尋錯誤程式碼。 注意：JavaScript 是屬於同步的程式語言，如果出現錯誤就會造成下方的程式碼導致無法運行，當紅字沒有解決，都可能造成接下來的程式碼運行錯誤或是無法繼續運行。 錯誤類型：SyntaxErrorSyntaxError 這類型錯誤通常是語法結構錯誤，遇到這類型錯誤建議透過 “文字編輯器”除錯，以 VSCode 來說會直接跳出這類型的錯誤提示。 如下圖，VSCode 以紅字提示 family 物件有錯誤，當出現錯誤時會建議不要只檢查當行，錯誤可能會存在於前後文之中（有可能跨多行的錯誤），此範例中仔細檢查可以發現 ‘小明’ 後方缺少了一個逗點。 除錯重點：使用主流的文字編輯器，如 “VSCode” 進行除錯 Uncaught SyntaxError: Unexpected identifiervar person = &#123; name: &#x27;小明&#x27; family: &#123; name: &#x27;小明家&#x27; &#125; &#125; 語法解析錯誤，因為在物件結構中缺少一個逗點，除了透過 VSCode 查看外，也可以直接透過 Chrome Console 連結至 Source 頁面查看錯誤行數，並請檢查此行的前後文是否有語法結構上的錯誤。 Uncaught SyntaxError: Unexpected end of inputfunction fn() &#123; console.log(&#x27;這是一段函式&#x27;); console.log(fn); 語法解析錯誤：未預期的結束，此範例中缺少結尾的 &#125;，會建議在撰寫程式碼時盡可能維持正確的縮排，將程式排整齊後比較容易正確找到錯誤。 Uncaught SyntaxError: Unexpected token ‘}’if (name) console.log(&#x27;立即函式&#x27;) &#125;; 語法解析錯誤：未預期的符號 &#125;，程式碼多了 &#125; 結尾符號導致環境運行錯誤，此錯誤排除與上述相同，盡可能將程式碼排整齊且維持首尾符號的一致。 除此之外再推薦一個 VSCode 工具，為你的首尾標籤加上對應的色彩：https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer 範例：程式碼中的 &#123;&#125; 都會以一對的色彩呈現。 Uncaught SyntaxError: Identifier ‘a’ has already been declaredlet a; let a; 語法解析錯誤：識別符號（在此指的是變數）已經被宣告，請避免重複宣告同一個變數，ES6 中都禁止 let、const 重複宣告，直接排除即可。 錯誤類型：ReferenceErrorReferenceError 此類型錯誤通常是指「參考」找不到，當出現這類型錯誤時文字編輯器 “不一定” 出現錯誤（有裝 Linter 才會提示），所以時常會在執行階段才會看到這類型錯誤。 除錯重點： 透過 Chrome 的提示修正 在 JavaScript 撰寫環境中安裝 ESLint ReferenceError: a is not definedReferenceError: a is not defined 語法參考錯誤：由於 a 變數未定義，所以在取用該變數時會出現未定義的提示，只要預先定義此變數即可。 不過還有另一種很常見的情況，當引用外部套件時出現「套件名稱 + is not defined」，這類型情況通常是外部資源沒有正確載入，請確保該資源有加入到此網站中。 以下範例來說，就是屬於 jQuery 沒有正確導入。Uncaught ReferenceError: $ is not defined 錯誤類型：TypeErrorTypeError 則是型別上的錯誤，文字編輯器一樣不會預先提示有錯，必須在執行環境時才會看到，這類型的錯誤通常是以下幾種： 在 undefined、null 嘗試取得其屬性（ex: undefined 中取得屬性值） 嘗試呼叫非函式變數或表達式（ex: &#39;text&#39;()） 除錯重點：在取得變數前方確認該變數當前的資料型別及結構 Uncaught TypeError: Cannot read property ‘a’ of undefinedvar a; console.log(a.a); 說明：該變數的值下無法找到特定的屬性，undefined、null 的值內無法在查找到其它的屬性，如果無法確認該變數是否為 undefined，可改寫其程式碼如下： if (typeof a !== &#x27;undefined&#x27;) &#123; console.log(a.a); &#125; Uncaught TypeError: console.log(…) is not a functionconsole.log(&#x27;a&#x27;) (function() &#123; console.log(&#x27;立即函式&#x27;) &#125;)() 說明：這段程式碼中看起來會是立即函式的錯誤，但卻出現了 console.log(...) is not a function。此錯誤主要是因為缺少了分號，因此將兩段程式碼合併為一行執行，運行的結果如下： console.log(&#x27;a&#x27;)(function() &#123; ... &#125;)() 當遇到此類型錯誤只要在兩者之間補上分號即可正常運作。 console.log(&#x27;a&#x27;); (function() &#123; console.log(&#x27;立即函式&#x27;) &#125;)() 錯誤類型 RangeError這是建立了超過長度的陣列或過度的執行函式（產生過多執行堆疊）所造成的錯誤，這類型則需要重新檢視程式碼的邏輯，是否會造成過度的硬體資源消耗（記憶體或運算資源）。 除錯重點：需重新檢視邏輯，如果必要可先刪除部分程式碼，先找出錯誤的片段後再進行除錯。 Uncaught RangeError: Maximum call stack size exceeded(function a() &#123; a(); &#125;)(); 說明：函式呼叫時會產生一個執行堆疊，如果堆疊的過程中超過最大數量則會產生錯誤（函式內呼叫自己）。 此類錯誤也很常見，但卻不容易找到為何出錯，主要原因是執行堆疊超過環境的限制（運用框架中也很常見），如果遇到此錯誤建議改寫目前呼叫函式的方式。 結語當 Chrome Console 出現錯誤時請維持正確的心態，新手常常會看到錯誤而緊張不知所措（畢竟從小紅被用紅字提醒就會感到緊張，深怕這個錯誤自己無法解決而影響到其他人）。 錯誤在撰寫程式碼中常見的過程，資深開發者與新手的差異是面對錯誤的經驗，同一個錯誤前幾次不清楚沒關係，都是經驗的累積，只要往後再次遇到相同的錯誤自然而然就能輕鬆面對。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"完全解析 JavaScript import、export","slug":"import-export","date":"2020-03-24T16:00:00.000Z","updated":"2020-03-25T07:54:53.289Z","comments":true,"path":"development/2020/03/25/import-export/","link":"","permalink":"https://wcc723.github.io/development/2020/03/25/import-export/","excerpt":"","text":"import、export 是 JavaScript 模組管理的方法，可以將每個檔案視為一個獨立的模組匯出，並在另一個檔案匯入使用。透過此方式每個檔案更能專注在特定的功能上，且能避免單一檔案過度龐大。 相容性介紹此方法前，還是要了解一下相容性，目前來說許多主流瀏覽器都是可以運行的，但是寫法需要稍做調整，而 Node.js 則是要到 13.2 才可直接運行模組化。 瀏覽器中運行如果要在瀏覽器運行模組化，可以在 &lt;script&gt; 標籤加上 type=&quot;module&quot;，接下來無論是使用行內或是外部的 JS 都能運用模組功能。&lt;script type=&quot;module&quot;&gt;&lt;/script&gt; 當然，這樣的模組功能並非所有瀏覽器都能夠運行，如果要同時兼顧新舊瀏覽器，可以改用以下做法：&lt;!-- 支援 module 語法的新瀏覽器 --&gt; &lt;script type=&quot;module&quot; src=&quot;module.js&quot;&gt;&lt;/script&gt; &lt;!-- 不支援 module 語法此段會被新型瀏覽器忽略 --&gt; &lt;script nomodule src=&quot;IENotGood.js&quot;&gt;&lt;/script&gt; Export 匯出 export 可以將函式、物件甚至是純值匯出，大部分運用上都是匯出物件（函式）為主，畢竟純值作為模組意義並不大。 export 又可區分為兩種，這兩種的匯出手法略有不同，也會影響到 import 的運用，所以在運用前請先明確區分這兩種的差異（非常重要）： named export（具名匯出）：可匯獨立的物件、變數、函式等等，匯出前必須給予特定名稱，而匯入時也必須使用相同的名稱。另外，一個檔案中可以有多個 named export。 default export（預設匯出）：一個檔案僅能有唯一的 default export，而此類型不需要給予名稱。 除此之外，兩者也可共存於同一個檔案內，只不過 default export 僅能有一個。 default export（預設匯出）default export 匯出時不需要預先賦予名稱，可以在 import 時另外賦予，但要特別注意 export default 每個檔案僅能有一個。 直接匯出純值或表達式結果。export default 1; 預先定義一個變數並匯出，這種方式結果與上述的純值一樣。const a = 1 export default a; export default 匯出物件是最常見的使用方式，此方法通常也會搭配物件的縮寫形式（Object shorthand）。const obj = &#123; name: &#x27;obj&#x27; &#125;; const obj2 = &#123; name: &#x27;obj2&#x27; &#125;; export default &#123; obj, obj2 &#125;; 上段介紹的具名匯出所匯出的函式必須使用函數陳述式，而 export default 則可以直接使用匿名函式的形式匯出，就不需要預先定義。// 匯出匿名函式 export default function() &#123; console.log(&#x27;這是一段函式&#x27;); &#125; // 匯出 class export default class &#123; constructor(name) &#123; this.name = name; &#125; callName() &#123; console.log(this.name); &#125; &#125; named export（具名匯出）named export 是將物件、函式等等預先賦予在特定的名稱上才能匯出，並且在 import 時也必須使用相同的名稱才能取到相同的變數或物件。 方法 1：具名匯出是需要將變數、物件預先宣告後再進行匯出，因此可以在 export 後緊接 let、const 宣告後再進行匯出。// let, const 純值 export let a = 1; export let obj = &#123; name: &#x27;obj&#x27;&#125;; 方法 2（使用率高）：使用函式陳述式匯出，這種方式與上述概念是相近的，一樣是先宣告再匯出。// 具名方法 export function fn() &#123; console.log(&#x27;這是一段函式&#x27;) &#125; 方法 3（使用率高）：使用物件縮寫的形式（Object shorthand）匯出物件，算是較為普遍運用的方式，可預先定義好所有的物件、方法後，在文件的結尾統一匯出。const b = 2; const obj2 = &#123; name: &#x27;obj2&#x27; &#125;; const obj3 = &#123; name: &#x27;obj3&#x27; &#125;; export &#123; b, obj2, obj3 &#125;; 小技巧：再匯出前可另外使用 as 修改名稱。const obj2 = &#123; name: &#x27;obj2&#x27; &#125;; export &#123; obj2 as objNewName &#125;; 並存具名、預設匯出兩種方法可以並存在同一個檔案內，預設匯出僅能有一個。export const obj = &#123; name: &#x27;obj&#x27; &#125;; export default function() &#123; console.log(&#x27;這是一段函式&#x27;); &#125; Import 匯入 匯入的方式會與因為匯出方法不同而改變，因此必須清楚外部資源的匯出方式，如果是第三方資源則可以透過文件了解該如何匯入。 匯入 default export 並賦予名稱預設匯出每個檔案僅會有一個，並且不會給予名稱，這種匯入方式會將預設匯出的模組引入，並且重新賦予一個變數名稱。// export file export default function() &#123; console.log(&#x27;這是一段函式&#x27;); &#125; // import file import fn from &#x27;./defaultModule.js&#x27;; fn(); // 直接執行函式 匯入 named export具名的匯出方式，則需要使用解構的語法將特定的模組取出（命名需與匯出的名稱一致），並且只有被匯入的原始碼片段才能夠被執行。// export file export const obj = &#123; name: &#x27;obj&#x27;&#125;; // 此段如果沒有被匯入，則無法運作 export function fn() &#123; console.log(&#x27;這是一段函式&#x27;) &#125; // import file import &#123; fn &#125; from &#x27;./module.js&#x27;; fn(); 也可以透過解構同時匯入多個物件、變數、函式等等。// import file import &#123; fn, obj &#125; from &#x27;./module.js&#x27;; fn(); console.log(obj) 重新命名具名匯出的物件、變數本身就帶有固定的名稱，如果要避免與當前的作用域產生衝突，則可以使用 as(alias) 來重新命名匯入的名稱。 可以在解構時針對單一的物件、變數重新賦予名稱：// export file export const obj = &#123; name: &#x27;obj&#x27;&#125;; export function fn() &#123; console.log(&#x27;這是一段函式&#x27;) &#125; // import file import &#123; fn as newFn &#125; from &#x27;./module.js&#x27;; newFn(); 具名匯入亦可使用 * 來全部匯入，這時候就必須搭配 as 指向一個新的物件變數，此物件的屬性則會帶上所匯入的內容。// import file 全部匯入並賦予至一個物件上 import * as name from &#x27;./module.js&#x27;; name.fn(); console.log(name.obj); 同時匯入預設、具名匯出時可同時存在兩種形式，因此匯入時也同樣支援。以下片段來說，在匯入時前者是帶入 default export，逗點後方則是帶入 named export：import defaultExport, * as name from &quot;module-name&quot;; 以下程式碼分別執行了： 匯入 default export 並賦予 fn 的名稱 匯入全部的 named export，並給賦予至 named 的物件上// export file export const obj = &#123; name: &#x27;obj&#x27; &#125;; export default function() &#123; console.log(&#x27;這是一段函式&#x27;); &#125; // import file import fn, * as named from &#x27;./defaultModule.js&#x27;; fn(); console.log(named.obj); 匯入 Side Effect 模組有些模組並沒有實作 export，例如可直接執行的函式檔案，載入後會直接執行，不需要例外的呼叫即可作為 Side Effect 模組。 常見案例如早期版本的框架，直接將方法綁定於 window，因此不需要另外呼叫即可運作，如：jQuery、angularJs 就屬於此類型。 範例如下：模組檔案不需要進行匯出，直接 import 後就能運行。// module file (function() &#123; console.log(&#x27;IIFE&#x27;); &#125;)(); // import file import &#x27;./fn.js&#x27;; 要用 default 或 nameddefault 是非常易於使用的，針對只有單一元件、模組的檔案匯出上相對直覺很多，我自己開發上也多是利用 default export。 但在針對此議題來說，也有查閱過部分的文件，許多都是提到 export default 有管理上的問題，如： 具名匯入時，命名須完全一致才可匯入，增加開發的嚴謹性 預設匯入時，無法確認該模組內是否有特定變數 因此在開發大型專案、開源套件、眾多模組時，大多都會推薦使用 named export 的形式，不過這並非強制性的要求，大家也可以是自己開發上的需求做選擇。 相關文件： 深入理解 TypeScript - export default 被认为是有害的 Why I’ve stopped exporting defaults from my JavaScript modules (译) 为什么我不再使用 export default 来导出模块","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"modules","slug":"modules","permalink":"https://wcc723.github.io/tags/modules/"}]},{"title":"開公司的流程及雷點分享","slug":"how-to-register-a-company","date":"2020-03-17T16:00:00.000Z","updated":"2020-03-20T05:44:22.787Z","comments":true,"path":"business/2020/03/18/how-to-register-a-company/","link":"","permalink":"https://wcc723.github.io/business/2020/03/18/how-to-register-a-company/","excerpt":"","text":"這次跟大家分享開公司上的一些心得，由於網路上可以找到許多開公司的流程，本篇會著重在心得的分享，當然我也並非專業的會計、法務，正確的流程建議可以詢問合作的會計。 會計開公司如果要省時間，找一個好會計是必要的，因為開公司在學校並非必修課程，大部分人都不會有開公司的經驗，雖然說是「開公司」但林林總總的項目非常多，除了公司設立外還有包含發票、營業稅、勞健保這些項目都是需要獨立申請，如果沒有一個人引導將會花去許多時間在搜尋。 還記得一開始的時候，以為公司申請好就會有發票、勞健保這些項目，申請後才知道這些是一一獨立的，如果沒有會計師協助處理，那麼就是負責人要了解這些項目，甚至需要親自排隊申請或者打電話到各個窗口詢問事宜。不熟的情況下整個流程耗去一個月是有可能的，從決定開公司那時候開始，經費就不斷的在燃燒，會建議申請的過程交給專業的人，負責人應該是將時間花費真正有價值的事情上！ 交給專業的處理，也要了解一下大致上要花多少錢，基本上費用分為兩個部分，可以參考 Simpany： 一次性費用：通常是在申請時才產生，如設立公司來說約需要一萬多元就屬於此類型。另外現在公司股東持有股份也需要公開申報，這也會產生一次性費用（會計師也會提供後續的年度維護，所以也有年度維護費用）。 每月記帳費用：記帳包含從進項、銷項的費用計算，並且會製作 401 表作為稅務申報使用，如果公司進銷項複雜需要花上許多時間，也是建議給予專業的會計師處理，每月收費約 2000 元（依據地區、營業額會略有不同），每年計費則是以 14 個月做計算（年度營所稅的費用）。 自己申報營業稅的感覺： 另外每間會計事務所的「嚴謹」程度不同，有些事務所給他們發票後就會處理到好，不會詢問發票內的細項；有些則會一一比對帳務，確認發票是符合公司需求的。而越嚴謹的事務所，公司也需要更加配合，對於想要發展成中、大型企業的公司是比較好的（營業額 3,000 萬以上則會使用查帳，嚴格程度也會不統，有些事務所在營業額不高時就會做到接近查帳的條件）。 公司、行號？在開立公司時，也需要決定是要使用公司或行號（公司又區分為有限公司及股份有限公司，在此就不多做說明），公司或行號通常會使用營業額來做區分，月營業額 20 萬以下可設立免用統一發票的行號，如果預期會超過此數目並且有開立發票的需求，則會直接建議開立有限公司，政府對於公司也會提供補助及更多法律上的保障（像是我們進駐在數創就必須是使用公司）。 需要準備什麼？了解會計師重要性以後，我們就來開始準備開立公司吧，就算有請會計師，許多項目還是需要自行處理，以下列出可以事先準備的項目吧 公司名稱預查開立公司前先想好一個名字是必要的，可以透過經濟部的預查輔助查詢看看想要的名字是否可以使用，避免自己一廂情願用特定的名稱，屆時卻發現該名稱已經被佔用了。 以下幾點經驗跟大家分享： XXXX資訊科技有限公司、XXXX科技有限公司、XXXX有限公司：這些都屬於不同的名稱，可以自行排列組合。 名稱也要刻在印章上，請謹慎選擇 名字太長以後要寫很久（我就取太長了） 主要名稱目前還是以中文為主，據說近幾年要調整成可接受英文申請，但沒有持續關注此議題。 大小章印章又稱為大小章，大章也就是公司章，小章則是負責人印章，雖然小章代表負責人，但基本上會與個人私章做區分，部會將公司的小章與個人私章混合使用，畢竟大小章在一起時就可代表公司執行許多業務，如銀行帳戶申請、匯款、公司合約或是政府單位各項業務都是使用大小章，必要時會將大小章交付給特定人士使用，所以會建議小章與私章是分開的。 印章會分為兩個階段使用，一則是在公司設立前會先帶有「籌備處」字樣的大章，在公司設立前會使用籌備處的印章申請各項業務，如開立銀行帳戶（有些銀行已經可接受不使用 “籌備處” 的印章，相對可省去一些麻煩）；另一則是公司成立後的正式大章，會建議在申請公司的過程中花些費用刻好，以便公司成立後可立即使用。 資本額、銀行帳戶成立公司時必須投入資本額作為股份，此資本額是作為公司營運使用，並且會作為盈餘分配的依據，原本公司設立有最低資本額的限制（股份有限公司為 50 萬元，有限公司為 25 萬元），後來也移除此項規定，所以只要會計師核准，資本額基本上可以無視。 接下來就是將你跟夥伴（股東）的資金準備好，然後到銀行開立帳戶（籌備戶），開立帳戶會產生一組臨時的帳戶名稱及號碼，名稱也就會帶上 “籌備戶” 的字樣，而現在有些銀行會在申請完後直接將 “籌備戶” 移除，並且使用同一組帳戶號碼。 申請完籌備戶以後，就可以在指定的時間內各自匯入談好的比例資金（太早匯也不行喔），交由會計師、政府查核後即可準備設立。 準備設立準備就緒以後，會計師會提供許多文件以供簽署，如公司章程、設立登記表、房屋所有權（或者願意租你開公司的證明文件）等各項表單，申請的過程中也可以選擇將大小章直接交由會計師（選擇信任的會計師，可以省去不少麻煩），加速整個設立的流程。 設立完成後就會收到政府的來函，包含設立許可、營業登記等等文件，尤其營業登記是政府許可的證明，申請網路線路、政府補助、正式銀行帳戶都是會使用到的，雖然它只是張 A4 紙，但請確保它有被妥善收藏。 其它事項公司如果申請完了，就可以開始營業了嗎？ 不行，畢竟要請員工就需要協助加保勞健保，有銷售就必須開立發票，這些項目還是需要在設立公司時一口氣完成。 工商憑證現在政府許多業務都慢慢的電子化，工商憑證就如同個人使用自然人憑證，只不過它所代表的是公司行號。 申請完的政府業務如勞健保、電子發票，都會要求使用工商憑證登入（除非你喜歡臨櫃申請這些業務）。登入後可將業務指派給特定的職員或負責人，往後改為使用個人的自然人憑證或健保卡登入執行該業務（所以自然人憑證太破爛的也可以順便換新）。 每月的痛 - 勞健保對於許多新創公司來說，每個月的噩夢除了薪資以外，另一個就是勞健保了（有部分負責人會認為勞健保比薪資可怕，費用約是總薪資的 20%），隨著勞工權益上升，公司所負擔的勞健保費用也越來越高，現在的勞健保也是屬於逐年調漲，在成立公司時不可忽視這個成本。 關於許多勞健保的細節可以獨立一篇做介紹，這邊僅說明前期可能會遇到事項： 申請、投保：勞健保是屬於勞保、健保的簡稱，所以實際上投保時兩者是分離的，好在申請、投保這兩個步驟可以合併處理，因此一開始可以先帶著大小章以及營業登記到「勞保局」一起申請，第一次申請時也可順便投保，申請完一段時間即會收到勞保單位、健保單位設立的許可文件。 單位設立以後，就可透過工商憑證登入勞保局的系統進行投保及各項查詢，雖然勞健保是分離的，但勞保局系統可 “同時加保勞健保”，算是流程中的小確幸…。 勞保、勞退：勞保基本上就是依據員工的薪資做投保，投保級距可參考：https://twworkforce.com/2019/11/17/3in1/ 關於負責人在勞保上，有以下一些事項需要注意： 負責人預設是沒有勞退的 負責人的勞健保級距不可低於 45,800 元，亦不可低於全員工的最高薪資 如果員工薪資為 50,000，負責人也不可低於此數字 新設立公司前半年可直接套用全員工最高薪資（如果最高薪為 36,000，前半年可先用此數字申請） 負責人一定要保勞保，但可以不要領薪水 :D 除此之外，每月的帳單上不會有每個員工的勞保明細，需要至勞保局的網站查詢。 健保：原則上，健保與勞保是一體的，所以在申請勞保時也會同時納入健保，在投保前也可先詢問員工是否要加保眷屬，加保原則是以一等親為主，二等親有其它條件（兄弟姊妹屬二等親）。 另外，在很少部分情況下，可以選擇不需要加保健保 勞工從事短期性工作未滿三個月，或是一週工時少於 12 小時，勞工是可以要雇主不幫他投保的，並繼續依原投保狀況投保(Ex:寄託在直系親屬的公司裡)，但也特別要注意，基本上成年以後的人都要獨立加保不能依附在父母親名下，除非子女為學生才可以。所以有工作、又成年，你就不能拒絕雇主幫你投保健保哦。 簡單來說： 短期、工時少 學生 員工同意 參考：https://www.1111.com.tw/dayoff/discussTopic.asp?cat=vacationQuestion&amp;id=222376 除此之外，每月的帳單上不會有每個員工的健保明細，需要至健保局的網站查詢（這個系統真心覺得難用，各項登入說明的詞彙很容易誤解）。 發票發票分為手寫發票與電子發票，顧名思義手寫發票就是用手寫的，電子發票可以用電腦輸入並以電子的方式傳送，以下列出其中的共通點及注意事項： 發票共通概念： 都是以「本」為單位，一本為 50 張發票（也就是 50 個連續發票字軌） 無論電子發票、手寫發票都需要上傳或繳回已使用發票及作廢發票 開立發票有固定 5 % 的營業稅 手寫發票：優點只有一個：申請過程簡便，除此之外都是一堆雷缺點： 每張之間都要隔複寫紙，隔錯就報廢好幾張 不能寫錯字，一寫錯就作廢（我通常三張錯兩張，好一點三張錯一張） 耗費許多時間在手寫上 稅額要自己算（有現成工具，但還是要自己輸入數值才會有結果） 寫完還要寄給用戶 先前手開發票一次要花上半小時到一小時的時間（包含寄送），真的不想再面對那樣的流程。 電子發票：電子發票申請上相當麻煩，而且每間國稅局回覆都略有不同，除了國稅局這關以外，還會建議在串接第三方的發票服務，並透過 API 的形式串接發票，可以節省非常多的時間在開發票上。 電子發票具有以下特點： 開立後不需要提供紙本發票（用戶可要求索取，但大部分不會有這些需求） 有效減少錯誤，不用擔心寫錯字浪費紙張 廠商收到電子發票，可直接用印表機列印後報帳（不需要主動寄送，節省雙方成本） B2C 發票中獎需另外主動聯絡用戶 可以串接 API，並且自動化發送發票明細 申請完電子發票後，就可以在政府的平台上使用基本的電子發票功能，包含： 索取電子發票（以本為單位下載） 開立單張電子發票（如同手開） 上傳空白電子發票字軌（沒上傳國稅局會打電話過來唸） 不過同時也建議串接第三方的發票系統，雖然需要額外的費用，但可以節省非常多的時間成本，費用上每張約 1 ~ 1.5 元，量越大價格越低，第三方電子發票平台具有以下特點： 提供 API 自動化開立發票 發票管理系統，便於開立、作廢、折讓等各種功能 自動計算稅額 提供每月申報的銷項列表（節省會計時間） 自動化上傳空白發票字軌 可開立預約發票（預先預約，等時間到才開立） 中獎查詢 光自動化開立發票我就買單了，剩餘功能也是有效節省許多時間，也可以跟經常寫錯的人工發票說掰掰，真的沒有理由不使用（也可以自行串接國稅局的 Turnkey，但不建議）。 開完公司了本篇是在開完公司後將近兩年後的時間寫的，其中也包含這段時間的一些經驗分享，希望對於想創業的夥伴有些幫助。 看完這篇以後，如果你也成功了設立公司，先恭喜你踏出了第一步，接下來還有更多的挑戰等你來面對 :D","categories":[{"name":"business","slug":"business","permalink":"https://wcc723.github.io/categories/business/"}],"tags":[{"name":"business","slug":"business","permalink":"https://wcc723.github.io/tags/business/"}]},{"title":"Flex 空間計算規則","slug":"flex-size","date":"2020-03-07T16:00:00.000Z","updated":"2020-03-08T05:42:31.104Z","comments":true,"path":"css/2020/03/08/flex-size/","link":"","permalink":"https://wcc723.github.io/css/2020/03/08/flex-size/","excerpt":"","text":"此篇是延續先前的 Flex 的文章（圖解：CSS Flex 屬性一點也不難），本篇則是著重在 flex 中的 flex-grow、flex-shrink 和 flex-basis 這三個屬性，如果對於 Flex 基礎尚不熟悉的可先閱讀前一篇文章。 首先，回顧下先前的三個屬性介紹： flex 是縮寫，裡面依序包含三個屬性 flex-grow、flex-shrink 和 flex-basis。 flex-grow: 元件的伸展性，是一個數值，當空間分配還有剩餘時的當前元件的伸展性，預設值為 0，如果設置為 0 則不會縮放。 flex-shrink: 元件的收縮性: 元件的伸展性，是一個數值，當空間分配還不足時的當前元件的收縮性，預設值為 0，如果設置為 0 則不會縮放。 flex-basis: 元件的基準值，可使用不同的單位值。 在以上的 flex-grow、flex-shrink 中，這兩個數性可以填入任意整數，關鍵也在於這個任意整數的計算方式如何，本篇將用圖文方式介紹其中運算的規則。 grow, shrink 的計算概念這兩者所填入的皆是整數，運作的概念上非常接近，都是 按比例分配剩餘空間，只是兩者是在相反的情境下運作，我們先來介紹比較常使用到的 flex-grow，接下來再用相同的概念來理解 shrink。 Grow 伸展值，分配剩餘的空間我們先建立一個簡單的基礎，在一個外部容器上加上 display: flex;，內部則補上 flex: 1; 預期會得到如下的結果：三個等比切分的內元素（三個寬度各佔 33%）。 下方的介面中，可以自行開啟 HTML, CSS 來檢視、調整原始碼，如果看到的結果不符合預期可以點選右下角的 rerun。 See the Pen Flex 寬度計算規則 - 1 by Wcc723 (@Wcc723) on CodePen. 接下來，為了讓接下來的實驗更好驗證，對於這些元素再補上一些設定： 外層容器設定為 600px 內容最左邊的元素設定 200px 寬度（flex-basis 強制設定） 右方兩個藍色元素設定 flex-grow: 1 到這個階段會看到以下的結果，三個方框的寬度依然是一致的（都是 200px）。 See the Pen Flex 寬度計算規則 - 2 by Wcc723 (@Wcc723) on CodePen. 接下來，將最右方的元素 flex-grow 改為 2，則可以看到以下的結果。 See the Pen Flex 寬度計算規則 - 3 by Wcc723 (@Wcc723) on CodePen. 由於 Flex 是按比例分配剩餘空間，因此在前面的範例中，兩者 flex-grow 都是 1 的情況下，會呈現 1:1 的結果，這次改為 1:2 那麼寬度的計算上也會改為 1:2，重點如下： 分配空間是依據比例（flex-grow 的總和值再重新分配） 是分配 剩餘的空間，已經佔用的空間不會重新分配 因此，以上方的範例來說： 總寬度為 600px，最左方的元素佔用 200px 寬度，因此剩餘 400px flex-grow 分別為 2、1，因此總和為 3 比例分配上為 400px / 3 = 133.33333px 左方寬度為 133 * 1，右方元素為 133 * 2 = 266 圖文說明： 接下來，請使用你的開發者工具檢視上方的結果（左方約為 134px，右方為 266px）。 注意，可分配的空間flex 的可分配空間會隨著條件不同而改變，以下範例來說，中間的元素補上了 100px，我們會發現他的寬度計算會與上一個的範例有所不同。 中間的元素與右邊元素尺寸大小不相上下 See the Pen Flex 寬度計算規則 - 8 by Wcc723 (@Wcc723) on CodePen. 此段的計算邏輯： 計算出可分配的空間：總寬(600px) - 左方元素(200px) - 中間元素的固定寬(100px) = 300px 計算比例：300px / 3(flex-grow 總值) \b= 100px 重新分配： 右方元素(grow: 2) 100px * 2 = 200px 中間元素(basis: 100px; grow: 1) 100px + 100px * 1 = 200px 接下來，透過開發者工具會得到 接近 上述的結果。 問題：為什麼是接近上述的結果，而不是完全符合呢？ 因為 flex 計算上是 分配剩餘的空間，空間上被佔用的因素非常多，如上述的 flex-basis 就是會屬於佔用空間的一種，除此之外包含元素內部的 文字、邊線、任何內容都會影響到佔用空間，因此也會影響到剩餘的空間分配。 Shrink 收縮值，分配多餘的空間flex-shrink 與 flex-grow 運作上則是相反，shrink 是將超出的部分重新分配，確保元素不會被裁切（如果足夠被分配完）。 以下範例透過三個 flex-basis: 250px 來超出範圍，並且統一設定 flex-shrink 與 flex-grow 皆為 0（禁止伸展、收縮），可以得到以下的結果：內元素超出了外容器。 See the Pen Flex 寬度計算規則 - 4 by Wcc723 (@Wcc723) on CodePen. 接下來，將右邊兩個元素 flex-shrink 設為 1，會看到兩個元素多餘的內容收縮到外容器內部並維持相同的寬度，最左方的元素則維持原本的寬度不變。 See the Pen Flex 寬度計算規則 - 5 by Wcc723 (@Wcc723) on CodePen. 接下來，一樣進行 2:1 的 shrink 設置實驗，左方為 flex-shrink: 1，右方為 flex-shrink: 1，接下來你可能會猜想兩者的尺寸應為 2: 1 吧！ See the Pen Flex 寬度計算規則 - 6 by Wcc723 (@Wcc723) on CodePen. 實際結果：當然不是～ 上面有提到 shrink 是分配多餘的空間，因此不是全部的空間上都重新分配，所以運作的結果如下： 接下來，重新使用你的開發者工具，檢視上方的結果吧（會得到中間元素寬度 200px，右方元素寬度 150px）。 遵循軸線Flex 撇除了原本的寬度、高度的空間定義，改用三個屬性（basis、grow、shrink）來定義一個容器的尺寸，不僅是為了提高容器的空間彈性，除此之外計算出來的空間尺寸還能依據 Flex 的軸線重新計算，大大增加了空間的彈性。 以下範例來說，將 Flex 主軸線切換為 flex-direction: column;，內層元素依然可依據垂直的方式重新分配空間大小，且計算邏輯一致。 See the Pen Flex 寬度計算規則 - 3 - cloumn by Wcc723 (@Wcc723) on CodePen. 如果透過文字還是不容易理解，可以看我過去線上教學的影片 - Flex 寬度計算方法，或是Flex 完整教學","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"爬蟲、E2E 測試兩相宜的好工具 - Puppeteer","slug":"puppeteer","date":"2020-02-29T16:00:00.000Z","updated":"2020-03-01T05:39:29.386Z","comments":true,"path":"development/2020/03/01/puppeteer/","link":"","permalink":"https://wcc723.github.io/development/2020/03/01/puppeteer/","excerpt":"","text":"Puppeteer 是 Node.js 的函式庫，它提供各種 API 來控制 Chrome 或 Chromium 瀏覽器，而此瀏覽器也是目前主流的瀏覽器，用來做為測試、爬蟲都相當合適，並且所提供的 API 語法淺顯易懂，只要具有 jQuery 的使用經驗就可以很快速地上手。 安裝官方提供兩個版本，一個包含 Chromium，另一個則無，如果有安裝 Chrome 的情況下可以不需要另外下載 Chromium，直接運行本機的應用程式即可（選擇輕量 headless 模式運行一樣很快）。 所以可以採用以下語法加入設定後跳過下載（或者也可以直接使用 puppeteer-core）：npm config set puppeteer_skip_chromium_download true 下載 Puppepeernpm i puppeteer 接下來可以新增一個檔案 test.js，使用官方提供的範例：const puppeteer = require(&#x27;puppeteer&#x27;); (async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto(&#x27;https://example.com&#x27;); await page.screenshot(&#123; path: &#x27;example.png&#x27; &#125;); await browser.close(); &#125;)(); 執行 node test.js 則會出現錯誤，主要原因是沒有下載 Chromium，這部分可以手動設置自己的 Chrome 使用。 接下來將上述原始碼中的 browser 變數改為如下即可運行，const browser = await puppeteer.launch(&#123; executablePath: &#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;, headless: false &#125;);Windows 路徑可參考：&#x27;C:\\\\Program Files (x86)\\\\Google\\\\Chrome\\\\Application\\\\chrome.exe&#x27; 重新執行一次上述的原始碼，則可以發現快速打開了 Chrome 後就關閉了瀏覽器，打開你的專案資料夾可以發現多了一張圖片，在這個過程中 Chrome 已經依據腳本完成了流程，因此來看一下剛剛發生了什麼事： 打開瀏覽器 開啟新的分頁 進入特定的網址 截圖，並把圖片存到特定的路徑 在這個流程下大致就能體會到 Puppeteer 是怎樣的工具，它可以模擬用戶的行為對瀏覽器操作，因此只要熟悉的它的語法做到爬蟲、測試都不會有太大的問題。 const puppeteer = require(&#x27;puppeteer-core&#x27;); (async () =&gt; &#123; // 使用自訂的 Chrome const browser = await puppeteer.launch(&#123; executablePath: &#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;, headless: false // 無外殼的 Chrome，有更佳的效能 &#125;); const page = await browser.newPage(); // 開啟新分頁 await page.goto(&#x27;https://example.com&#x27;); // 進入指定頁面 await page.screenshot(&#123; path: &#x27;example.png&#x27; &#125;); // 截圖，並且存在... await browser.close(); // 關閉瀏覽器 &#125;)(); 基礎方法說明中文文件：https://zhaoqize.github.io/puppeteer-api-zh_CN/#/ Puppeteer 大部分的行為都是非同步的（都是 Promise 的方法），因為無法確認網頁點擊後多久後開啟，也無法確認輸入文字需要多長的時間，而 Promise 搭配 async、await 就能將程式碼轉成類似於同步的語言。 所以使用 Puppeteer 時會看到很多 await ...，目的是要確保原始碼可以依序執行，因此以下介紹的方式也都建議都加上 await。 常見方法可以先思考下載網頁中通常會進行哪些行為，不外乎就是： 點擊連結 填寫表單 進入特定頁面，確保資訊有出現 這些方法在文件中都是在文件中的 page 找到（所有的頁面行為基本上都在這），以下列出常見的方法給大家參考： page.goto(url[, options])：直接進入特定的連結頁面 page.$(selector)：選取特定元素，等同於 document.querySelector page.$$(selector)：前者的複數型，等同於 document.querySelectorAll page.$eval(selector, pageFunction[, ...args])：對於選取的元素進行特定行為，如取出元素的 HTML 屬性值。 page.$$eval(selector, pageFunction[, ...args])：前者的複數型 page.click(selector[, options])：點擊特定的元素 page.type(selector, text[, options])：在特定的元素上輸入文字內容，通常是 input 上輸入 page.select(selector, ...values)：在 select 元素上選取特定的值 page.waitForSelector(selector[, options])：等待頁面上的特定元素出現，在非同步的過程中很實用。 方法中可以看到 selector 不斷的出現，selector 即是畫面上的元素選取方式，因為它可以模擬用戶的行為，所以 selector 的選取技巧在此工具中是非常重要的。 Selector 技巧選取器是遵循 document.querySelector 的規則，基本上就是與撰寫 CSS 時的方式一致（所以才會提到熟悉 jQuery 會非常有幫助），在選擇元素的過程中，最準確的是 id（一個網頁原則上只有一個 id），所以直接的方式就是使用 id 選擇該元素。 page.click(&#x27;#button&#x27;); // 點擊網頁中 id 為 button 的元素 但許多時候網頁元素是沒有 id 的，那麼就可以搭配 Chrome 的開發者工具直接抓出特定元素選取器。 如上圖，在特定的元素上按下右鍵 &gt; Copy &gt; Copy selector，接下來就可以取得絕對的元素路徑（頁面必須維持在固定的狀態）。#tsf &gt; div:nth-child(2) &gt; div.A8SBwf &gt; div.RNNXgb &gt; div &gt; div.a4bIc &gt; input 另外一種方式，如果確定元素具有特定的 HTML 屬性時，也可以使用以下的方式選取，這種寫法是使用 CSS 的屬性選取器。await page.$(&#x27;input[title=&quot;Google 搜尋&quot;]&#x27;)); // 可以選到標籤屬性為 title=&quot;Google 搜尋&quot; 的項目 流程實戰最後，透過 Google 搜尋特定的文字，並且進入特定頁面的方式，規劃一個簡單的流程，來測試是否可以正確運行，流程如下： 開啟 Google 頁面 搜尋 flex 文字並送出 轉址進入搜尋結果頁面 點選具有 https://wcc723.github.io 的頁面 const puppeteer = require(&#x27;puppeteer-core&#x27;); (async () =&gt; &#123; // 使用自訂的 Chrome const browser = await puppeteer.launch(&#123; executablePath: &#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;, headless: false // 無外殼的 Chrome，有更佳的效能 &#125;); const page = await browser.newPage(); // 開啟新分頁 await page.waitFor(10000); // 等待十秒鐘（給我開錄影工具用的） await page.goto(&#x27;https://www.google.com.tw&#x27;); // 進入指定頁面 await page.type(&#x27;input[title=&quot;Google 搜尋&quot;]&#x27;, &#x27;flex&#x27;); // Google 搜尋特定項目 await (await page.$(&#x27;input[title=&quot;Google 搜尋&quot;]&#x27;)).press(&#x27;Enter&#x27;); // 特定元素上按下 Enter await page.waitFor(1000); // 等待一秒 await page.waitForSelector(&#x27;#gsr&#x27;); // 確定網頁的元素出現 await page.click( // 點擊網址中包含以下的連結... &#x27;a[href*=&quot;https://wcc723.github.io&quot;]&#x27;); // 接下來也可插入 await browser.close(); 關閉瀏覽器 &#125;)(); 在上述的範例中 href*=&quot;https://wcc723.github.io&quot;] 是選取網址中包含 https://wcc723.github.io 的連結， Your browser does not support the video tag. 運行中的畫面 參考資料： Google 提供的範例：https://developers.google.com/web/tools/puppeteer/examples 中文文件：https://zhaoqize.github.io/puppeteer-api-zh_CN/#/ Chrome 與 Chromium 差異：https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"test","slug":"test","permalink":"https://wcc723.github.io/tags/test/"},{"name":"puppeteer","slug":"puppeteer","permalink":"https://wcc723.github.io/tags/puppeteer/"}]},{"title":"CSS Border 運用技巧（手繪框線、三角形、空間運用）","slug":"css-border","date":"2020-02-20T16:00:00.000Z","updated":"2020-02-23T03:27:20.055Z","comments":true,"path":"css/2020/02/21/css-border/","link":"","permalink":"https://wcc723.github.io/css/2020/02/21/css-border/","excerpt":"","text":"CSS Border 大部份來說是用在裝飾上，卡片的邊線、hover 的視覺效果、物件之間的間隔等等，這些視覺效果除了 Border 以外亦有其它方式可以達到；雖然如此，Border 的使用率還是比較高，因為相對來說更為簡單方便，不過也別這樣小看它，透過一些小技巧時，Border 還有很多靈活運用的方式。 基本觀念介紹先了解 Border 基本的觀念，有助於接下來的靈活運用。 Border 具有空間這是很多新手常遇到的問題，border 本身是具有空間的，因此元素如果增加了 border 以後會導致整體元素空間增大。因此元素如果要維持原有的尺寸，則必須將 border 所增加的空間給扣除。 以下範例來說，左方的方框增加了額外 border 時，就導致元素尺寸大於右方的方框。 .d-flex { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; } .box { height: 80px; width: 80px; margin: 3px; display: flex; justify-content: center; align-items: center; } .bg-gray { background-color: #ccc; } .border-2 { border: 2px solid #00cc99; } Border 可以搭配圓角CSS 中的圓角 border-radius 是一個偉大的發明，他並不會使元素的邊緣被裁切，而是能夠產生滑順的圓角。除此之外，雖然名稱為 border-radius 但運用上並不只限於 border，在大部分的元素上都可以運用 border-radius，而 border-radius 運用上具有以下的技巧： 不需要所有角都使用等距空間，每個角可自訂獨立的數值（左二範例） 當圓角數值超過元素空間時，將會以 較短的邊線距離產生正圓角，這樣的特性下可以在元素的邊緣套用正圓形（左三範例） 當圓角數值採用百分比且超過 50% 時，將會以 邊線距離的一半產生圓角，此特性在非正方形的情況下可能會變成橢圓形。 大多數情況來說，我都會將圓角數值設為極大值，來產生更好看圓邊，避免會出現橢圓形的狀況。 .radius { border-radius: 24px } .radius-6-12-24-48 { border-radius: 6px 12px 24px 48px; } .radius-circle { border-radius: 200px; } .radius-oval { border-radius: 50%; } 不同的樣式大部分來說 border 運用都是以 solid 為大宗，其次為 dashed 及 dotted，以下列出所有的 border 樣式，除此之外 border 的樣式還可以混合使用喔。 dotted dashed solid double groove ridge inset outset 混合 .border-4 { border: 4px solid #00cc99; } .border-dotted {border-style: dotted;} .border-dashed {border-style: dashed;} .border-solid {border-style: solid;} .border-double {border-style: double;} .border-groove {border-style: groove;} .border-ridge {border-style: ridge;} .border-inset {border-style: inset;} .border-outset {border-style: outset;} .border-mix {border-style: dotted dashed solid double;} 技巧空間運用Border 很常運用在選單的 hover 或 active 的視覺效果，但如果沒有注意到就可能因為 border 的空間讓選單產生位移，如以下範例來說，滑鼠移入選單時就會造成選單位移。 關鍵程式碼：a.demo-item:hover &#123; border-bottom: 3px solid #00cc99; &#125; 選單 1 選單 2 .demo-navbar { background-color: #fff; box-shadow: 0 3px 3px rgba(0, 0, 0, .16); padding: 0 30px; justify-content: center; } a.demo-item { display: block; padding: 10px 15px; } a.demo-item:hover { border-bottom: 3px solid #00cc99; text-decoration: none; } 會造成這樣的原因在於「Border 本身是具有空間的」，因此直接在 hover 上新增 border 時就會發生此問題，其中一種解決方法則是預先加入 “透明的 border 空間”，在 hover 或其它的行為時再來切換 border 的色彩。 關鍵程式碼：.demo-navbar &#123; /* 將部分的空間先扣除 */ padding: 0 27px; &#125; .demo-navbar .demo-item &#123; /* 加入下方透明的 Border */ border-bottom: 3px solid transparent; &#125; 選單 1 選單 2 .demo-navbar-update { padding: 0 27px; } .demo-navbar-update .demo-item { border-bottom: 3px solid transparent; } 由於 Border 本身是佔有空間的，所以也可以使用其它不含空間的視覺效果來達到此效果，以下範例則是使用 box-shadow 做到類似的效果。 關鍵程式碼：a.demo-item:hover &#123; box-shadow: 0 -3px #00cc99 inset; &#125; 選單 1 選單 2 .demo-navbar-update2 a.demo-item:hover { border-bottom: 0; box-shadow: 0 -3px #00cc99 inset; } 三角形接續一開始所提到 border 本身是佔有空間的，當有兩個邊線的 border 重疊的部分就會產生 “實體的交疊”，這個實體的交疊就會產生三角形的視覺效果。 下方的範例來說，上者是下邊、右邊的 border 產生，下者則是四邊的 border 產生。 .left-border { width: 0; height: 0; margin: 0 auto; border-right: orange 20px solid; border-bottom: blue 20px solid; } .arrow { width: 0; height: 0; margin: 0 auto; border-top: red 20px solid; border-right: orange 20px solid; border-bottom: blue 20px solid; border-left: green 20px solid; } 當四邊均為 border 時，就能產生四個三角形，當如果僅需要一個方向的三角時，就可以使用到前一個段落所提到的技巧 “透明 border”。 關鍵程式碼：.message-box:after &#123; content: &quot;&quot;; /* 四邊透明的 border */ border: transparent 10px solid; /* 將其中一補上色彩 */ border-top-color: #00cc99; &#125; 透過此方法就能做到類似訊息框的視覺效果。 歐拉歐拉歐拉歐拉歐拉！ .message-box { background: #00cc99; color: white; padding: 10px; border-radius: 5px; position: relative; } .message-box:after { content: \"\"; width: 0; height: 0; position: absolute; left: 10px; bottom: -20px; border: transparent 10px solid; border-top-color: #00cc99; } 多層次除了 Border 以外，有很多方法可以做到類似的視覺效果，而其中一個很常利用的就是 box-shadow，與 border 最大不同之處就是 box-shadow 不佔有任何空間\b\b。兩者在此也可以作為好朋友產生多層次的邊框效果。 .border-multi &#123; border: 5px solid red; box-shadow: 0 0 0 5px orange, 0 0 0 10px yellow, 0 0 0 15px green, 0 0 0 20px blue; margin: 25px &#125; .border-multi { border: 5px solid red; box-shadow: 0 0 0 5px orange, 0 0 0 10px yellow, 0 0 0 15px green, 0 0 0 20px blue; margin: 25px } 手繪邊框最後，展示比較特別的視覺風格 “手繪邊框”，前幾個範例都是圍繞在 border-radius 上，這個也不例外，最重要的關鍵點在於 border-radius 可以在同一個角設定兩個以上的參數。 如以兩個範例 範例一：設定左上的圓角，前者的數值是左上圓角靠上方邊線的圓半徑，後者的數值則是左上圓角靠左方邊線的圓半徑，原始碼 如下： 範例二：縮寫方法，可以一次設定四個圓角不同的形式。 /* 範例一 */ .border-top-left-radius &#123; border-top-left-radius: 10px 100px; &#125; /* 範例二 */ .border-2-size &#123; border-radius: 15px / 100px; &#125; .border-top-left-radius { border-top-left-radius: 10px 100px; } .border-2-size { border-radius: 15px / 100px; } 最後也補充此風格的技巧說明： border-width：可設定不同的粗細變化，做出手繪過程中的不同粗細變化 transform：手繪過程中通常不會過於水平或垂直，所以外層都可以補上 transform 製作出傾斜的效果 內層也同樣需要補上 transform 將文字內容給予補正 border-style：也可試著加入不同樣式的邊線，做出不同的手繪視覺效果 關鍵程式碼：.ink-box &#123; border-width: 2px 3px 2px 5px; border-radius: 90% 6% 93% 5% / 5% 94% 7% 95%; /* 做出傾斜的視覺感 */ transform: rotate(2deg); &#125; .ink-box-double &#123; border: dashed black 2px; &#125; .box-inner &#123; /* 將傾斜的部分修正 */ transform: rotate(-2deg); &#125; Handwriting style Handwriting style @import url('https://fonts.googleapis.com/css?family=Caveat&display=swap'); .ink-box { width: 150px; height: 150px; background:#fff; border: solid black 1px; display: flex; justify-content: center; align-items: center; /* 紙風格 */ border-width: 2px 3px 2px 5px; border-radius: 90% 6% 93% 5% / 5% 94% 7% 95%; font-family: 'Caveat'; transform: rotate(2deg); } .ink-box-double { border: dashed black 2px; } .box-inner { transform: rotate(-2deg); } 參考文件： https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius https://code.tutsplus.com/tutorials/css-refreshers-borders--net-24655 https://freefrontend.com/css-border-examples/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"border","slug":"border","permalink":"https://wcc723.github.io/tags/border/"}]},{"title":"JavaScript Promise 全介紹","slug":"all-new-promise","date":"2020-02-15T16:00:00.000Z","updated":"2020-03-06T08:25:47.043Z","comments":true,"path":"development/2020/02/16/all-new-promise/","link":"","permalink":"https://wcc723.github.io/development/2020/02/16/all-new-promise/","excerpt":"","text":"最近直播介紹如何串接開源資料，也剛好許多朋友詢問到 Ajax、Promise 相關的問題，因此重新撰寫一篇文來介紹 Promise，這篇文章也與過去形勢不太一樣，試著先將常見的問題放在前頭，接下來才開始介紹 Promise。 另外本文的內容較多，Promise 想看簡易版可參考：/javascript/2017/12/29/javascript-proimse/。 使用 Vuejs 結合 Open Street Map 製作口罩地圖 關於 Promise 常見問題Q: Promise 跟 Ajax 有什麼關係？ 關於 Ajax 可以先參考這份：https://zh.wikipedia.org/wiki/AJAX 以目前來說，Ajax 可以向伺服器傳送及取得資料，並且不需要重新整理瀏覽器畫面，這樣可以大幅提升使用者體驗並且減少伺服器負擔（僅處理資料，畫面由前端處理）。 Ajax 是屬於一個透過 JavaScript 技術名稱，用於取得遠端資料；而 Promise 則是一個語法，專門用來處理非同步行為，並不是專門用來處理 Ajax 使用，所以兩者是不同的。 Q: Promise 與 Async、Await 有什麼關係？ Promise 是用來優化非同步的語法，而 Async、Await 可以基於 Promise 讓非同步的語法的結構類似於 “同步語言”，更易讀且好管理。 Async、Await 參考：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function Q: 請問 Promise 很常用到嗎？是否一定要學呢？ 使用頻率高，必學。 非同步的問題Promise 本身是用來改善 JavaScript 非同步的語法結構。 在過去的文章中有提到，JavaScript 是屬於同步的程式語言，因此一次僅能做一件事情，但遇到非同步的事件時，就會將非同步的事件移動到程式碼的最後方，等到所有的原始碼運行完以後才會執行非同步的事件。 以下列的程式碼來說，在 console 中依序的會出現的順序為： 開始 程式碼結束 非同步事件 &lt;- 最後執行 console.log(&#x27;開始&#x27;); setTimeout(() =&gt; &#123; console.log(&#x27;非同步事件&#x27;); &#125;, 0); console.log(&#x27;程式碼結束&#x27;); 雖然在上段的原始碼中，setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行。 在 Ajax 的行為中也是一樣，當需要確保擷取到遠端資料才繼續往下執行時，如果程式碼是依序撰寫的方式，就會無法正確呈現資料，以下範例我們使用 Promise base 的 Ajax 函式庫 axios 進行一下錯誤的示範： 與上述的概念是相同的，Ajax 本身也是屬於非同步的行為。在一開始先定義了一個 data 物件，中間段落使用 axios 嘗試取得遠端資料，後面的緊接的 console.log(data); 呈現的依然是一開始定義的物件，並不會是 Ajax 取得的資料。 let data = &#123;&#125; console.log(&#x27;開始&#x27;); axios.get(&#x27;https://randomuser.me/api/&#x27;).then(function(response) &#123; data = response; &#125;); console.log(data); 在上述的範例中，data 正確的賦值位置在以下片段，如果預期在取得資料後進行其它的行為，了解整個 Promise 的運作將非常的重要。then(function(response) &#123; data = response; &#125;) Promise 的結構及狀態結構Promise 本身是一個建構函式，函式也是屬於物件的一種，因此可以附加其它屬性方法在上，透過 console 的結果可以看到 Promise 可以直接使用 all、race、resolve、reject 的方法，寫法如下（後面再介紹運用方式）： Promise.all Promise.race Promise.resolve Promise.reject Promise 建構函式 new 出的物件，則可以使用其中的原型方法（在 prototype 內），其中就包含 then、catch、finally，這些方法則必須在新產生的物件下才能呼叫。 透過 new Promise() 的方式建立 p 物件，此時 p 就能使用 Promise 的原型方法：const p = new Promise(); p.then(); // Promise 回傳正確 p.catch(); // Promise 回傳失敗 p.finally(); // 非同步執行完畢（無論是否正確完成） 除此之外，Promise 建構函式建立同時，必須傳入一個函式作為參數（executor function），此函式的參數包含 resolve, reject，這兩個方法分別代表成功與失敗的回傳結果，特別注意這兩個僅能回傳其中之一，回傳後表示此 Promise 事件結束。new Promise(function(resolve, reject) &#123; resolve(); // 正確完成的回傳方法 reject(); // 失敗的回傳方法 &#125;); resolve 及 reject 的名稱可以自定義，但在開發上大多數開發者習慣維持此名稱。 狀態Promise 的關鍵在處理非同步的事件，而非同步的過程中也包含著不同的進度狀態，在 Promise 的執行過程中，可以看到以下狀態。 pending：事件已經運行中，尚未取得結果 resolved：事件已經執行完畢且成功操作，回傳 resolve 的結果（該承諾已經被實現 fulfilled） rejected：事件已經執行完畢但操作失敗，回傳 rejected 的結果 進入 fulfilled 或 rejected 就算完成後不會再改變，Promise 中會使用 resolve 或 reject 回傳結果，並在調用時使用 then 或 catch 取得值。 如果要判斷 Promise 是否完成，可依據 Promise 事件中的 resolve 及 reject 是否有被調用，以下範例來說在沒有調用兩個方法時，Promise 的結果則會停留在 pending。function promise() &#123; return new Promise((resolve, reject) =&gt; &#123;&#125;); &#125; console.dir(promise()); 在 Promise 的執行函式中，可以看到以下兩個屬性： [[PromiseStatus]]: &quot;pending&quot; -&gt; 表示目前的進度狀態 [[PromiseValue]]: undefined -&gt; 表示 resolve 或 reject 回傳的值 以下範例來說，執行完函式直接 reject(&#39;失敗&#39;)，最終也能取得 rejected 的狀態及值。function promise() &#123; return new Promise((resolve, reject) =&gt; &#123;reject(&#x27;失敗&#x27;);&#125;); &#125; console.dir(promise()); 建立自己的 Promise如果要熟悉 Promise，最好的方式莫過於自己撰寫一次 Promise。 Promise 預設會帶入 resolve, reject 的參數（可自訂名稱，但大家習慣 resolve 及 reject），resolve 代表成功；reject 代表失敗，而兩者必定只能回傳其中之一，且必定只能回傳一次。 函式陳述式建立以後，直接透過 return new Promise 回傳並建立一個 Promise 物件，並且在內部加入一個執行函式且帶上 resolve, reject 的參數，到這個階段就是常見的 Promise 結構，接下來在依據執行的結果來透過 resolve, reject 回傳值即可（以下範例會隨機調用 resovle 及 reject）。function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; // 隨機取得 0 or 1 const num = Math.random() &gt; 0.5 ? 1 : 0; // 1 則執行 resolve，否則執行 reject if (num) &#123; resolve(&#x27;成功&#x27;); &#125; reject(&#x27;失敗&#x27;) &#125;); &#125; 在呼叫前 Promise 前回顧一下 Promise 會有三個狀態： Pending -&gt; 尚未得到結果 Resolved：事件已經執行完畢且成功操作，回傳 resolve 的結果 Rejected：事件已經執行完畢但操作失敗，回傳 rejected 的結果 上列的三種狀態每次執行必定會經過 Pending，接下來進入 Fulfilled 或 Rejected 的其中之一，並且可以使用 then() 及 catch() 取得成功或失敗的結果。 在 .then(onFulfilled, onRejected)中可帶入兩個回呼函式，兩者分別又可以帶入各自的參數： onFulfilled：執行成功的函式，所帶入參數表示 Promise 函式中 resolve 所帶入的值。 onRejected：執行失敗的函式，帶入參數表示 Promise 函式中 reject 所帶入的值。 // promise.then(onFulfilled, onRejected); // 前者為 resolve callback，後者則為 reject promise() .then((success) =&gt; &#123; console.log(success); &#125;, (fail) =&gt; &#123; console.log(fail); &#125;) 在大部分情況下，開發者習慣僅使用 .then() 來取得成功的結果，失敗的部分交由 catch(onRejected) 來處理，這兩種寫法差異很小。 // promise.then(onFulfilled); // promise.catch(onRejected) promise() .then(success =&gt; &#123; console.log(success); &#125;) // 失敗的行為一律交給了 catch .catch(fail =&gt; &#123; console.log(fail); &#125;); 鏈接為了確保非同步完成後才執行另一個方法，過去都只能不斷的透過 callback 的方式來確保下一個方法正確執行，網路上如果搜尋 callback hell 也可以看到相關的文章及程式碼波動拳的圖片。 Promise 另一個特點在於 then、catch 都可以使用鏈接的方式不斷的進行下一個任務，在此範例中我們修改 Promise 的結果，改成傳入 0 則會調用 reject，其它數值則會調用 resolve。function promise(num) &#123; return new Promise((resolve, reject) =&gt; &#123; num ? resolve(`$&#123;num&#125;, 成功`) : reject(&#x27;失敗&#x27;); &#125;); &#125; 接下來，當我們要進行確保 Promise 任務結束後在進行下一個任務時，就可以使用 return 的方式進入下一個 then，此 return 也有以下特點： 方法不限於 promise 函式，任何表達式（expression）都可進行回傳 如果是 promise 函式，則會繼續遵循 then 及 catch 的運作 如果不是 promise 函式，在下一個 then 則可以取得結果promise(1) .then(success =&gt; &#123; console.log(success); return promise(2); &#125;) .then(success =&gt; &#123; console.log(success); return promise(0); // 這個階段會進入 catch &#125;) .then(success =&gt; &#123; // 由於上一個階段結果是 reject，所以此段不執行 console.log(success); return promise(3); &#125;) .catch(fail =&gt; &#123; console.log(fail); &#125;) Then VS Catch 的失敗回呼差異then、catch 都可以透過進行鏈接，上述也有提到 then 同時也能接收失敗的結果，在此用圖示表示兩者在執行上不同的結果。 不使用 then 接收失敗：無論在哪一個階段遇到 reject 時，接下來會直接跳到 catch，在其後的 then 都不會執行。另外提一下：catch 依然可以使用 return 繼續串接（實戰中很少這樣寫）。 使用 then 接收失敗：then 中的兩個函式必定執行其中一個（onFulfilled, onRejected），可以用此方式確保所有的鏈接都能夠被執行。 Finally 完成最後方可以使用 finally 來確認工作結束，finally 不帶有任何參數。這個方法適合用來作為 Ajax 已經讀取完成，透過 finally 來關閉讀取的效果。 promise(1) .then(success =&gt; &#123; console.log(success); &#125;).finally(() =&gt; &#123; console.log(&#x27;done&#x27;); &#125;) 使用 Promise 改寫 XMLHttpRequestPromise 很大一部份是用來處理 Ajax 行為，此段透過改寫的形式了解使用 Promise 及傳統的寫法有哪些差異。 傳統上，需透過 XMLHttpRequest 建構式來產生可進行遠端請求的物件，並且依序定義方法(GET)及狀態(onload)並送出請求(send)，取得結果後的其它行為則需要撰寫在 onload 內，程式碼結構如下：var url = &#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;; // 定義 Http request var req = new XMLHttpRequest(); // 定義方法 req.open(&#x27;GET&#x27;, url); // 當請求完成，則進行函式的結果 req.onload = function() &#123; if (req.status == 200) &#123; // 成功直接列出結果 console.log(req.response); &#125; else &#123; // 失敗的部分 &#125; &#125;; // 送出請求 req.send(); 接下來將以上的行為封裝至 get 函式內，此函式包含 Promise 及上述的 XMLHttpRequest 行為，運用時只要直接使用 get(url)...，接下來的運用方式則是符合 Promise 的結構，重複運用的情況下程式碼可以大幅提高易讀性。 function get(url) &#123; return new Promise((resolve, reject)=&gt; &#123; // 定義 Http request var req = new XMLHttpRequest(); req.open(&#x27;GET&#x27;, url); req.onload = function() &#123; if (req.status == 200) &#123; // 使用 resolve 回傳成功的結果，也可以在此直接轉換成 JSON 格式 resolve(JSON.parse(req.response)); &#125; else &#123; // 使用 reject 自訂失敗的結果 reject(new Error(req)) &#125; &#125;; req.send(); &#125;); &#125; // 往後的 HTTP 直接就能透過 get 函式取得 get(&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;) .then((res) =&gt; &#123; console.log(res); &#125;) .catch((res) =&gt; &#123; console.error(res) &#125;) Promise 方法最後，介紹 Promise 中其它的方法，就 Promise 的物件下，展開後可以看到以下方法： Promise API all -&gt; 多個 Promise 行為同時執行，全部完成後統一回傳。 race -&gt; 多個 Promise 同時執行，但僅回傳第一個完成的。 Promise.reject, Promise.resolve -&gt; 定義 Fulfilled 或 Rejected 的 Promise 物件。 此段用下方定義的 promise 函式做說明，可以傳入兩個參數： num: 此 Promise 執行成功與否 time: 此 Promise 所執行的時間長度function promise(num, time = 500) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; num ? resolve(`$&#123;num&#125;, 成功`) : reject(&#x27;失敗&#x27;); &#125;, time); &#125;); &#125; Promise.all透過陣列的形式傳入多個 promise 函式，在全部執行完成後回傳陣列結果，陣列的結果順序與一開始傳入的一致。 Promise.all([promise(1), promise(2), promise(3, 3000)]) .then(res =&gt; &#123; console.log(res); &#125;); 這個方法很適合用在多支 API 要一起執行，並確保全部完成後才進行其他工作時。 Promise.race透過陣列的形式傳入多個 promise 函式，在全部執行完成後回傳單一結果，結果為第一個運行完成的，以下範例來說就會回傳 promise(1) 的結果。 Promise.race([promise(1), promise(2), promise(3, 3000)]).then(res =&gt; &#123; console.log(res); &#125;); 這個方法可以用在站點不穩定，同時發送多支同行為 API 確保可行性使用，但實作中使用率並不高。 Promise.reject, Promise.resolve這兩個方法是直接定義 Promise 物件已經完成的狀態（resolve, reject），與 new Promise 一樣會產生一個新的 Promise 物件，但其結果是已經確定的，以下提供範例說明： 使用 Promise.resolve 產生一個新的 Promise 物件，此物件可以使用 then 取得 resolve 的結果。 var result = Promise.resolve(&#x27;result&#x27;); result.then(res =&gt; &#123; console.log(&#x27;resolved&#x27;, res); // 成功部分可以正確接收結果 &#125;, res =&gt; &#123; console.log(&#x27;rejected&#x27;, res); // 失敗部分不會取得結果 &#125;); 改為 Promise.reject 產生 Promise 物件，此物件必定呈現 rejected 的結果。var result = Promise.reject(&#x27;result&#x27;); result.then(res =&gt; &#123; console.log(res); &#125;, res =&gt; &#123; console.log(res); // 只有此段會出現結果 &#125;); // rejected result 注意：Promise.reject、Promise.resolve 是直接定義結果，無論傳入的是否為 Promise 物件。 參考文章： Google 開發者文件：https://developers.google.com/web/fundamentals/primers/promises MDN Promise：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://wcc723.github.io/tags/promise/"}]},{"title":"單元測試 - 非同步及 Ajax","slug":"jest-async","date":"2020-02-08T16:00:00.000Z","updated":"2020-02-09T06:22:08.215Z","comments":true,"path":"development/2020/02/09/jest-async/","link":"","permalink":"https://wcc723.github.io/development/2020/02/09/jest-async/","excerpt":"","text":"本篇延續上一篇：十分鐘上手前端單元測試 - 使用 Jest JavaScript 是屬於同步，單執行緒的程式語言，因此當有非同步的事件時就會被往放到事件佇列，直到所有程式碼運行過後才會執行事件佇列內的程式，如果不熟悉這段觀念就會使程式的運行不符合預期，相關概念可以看此文章一次只能做一件事情的 JavaScript。 另外，現在的非同步大多都使用 Promise 來撰寫，包含 ES6 的 Fetch 及許多遠端請求的套件亦是使用 Promise 作為基礎。因此在撰寫 Jest 撰寫非同步測試時也會使用到相關的概念，至於 Promise 可參考 使用 Promise 處理非同步 範例函式這次的測試目標是使用 Ajax Get 取得遠端資料，並且確保遠端的資料是符合預期的。JSONPlaceholder 此服務可以供前端模擬 Ajax 行為，包含 GET、POST、PUT、DELETE 都可以練習，同時也可以使用 id 的方式取得固定的資料內容。 使用的遠端資料 API 路徑（最後一個數字則是 id，可確保取得固定資料）：https://jsonplaceholder.typicode.com/todos/1 該路徑取得的格式及值如下，本次將會驗證 title 的值是否為 “delectus aut autem”：&#123; userId: 1, id: 1, title: &quot;delectus aut autem&quot;, completed: false &#125; 除此之外，我們還會使用 axios 此套件來取得遠端資料，這是一個基於 Promise 開發的 HTTP 請求工具，可運用於瀏覽器或 Node.js 上（axios），使用以下指令安裝 axios：npm install axios 接下來在範例專案引入 axios，並且取得遠端資料。const axios = require(&#x27;axios&#x27;); const fns = &#123; fetchData: (num = 1) =&gt; &#123; return axios .get(`https://jsonplaceholder.typicode.com/todos/$&#123;num&#125;`) .then(res =&gt; res.data) .catch(err =&gt; &#x27;error&#x27;); &#125; &#125; 如果透過 console.log() 檢視此段函式，可以發現他所回傳的是 Promise 函式，並非遠端的值。console.log(fns.fetchData()) 如果要正確取得遠端值，則必需使用 then 這個方法。fn.fetchData(1).then(res =&gt; &#123; console.log(res); &#125;); 錯誤範例JavaScript 特性是同步的，它會依序執行所有的程式碼，但遇到「非同步的事件」則會將事件移動到事件佇列內最後執行。因此，測試的預期結果如果是直接放到非同步的後方，則會無法正確取得資料。 以下範例來說： fn.fetchData(1) 是屬於非同步事件，因此會最後才執行。 因為 fn.fetchData(1) 是最後執行，所以 expect(data.title) 中的 data 是一開始定義的 &#123;&#125; 所以結果必定為 failed（fn.fetchData(1) 不可能先執行完）。test(&#x27;should 返回值必定為 &quot;delectus aut autem&quot;（沒有正確套用 Promise）&#x27;, () =&gt; &#123; // 非同步必定需要加上 return，才能正確驗證結果 let data = &#123;&#125;; fn.fetchData(1).then(res =&gt; &#123; data = res; &#125;); // expect 無法正確取得值 expect(data.title).toEqual(&#x27;delectus aut autem&#x27;); &#125;); 非同步Promise 是常見的非同步的方法，基於 Promise 上還可以使用 Async、Await，這兩種寫法在 Node.js 中都可以運行，因此也都可以導入 Jest 中撰寫。 使用 Promise由於上述提到 fn.fetchData 會直接回傳 Promise 函式，Promise 執行完後回傳的值則必須使用 then 來取出，測試的期望及匹配也就必須寫在 then 之內，確保 Promise 已經執行完成。 所以只要將先前範例中的 expect() 移動到 then 內部基本上就能運作。// 非同步：Promise 寫法 test(&#x27;should 返回值必定為 &quot;delectus aut autem&quot;&#x27;, () =&gt; &#123; // 斷言，確保非同步有正確取得資料 expect.assertions(1); // 當有使用 assertions 則必需加上 return，才能正確驗證結果 // The assertion for a promise must be returned. return fn.fetchData(1).then(data =&gt; &#123; expect(data.title).toEqual(&#x27;delectus aut autem&#x27;); &#125;) &#125;); 斷言在前面的範例中，如果移除 expect.assertions 還是可以正確運作，而 assertions 的目的是確保有完整取得 Promise 資料，可以將程式碼改為如下將得到不同結果：// 此段範例中，Promise 直接進入 Catch 則會通過驗證 // 因為 catch 回傳的 &#x27;error&#x27; 與期望值一致 test(&#x27;assertions 驗證&#x27;, () =&gt; &#123; return fn.fetchData(1).catch(e =&gt; expect(e).toMatch(&#x27;error&#x27;)); &#125;); 如果要確保程式碼正確取得 Promise Resolve 的結果，就可以使用 expect.assertions(num)（num 表示斷言的數量）。 當補上 expect.assertions(1) 就必須使用 resolve 的結果才能通過驗證，expect.assertions 在 async 的寫法上也會更顯得重要。test(&#x27;assertions 驗證&#x27;, () =&gt; &#123; expect.assertions(1); return fn.fetchData(1).catch(e =&gt; expect(e).toMatch(&#x27;error&#x27;)); &#125;); 使用 ES6 Async, AwaitJavaScript 特性是同步的，它會依序執行所有的程式碼。但在 ES6 中，只要將函式轉為 Async 函式，就可以使用 await 來接受 Promise 回傳的結果，相對於 Promise 來說，await 不需要另外使用 then 或函式的巢狀結構，並且會依序執行 Promise 的事件，也因為這個特性使非同步原始碼不需要寫得很 “巢”。 test(&#x27;should 回傳值必定為 &quot;delectus aut autem&quot;（async）&#x27;, async () =&gt; &#123; expect.assertions(1); // async 函式下，await 會確保取得遠端資料後才繼續往下運行 const data = await fn.fetchData(1); expect(data.title).toEqual(&#x27;delectus aut autem&#x27;); &#125;); 驗證特定屬性是否存在除此之外，遠端資料相對於本地端是更不可預期的，因為蝴蝶效應的關係，後端改了程式碼可能沒有知會前端，導致前端程式碼發生不可預期的錯誤（但開發者可能找不到原因），測試中也可以導入特定欄位是否存在的驗證。 test(&#x27;驗證非同步 特定屬性是否已被定義&#x27;, async () =&gt; &#123; expect.assertions(1); const data = await fn.fetchData(1); expect(data.title1).toBeDefined(); &#125;); 參考資料：參考： 官方文件：https://jestjs.io/en/ 影片：https://www.youtube.com/watch?v=7r4xVDI2vho","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"test","slug":"test","permalink":"https://wcc723.github.io/tags/test/"},{"name":"jest","slug":"jest","permalink":"https://wcc723.github.io/tags/jest/"}]},{"title":"十分鐘上手前端單元測試 - 使用 Jest","slug":"jest-intro","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T13:46:18.534Z","comments":true,"path":"development/2020/02/02/jest-intro/","link":"","permalink":"https://wcc723.github.io/development/2020/02/02/jest-intro/","excerpt":"","text":"隨著應用程式越來越大，人工流程的測試也會耗去許多的時間，許多功能再開發後都必須重新進行點擊特定目標、撰寫複雜表單、送出來檢驗功能的正確性，當功能越來越複雜時，人工測試所花的時間也會越來越常，因此改用測試工具相對會節省去許多時間。尤其到了上線時才發現錯誤，那時候心中真的會吶喊 No、No、No～。 前端的測試常見的有兩大類別： Unit Test：中文稱為單元測試，是以一個行為進行測試，可驗證運行是否符合結果。 E2E Test：直接模擬使用者在瀏覽器上的行為做測試 圖片來源：Unit vs E2E Testing for Vue.js 因此 Unit Test 相對來說測試成本降低非常多，在任何時間點都可以優先導入測試（甚至在開發前 - TDD），雖然測試聽起來要另外撰寫程式碼做驗證，但撰寫並不一定會花上許多時間（思考驗證邏輯反而會花上許多），但好的測試可以帶來許多的優點： 避免修改程式碼後的錯誤：修改程式的過程中可能會發生蝴蝶效應，A 處修改的原始碼卻使看似毫無關聯的 B 處錯誤。 不需要每次修改都重新人工測試 除此之外，身為一個工程師看不慣前輩（或是過去的自己）的 Code 是很正常的，但重構同時也會帶來風險，如何確保新舊程式碼之間的結果一致是相對困難的過程。 Jest本篇會以 Jest 作為起手式介紹，後續也會另外介紹一篇 E2E 的測試框架。Jest 在 React 界有許多開發者推薦使用，Vue 的 Cli 中也是可做為預設的單元測試選項。 單元測試的基本觀念是對 function 進行測試，但許多同學可能聽到 “測試” 就會覺得些許的麻煩。接下來我們透過一個小故事來介紹單元測試中的各種行為。 小明是一間麥當當分店的店長，接下來要為新進的員工進行評鑑，因此他模擬了顧客行為要在麥當當買大麥克套餐 127 元，並且使用百元鈔票付款，因此他會拿出 200 元現金，預期讓點餐員找回正確的零錢。 因此，這段對應到單元測試會有以下流程： 測試的目標為何？ -&gt; 會使用一段文字描述做什麼、期望的結果為何 小明決定拿出 200 元，心裡想著「拿 200 元買套餐，預期會找 73 元」 導入要測試的函式 -&gt; 實際運行的過程 點餐員收走了 200 元減去大麥克套餐的 127 元，得到了 73 元找給了小明 測試的期望是什麼？ -&gt; 驗證的期望值，可以用各種方式比對結果 小明收了錢後，算了算確實是 73 元沒有錯 在這個過程中就有可能發生： 點餐員不夠專業，找錢的過程出錯 小明的預期是錯誤的，可能小明在一開始就沒規劃好，也沒算準導致錯誤 無論如何，接下來我們將透過實際的程式碼來介紹上述的過程。 驗證點餐員的行為是否符合預期接下來，我們會新增兩個檔案，一個是點餐員的行為，另一個是測試整個過程的腳本。|- employee.js 點餐員的行為 |- employee.test.js 點餐員的測試腳本 點餐員目前只有一個行為就是找零錢，他會接收兩個數值（顧客的現鈔、餐點的價格），並且回傳一個結果（找的零錢）。注意：這個檔案必需 export 才能被測試檔案接收並測試。const employee = &#123; makeChange: function(bill, price) &#123; return bill - price; &#125; &#125;; module.exports = employee; 命名一個中間補上 .test. 的檔名作為測試檔（這是測試預設的檔名），接下來在此補上要測試的內容。測試的過程中會明確的標上「測試的目標描述test(...)」，並且定義「測試的結果是否符合預期expect()...」const employee = require(&#x27;./employee&#x27;); // 明確描述測試的目標：&#x27;拿 200 元買套餐，預期會找 73 元&#x27; test(&#x27;拿 200 元買套餐，預期會找 73 元&#x27;, () =&gt; &#123; const bill = 200; // 小明手中的鈔票 const price = 127; // 餐點的價格 // 期望找錢的結果是符合預期的 expect(employee.makeChange(bill, price)).toBe(73); &#125;); 準備安裝環境及測試結果，在上述過程中已經將原始碼及測試的過程都準備好，接下來只要小步驟就能將測試環境導入： 輸入 npm install jest --save-dev 安裝 Jest 打開 package.json 內將 script 內新增方法並加入 jest。 &#123; &quot;devDependencies&quot;: &#123; &quot;jest&quot;: &quot;^24.9.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;jest&quot; // 運行 test 的方法時，會使用 jest 作為套件開始運行 &#125;, // ... &#125; 輸入 npm run test 查看結果 如果過程沒有錯誤，你應該可以在終端機下看到以下結果，我們定義了一個目標「拿 200 元買套餐，預期會找 73 元」，這個測試結果是沒有問題的。 到此，已經掌握到基礎的測試過程，提出一個目標並且使期望值通過（心中是否會聽到 Yes、Yes、Yes 的聲音呢？）。 監控測試：也可以將 scripts 中的方法改為如下，就可以不需要每次都重新輸入 npm run test&#123; &quot;devDependencies&quot;: &#123; &quot;jest&quot;: &quot;^24.9.0&quot; &#125;, &quot;scripts&quot;: &#123; &quot;testwatch&quot;: &quot;jest --watchAll&quot; // 使用 npm run testwatch 時會持續用監控的形式，而不是只有單一次報告 &#125;, // ... &#125; 藉此，相信你對於測試有基本的概念，在進入下一個階段前可以先回顧一下三個階段： 測試的目標為何？ -&gt; test(&#39;...&#39;, ()=&gt;&#123;&#125;) 導入要測試的函式 -&gt; employee.makeChange() 測試的期望是什麼？ -&gt; expect(...).toBe(...); 專案結構調整透過範例了解以後，我們稍微調整一下專案結構，便於後續的介紹： 資料夾目錄與上述接近，將 employee 改為 fn，用來定義多個函式。|- fn.js 原始的測試檔案 |- fn.test.js 測試的腳本 JS 檔案中，透過物件定義多個行為。const fns = &#123; // ... &#125; module.exports = fns; // 將函式給予匯出 fn.test.js 這個測試檔案將匯入上述的函式檔案，並且開始進行測試：const fn = require(&#x27;./fn&#x27;); test(&#x27;...&#x27;, ()=&gt; &#123; ... &#125;); 準備好以後，我們來繼續往下介紹吧！ 搭配 VSCode 環境除了使用終端機外，Jest 與 VSCode 也能有很好的整合，不需要每次運行都輸入 npm run test，搭配套件使用即可在每次存檔後看到測試的結果。 套件連結：https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest 接下來新增一個 jest.config.js，此測試檔案預設僅需要匯出一個空的即可運作（全部使用官方預設即可），參考如下：module.exports = &#123; &#125;; |- fn.js 原始的測試檔案 |- fn.test.js 測試的腳本 |- jest.config.js 新增的 Jest 設定檔案 在測試的文檔右方即可看到測試成功的 v，如果是失敗狀態則會出現紅色的 x。 錯誤的狀態如下，會出現 x ，並且在 expect 行列上出現紅色下底線，游標在上時會提供預期值及實際接收值。 VSCode 片段提示每次都要重新輸入 test(&#39;....&#39;, ()=&gt; &#123;&#125;) 或各種驗證覺得麻煩嗎？Jest 的各種語法都很好理解，但反覆輸入真的會花上許多時間，因此可以透過 Snippets 來增快寫測試的速度。 https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets 使用方式，輸入比對方法中的首字及其後的大寫字母（建議直接從 Jest 官方文件去做聯想，可以學得更快），參考如下： tb -&gt; expect().toBe(); tblt -&gt; expect().toBeLessThan(); tblte -&gt; expect().toBeLessThanOrEqual(); 基本的起手式，也可以輸入 test + tab 即可出現以下片段：test(&#x27;should &#x27;, () =&gt; &#123; &#125;); 在測試的檔案下，輸入特定字母也會提示具有哪些片段可用。 常見的條件驗證方式 - matchers編寫測試時需要讓值符合期望，Jest 中的 expect 後方可以使用 matchers（匹配器）作為條件驗證，如先前的範例 expect(...).toBe(...); 中的 toBe 就屬於 matchers，作為各種不同條件的驗證使用。 如果是熟悉 JavaScript 的開發者，可以直接看 Jest 官方文件 expect 的部分，所有的 matchers 皆陳列於此，本段落會列出實際開發中常見的 matchers，有了基礎概念後，對於官方所提供的文件也能更快上手。 在 fn.js 中先定義多個方法，這些方法會回傳數值、null、undefined 等各種純值，另外還會回傳物件（物件的驗證概念會與純值不同）。// 原始碼 const fns = &#123; add: (num1, num2) =&gt; num1 + num2, isNull: () =&gt; null, isUndefined: () =&gt; undefined, isNaN: () =&gt; NaN, checkValue: (val) =&gt; val, createUser: () =&gt; &#123; return &#123; name: &#x27;小明&#x27; &#125; &#125; &#125; 在純值的驗證上相對單純，除了 toBe 外，有各種直白的 matchers 可供利用。// toBe：使值完全符合，判斷是使用 Object.is // 概念接近於 `===` test(&#x27;測試 fn 相加是否正確&#x27;, () =&gt; &#123; expect(fn.add(5, 5)).toBe(10); &#125;); // toBeNull：測試回傳值是否為 null test(&#x27;測試 fn 是否為 Null&#x27;, () =&gt; &#123; expect(fn.isNull()).toBeNull(); &#125;); // toBeUndefined：測試回傳值是否為 undefined test(&#x27;測試 fn 是否為 Undefined&#x27;, () =&gt; &#123; expect(fn.isUndefined()).toBeUndefined(); &#125;); 在 JavaScript 中，如果使用 NaN === NaN 則會回傳 False，官方另有提供 toBeNaN 作為驗證，但其實使用 toBe(NaN)也能通過，主要原因 toBe 是使用 Object.is 的方法，相關討論可參考 NaN check：// toBeNaN：測試回傳值是否為 NaN test(&#x27;測試 fn 是否為 是否為 NaN&#x27;, () =&gt; &#123; expect(fn.isNaN()).toBeNaN(); &#125;); 真值、假值（truthy、falsy）是判斷式中的判斷依據，並不一定完全是布林值的 true or false，所以在此就不適合使用 toBe，可以使用 toBeFalsy、toBeTruthy 進行驗證。// 以下是判斷真值與 test(&#x27;測試 fn 是否為 是否為假值&#x27;, () =&gt; &#123; expect(fn.checkValue(0)).toBeFalsy(); &#125;); test(&#x27;測試 fn 是否為 是否為真值&#x27;, () =&gt; &#123; expect(fn.checkValue(1)).toBeTruthy(); &#125;); 物件比對JavaScript 的特性之一，物件是傳參考而不是傳值（關鍵字可查詢：Javascript call by sharing）。 以下列範例來說，雖然物件內的值是相同的，但因為物件是傳參考的特性，所以最終所回傳的結果還是 false。const user = &#123; name: &#x27;小明&#x27; &#125; console.log(user === &#123;name: &#x27;小明&#x27;&#125;); // false 在 Jest 也是相同的概念，如果直接使用 toBe 來比對物件，就算其內部的屬性值是相同的，一樣會得到 failed 的結果。 範例：// 原始碼 const fns = &#123; createUser: () =&gt; &#123; return &#123; name: &#x27;小明&#x27; &#125; &#125; &#125; // test (failed) test(&#x27;測試 fn 是否為 小明&#x27;, () =&gt; &#123; expect(fn.createUser()).toBe(&#123; name: &#x27;小明&#x27; &#125;); &#125;); 因此在做物件比對時，必須使用另一個方法 toEqual 才能比對兩個物件內的值是否相同。 // test (passed) test(&#x27;測試 fn 是否為 小明&#x27;, () =&gt; &#123; expect(fn.createUser()).toEqual(&#123; name: &#x27;小明&#x27; &#125;); &#125;); toBe 及 toEqual 的差異toBe 及 toEqual 語意上都是很接近的，許多情況下兩者混用也會出現相同的結果，但在運作上會有所不同，以下分別列出兩者特點及差異： toBe 是使用 Object.is 作為判斷，並非使用 ===，所以在部分情況下會與 ECMAScript 有所不同。 toEqual 是屬於深度比對（deep equality），一一使用 Object.is 比對物件或陣列內的純值；也由於是深度比對，就如同在物件內將值一一取出重新比對，效能上會較差一些。 參考： https://jestjs.io/docs/en/expect#toequalvalue https://jestjs.io/docs/en/expect#tobevalue Jasmin（此段說明接近 Jest）：https://stackoverflow.com/questions/22413009/jasmine-javascript-testing-tobe-vs-toequal 數值比對數值比對中也有提供「大於、小於、大於等於、小於等於」等方法，以下直接提供範例做參考： // test test(&#x27;測試數值 是否小於 2000&#x27;, () =&gt; &#123; const num1 = 1000; const num2 = 900; expect(num1 + num2).toBeLessThan(2000); &#125;); test(&#x27;測試數值 是否小於 2000&#x27;, () =&gt; &#123; const num1 = 1000; const num2 = 1000; expect(num1 + num2).toBeLessThan(2000); &#125;); test(&#x27;測試數值 是否小於或等於 2000&#x27;, () =&gt; &#123; const num1 = 1000; const num2 = 1000; expect(num1 + num2).toBeLessThanOrEqual(2000); &#125;); 字串符合字串除了 toBe 以外，還可以使用 toMatch 搭配正規表達式進行驗證，以下提供 mail 的驗證供參考： test(&#x27;測試 email 格式是否正確&#x27;, () =&gt; &#123; expect(&#x27;gres@gmail.com&#x27;).toMatch( /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z]+$/ ); &#125;); test(&#x27;測試 email 格式是否正確 2&#x27;, () =&gt; &#123; expect(&#x27;gres@gmail&#x27;).toMatch( /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z]+$/ ); &#125;); 陣列是否包含特定值陣列比對上與物件相同，都是使用 toEqual()，另外可以使用 toContain 檢視陣列中是否有包含特定值。 test(&#x27;陣列是否包含 Casper&#x27;, () =&gt; &#123; const newArray = [&#x27;Bob&#x27;, &#x27;Someone&#x27;, &#x27;Casper&#x27;]; expect(newArray).toContain(&#x27;Casper&#x27;); &#125;); describedescribe 的用途是提供一個群組的描述，以一開始的範例來說，我們可能會驗證點餐員以下行為是正確的： 點餐內容與顧客需求相符 結帳金額正確 找零的金額正確 那麼 describe 就可以將這些測試定義成一個群組：describe(&#x27;僱員的行為測試&#x27;, () =&gt; &#123; test(&#x27;點餐內容與顧客需求相符&#x27;, () =&gt; &#123;&#125;); test(&#x27;結帳金額正確&#x27;, () =&gt; &#123;&#125;); test(&#x27;找零的金額正確&#x27;, () =&gt; &#123;&#125;); &#125;); 在使用 npm run test 則可以接受到群組的測試結果。 describe 的群組定義也同樣可以使用巢狀，詳細可見官方網站：https://jestjs.io/docs/en/api#describename-fn 預告單元測試難的也並非是語法，更重要的是如何驗證函式的行為與產品邏輯一致。本篇簡單入門了 Jest 的運作方式，接下來還會繼續介紹非同步的測試及框架的實戰測試方法。 參考： 官方文件：https://jestjs.io/en/ 單元測試和整合測試的涵蓋範圍：https://ithelp.ithome.com.tw/m/articles/10229734 影片：https://www.youtube.com/watch?v=7r4xVDI2vho 神 Q 超人簡報：https://hackmd.io/@ei_7gAIeSEq2x9U-cH1WoQ/r1FoTHClL","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"test","slug":"test","permalink":"https://wcc723.github.io/tags/test/"},{"name":"jest","slug":"jest","permalink":"https://wcc723.github.io/tags/jest/"}]},{"title":"前端開發者，圖片常犯的五個粗心錯誤","slug":"image-common-mistakes","date":"2020-01-03T16:00:00.000Z","updated":"2020-01-05T23:54:19.954Z","comments":true,"path":"development/2020/01/04/image-common-mistakes/","link":"","permalink":"https://wcc723.github.io/development/2020/01/04/image-common-mistakes/","excerpt":"","text":"前端開發者是透過程式碼將資訊呈現成畫面，因此畫面的好壞也多少影響品質，在觀看許多履歷或作業的過程中，會發現許多相似的錯誤，而這些錯誤都是有跡可循，並且可以避免的；本篇先以常見的圖片問題與大家分享，看是否你也犯了這些錯誤呢？ 一、圖片變形新手錯誤率：⭐⭐⭐⭐令人感受的粗心度：👎👎👎👎 圖片變形是最明顯的錯誤，大部分的使用者都能看到這樣的問題，而這些問題會讓人感受到開發者的不細心。 要避免圖片變形，關鍵在於「避免在 比例可能會調整 的空間使用 img 標籤」 以下圖為例：該圖的原始檔案長寬為 1350px * 901px 就比例來說是張橫式的圖片，如果在網頁上的空間提供非此比例則會造成變形。 以下圖來說，左方是屬於正確呈現的圖片，維持原本的橫向矩形，如果改為右圖接近方形的情況就會產生變形。 有些時候，比例變化沒有那麼大的情況下，開發者可能會誤以為圖片沒有變形，但在用戶看來並非如此，現在人普遍美感大幅提升的情況下，越來越多人可以輕易看出這樣的問題。 避免方法： 僅限制寬 或 高，另一邊使其自由伸展 如果寬高比例是無法控制的，可以使用背景圖作替代 錯誤範例及解決辦法： See the Pen 圖片變形範例 by Wcc723 (@Wcc723) on CodePen. 範例連結：https://codepen.io/Wcc723/pen/zYxPmXR 二、圖片尺寸過大新手錯誤率：⭐⭐⭐⭐⭐令人感受的粗心度：👎👎 雖然越高的解析度會有更好的畫質呈現，但受限於裝置能夠呈現的極限及人眼的辨識度下，過於提高的解析度並不會有更高的畫質，反而會造成 1. 圖片下載速度過慢、2. 瀏覽器渲染速度變慢導致網頁操作不順暢。雖然現在的裝置普遍效能很高，但超過 2000px ~ 3000px 的圖片還是會影響顯示效能。 這個錯誤算是最常見，但卻不一定會被發現的錯誤，因為圖片顯示上是沒有問題的（只是可能慢一些），大多情況則是會透過開發者工具檢查此問題。以下圖來說就載入該空間所需十倍尺寸大的圖片 See the Pen 圖片檔案過大 by Wcc723 (@Wcc723) on CodePen. 範例連結：https://codepen.io/Wcc723/pen/NWPwOQr 避免辦法： 簡單解決辦法，釐清你的圖片的用途： 主要圖片、小圖：圖片的寬高尺寸盡量不超過顯示區域的兩倍（ex: 寬度 300px 的顯示區域則圖片寬度不超過 600px 為主），現在許多裝置都有 Retina 顯示器，此情況下 2 倍解析度已有不錯的品質。 背景圖：因為背景圖並非主要用來傳達資訊的內容，因此使用 1:1 的顯示尺寸即可。 使用 srcset 設置響應式圖像： 透過 srcset 可以在同一個 img 標籤載入不同尺寸的圖片，參考文件 範例程式碼：&lt;img class=&quot;img-fluid&quot; srcset=&quot;https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=300&amp;q=80 800w, https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1200&amp;q=80 1200w&quot;&gt; 請另開分頁，並調整視窗尺寸後並重新整理畫面（可以取得不同尺寸的圖片）：https://codepen.io/Wcc723/full/oNgoQXm 三、SVG 內混用了點陣圖、未外框的文字新手錯誤率：⭐⭐令人感受的粗心度：👎👎 SVG 是屬於向量圖，而一般的 jpg, png 是屬於點陣圖，向量圖來說最大的特性在於沒有解析度的限制，並且是屬於數學座標，且檔案大多小於點陣圖，並且有極佳的顯示品質。因此再大的區塊，也都僅需要載入很小檔案的 svg 就有很棒的呈現。 SVG 是屬於 XML 格式的標記語言，原始碼的內容都是在標記所有節點的座標位置，因此在原始碼會看到元素標籤、座標位置的相關資訊，輸出的檔案結構如下：&lt;svg width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 100 100&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;g id=&quot;svg-outline&quot; stroke=&quot;none&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; fill-rule=&quot;evenodd&quot;&gt; &lt;path d=&quot;M49.564,64.336 C45.878,64.336 41.926,62.968 39,60.27 L42.838,55.596 C44.852,57.306 47.474,58.484 49.716,58.484 C52.224,58.484 53.402,57.534 53.402,56.014 C53.402,54.38 51.844,53.848 49.412,52.822 L45.802,51.302 C42.838,50.124 40.064,47.654 40.064,43.55 C40.064,38.8 44.32,35 50.324,35 C53.592,35 57.05,36.254 59.52,38.724 L56.138,42.98 C54.276,41.574 52.528,40.814 50.324,40.814 C48.234,40.814 46.942,41.65 46.942,43.17 C46.942,44.728 48.728,45.336 51.236,46.324 L54.77,47.73 C58.266,49.136 60.356,51.492 60.356,55.482 C60.356,60.194 56.404,64.336 49.564,64.336 Z&quot; id=&quot;S&quot; fill=&quot;#000000&quot; fill-rule=&quot;nonzero&quot;&gt;&lt;/path&gt; &lt;/g&gt; &lt;/svg&gt; SVG 圖片範例 當 SVG 內容插入點陣圖片後，圖片就不是只存在著座標位置，還會將點陣圖片以 base64 的格式插入。記得，這個圖片會造成許多額外的檔案大小，並且無法如同 SVG 一樣自由縮放，如同喪失使用 SVG 的用意。 通常會出現這樣的錯誤是在設計稿插入了點陣圖，並誤將此圖片輸出出來，開發者如果沒有檢查通常不會主動發現這樣的錯誤。&lt;svg width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 100 100&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;g id=&quot;svg-bmp&quot; stroke=&quot;none&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; fill-rule=&quot;evenodd&quot;&gt; &lt;image id=&quot;Bitmap&quot; x=&quot;39&quot; y=&quot;35&quot; width=&quot;22&quot; height=&quot;30&quot; xlink:href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAeCAYAAAAo5+5WAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAFqADAAQAAAABAAAAHgAAAAAsUXibAAACGklEQVRIDaWVzUtWQRSHX0sjXfiBCJGErowgqFaJK10kbkUoaKFILmon2V/Qulq0yFoErowWhatEDcGFbcOVIm0EP7ACsbJU+np+rw7OnTtz517eA887M2d+58x978ycW1UKWxNTt6AHrkEL1MFn2IQP8A4W4BCipuBH8AP+5WAdzT04A0G7yMwq5EnoapaJU3zK2vBodTegyHiX+E4381yFSfUAK1BvJ+6NJP3L/Bbo734JaL/hvwQJm2AU+sva9Y6EulRqZzwGG6A4LdwPKVvCE0rcmlKfOM7S1Ql6eOJK9rYZ+hL/xt+YlOYbnTqWaTd9dhrnE6j2TebxvUHke2Lj09kehto8yWzNTQYmSVa7g+4pXLaDY/1FBFlJ3TnViiGoiSW+gkDv2k0QG38i5jZUQdCuMqOLEEvmm39FXOYm69y+BB01X4Is3xQxUVOleg55y6dZ0HsDfas14ByFvOVUt7iQaXP6YAHM04Xa5kKZLfEd+n8yFrhuacvdNn4T9dQVWOP39ENPPGBqhfR6lzPwEbogZvsZgq9mTgtMg/0EbxmnPjPHATdoDxy9idUr0he9bKqpZsJt15h7DY/hBcSu/jyasg3y6yarZNx9lPbollWSyI59ZpKadoTOT7BFRfuTxOvDkLJ2POOg3S6SVBXxLkTtPIoHMAu/wLfIIX7V4/vgPfeZNZQgfYUvwDnQNf0OOqOqwXsQtP8amWC6AXj6RwAAAABJRU5ErkJggg==&quot;&gt;&lt;/image&gt; &lt;/g&gt; &lt;/svg&gt; SVG 圖片範例，此範例文字在高解析的裝置下會變得模糊。 在 SVG 加入文字內容時，需要確保文字輸出是有被轉外框，如果沒有轉外框程式碼會看似如下簡短，但如果用戶沒有此字體，該文字就無法如預期顯示。 此錯誤是屬於設計稿中的文字沒有轉外框，因此開發者很難以發現。&lt;svg width=&quot;100px&quot; height=&quot;100px&quot; viewBox=&quot;0 0 100 100&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;g id=&quot;svg-font&quot; stroke=&quot;none&quot; stroke-width=&quot;1&quot; fill=&quot;none&quot; fill-rule=&quot;evenodd&quot; font-family=&quot;NotoSansCJKtc-Black, Noto Sans CJK TC&quot; font-size=&quot;38&quot; font-weight=&quot;700&quot;&gt; &lt;text id=&quot;S&quot; fill=&quot;#000000&quot;&gt; &lt;tspan x=&quot;38.359&quot; y=&quot;66&quot;&gt;S&lt;/tspan&gt; &lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; SVG 圖片範例，此範例的文字可以圈選，且與上方的字體不一定相同（視系統內是否有該字體）。 S SVG 的錯誤與設計師有很大的關係，因此前端開發者在使用 SVG 稿件時也有義務一同檢視該檔案是否正確。而設計師也需要對此更加注意，避免輸出錯誤的圖檔給予開發者使用。 相較於其它錯誤來說，此錯誤與設計師的稿件輸出有很大關係。因此，如果你是 UI 設計師，此類型錯誤會令人感受到不專業。 四、背景圖裁切掉主體新手錯誤率：⭐⭐⭐令人感受的粗心度：👎 現在開發都會考量 RWD 的顯示，RWD 中的圖片大多會改變寬高或轉為背景圖來處理，而背景圖並非都適合運用在 RWD 中，因為在縮放的過程中會有不同比例的裁切，這些裁切如果是在主體上，對於網頁品質會有很大的扣分。 在以下的範例中有一個長形的沙發，也由於沙發長度過長，因此在行動版中左右方會有裁切。 See the Pen 圖片裁切掉主體 by Wcc723 (@Wcc723) on CodePen. 因此在選擇圖片時，可以先思考行動版、桌面版所呈現的比例，兩者比例中的重疊空間稱為「重疊安全區域」，如果主體可以完整置入此區域內就可以避免被裁切。 完整的介紹文章：網頁設計 - 響應式圖片選用技巧 五、圖片連結錯誤新手錯誤率：⭐⭐令人感受的粗心度：👎👎👎👎👎 如果圖片是屬於裝飾類型，並且由開發者所置入，就必須要多加注意。開發者也通常會反覆檢視自己輸出的頁面是很正常的，因此這類型錯誤通常不會是在開發階段時遺漏，很多是在轉換環境時沒有完整檢查出錯。大多原因在於相對路徑與絕對路徑的掌握度不足。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"}]},{"title":"CSS 技巧：精簡語法操作暗色主題 - CSS Dark Mode","slug":"css-dark-mode","date":"2019-12-21T16:00:00.000Z","updated":"2019-12-22T13:04:00.023Z","comments":true,"path":"css/2019/12/22/css-dark-mode/","link":"","permalink":"https://wcc723.github.io/css/2019/12/22/css-dark-mode/","excerpt":"","text":"Mac 暗色主題推出後，就讓黑色控非常喜愛，而且這樣的暗色佈景使用起來更不傷眼。以我來說是比較喜歡在亮色的佈景下工作的，但暗主題的對於長期需要在電腦面前工作來說，真的相對輕鬆很多。雖然如此，也並非所有的介面都是有提供暗主題，以網頁來說就需要開發者另外定義暗主題才會進行切換（不使用任何瀏覽器插件的情況下）。 好在，暗色主題的語法相當容易，以下介紹如何作切換，並且會提供一個小技巧，只要透過短短的幾行就能操控整個網站所有元件的主題色彩。 支援度先附上大家所在意的支援度，但其實暗色主題本身就是由 Apple 先提出的，所以 Mac OS、iOS 的支援度會比較高，其它的瀏覽器也正在持續跟進中。 語法MDN 上的介紹：https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme 暗色主題的 CSS 是透過 @media 取得裝置的主題模式，就如同取得裝置的形式一樣（尺寸、橫向或垂直、是否為螢幕等等…），相信對於撰寫過響應式的開發者都不陌生。 語法上使用 prefers-color-scheme 來監測是亮色或暗色的主題，相對應的值也就是 dark or light。@media (prefers-color-scheme: $&#123;dark or light&#125;) &#123; // ... &#125; 實際演示範例範例：&lt;style&gt; .mode &#123; background-color: #eee; color: #333; &#125; .text-mode:after &#123; content: &quot;light&quot;; &#125; @media (prefers-color-scheme: dark) &#123; .mode &#123; background-color: #333; color: #eee; &#125; .text-mode:after &#123; content: &quot;dark&quot;; &#125; &#125; &lt;/style&gt; &lt;div class=&quot;demo mode&quot;&gt; &lt;p&gt;本區塊會隨著暗色與亮色主題切換&lt;/p&gt; &lt;p&gt;您目前的是 &lt;span class=&quot;text-mode&quot;&gt;&lt;/span&gt; 主題&lt;/p&gt; &lt;/div&gt; 請透過切換你的暗色、亮色主題來改變下方的範例（暗色主題為深色背景，亮色則反之）。 .mode { background-color: #eee; color: #333; } .text-mode:after { content: \"light\"; } @media (prefers-color-scheme: dark) { .mode { background-color: #333; color: #eee; } .text-mode:after { content: \"dark\"; } } 本區塊會隨著暗色與亮色主題切換 您目前的是 主題 使用變數快速切換網頁的主題色暗色系與亮色中的色彩並不是黑白兩色互相切換，以 Material Design 來說，如果亮色的主色色彩為 #6222ee，在暗色系並不會使用相同色，而是會改變為 #bb85fc 藉此來增加辨識度，而整個網頁中所需要套用色彩的區塊非常多，從按鈕到元件都會不斷地引用，如果透過一個個的 @media 設定將會增加開發及管理的困難度。 Material Design 中的暗色、亮色切換範例，兩者的主色（紫色）在不同的主題下色彩也會改變。 因此，在開發時可以將暗色、亮色的佈景主題色彩以 CSS 變數的方式作定義，避免直接將色彩寫入 CSS 元素上，接下來在 @media 中僅需要改變 CSS 的變數就能夠完整切換所有元件的主題色彩。 .card &#123; --theme-primary: #6222ee; --theme-background: #eee; &#125; .card &#123; /* ... */ background-color: var(--theme-background); color: var(--theme-primary); &#125; @media (prefers-color-scheme: dark) &#123; .card &#123; --theme-primary: #bb85fc; --theme-background: #111; &#125; &#125; .card { --theme-primary: #6222ee; --theme-background: #eee; } .card { margin: 0 auto; padding: 15px; text-align: center; max-width: 320px; border-radius: 3px; border: 1px solid #777; background-color: var(--theme-background); color: var(--theme-primary); } @media (prefers-color-scheme: dark) { .card { --theme-primary: #bb85fc; --theme-background: #111; } } 本卡片會隨著暗色與亮色主題切換 本文中還有利用到 CSS Variables，有興趣可參閱本篇文「原生 CSS 變數運用技巧（CSS Variables）」。 設計規範目前在 Apple 及 Material Design 中也都有針對亮色、暗色的佈景主題提供規範，在完整投入之前，也不妨先參考看看。 Material Design Material Design：https://design.google/library/material-design-dark-theme/ Apple Mac：https://developer.apple.com/design/human-interface-guidelines/macos/visual-design/dark-mode/ iOS：https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"develop","slug":"develop","permalink":"https://wcc723.github.io/tags/develop/"}]},{"title":"一分鐘切換成中文版 VSCode（完整圖文版）","slug":"vscode-chinese","date":"2019-11-30T16:00:00.000Z","updated":"2020-10-17T02:14:54.011Z","comments":true,"path":"development/2019/12/01/vscode-chinese/","link":"","permalink":"https://wcc723.github.io/development/2019/12/01/vscode-chinese/","excerpt":"","text":"雖然開發者都具有一定的英文閱讀能力，但如果在不熟悉的情況下，就比較難以快速上手一個新工具。如果要快速掌握一個完整的工具或技術，最好的方式還是先切換成熟悉的語言。 而 VSCode 雖然預設並無法直接切換語系，但官方有提供各國的語言套件，讓開發者可以自行選用。 切換成中文版如果你對於 VSCode 有興趣，別因為 VSCode 預設開啟是英文版就急著關閉，預設雖然是使用英文版，也找不到語系切換的地方，但其實官方有提供中文版的套件安裝（為了讓 VSCode 輕量化，語系需要另外安裝）。 畫面的左方功能列表中，可以找到 Extensions，點選後輸入 “Chinese” 即可搜尋到中文的相關語系，選擇中文（繁體）後頁面的右方即會出現相關介紹，此時按下 “Install” 就會安裝中文語系套件。 安裝後系統會自動跳出是否切換成該語系，按下 Yes 後就會套用成中文版囉～ 不過人生中最怕的就是那個 “But”，如果沒有自動跳出右下方的提示該如何切換呢？另外 VSCode 如果更新時，可能也會再次切換為英文版，這時候就需要手動切換語系。 手動切換流程也並不複雜，可使用以下三個步驟手動切換 按下 ctrl + shift + P（Mac 版請按下 cmd + shift + P） 輸入 display language 就會跳出 “Configure Display Language” 選擇安裝的語系 “zh-tw” 即可安裝 以下附上影片供參考","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://wcc723.github.io/tags/develop/"},{"name":"vscode","slug":"vscode","permalink":"https://wcc723.github.io/tags/vscode/"}]},{"title":"十分鐘快速掌握 Markdown","slug":"ten-mins-learn-markdown","date":"2019-11-22T16:00:00.000Z","updated":"2019-11-23T03:35:10.315Z","comments":true,"path":"development/2019/11/23/ten-mins-learn-markdown/","link":"","permalink":"https://wcc723.github.io/development/2019/11/23/ten-mins-learn-markdown/","excerpt":"","text":"Markdown 是目前非常普遍用來撰寫文檔的語言，一開始的目標就是使用「易讀易寫的純文字格式編寫文件」，此初衷讓使用者可以專注在文字的本身，而不需要透過其它工具來切換格式。以 Word 撰寫文檔來說，就必須透過上方的工具列來切換標題、列表、粗體、斜體等等；而 Markdown 並沒有這樣的工具列，完全都是使用標示符號來完成這些需求。 常見應用大部分情況下 Markdown 是用來撰寫程式語言相關的文檔，因為純文字的特性與程式碼一致，且可搭配標示符號來改變呈現格式，像是在 Github 的文件中使用 readme.md 的 Markdown 格式，則會預設作為該儲存庫的介紹。 除了軟體開發以外，目前也越來越多的服務加入了 Markdown 的編寫支援，與文字傳達有關聯性的都慢慢加入其中的語法，像是筆記工具、文字通訊、部落格等等都有這類影子，如 Bear note 就是完全使用 Markdown 的筆記工具、Slack 則是支援部分的文字訊息、Hexo 則是透過 Markdown 撰寫的部落格工具；除此之外，現在 Facebook 發文也可以使用此格式來撰寫文章（目前是限定社團才能使用）。 現在台灣主流的通訊工具 LINE，也可以透過部分的 Markdown 語法來傳遞程式碼或是調整文字格式（電腦版限定）。 學習 Markdown基本概念：Markdown 可以輸出成 HTML 的格式，所以各種標示也會對應 HTML 的標籤，就顯示的結構上可區分為兩大類：區塊、行內。 區塊：此類別會讓內容獨立形成一個區塊，區塊內的 全部文字都是套用同樣的格式，標題、引用、清單都是屬於此類型，而區塊可以疊加使用，如引用內可以包含標題。 行內：套用此類別的內容可插入於區塊內，如：強調文字、斜體字、文字連結等等，要特別注意插入圖片也是屬於此類別（與 HTML 特性相符合）。 以 Word 的概念來介紹，區塊元素表示文字整段都是同樣的風格、層級（洋紅色標示），而行內元素則是在區塊的文字上做修飾（綠色標示）。 除了以上兩點以外，每個 Markdown 環境所能接受的語法都略有不同，像是部分工具、環境雖然接受使用 Markdown 撰寫，但標題上只接受三個以下的層級（正確為六個層級），所以實際上還是需以運行的環境為主，而本篇介紹的則是介紹通用的使用方式。 區塊元素此類別會讓內容獨立形成一個區塊，區塊內的 全部文字都是套用同樣的格式，標題、引用、清單都是屬於此類型，而區塊可以疊加使用，如引用內可以包含標題。 標題總共分為六個層級，依據 HTML 的結構會轉為 &lt;h1&gt; ~ &lt;h6&gt;，形式上是在文字前方補上不同數量的 #，# 數量越少層級越高，反之則是越低，以下方結構來說 # 標題 1 是層級最高，且視覺上最大的標題。 # 標題 1 ## 標題 2 ... ###### 標題 6 呈現結果（以下為 Bear note 的範例） 文字段落當沒有加上任何標示符號時，該區塊的文字就是文字段落區塊，而段落與段落之間會保留一行空白空間，在接下一段的內容。 ## 這是標題 這是一段文字段落 這是第二行的文字段落，還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 實際運作範例：標題、內文 這是標題 這是一段文字段落 這是第二行的文字段落，還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 引用引用的寫法與樣式都類似於 Email 中的回文原文，只要在文章前面補上 &gt; 的符號即可。 &gt; 這裡是一段引用文字 實際運作範例：引用文字 這裡是一段引用文字 部分文件提到：引用文字不僅可以單獨使用，也可以混用其他的區塊元素，或者透過多個 &gt; 來調整層級。但要特別注意，並非所有的 Markdown 環境都支援多個層級的寫法，許多環境僅能單獨使用 &gt;， 清單清單分為一般列表及包含數字符號的列表，兩種都包含多個層級，只要加上一個縮排或兩個空格就可以新增一個層級。 一般列表的使用彈性較高，-、+、* 等符號後方加上一個空白後都可以轉為列表，要表示下一個層級可多一個縮排或是兩個空白即可。 - 這是清單 + 這也是清單 * 這同樣是清單 - 清單子項目 實際運作範例：一般列表 這是清單 這也是清單 這同樣是清單 清單子項目 包含數字符號的列表則是使用 數字 + .作為開頭，列表中的第一個數字是數字列表的起始序號，而後方的數字不需要按照順序，如：1. 2. 2. 結果依然會是 1. 2. 3.；另外縮排的規則與一般列表相同。 1. 數字型清單 2. 第二個數字清單 2. 數字清單不需要連續數字 3. 數字清單子項目 後方的數字不需要按照順序。 2. 數字清單從 2 開始 3. 第 3 實際運作範例：數字列表（數字 3 開始） 數字型清單 第二個數字清單 數字清單不需要連續數字 數字清單子項目 如果段落文字需要以數字 + . 作為開頭，可以改為 數字 + 反斜線 + .，範例如下。 2019\\. 避免 `數字.` 轉為數字型清單的方法 區塊程式碼作為許多開發者撰寫文本的工具，插入程式碼片段也是合情合理的。Markdown 中會使用三個連續的反引號（`）開頭及結尾做為區塊的程式碼，並且可以在首行的位置補上該段程式碼的語言類別，藉此輸出具有 Highlight 的程式碼。 三個連續的反引號（`）用在開頭結尾，即可作為區塊程式碼。 首行補上特定程式碼語言名稱，該段可使用特定語言的 Highlight （依據輸出的環境而定），以下圖為例則是使用 js 或 javascript。 for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log(&#x27;這執行第&#x27; + i + &#x27;次&#x27;); &#125;, 0); &#125; 當輸出為 html 時，該段落並不會被瀏覽器作為標籤渲染，而是呈現可被使用者閱讀的程式碼。 &lt;body&gt; &lt;p&gt;這是一段 HTML 結構&lt;/p&gt; &lt;/body&gt; 分隔線分隔線，可以使用三個連續符號表示（-、*，部分環境亦可使用 _） --- *** ___ 實際運作範例：分隔線 表格雖然 Markdown 有提供表格的符號，但實際運用上並不是很方便，如果環境許可我大多會直接使用 HTML 的表格標籤替代 Markdown 的表格。Markdown 的表個就像是使用符號 “畫” 一個表格，實際撰寫時對其很麻煩。 下圖為表格的範例。 | thead 1 | thrad 2 | thread 3 | |---------|---------|----------| | td | td | td | 實際運作範例：表格 thead 1 thrad 2 thread 3 td td td 行內元素套用此類別的內容可插入於區塊內，如：強調文字、斜體字、文字連結等等，要特別注意插入圖片也是屬於此類別（與 HTML 特性相符合）。 斜體斜體字與強調文字使用上是很接近的，可以使用 * 或 _ 符號套用在文字的前後方，即可將文字改為斜體字；而將 * 或 _ 使用連續兩個加在文字的前後方則會是強調文字。 以下為斜體文字的範例，另外在 * 或 _ 的前後補上空白會維持原本的符號，就不會套用斜體效果。 還是要*勉強自己*，笑起來處子般通紅；看人_突然好想你_，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。* 普通文字 *。 實際運作範例：斜體 還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 普通文字 。 強調以下為強調文字的範例，使用兩個 * 或 _套用在文字的前後方 。** 或 __ 的前後補上空白會維持原本的符號，一樣不會套用強調效果。 還是要**勉強自己**，笑起來處子般通紅；看人__突然好想你__，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。** 普通文字 **。 實際運作範例：強調 還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 普通文字 。 行內程式碼與區塊程式碼一樣使用反引號，在此改為單一個反引號加在文字的前後方即可。 還是要勉強自己，笑起來處子般通紅；看人 `&lt;strong&gt;` 突然好想你 `&lt;/strong&gt;`，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣 `var a = 0`。 實際運作範例：行內程式碼 還是要勉強自己，笑起來處子般通紅；看人 &lt;strong&gt; 突然好想你 &lt;/strong&gt;，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣 var a = 0。 連結連結的結構略有不同，會分為前後兩個片段符號： 前者為 [ ]：中括號內需要補上連結的顯示文字。 後者為 ( )：小括號內補上的是連結路徑。 以下為連結範例：Google [Google](https://www.google.com.tw/) 圖片圖片要特別注意是屬於行內元素，因此圖片也可以放在文字段落之中（與 HTML 中的 img 標籤邏輯一致），不過大多情況下會將圖片作為獨立區塊使用。 圖片也與連結結構接近，只不過前方多了 !。 ![ ]：與連結結構接近，但前方緊貼著 ! 符號。中括號的內容也並非必填，其文字內容通常作為 hover 後的提示文字或作為 SEO 增強使用。 ( )：圖片連結位置。 ![unsplash 圖片](https://images.unsplash.com/photo-1573900941478-7cc800f708f3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2100&amp;q=80) 實際運作範例：圖片 參考文章： https://markdown.tw","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://wcc723.github.io/tags/markdown/"},{"name":"develop","slug":"develop","permalink":"https://wcc723.github.io/tags/develop/"}]},{"title":"鐵人賽：獲利優先，將你的資金塊狀化","slug":"block-your-money","date":"2019-09-26T16:00:00.000Z","updated":"2019-09-26T23:24:41.859Z","comments":true,"path":"ironman/2019/09/27/block-your-money/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/27/block-your-money/","excerpt":"","text":"獲利優先的概念是來自於這本書：https://www.books.com.tw/products/0010794087 此書是在介紹公司的資金管理方式，大多數新創公司管理人，容易在資金上升後喪失對金錢的敏感度，導致支出費用過高，收入不敷支出使用而使公司倒閉，這個狀況不僅會出現在公司上，家庭中大數目的資金運用時都很容易忽略掉細節。 這會導致： 跳巢加薪才 3000 ，下個月就多花 6000 高金額的費用沒有注意細向花費 月底還以為剩錢，結果在領薪水前透支了 預支未來的資金做運用 （提早透支，真正拿到資金時卻又不夠，只好再次預支 第一次投資就失敗（投入數字過高，導致恐懼心理容易認賠出場 資金塊狀化為了維持對於金錢的敏感度，書中提供了「資金塊狀化」的概念，簡單來說 10,000 數目看似很大，但如果拆成 2,000 來看就簡單很多，如果把每個花費都用 2,000 做拆分在花費上就容易更警慎，用一個小故事來介紹這個概念。 | 小朋友們參加幼稚園的活動，活動中有一塊大蛋糕，兩三個小朋友就想直接用湯匙挖來吃，想說一起吃一個大蛋糕是可以吃完的，但小朋友們其實沒有辦法掌握自己的食量，加上這麼大的蛋糕容易產生誤判。因此老師看到急忙阻止，因為很清楚這幾個小朋友是吃不完的，接下來老師將大蛋糕一一的切小，每個小朋友都分發到了切片小蛋糕，就能大概感受到這是平常爸爸媽媽切好給他的份量。 不知道大家是否有相同經驗，訂購一大份蛋糕、烤雞、合菜都曾經錯估合適的用餐人數，不是過多就是過少，但一一分盤以後，用餐人數的掌握度就會提高。 金錢的掌握也是同樣的概念，從學生時代的消費都是 50 ~ 100 做計算，長時間下來對於百元上下的費用掌握度提高，出可支配費用上升，但對於上千、上萬的金額敏感度卻沒有因此而提升，沒有足夠經驗的情況，就常常會錯估花費的金額。我們對於小數目的費用已經有數年的經驗，累積下來也有上千、上萬次，但在萬元以上的運用卻僅有數十次到數百次，所以經常容易錯估費用導致額外的花費 用盤子分裝你的存款先前的章節介紹到花費基本上可以分為 固定、生活、變動三大類，收入的分配也可以做這種方式有些銀行提供子帳戶的服務，就可將預先將錢分配到不同的帳戶上。經過每月的紀錄，也可抓出這幾個類別在通常需要花費多少；也就像是將食物分盤的概念一樣，集中、大量的食物、金錢我們難以去估算份量。 透過拆分的方式將需要花費的預先保留，以供當月使用，最後再將一部份百分比的費用預先留存（如：每個月另外留下 20% 收入），以薪資五萬為例，結構如下： 固定花費 35%：17,500 生活費 10%：10,000 變動花費 10%：10,000 保留存款 45%：22,500 每個人的收入、支出大不相同，可依據自己的帳務統計來規劃合適的盤子，使用這種方式更能控制即將花費的項目，也能藉此慢慢的增加存款以供未來投資使用。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：有土斯有財？還是緊握著負債","slug":"buy-a-house","date":"2019-09-25T16:00:00.000Z","updated":"2019-09-26T07:32:16.488Z","comments":true,"path":"ironman/2019/09/26/buy-a-house/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/26/buy-a-house/","excerpt":"","text":"傳統觀念中有土斯有財，不斷的鼓勵大家去擁有自己的土地、住宅，出社會後也會有許多長輩洗腦「該擁有屬於自己的房子」。但在臺北這樣高房價的地區，許多人買了第一間房後就長期背著負債，「窮爸爸、富爸爸」一書中提到「自用住宅即是負債」，雖然房子也是資產的一種，但資產是可以脫手轉為現金的，第一間房是否可以轉為現金呢？還是在房貸的壓力下產生難以轉移的問題。 開始工作幾年以後，到許多同輩開始擁有屬於自己房子，有些人有部分長輩資助，也有些人靠自己買了千萬豪宅，但要特別注意自己是否能夠負擔，如果你和我一樣是沒有長輩資助，全額靠自己的可聽聽以下建議。 買房的負債，以不影響生活為前提當然，每個人都會老，老人不太可能在以租屋為前提尋找住所，以目前的社會環境來說會避免租用房子給年長者，為避免額外的延伸問題，大多還是租給年輕學生、小家庭為主，所以長期下來還是需要規劃屬於自己的自住宅。而購買房子時都會有一筆不小貸款，對於貸款有以下的建議： 確保手中現金至少可維持一年的還款費用意外總是來的像龍捲風，如被資遣、家中事故、個人因傷無法工作等等…，這都會造成短期的資金不足，許多文章建議每月還款金額低於家庭收入 35%，我自己則是建議更低於此值 (看地區而定)。別忘了，自住宅就是負債，負債當無法轉正（無法脫手）就永遠是負債， 所以除了每月還款外，自己依然要有留存一定的錢財作為風險控制及投資使用，這是意外發生時無法還款，以及讓自己資產有辦法成長，並在未來能夠將當前房屋脫手使用。 每月還款避免超過租金行情租不如買，前提要是買比租還划算，以天龍國內湖的公寓輕鬆突破 1500 萬來說，每月還款約落在 42,000，但平均租金則是 30k+，目前來說台北的房價成長趨緩，如果以往後想要脫手 (或租人) 都會具有風險。 每月還款不影響生活水平上一篇有介紹分裝你的費用，頭期款 + 每月還款 將是一筆不小的數目，如果因此壓縮生活品質，會讓人的情緒進入負面的循環，無法出國玩、無法買自己想要的東西、買任何東西都要斤斤計較，加上時程長達二三十年(大概就是自己人生長度了!?)，相信大家不想過著長期被房貸綁架的日子。 也想想你住的是哪一區上面的項目列出後，是不是發現似乎沒房好買了呢？ 想要買房不是看房價，而是看自己的還款能力，天龍國自然具有高競爭力、高房價；許多買房者最終被房貸壓垮，就是選擇高房價的地區且錯估自己的還款能力，但並非全台灣都是天龍價，如果你的薪資只有雞蛋等級，就別試著去接巨石等級的房價，買房是長期的規劃，全台灣那麼大，雞蛋等級的薪資也會有適合的巢可以放置。 買房的最終目的是賣出如果要避免房子就是負債，那就需要確保手中的房子是可以脫手的，傳統觀念買房都是為了自住，出售則是次要目標；但如果將者兩者對調思維結果將會大不同，如果是為了售出優先自住為次要需求時： 地點優先而不是屋齡 具有成長性的區域，不會挑選毫無成長力的區域 會逐一挑選有價值的物件，而不會急於一時 當觀念改變後，選擇也會大不同。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：超簡易記帳 - 輕鬆規劃你的理財目標","slug":"how-to-accounting","date":"2019-09-24T16:00:00.000Z","updated":"2019-09-25T07:53:27.758Z","comments":true,"path":"ironman/2019/09/25/how-to-accounting/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/25/how-to-accounting/","excerpt":"","text":"前一篇介紹到退休所需要的資金是兩千萬，雖然這是大部分 “投資廣告” 所提出的金額，但這個金額確切是如何計算出來的呢？這個金額與每個人的花費習慣有很大的關係，兩千萬則是大部分人計算出來的結果，大家也可以用以下方法試著估算一下自己的每月花費，再用每月花費來估算 “年花費”。 目前大部分人類都可以活到 9x 歲來說，從 60 歲退休到 9x 約有 30 年時間，年花費 * 30 就是退休所需的基本金額。 經常錯估的金額沒有記帳習慣的人來說，“年花費” 是很容易低估的，因為我們總是會忘記把錢花去哪邊，翻開銀行的交易紀錄，看著上個月或上上個月，總有許多想不起來的大筆支出。因此，記帳將會是預估年花費一個很重要的方法。年花費大多來說也會逐年提高，隨著家庭人員增加、年紀的增長，透過記帳更能了解消費習慣的改變。 簡單的記帳方法雖然現在有許多記帳軟體，可以記錄到細微的花費，如早餐、交通、點心等等。但記帳最重要的是區分 “固定花費” 及 “變動花費”，每日的餐點、下午茶、點心，甚至是搭車繞了遠路不需要記得那麼細，這麼細微的紀錄會額外花費許多精力，只要錯過幾次就容易導致放棄。 在此與大家介紹一下我的記帳模式，每月可只記錄兩次（次數越少，越不會因為一次的遺漏導致放棄），紀錄上也僅要針對主要費用做紀錄即可，不需要過度細節。 固定花費我們每月都有必備需要支出的項目： 水電、房租、房貸、瓦斯費、電話費 保險費 孝親費 及其它每月落差不大的支出費用 這些費用每月都需要且數目變動不大，可預先列出固定欄位來記錄這些品項。 生活費生活費包含：吃、喝、交通等大部分用小額現金的費用。雖然每天飲食不同、交通方式略有改變，但其實每月的生活費其實差異不大，與其一一的紀錄這些花費品項，不如使用一個固定小錢包來支付這些費用，因此每次提款進入小錢包時，就可以了解生活費的使用狀況，記帳時僅需紀錄提款的時間點、額度就可算出生活費的概略值。(每月幾百元以下的誤差可忽略) 變動花費生在江湖，推坑、聚餐、出國玩樂在所難免，因此包含： 卡費（依據品項分類） 聚餐費用 玩樂費用 奢侈品 意外費用 服務訂閱費用（雲服務、iCloud、Adobe 服務…，可以使用年計算） 非固定的大金額支出 預先訂一個額度（如 2000 元），如果不是每月都需要支付的，只要超過就屬於變動花費，因此實際上需要另外紀錄的也是此項目。記帳時，翻開你的信用卡消費記錄或是另外透過工具紀錄這些消費，就可以知道實際的高額消費情況。 下圖是幾年前我實際紀錄的表格，可以算出每月最終的餘額，非固定支出部分也都有註解說明品項，每月紀錄兩次即可。 有了以上帳目之後，你可以了解到： 多少錢是你的最低需求（固定花費 + 生活費） 哪些費用是可以節省的（變動花費的特定項目檢視） 一年多少錢，你可以過的還不錯 (固定花費 + 生活費 + 變動花費) 一年兩千萬的退休金也就是大多數人的 固定花費 + 生活費 + 變動花費 總和（約每年 60 萬），乘上 30 年的結果，平均則會落在 1800 ~ 2000 萬之間。 透過記帳，可以真正認識自己的消費習慣，能夠了解每年可動用的金額是多少，預先規劃出幾年的投資計劃，並且預先推算退休所需的費用，藉此設計出屬於個人的投資方式。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：iPhone 11 Pro Max 心得文","slug":"iphone-11","date":"2019-09-23T16:00:00.000Z","updated":"2019-09-24T04:07:31.217Z","comments":true,"path":"ironman/2019/09/24/iphone-11/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/24/iphone-11/","excerpt":"","text":"參加個人挑戰的好處，就是可以隨意的歪樓！？ 最近入手了三眼神童 iPhone 11 Pro Max，在這支手機上是好幾個月前就已經打算入手，與這台本身的特性沒有什麼關係，會購買主要原因是一般的 LCD 手機螢幕只要看 5 分鐘就會開始頭暈，也因為如此，一天觀看手機的時間平均是不超過 30 分鐘的（不清楚原因，目前僅了解對於要專注細微的發光體會感到不適）；看過 OLED 後發現可以減輕看螢幕的不適，加上家中老母希望可以換一台手機，所以就適順勢換一台手機了。 我：「要 Android 的還是要我用過的 iPhone？」 老母：「iPhone」 我：「iPhone 二手的，確定？」 老母：「我要 iPhone」 所以就只好順勢換一台手機，把舊的 iPhone 給老母。另外 OLED 也並非蘋果專利，看到 Pixel 系列也是有些興趣，但不得不說蘋果近幾年除了 iPhone 以外，更重視整個生態系，例如： 蘋果系統下的 iCloud 對於相關產品的支援度很高，加上老婆手機儲存空間不足時，可以直接升級成家庭版的 iCloud，費用不高也方便。 各裝置的整合性，如 iPhone 所接到的電話可以使用 Mac 接聽，Mac 複製的連結可以直接貼到 iPhone 上（直接開啟也沒有問題）。 與其它的裝置便利性，AirDrop 可以直接丟檔案可其它人，AirPlay 可以不接線直接投影畫面等等。 而這些功能就會讓習慣 iPhone 的人在轉移上有所顧慮，綜合以上所述，反正我就是買了一台 iPhone。 我選擇的是金色的 iPhone，雖然這次主打的是新色彩夜幕綠，但我對於深色並沒有特別的愛好，所以還是從亮色系做選擇（金或銀），當然兩者都不錯，後來選擇略有些變化的金色。 11 Pro Max 的優缺點這次的 iPhone 主打特色就是三眼神童，具有超級強的相機，在官網的介紹中可以發現三眼相機介紹佔了將近 2/3 的篇幅，這幾天並沒有拍相當多的照片，但還是可以略感受到它與前幾代的差異，如： 色彩更討喜：這點我認為是最大的改動，雖然 iPhone 一直給人稱讚的是接近原色的表現，但原色不一定是討喜的色彩，這方面在韓國、中國的手機可以感到很大的優勢，而這次的 iPhone 依然與原色接近，但同時更能呈現豐富的變化色彩在其中，讓畫面更為討喜。 暗處表現更好：AI 的運算已經讓暗處不受相機感光的限制，而三眼童子結合 AI 自然能有更優的表現。 長距離拍攝依然清晰：多一個長鏡頭當然會更好 拿到手機後帶著女兒去草衙道，但是她幾乎從頭哭到尾，只有在晚上的時候才能好好的拍一張照片，雖然畫面上所提供的是室外照片，但不得不說這次在室內的日光燈下也有很好的調整，讓膚色不會像過往一樣偏綠，看起來會更討喜。 這次的相機加入了長時間曝光，這對於習慣使用單眼的拍照者來說多了更多成像手法，雖然如此，對於手抖者來說，透過 AI 的輔助夜景也依然清晰。 除了相機以外，再說說從 iPhone 8 替換成 11 Pro 的一些感想： 優點： OLED 螢幕：這是換這台手機的主因，搭配深色主題讓畫面呈現對我沒那麼刺眼，使用來說可以比以往有更長一點的時間（恩，就長一點，大概兩倍吧，所以適十分鐘）；不過官方說的螢幕可以呈現更亮這對我來說就沒什麼興趣了 ～＿～。 深色主題：結合上述優勢，自然能讓眼睛能夠更為舒適，且現在許多 APP 也開始加入深色模式，使用上也比較不會疲勞（OLED 在黑色部分是不發光的）。 刷臉：真的挺方便的，臨時 LINE 的訊息喵一眼就能看到。 三眼神童：很厲害，但沒仔細用的拍照功能，有機會會希望多些嘗試，讓我回到文青的年代（有那個年代過嗎）。 還沒看過的 Apple TV+ 這台也並非沒有缺點，其中 3D Touch 的移除是最難過也是最不爽的，在先前的版本 3D Touch 很適合用來看 LINE 的訊息，而且不會變成已讀的狀態，這就很適合用來看老婆傳來的訊息（x）；現在改了一個爛名字，找個爛藉口來取代本來的優點，更不爽的是 Macbook 的 Touchbar 更沒有用，卻不找個機會將它給移除。 現在只希望 LINE 能夠透過長點擊來開啟訊息，讓訊息不會變成已讀 :(。 另外也由於 Home 鍵的移除，許多操作就與原本略有不同，像是 Apple Pay 的啟用改為右側按鈕點擊兩下，這也讓付款的時候一時不知道怎麼使用，還好店員遇過類似問題立馬解決我的困惑。 目前入手還沒有幾天，加上使用時間並不長，有機會希望可以補上更多的介紹。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：從哪邊學習投資？","slug":"where-to-learn","date":"2019-09-22T16:00:00.000Z","updated":"2019-09-23T08:55:18.947Z","comments":true,"path":"ironman/2019/09/23/where-to-learn/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/23/where-to-learn/","excerpt":"","text":"在開始學習投資以前，我心裡是牴觸的，主要原因是不了解，認為這是高度風險的財富管理方式。身邊也有許多人對於投資不熟也會有這樣的疑惑： 聽說買股票的人都賠錢誒 &gt; 如果都賠錢怎麼會那麼多人投入 是不是要很多錢才能開始學投資啊 &gt; 是投資才有錢，不是有錢才投資 那是內線的人玩的，我們這種局外人玩不起 &gt; 真正好的股票不是少數人決定的 這些疑惑其實是來自於自身恐懼心理造成的，各種優點將會被忽略不見，而將細微的點不斷放大。 正確的投資來說，只要掌握少量的幾檔好投資標的，不斷的長期持有就可以致富，以 GoodInfo 這個網站來說可以填入股票名稱，下方就會列出這張股票 每月、每季、半年、年、三年、十年的成長紀錄，在此可以試著輸入認識的股票名稱，就可以看到這些股票的成長狀態，以近年來大家都認識的台積電來說，三年的成長幅度也有 47% (2019/9/9 的資料)，意指投入 100 萬，三年後如果賣出至少有 147 萬，另外還有每年的股利可領取。 上面僅是列出公開的數據，更重要的是如何選擇一個投資標的，無論選擇的是海內外股票、債券、基金等等，在沒有任何經驗之前，都需要一名導師來帶領我們進入這個領域，選擇導師的重點： 產生連結 選擇導師時，盡可能選擇能與其產生連結的導師，無論是家人、朋友、同事，因為投資過程中是非常漫長的，許多問題都是在操作的過程中才會出現，在遇到問題時能夠詢問「導師」會增加你持有的信心，避免在正確的機會下做出錯誤的操作。 信任 信任再投資中是非常重要的，為何選擇一檔股票都是可以用「信任」這個詞來說明，在與任何導師進行學習時，會有產生不斷的溝通對答，如果你無法信任這名導師的教導，就別繼續與這名導師學習，因為不信任也會使操作投資時的信心動搖，無法具有長期持有的信心，容易在投資目標短期下跌時就出手導致賠錢。 獲利經驗 上方我提出了持有台積電三年可成長 47%，這句話具有很大的錯誤，真正的投資獲利來自於兩個步驟，一是從購買到賣出中間的價差；二則是持有時間的利息。因此，除了股利以外，如果沒有賣出就無法賺到那個 47%，而且大多數人看到股票成長時都會繼續持有，下跌時賣出，許多老鳥也會說到：股票中最困難的判斷是「何時賣出」。所以找的導師不僅要教如何買，更要教你怎麼賣！ 哪邊可以找到投資的導師呢？每個人的背景不同，適合的方式也不同： 工作場所這是我主要學習投資的地方，也很幸運讓我有機會糾正錯誤的財務觀念，當學到一定程度以後，也從中了解到什麼是財富自由，且財富自由並沒有那麼困難。 並非所有的工作環境都會有擅長投資的同事，依據產業的不同，每個工作者所具有的次要幾能也會不同，有些擅長交際、有些則擅長交易。因此要尋找擅長投資的同事，可以從百大企業、金融體系、具規模的傳產、公教體系這些尋找，因為這些員工普遍來說收入穩定 (不太會換工作) 且具有一定資金 (有一定年資)，所以比較會投資股票。 專門的講師去除上面兩種，如果還是無緣接觸，則可以試著去尋找專門的講師，專門的講師具有一定經驗，且會為了課程專門設計教材，在學習上自然會更有成效。但要特別注意，講師相對來說難以產生連結，除了學習外一定要從過程中與人再次產生連結 (講師或其他學員)，這樣在實際操作的過程中才能解除疑惑，更能降低投資失敗的機率 (投資只要降低失敗就能穩定成長)。 家庭如果家族中有人擅長投資，尤其是自己的父母，從他們開始學習最好，因為他們是最能夠直接產生連結與信任的導師。大部分的家庭都是不斷地述說金錢的可惡，但卻沒有教導正確的理財觀念，導致窮不只窮一代，還窮了好幾代，這不僅是物質上的窮，更是心態上的貧窮(因為恐懼而不學習)。 這也是出社會以後的體悟，因此也很欣賞將理財經驗傳授給自己子女的家長，而不是避而不談相關的財務概念。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：充滿未來希望的成長公式","slug":"hope","date":"2019-09-21T16:00:00.000Z","updated":"2019-09-22T08:40:42.452Z","comments":true,"path":"ironman/2019/09/22/hope/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/22/hope/","excerpt":"","text":"當初花了大量的時間不斷充實自己能力，目的就是可以能拿到更好的收入，雖然薪資也如預期的不斷成長，但是心中還是有一個結沒有解開，以台灣來說，每個人退休所需要的資金約是兩千萬，在薪資成長的幅度下，就算不吃不喝達到目標還是非常的困難。 主計處所提供的網站來說，研究所畢業生年收入在 100 萬也算是接近中位數，而 100 萬實際要存下來的錢並不多，以一般大部分人的年支出約落在六十萬的情況下，實際能存下的約四十萬，以不買房地產的情況下至少要存 50 年，更別說要買房或者薪資未達中位數的。 https://earnings.dgbas.gov.tw/experience_sub_01.aspx 而這個問題，在我進入鴻海後有很大的轉變，還記得有一天主管問我，認為要工作到幾歲時退休呢？ 我很天真的回覆：「應該是需要工作到老吧」 他很認真的回覆：「為了錢工作一輩子這個思維是不對的」 也就持續跟我說明理財的重要性，還記得剛開始的前幾年我無法接受他這個思想，認為「不工作就有錢」是有錢人才有可能達到的，而在這個大企業下，可以認識許多對於財務管理有一定掌握的人。因此那幾年，除了眼界有很大的不同外，對於理財的觀念也有很大的增長，也對於這些觀念慢慢有所改觀，也在此學到不同的理財觀念，並整合成屬於自己的投資模式。 透過理財觀念，大幅降低難度以下說明很容易理解的概念，假設我們每年能夠存下的款項是 30 萬，如果持續 20 年不中斷則可以存到 600 萬；但如果透過股票或各種形式的投資 (每年 7% 的成長率)，一樣每年投入 30 萬約 14 年就可以達到 600 萬（到此投入才 420 萬），而 20 年後則有機會可以達到 1200 萬（投入 600 萬），這樣的數值是單純存款的兩倍（注意，這是極度理想化的數值，實際上還是依據每個人的投資選擇而定）。 公式參考：https://docs.google.com/spreadsheets/d/1YosXnSu3nguHuQEpJ9xpdVbD3V1x1pPKFSH37eeSjzM/edit#gid=1444089297 除此之外，如果是每年 7% 的成長率，每七年則會翻倍一次。 意指，上述的資金在 20 年後沒有再持續投入，則會在第 27 年到達 2400 萬（成本依然是 600 萬）。沒有學會投資理財的觀念，很難想像如何存到退休所需要的資金，而且沒有正確的理財觀念，縱使獲得了 2000 萬也很難妥善管理。 而是否是在真的有足夠收入時才思考投資呢？絕對不是，金錢投資是要在平時就要慢慢培養觀念，資金的成長不是立即性的（有，也通常輪不到大部分人），透過平時的累積觀念，才能在機會來臨時正確出手。但大多人會忽略這段期間的理財觀念培養，當有足夠資金時，想嘗試投資時又無法掌握大數字的精準度，也就因此會常聽到新手投入股市失敗，卻又不敢再次投入的故事。 https://github.com/xiaolai/regular-investing-in-box 李孝來：投资，是我能找到的唯一一个普通人可以跨越阶层的通路 跨越階層的方式非常多，創業、中樂頭、理財投資等等方法非常多。撇除中樂透的低機率以外，創業也是一種方式，但創業的成功率極低，根據經濟部中小企業處統計，公司成立一年內倒閉的機率高達 90%，相對來說投資理財是成功率更高的，但並非每個人都有機會可以接觸到合適的理財導師。因此，不斷的學習成長是非常重要的，在增加物質上資產的同時，也增加思維上的資產，讓自己更能接觸到符合自己的理財導師。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：樂觀、悲觀 - 財務的思維改變","slug":"poverty","date":"2019-09-20T16:00:00.000Z","updated":"2019-09-21T06:13:04.234Z","comments":true,"path":"ironman/2019/09/21/poverty/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/21/poverty/","excerpt":"","text":"出社會以前，因為對於市場的不理解，所以有許多「天真」的用詞，也因為這個天真過去還認為自己挺樂觀的，曾經認為窮人與富人差異沒有那麼大，許多故事都告訴我們窮人也能翻身。 但出了社會才瞭解故事只是故事，那並非容易的事情。 小故事： 舉個例子，一個不靠家中努力向上的青年，每天早出晚歸，年收入約落在 120 萬的情況下，除了生活費、卡費、孝親費等每年亦能存下 60 萬（實際上收入越高，支出也會越高），後來看收入不錯就買了台北市一間公寓價值 1500 萬，（貸款 1200 萬情況下，每月約四萬的房貸，每年的支出增加 48 萬），接下來的每年的存款剩餘 12 萬。 而另一位家境小康的朋友雖然不算挺有錢，但家中資助一間台北市公寓，雖不算認真，但吃住都在家中費用省下許多，年收入 80 的情況下，因為沒有孝親費及房貸每年存款依然有 50 萬，加上家中從小就幫小孩存上基金、股票，每年還有十幾萬可領，另外還有持續增加的資產。這樣穩健的基礎下，再不背負房貸的情況下資產輕鬆超越「努力向上的青年」，加上家中持續灌輸基本的理財觀念，所以長期下來也是不愁吃穿。 上述故事可以了解到家庭背景對於新鮮人的影響，更何況出了社會，就要認真面對 “收入” 這個問題，除了要能夠養活當前的自己外，也同時需要為了 “未來“ 以及 ”風險“ 做準備，一個人老年約需要的資金約是兩千萬，而風險更是不確定性，除了自身的風險外，更大一部份來自於長輩的風險（年紀大自然容易遇到不確定性的意外），這些風險可能會讓我們短時間內沒有收入，並且面臨許多親情與現時兩難的問題。 從自以為的樂觀到悲觀問題不斷的湧出後，每天都在思考該怎麼面對這些困境，每當越思考就會越難過、越悲觀，這是一面難以跨越的牆，並非無法做到，只是一時找不到解法，卻不曉得這個問題讓曾經自以為樂觀的自己，慢慢的散佈出悲傷的情緒到周圍的人身上，直到有人對我說到：「我認為你挺悲觀的」，才真正地認清這樣的思維對自己的打擊有多大。 貧窮分為兩個層面，一個是物質上的貧窮，另一個則是思維上的貧窮，我們大多數被物質上的貧窮限制了思維的成長，所以有句話說「貧窮限制了你的想像」，負面、悲觀的思維也是如此。因此，要達到物質的富有，也需要先讓思維富有才行。 重新振奮思而不做是沒有任何幫助的，出社會的第二年以後我投入許多技職上的改變，目的是消除這些恐懼，另一方面則試著去面對這些問題。到了現在，透過學習讓有機會進入更好的環境，更高的薪水、更優秀的人才、更豐富的環境，也因此慢慢改變我原有的想法，更知道如何改善自己及未來的生活。 接下來幾篇會寫到關於財務觀念的改變，這些觀念讓我重新規劃我的人生，並深切地相信我的女兒可以過得比我更富有。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：改變思維的三個重要技能","slug":"three-skills","date":"2019-09-19T16:00:00.000Z","updated":"2019-09-20T05:45:45.783Z","comments":true,"path":"ironman/2019/09/20/three-skills/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/20/three-skills/","excerpt":"","text":"當掌握第二個技能以後，視野自然也會更為開闊，出社會陸續掌握的技能不少，雖不一定到精通，但有些技能帶給我許多思維上的衝擊，讓我不得不思考過去的觀念是否需要調整，也慢慢地了解到為什麼能力越強的人會更為謙卑。 出社會後主要改變思維的三個技能為： 程式 理財 行銷 程式語言雖然在學生時代就開始慢慢接觸程式語言，但真正認識則是出社會以後，程式語言真正教給我的並不是單純一個技能，它同時能夠影響工作效率及思考能力，並且因為這是趨勢，它同時會帶來更為主流的工作型態及思維。以下大致列出對於我的改變： 掌握趨勢：軟體開發是趨勢，而我的切入點是前端開發，前端開發的崛起與目前的行動裝置有很大的關聯性，也因此更需要了解目前行動裝置的趨勢。~所以，買新手機絕對可以說是為了工作。~ 高速學習的技能：現在的程式語言淘汰更快，尤其是前端，因此不斷學習是必備條件，也因此開發者的學習速度相對來說是更快的。 持續學習：同上，因為我們知道技術有可能被淘汰，所以自然養成持續學習的習慣，長期下來我們更能避免在社會上被淘汰。 自動流程：軟體開發者大多都很懶惰，步驟能越少越好，如果是同一件事情需要無腦的反覆執行時，開發者就會將它給自動化，藉此能夠釋放出更多的時間，做更有價值的事情。 工作模組化：開發中很重視相同的程式碼 “不要” 寫兩次，因此會習慣將類似的片段給模組化，這對於工作管理及效率有很大的幫助。 更能掌握價值的核心：作為開發者，工作很容易就進入核心（當沒有工程師時，也代表產品無法完成），很容易清楚自己的定位，也能夠從中獲得許多成就感（~不過也容易從中迷失~）。 邏輯能力：開發的過程中自然會不斷的訓練邏輯能力，這會讓理解事情的速度加快，並且與不同領域之間具有更有效率的溝通（無法溝通的人也就無需溝通）。 分享：能夠獨佔就代表自己優於其他人，這是許多傳統技能的邏輯，但在軟體開發上不一定是好事，許多企業也慢慢將專有技術開源化，因此「開源已是常態，分享更能造福更多人」（包括未來的自己）正是軟體開發的生態。 社群：由於新技術不斷出現，自學的速度有限，必須透過各種形式來加快「認識新技術」，而社群也因此孕育而生，率先掌握技能者可以從分享加強對新技能的概念，而後進者也能從中認識新的技能，開發者們也能透過社群增加彼此的連結，形成互助的環境。 在這個社會上，更能看到許多具有軟體技能的成功者，無論是在原有或另一個領域都能有不錯的表現。 理財對於財務方面長期沒有安全感，不僅是對於當下，更對未來感到無力，而在鴻海工作的那幾年與同事之間學習與討論許多相關的觀念，並且糾正長期對於理財的錯誤觀念，也讓我從對於財務沒有安全感並漸漸地對於此充滿希望。 本系列文章會有許多關於理財的主題介紹，讓大家慢慢地了解為何我會從缺乏安全感到對未來感到希望（絕對可以開場就讓大部分人感到絕望），相關內容會有大量的篇幅作介紹，在此就不多述。 行銷這段標題是 “行銷”，更精確地來說是 Growth Hacker。開發、設計的過程中都是用 “我” 的思維在執行，例如： 我認為這個色彩比較好 我認為流程應該是這樣 我認為用戶喜歡這樣做 我認為 XX 廠商這麼做廣告效果不會好 我認為主管的意見不專業 我覺得老闆這麼做一定會虧錢 我覺得工程師沒有站在用戶端的思維 我覺得賈伯斯在世一定會這麼想 強者我朋友的意見是 … … 這樣的思維具有強烈的自我意識，這些意見容易造成與其他人的衝突，更重要的是 無法證明是否正確。以 UX 來說，我們都清楚站在用戶端思考是正確的，但如何真正的站在用戶端呢？難道是去詢問用戶？（透過直接詢問時，此流程已經有所預期性，參考性將大幅降低） 幾年前接觸到 Growth Hacker 時，慢慢地了解到大多數人所認為的與用戶具有非常大的差異，因為我們的生活環境不同，無法真正認識其他背景的人們，所以許多猜想都是無意義且錯誤的，更有效的方式是直接透過數據來分析用戶行為，透過學習這個技能也知道自己的思維不代表他人，也知曉應從另一個觀點觀察這個社會。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：放棄十年本科經歷，投入網頁開發領域","slug":"became-a-webdesigner","date":"2019-09-18T16:00:00.000Z","updated":"2019-09-19T07:25:20.266Z","comments":true,"path":"ironman/2019/09/19/became-a-webdesigner/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/19/became-a-webdesigner/","excerpt":"","text":"當完兵投入社會的時候，家裡也剛好出了些事情，心中最大的希望就是找份工作。當時，Flash 因為 iPhone 的出現而沒落，所以當下選擇可以是回到設計的本業、網頁設計師或者是繼續找 Flash 工作試試看（沒落，但它還是存在的）。 而無論哪一種，其實我當下的選擇是 “看哪個薪水多，就選哪個！”；打開求職網站後「設計的工作基本上可以移除了」，普遍的薪資是低於網頁設計、Flash 的工作，所以就以網頁設計師、Flash 的選擇為主。 我投的履歷並不多，可是有投的履歷只要有回應，基本上都是錄取的，主要是在研究所的 Flash 作品非常搶眼，加上學歷及經歷（得獎）的優勢，面試上很容易就能打動人，其中一間主要製作 Flash 教學的公司也坦言：「如果到他們公司，很快就能升上主管」。但也是考慮長久的發展性，我又再次放棄修練許久的專長，投入另一個不熟悉的領域。 除此之外，雖然我是台北人，但後來都在高雄工作，許多人會因此詢問為何在高雄工作？而不是在機會豐富的台北，相關的內容將會有獨立篇幅作介紹。 放棄原有技能，有時能獲得更多進入第一間公司是以接案為主，起初壓力挺大的，原因在於我是使用平面設計觀念在製作網頁設計，主管並不滿意我的設計作品，但由於主管並未具有設計背景，所以給予的建議也不一定能精準到重點： 我覺得你的顏色這樣不行 你不能用平面設計的思維做網頁 你可以多參考前輩們的作品 就這樣反反覆覆也花了不少時間摸索什麼是 “網頁設計”，幾周的時間下來也好不容易交出勉強被接受的作品，但也深知自己能力上的不足。 後來自己當老闆，在給予新進的平面設計師員工建議時，也一直會想到這段過去，但也好在自己是設計底，給予的建議也能夠更精確 接下來空閒的時間就不斷投入網頁設計的研究，會去不斷的翻找當時主流的開發模式，如： 響應式網頁 → 行動版剛開始盛行，由於是屬於新技術，投入後就是跟著浪頭走，許多優勢很明顯。但也由於是新技術，所有的觀念都要自己想辦法摸索。 文字編輯器 → 當時公司是 Dreamweaver 為主，後來改用 Sublime Text 戒除所見即所得的開發模式（WYSIWYG）。 Sass → 一開始我還以為是一種軟體，可以直接外掛於 Dreamweaver 或其它文字編輯器下，研究後才知道需要 Ruby 環境。 CSS3 → 雖然當時 CSS3 並沒有被許多瀏覽器所支援，但提前掌握這些技術在往後可被支援時，可以優先並精準的使用在網頁上。 社群是什麼？不斷的尋找新的技術、資源，自然也會搜尋到相關的資源，當時洧杰正好創立「高雄前端社群」，好奇心的驅使下也就去參加了，也由於「前端」這個技術正在發展中，也會思考如何強迫自己加快成長速度，當下決定站上講台與他人介紹來加速成長，因此與 洧杰 毛吹自薦介紹幾場不同的技術，這帶給我了： 更快速的成長 除了學一次，還要懂的如何介紹 認識許多比我更厲害的人 知道自己還有哪些需要進步 我也不是擅長在講台上分享的人，一開始很會很緊張面對數十人介紹一個主題，不過當時的想法是「提早犯錯總比未來犯錯成本更低」，透過幾次的介紹也會越來越熟悉該如何面對多人的舞台，其實也不會有人在意犯的哪幾個小錯誤，也因此認識許多前端的高手，讓自己接下來遇到問題也能有人可以討論。 鐵人的開始接下來，除了在台上介紹技術外，我更希望能有平時的學習計畫，如果希望一個持續性目標可以達成，就試著與周遭朋友或更多人說（立下 flag），因此我立下一個百日貼文的 flag，也順勢的被洧杰推坑參加了 IT 邦幫忙的鐵人賽，至今還是維持每年有 30 天的學習習慣…。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：初入程式語言，沒想到是 JavaScript 的親戚啊","slug":"start-to-learn-program","date":"2019-09-17T16:00:00.000Z","updated":"2019-09-18T08:07:52.662Z","comments":true,"path":"ironman/2019/09/18/start-to-learn-program/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/18/start-to-learn-program/","excerpt":"","text":"由於家境的關係，對於金錢一直都沒有安全感，雖然視覺設計、繪畫等等是興趣，但很清楚趨勢不是如此，研究所期間可感受到：「平面設計是夕陽產業，網頁等多媒體會是趨勢」。許多面向都証明如此，如果對金錢沒有安全感，就勢必需要做一些改變。 當時，網路上很紅的技術是 Flash，臉書在台灣也才剛崛起，那時候大家最常玩的遊戲就是開心農場，開心農場就是 Flash 的遊戲之一。而 Flash 當時是搭配 ActionScript 3.0 （簡稱 AS），這也是基於 ECMAScript 規範開發的語言，因此與 JavaScript 本是同根生，當時我也不會任何的程式語言，只是想著：「我要是可以做出類似的遊戲，相信以後會有更好的收入」，運氣也是挺好的，在當時都不懂的情況下居然選到目前主流的 ECMAScript 的同規範語言。 接下來為了一股腦的投入學習 AS 之中，為了可以全心全意學習該語言，當時也跟指導教授請求說希望以此做遊戲（藝術學院說要寫程式做論文的概念），搭配著經過 “設計” 的圖像，硬是在最後一年的期間做出一款小遊戲。 遊戲畫面的一景，目前遊戲忘記丟在哪了（遮臉），要是當年就認識 Github 有多好。 學習的經驗分享在一開始也是抱著天真的想法：「什麼程式語言的，了不起一個多月我就能學會」，預估學習程式及撰寫的時間也沒有很長，但實際上我學到差點放棄想休學 :(，這段我們就放到後面再說。 以學生來說，最便宜的學習方式莫過於買書，那時買了數本 AS 的書籍，包含： 基礎教學 字典類型的 AS 書籍 特效範例等等 如果從零開始學來說，基礎教學是最有效果的，因為可以從中瞭解程式碼運作的概念，記得很清楚當時為了搞清楚什麼是 var a = 1; 這句話其實就花了不少時間，更別說後來還要練習寫陣列、函式等等（其實我到作品完成後，還是沒有搞懂什麼是陣列）。所以在初學的時候最重要的是從範例中獲得一些些成就，別急著了解整個來龍去脈的觀念，讓它動起來再來思考細節。 字典類型的書籍是次要的，因為當時的文字編輯器（也就是 Flash 本身）的提示並不完整，所以當有語法上的需求時都是直接從字典中查找。最少用到的書籍則是範例特效，這些酷炫的效果並不一定適合放在作品內。 放棄的心態確實，我也是曾經想放棄這條路，學生時代缺錢加上獨立學習上的挫折感，在資源匱乏的情況下不知道可以從哪詢問，且日子一天一天過去，作品離完成還有很大一條路，也曾經跟家裡提到：「想要放棄研究所的學歷」。家裡的人後來也說給一些錢來讓我完成這個學業（後來我沒有拿），希望我可以再撐下去，也因為那多一點點的堅持，讓現在有機會可以投入前端開發這條路。 影響後來出社會的時候，拖賈伯斯的福 Flash 瞬間沒落，學了許久的 AS 馬上就派不上用場（雖然拿著個作品去面試時，基本上是不會被打槍的）。不過一個沒落也意味著另一個崛起，此時前端開發是正流行起來的時間點（預先準備，機會才會有可能來臨），也正好 AS 與 JS 本是一家親，所以再轉學習時的成本是比較低的。 除此之外，雖然早期資源沒有現在那麼多，那麼也會相對越早投入的人，越容易取得領先優勢並搶得先機；而現在的資源豐富讓更多人可以快速掌握技術，讓這些技術也並非只有少數人所掌握，大家不斷的成長情況下，業界審視這些人才時的標準自然會提高。以 JS 來說，過去僅需要掌握 jQuery 就足夠了，但現在除了函式庫、框架需要有基本的了解外，對於 JS 核心運作也需要有一定的掌握度。因此無論過去與現在，其實學習都需要花上大量的時間與精力，只是前者著重於探索，後者更需要專精。 雖然我花了一年左右的時間從無到有學會了 AS，在還沒派上用場的時他就已經沒落，但可以證明的是「學習」本身就是讓自己更容易接近機會的方法，我們無法確認學習到的技術是一定可以當下派上用場，但學習是可以不斷累積，並且造成良性的結果。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：從設計轉開發者的思維改變","slug":"design-to-developer","date":"2019-09-16T16:00:00.000Z","updated":"2019-09-17T06:04:24.097Z","comments":true,"path":"ironman/2019/09/17/design-to-developer/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/17/design-to-developer/","excerpt":"","text":"在學期間我的主力是「美術及平面設計」，從國中開始一直到研究所都是屬於相關領域，軟體開發是一個很大的轉變，這個轉變不僅影響我的生活更影響我的思維。也因為如此，我會向許多設計師推薦學習軟體開發， 設計小時候很喜歡看動漫，也因此認為自己喜歡畫畫，家中也認為我應該對此是有興趣的（我也真切的這麼認為），後來從國中在美術才藝班（算補習班吧!?）&gt; 復興商工美工科 &gt; 台南大學美術系 &gt; 高雄師範大學 視覺設計研究所 都是屬於美術、設計相關體系。 而學習的過程中，才慢慢的發掘自己比較想要什麼，但這個路程也是非常漫長的。以復興後期來說，認為自己對於美術的喜愛度或許沒那麼高，更希望能夠做出具有「價值」的作品，所以在高三時就選擇「視覺傳達組」，希望自己的作品並非只有用在升學或是自己觀賞，而是真正的可以賺錢。當然，以高職那時候還是太嫩惹，但至少已經慢慢往「價值」這個目標邁進。 當時那組不僅是全校分組第一，也是當時代表學校參與新一代設計展的組別，而新一代設計展是大學設計科系為主的展覽，高職當時僅有復興參加。 升大學時，因為高職功課普遍都很爛，我還是其中更爛的那種，所以重考了一年多，拼了命考上了公立台南大學美術系。美術系前幾年還是乖乖地畫畫，只不過會接些案子以及參加競賽來當生活費，在大四的時候，半學期的獎金加上案子的費用約有 15 萬～ 18 萬(實際數值忘記了)，那時候也是可以完全靠自己的方式賺錢，而主力就是在高職打好的設計底。 當時參加競賽都是有技巧的，用特定的風格就很容易得獎（水墨 + 向量風格，可參考北京奧運的設計），當時還有得過「高雄世運會 Logo 徵選」優選，也是用此方式得獎。 大學時轉到了高雄師範大學，案源及獎金沒有像過去那麼的高，當時也會思考「我接下來真的是要當設計師嗎？」，也會因此不斷的搜尋關於設計師的工作想像。而我的專長是平面設計，當時會認為平面設計的限制很大，設計本質就是傳達，而平面的傳達是受到限制的（當然也有屬於它的優勢）；相對於平面設計來說，多媒體網頁的傳達力更強，因此就開始了 ECMAScript 的學習之旅!?（這段故事在後面會另外補完）。 另外，近幾年我也不斷審思設計的價值是什麼？ 來自於案主或老闆的費用？ 比賽得獎的獎金？（我認為設計系學生真的是很好賺，又直接） 設計因為曝光而有價值？ （設計費其中一種計價模式是用印刷品數量計算） 還是設計可以為產品曝光加分？ 這個答案，一直到出社會後我才能慢慢體會，尤其是將許多技能整合後才能更清楚什麼是「設計的價值」。 從設計轉工程師在學期間無論是高職、大學、研究所我們都是獨立學習，美術設計的體系下，每個人都是獨立的個體，很少有經驗分享或技術分享的思維，而為什麼會有這個現象我認為是： 台灣設計領域的封閉：老師、業界、評審者都是固定的一群人，導致整個生態與思維是封閉的。 技術很固定：掌握工具後剩下的就是個人的美感培養，所以不太需要類似開發者的成長社群 每個人都是競爭的心態：案子、薪水要比別人多，就是要證明比別人強 不久前遇到了一個文化工作人士，也指出了藝術領域一個很大的問題點：「藝術領域的人都是個人主義，不太會有分享及社群的概念。」在美術設計長期的訓練下，自然也會有很強烈的自我主義，所以接觸到軟體領域後會發現這個環境與過去有很大的不同，奉獻的能量更有助於自我發展（鐵人賽也是一個例子）。除此之外，軟體開發者在成長的過程中，也會不斷的創造出更多社群，如：前後端開發者社群、行銷社群、創業家社群，這些群體中都很容易找到開發者們。 長期下來思維也慢慢的從全部自己來（過去，我是盡可能不使用任何圖庫、圖示或第三方的資源），慢慢轉變為分享、共享、共有的思維模式，不僅更有效率也更能接近價值的核心。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：你的願景是什麼？","slug":"what-is-your-vision","date":"2019-09-15T16:00:00.000Z","updated":"2019-09-16T07:01:51.974Z","comments":true,"path":"ironman/2019/09/16/what-is-your-vision/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/16/what-is-your-vision/","excerpt":"","text":"當兵的後期，有一位和我很好的義務役也即將退伍，他在退伍的時候發表感謝內容表示：「特別感謝我給他的希望的感覺」，平常的時候我常會找他閒聊，也許是談話的內容讓他更具有信心，也讓他想要去追求屬於自己的夢想（印象中是機場塔台相關的工作）。現在想起，也許是那時比較天真吧，認為什麼事情拼一下就有機會了。 天真的夢想與真誠的願景小時候各位應該都有自己的夢想，當超人、當總統、假面騎士、鋼彈駕駛員等等，但到了成年以後我們了解這些是有困難的（或者不可能!?），在這樣的情況下，是否還有夢想呢？還是夢想只存在天真的情況下才能擁有？ 在「你怎麼看待時間，決定你成為哪種人」這本書提到(精簡版：https://www.youtube.com/watch?v=pI0O_Oepay4)，目標是短期的，而願景是長期的，成功人士及企業都會擁有願景，並且以這個願景為使命來訂定目標，在訂定願景時和小時候的夢想來說都是接近遙不可及的目標(在怎麼說，小時候的我也是真誠地相信能夠成為假面騎士呢！)。 離開學校從軍中退伍，並進入社會職場的那幾年，過得並不是很如意，學貸、低薪、家庭不如意等種種的壓力不斷的接連而來，這些不愉快的情緒逐漸的影響生活，當時還真正能體會到無知就是一種幸福，承擔則是一種壓力，對於自己的過去具有許多不滿卻又無能為力。當然，這種情緒對於生活是會產生負面的影響，因此立下一個短期的願景「35 歲要過著讓人羨慕，而不是我忌妒人的生活」(說實話，當時看著許多富二代的生活真的很讓我忌妒)，而這個願景也深深的改變我接下來的生活。 今年過了 35 歲有了些許的成就，或許不一定讓所有人羨慕，但至少我不再忌妒他人的生活，並且很喜歡現在的自己(就以被討厭的「被討厭的勇氣」一書所提到，至少我已經達到滿意的階段，羨不羨慕我則是他人的課題)。這段時間也忙於小孩的出生、新課程的準備、公司的營運讓我沒有再去思考接下來的願景，這樣的日子過了一段時間，心靈上看似清閒卻又有些空虛，就好像是遊戲中拿到最想要的神裝，滿足的情緒下卻帶有一些空虛，主要原因是沒有訂定接下來的願景，讓自己似乎不斷的完成短期目標，卻不清楚自己該面向何處。而願景應該是難以達到的目標，而當初雖然我是設立難以達到的目標，但是具有一個時間點，所以時間後該願景也會結束。 接下來而在最近看到 洧杰 螢幕上的願景（他將願景直接秀在瀏覽器的新頁面上），第一個是「改善台灣的軟體就業環境」，第二則是「和太太長命百歲」。當下立刻思考到那我的呢？自從 35 歲的門檻度過之後，一時還想不到接下來的願景是什麼。 目前的工作是六角學院負責人，除了在公司內部打雜以外，更重要的是輔導學員們從零開始慢慢投入網頁開發的未來，剛開始的目標是教導學生掌握一個特定技能，隨著時間的累積越來越多的學員不僅掌握關鍵技能，還從這些技能轉職成功。從一開始大多成功投入的學員都是具有基本的背景，而許多非本科的學員對自己並沒有任何信心，但現在很多案例是從 0 開始學習並完成所有挑戰進入前端領域。 讓許多人成功邁向自己的目標時，也發現自己並非僅是傳遞一項技能的講師，而是輔導他們邁向自己目標的導師。因此，現在想回到以前過去的思維，相信這個世界並沒有那麼困難，像讓同儕士兵退伍後去追求自己目標一樣，慢慢引導更多人迎向自己的目標。 接下來我也會有兩個願景，一個請讓我作為秘密為家人付出，另一個將會是希望「讓更多人充滿希望，並真誠地相信自己能夠達到目標」 強化身心，破除無意義的恐懼 讓人了解如何安排挑戰計畫 協助最後的一哩路，讓他們找到對的人 身體力行，自己也要一同成長 真心期望大家都發大財 而這一系列文章也將會分享我的成長經歷，以及許多成長過程中的思維改變，經歷過小公司、百大企業員工並成為老闆的各種體驗分享，從一個不可能更差的人生，到改變思維看到各種希望的過程!?","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"自建 Name Server","slug":"custom_name_server","date":"2019-04-24T16:00:00.000Z","updated":"2019-04-24T07:13:59.984Z","comments":true,"path":"dns/2019/04/25/custom_name_server/","link":"","permalink":"https://wcc723.github.io/dns/2019/04/25/custom_name_server/","excerpt":"","text":"本篇教學是延續「大神來六角」的 “網址管理與 DNS 託管全攻略”，目的是讓參與的學員更了解 DNS 在轉址的過程觀念。 對於 Name Serve 的概念可以參考 AWS 提供的架構圖： 擁有一個網域後，只要網域的供應商可以設定 NS Record，都可以用來自行建立 Name Server，並且可以自行代管該網域下的所有子網域。 本篇中的環境在教學結束後被釋放，所以無法再次連接。 參考文章： http://linux.vbird.org/linux_server/0350dns.php#DNS_Zones https://eric0806.blogspot.com/2014/06/ubuntu-bind9-dns-server.html 建立環境 購買一個網域，並且該網域可以自訂 NameServer 的 本次服務購買 GoDaddy 準備一台主機，本次使用 Digital Ocean 的 Ubuntu 16 上層 Name Server 設定首先，必須先將給予自訂的 Name Server 一個網址，如果僅有 IP 的情況下將無法自訂 Name Server，在此先給予我的主機 dns 這個名稱： 接下來將 customdns 這個名稱交給予 dns.casper.tw 這個 Name Server 代管，因此： dns.casper.tw 這是 Name Server 主機 customdns.casper.tw 這是 Name Server 主機所代管的網域，接下來可以自訂 &#123;&#123; xxx &#125;&#125;.customdns.casper.tw 的網址在這個網域下。 Name Server 設定在此，會使用 Bind 這一個 Name Server 工具，本工具有許多觀念需要理解，會在接下來的流程中一一的說明： 安裝 Bind 工具：sudo apt-get install bind9 bind9-doc dnsutils 安裝完成後進入 /etc/bind 的套件下，輸入 ll 可以看到以下的資料結構： $ ll 主要調整檔案： named.conf.options：主要的 DNS 工具的選項。 named.conf.local：設定管理的 IP、正反解的對應檔案路徑、次要 Name Server 的設定等等。 自訂檔案： /zones/&#123;&#123;customdns.casper.tw&#125;&#125;.tw 正解檔 /zones/&#123;&#123; xxxip.rev &#125;&#125; 反解檔 其它 /etc/default/bind9：修正 ipv4、ipv6 的問題 Bind 設定檔撰寫的過程中，會不斷的重啟、除錯，以下列出重要的語法： /etc/init.d/bind9 restart：重啟。 /etc/init.d/bind9 status：目前機器的狀態，必須要調整到沒有錯誤訊息為止。 設定 named.conf.options透過編輯器設定 named.conf.options，這是 bind 工具的主要項目，按照預設也不會有太大關係，但本次是以 ipv4 為主，所以 v6 的功能可以先關閉，另外 Name Server 預設是 53 port，當上層網域指定過來後就會自動用 53 的接口，所以不要隨意調整。 acl intra &#123; xx.xx.xx.xx; &#125;; // 自訂義變數 intra，可查詢的 DNS 主機，不設定也沒關係 options &#123; directory &quot;/var/cache/bind&quot;; dnssec-validation auto; auth-nxdomain no; # conform to RFC1035 listen-on port 53 &#123; any; &#125;; allow-query &#123; any; &#125;; allow-query-cache &#123; none; &#125;; recursion no; // allow-recursion &#123; intra; &#125;; also-notify &#123; &#125;; &#125;; 設定 named.conf.local這是與配置檔案連接的檔案，算是主要的進入點，透過這個檔案與正解、反解配置檔案產生關聯。 另外 Name Server 可以設定超過一台主要的為 Master，其它次要的為 Slave，在這個範例中僅設定一個主要，實作中會建議另外設定 Slave，避免主要的機器無法連接導致所有網址失聯。 acl allow-trans-ip &#123; 138.68.229.69; &#125;; // 定義允許取得配置的 ip ，如果有多個 ip 可以使用分號隔開 // --- 正解的區域 --- // 定義掌管的 Domain zone &quot;customdns.casper.tw&quot; &#123; type master; // 定義 master 或 slave file &quot;/etc/bind/zones/customdns.casper.tw.fwd&quot;; // 自訂義正解檔案的路徑，名稱可自訂 // 定義可以從主要機器取得配置的 ip，在此不設定也沒關係，但實作中建議加上 allow-transfer &#123; allow-trans-ip; // 上方定義的變數 &#125;; &#125; // --- 反解的區域 --- zone &quot;229.68.138.in-addr.arpa&quot; &#123; type master; // 對應 master file &quot;/etc/bind/zones/138.68.229.rev&quot;; // 反解配置檔案路徑 allow-transfer &#123; allow-trans-ip; &#125;; // 同上 &#125;; // 反解命名規則： // ip 假設為 138.68.229.69 // 反解應設定為 229.68.138.in-addr.arpa 設定正反解配置檔案上方定義了 named.conf.local，其中又連向兩個配置檔案，分別為： /etc/bind/zones/customdns.casper.tw.fwd 正解 /etc/bind/zones/138.68.229.rev 反解 而這兩個檔案名稱是可以自訂的，在此僅是依據所管理的網域及反解路徑命名，首先設定 customdns.casper.tw.fwd 正解檔案： $TTL 120 ; @ IN SOA customdns.casper.tw. xxx.gmail.com. ( 2014062007; 600; 900; 86400; 120); ; @ IN NS dns.casper.tw.; dns.casper.tw. IN A 165.22.129.123; www.customdns.casper.tw. IN A 138.68.229.69; 分別說明以上檔案分別包含什麼內容： 定義 TTL 變數，單位是 “秒”，時間越短用戶就需要更頻繁的詢問 定義 SOA，SOA 算是 Name Server 的申明檔案，其中也包含該伺服器的管理者聯絡方式： customdns.casper.tw. Master DNS 伺服器主機名稱，後方的 . 是不能省略的 xxx.gmail.com. 負責該網域的聯絡人，gmail 前方的 @ 被轉為 . 2014062007 序號 (Serial)，在此可以思考為版本號，slave 用此來判斷 master 是否有更新 600 slave 的更新頻率 900 當 Slave 連線失敗重新嘗試時間 (Retry) 86400失效時間 (Expire)，當 Slave 重新連線到達多少時間會停止嘗試，屆時需要管理員處理。 120 TTL 預設時間 定義 Name Server NS：Name Server 縮寫 dns.casper.tw. Name Server 位置 定義 Record 參數 www.customdns.casper.tw. 自訂義網址 138.68.229.69 對應 ip 反解：一般網域查詢時是由右至左，如：.root &gt; .tw &gt; .casper &gt; .dns，而 ip 的運作是相反的，上述的 ip 中在運作時方向為 138 &gt; 68 &gt; 229 &gt; 69，用來從 ip 反向查詢到主機名稱。 定義反解檔案 138.68.229.rev，反解檔案的 SOA 與正解檔一致，不同的是 Record 內容：$TTL 3600 ; @ IN SOA customdns.casper.tw. agito723.gmail.com. ( 2014062007; 600; 900; 86400; 120); @ IN NS dns.casper.tw. ; 123.129.22.165.in-addr.arpa. IN PTR dns.casper.tw. ; 69 IN PTR www.customdns.casper.tw. ;反解檔案與正解檔案設定差異不大，規則上定義為 PTR(反解 Record)，並且在 ip 需要使用反解的規則撰寫。到這個步驟基本上就算完成了，接下來就是進入測試、重啟與除錯。 重啟及除錯接下來，輸入 /etc/init.d/bind9 restart 就可以重啟測試，重啟後建議再輸入 /etc/init.d/bind9 status 來除錯，以下列出常見的錯誤： 遇到的問題： network unreachable resolvingnetwork unreachable resolving &#x27;ns39.domaincontrol.com/AAAA/IN&#x27;: 2001:503:d414::30#53 解法：#編輯 /etc/default/bind9 gedit /etc/default/bind9 # 如下，加上 -4 # startup options for the server OPTIONS=&quot;-4 -u bind&quot; bad dotted quad設定檔中包含了不正常的空格，這些空格有可能在分號後方，可依據錯誤訊息尋找是否有多餘的空格。 正常的 status 運作應會出現以下訊息，並且沒有任何的紅色文字： Name Server 開張如果沒有任何錯誤，正常來說就能直接連線至你的網址。接下來再透過 dig +trace &#123; 網址 &#125; 也能看到自建的 Name Server 相關訊息。","categories":[{"name":"dns","slug":"dns","permalink":"https://wcc723.github.io/categories/dns/"}],"tags":[{"name":"dns","slug":"dns","permalink":"https://wcc723.github.io/tags/dns/"}]},{"title":"免費申請屬於自己的 SSL 憑證(手把手帶你加上 https 綠色鎖頭)","slug":"free-ssl","date":"2019-04-23T16:00:00.000Z","updated":"2019-04-24T06:31:44.889Z","comments":true,"path":"ssl/2019/04/24/free-ssl/","link":"","permalink":"https://wcc723.github.io/ssl/2019/04/24/free-ssl/","excerpt":"","text":"SSL For Free為了讓更多網站可以加上綠鎖頭(https)，並且提高網路的安全性，此服務免費提供網站 SSL 憑證，同時憑證不僅是免費的，還是屬於萬用憑證（包含所有子網域），雖然每次的憑證效期僅有三個月，但可以不斷的續約，對於每年需花個幾千、幾萬才能購買一個萬用憑證來說，算是節省不少。本篇將會一步一步介紹如何申請到此憑證。 開發環境說明： 主機 Digital Ocean：Ubuntu 16 後端語言：Node.js 另外，憑證的金鑰綁定是由開發者來完成，但這個服務是直接在網站上完成，開發者僅需要直接下載做好的憑證即可。 申請憑證透過以下網站申請：SSL For Free ，直接輸入要申請的網域即可。 申請後，他會要求認證網域是否由申請者管理，接下來會有以下的認證步驟(三選一)： 透過 FTP 上傳驗證檔 手動上傳驗證，本教學會使用此流程，順便說明一些細項 DNS 驗證，這是最簡單的流程，直接在 DNS TXT Record 補上驗證訊息即可 手動驗證流程選擇手動驗證會出現以下流程說明，接下來在我們的 Ubuntu 伺服器端先安裝好 node.js 及 express 環境後繼續以下動作。 開啟 express 框架中的 bin/www 將 port 改為 80 port，並且將 DNS 指向此主機（需與 SSL 申請的網址同一個）。 下載該手動驗證的檔案。 在 public 資料夾下，建立該資料夾 /.well-known/acme-challenge/ 並且把該檔案上傳上去(上傳方式可參考後方說明) 須確保網址上的這個檔案能夠被開啟 上傳驗證檔案的說明：方法 1: 可以直接透過指令上傳驗證檔案，需要在本地端輸入以下指令，並且對應遠端的路徑。scp &#123;&#123;檔名&#125;&#125; root@&#123;&#123;主機&#125;&#125;:~&#123;&#123;資料夾路徑&#125;&#125; // 範例： scp xxx root@12.3.45.678:~/website方法 2: 直接手動新增 vi &#123; 檔名 &#125;，將下載檔案的內容貼入 按下 Download ssl確保上述流程完成後，就可以按下 Download SSL，失敗也會提供訊息，但如果發生錯誤，請重新上述的步驟。 接下來會核發 90 天的憑證，並且已經生成了憑證、私鑰等檔案。接下來下載這些檔案，其中 certificate.crt、private.key 這兩隻需要上傳到 server 上。 express with https步驟 1: 上傳 certificate.crt、private.key 到伺服器上，直接放到專案中方便存取的路徑即可。scp certificate.crt root@0.0.0.0:~/&#123;&#123; 專案路徑 &#125;&#125;/ssl/ scp private.key root@0.0.0.0:~/&#123;&#123; 專案路徑 &#125;&#125;/ssl/ 步驟 2: 透過 npm install https --save 安裝 https 套件步驟 3: 打開 bin/www，並且將檔案修改成以下（後方有完整的程式碼） var fs = require(&#x27;fs&#x27;); var app = require(&#x27;../app&#x27;); var debug = require(&#x27;debug&#x27;)(&#x27;website:server&#x27;); var http = require(&#x27;http&#x27;); var https = require(&#x27;https&#x27;); /** * Get port from environment and store in Express. */ var privateKey = fs.readFileSync(__dirname + &#x27;/../ssl/private.key&#x27;); var certificate = fs.readFileSync(__dirname + &#x27;/../ssl/certificate.crt&#x27;); var credentials = &#123; key: privateKey, cert: certificate &#125;; var port = normalizePort(process.env.PORT || &#x27;443&#x27;); app.set(&#x27;port&#x27;, port); /** * Create HTTP server. */ var server = https.createServer(credentials, app); 完成後就可以直接連線至該網址，加上憑證後預設也會自動連線至 443 port，所以就可以直接使用當時的網址連線即可。 簽核的認證範例：","categories":[{"name":"ssl","slug":"ssl","permalink":"https://wcc723.github.io/categories/ssl/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://wcc723.github.io/tags/ssl/"}]},{"title":"JavaScript This 系列文：this 為什麼指向 window","slug":"this-why-window","date":"2019-03-20T16:00:00.000Z","updated":"2019-03-21T07:29:48.399Z","comments":true,"path":"javascript/2019/03/21/this-why-window/","link":"","permalink":"https://wcc723.github.io/javascript/2019/03/21/this-why-window/","excerpt":"","text":"本篇是接續先前的：鐵人賽：JavaScript 的 this 到底是誰？，會更深入的探討 JavaScript This 的運作及觀念，這一系列的文章順序上不會從基礎開始介紹，會建議先從先前文章開始閱讀。 純粹的調用 (Simple call)直接呼叫函式的情況下，this 會指向全域，在以下範例中可以取到 name 的值，但一般來說很不推薦這樣的寫法，後面會提到這樣的寫法是怎麼造成的。var name = &#x27;小明&#x27;; function callSomeone() &#123; console.log(this.name) &#125;; callSomeone(); // 小明 IIFE、Callback、閉包也屬於此類別嗎？上述的函式只有單一層級，為了加深大家的印象，我們透過各種改變 “函式” 作用域的方式看是否會改變 this 的結果。 IIFE立即函式，這算是直接在函式內直接在呼叫另一個函式，而這個結果下一樣與純粹的呼叫結果相同。var name = &#x27;小明&#x27;; (function() &#123; function callSomeone() &#123; console.log(this.name) &#125;; callSomeone(); // 小明 &#125;)(); 無論我們把函式宣告放在 IIFE 內與外結果都是一致的。var name = &#x27;小明&#x27;; function callSomeone() &#123; console.log(this.name) &#125; (function() &#123; callSomeone(); // 小明 &#125;)(); Closure這樣結果依然相同，並不會因為獨立的作用域改變造成 this 的不同。var name = &#x27;小明&#x27; function easyCard(base = 100) &#123; var money = base return function(update = 10) &#123; money = money + update console.log(this.name, money) &#125; &#125; var MingEasyCard = easyCard(100) MingEasyCard() // &#x27;小明&#x27; 110 Callback functioncallback function 也是一樣的結果，透過以上這些範例了解到，並不會因為作用域的改變導致 This 的不同，更重要的還是在於函式是不是與物件有扯上關係，至此為止我們實驗了各種函式呼叫方式，都可以知道函式再直接呼叫的情況下，this 都是指向 window。 function myEasyCard(callback) &#123; var money = 100 return callback(money); // window &#125; myEasyCard(function (money) &#123; console.log(this, money); // window &#125;) 而 callback function 會提到另一個常見的案例，就是陣列相關的處理方式，參考 MDN 的說明 forEach 的結構如下： arr.forEach(function callback(currentValue[, index[, array]]) &#123; //your iterator &#125;[, thisArg]); 因此 forEach 中間的 callback 一樣是屬於直接呼叫，所以會 this 會指向 window 物件。 var a = [1, 2, 3]; a.forEach(function(item) &#123; console.log(this, item) &#125;); 嚴謹模式 觀念說明開始，為什麼 this 會指向 window 物件 這個階段我們加上 &#39;use strict&#39; 則會進入嚴謹模式，接下來直接呼叫的內容都會變成 undefined的奇特景象，可以理解這是為了避免不必要的錯誤提示，在此也建議別透過一般函式呼叫的 this 取用 window。 直接套上嚴謹模式則會出現錯誤範例：&#x27;use strict&#x27; var name = &#x27;小明&#x27;; function callSomeone() &#123; console.log(this); // 這裡改成了 this，因為沒辦法找到 name &#125; callSomeone(); // undefined 而 undefined 與 window 有什麼關係呢？我們可以先介紹另一個觀念 call()，call 是可將物件傳入並替代函式內的 this： var Ming = &#123; name: &#x27;小明&#x27; &#125; function callSomeone(num) &#123; console.log(this.name, num); &#125; callSomeone.call(Ming, 2); // 小明, 2 透過 .call(Ming, 2) 的方式，可將 Ming 傳入並取代 this，後面帶上一個參數 2 則是函式的參數。因此 .call() 前者為套用 this 的物件，後者以後都是函式的參數。參考下圖：函式中的 this 為 call() 的第一個值，而函式參數為第二個(包含後續的值)。 接下來我們將 Ming 物件替換，直接定義一個 name 在全域之上，並且傳入 undefined 的值來替代 this，猜猜會發生什麼事!?var name = &#x27;全域魔王&#x27; function callSomeone(num) &#123; console.log(this.name, num); &#125; callSomeone.call(undefined, 2);此時會發現運作上依然沒有問題，傳入 undefined 進入後 this 會直接指向全域。 這麼神奇的狀態也算是 JavaScript 的 Feature，發生的理由可以參考：MDN 的說明。 MDN：若這個函數是在非嚴苛模式( non-strict mode ),null、undefined將會被置換成全域變數。 因此，上述程式碼在嚴謹模式下將無法正確運行，因為傳入 undefined 時將會正確以 undefined 作運行。同樣概念下，在一般全域環境套用 ‘use strict’ this 作為一般調用時，將會直接套用 undefined 而不會是 window。 而上述程式碼於嚴謹模式下，將會正確的傳入 undefined。 &#x27;use strict&#x27; var name = &#x27;全域魔王&#x27; function callSomeone(num) &#123; console.log(this, num); &#125; callSomeone.call(undefined, 2); 接下來，可以將本文的上方的程式碼都加上 &#39;use strict&#39; 都會得到相同的結果，this 都會指向 undefined。 延伸閱讀：This 都是物件前一篇介紹到 「this 大部分取決於 它在哪個物件下被呼叫」，所以其中改變 this 的方法之一則是透過物件下呼叫函式： function callName() &#123; console.log(this.name); &#125; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: callName // 這裡的 function 指向全域的 callName function &#125; auntie.callName() // &#x27;漂亮阿姨&#x27;，呼叫是在物件下調用，那麼 this 則是該物件 除此之外，還可以透過本文所介紹的 call 來改變 this 的值，先前範例都是傳入「物件」，此部分我們傳入數值來看看其型別： function callSomeone(num) &#123; console.log(typeof(this), typeof(num)); &#125; callSomeone.call(1, 2); // object number 此部分的 this 我們使用數字 1，函式參數使用數字 2，結果會發生 this 的型別變成了 object!? 重新透過 console 查看 this 會得到以下的結果，這是透過建構式產生的數值(new Number(1))，透過 call 所傳入的純值會被使用 new 建構式的方式產生，所以型別依然維持是「物件」（可參考：MDN），因此 this 終究為物件形式。 MDN：原生型態的值將會被封裝","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"JavaScript This 系列文：this 與物件的關係","slug":"JS-THIS","date":"2019-03-17T16:00:00.000Z","updated":"2019-03-18T09:17:50.296Z","comments":true,"path":"javascript/2019/03/18/JS-THIS/","link":"","permalink":"https://wcc723.github.io/javascript/2019/03/18/JS-THIS/","excerpt":"","text":"本篇是接續先前的：鐵人賽：JavaScript 的 this 到底是誰？，會更深入的探討 JavaScript This 的運作及觀念，這一系列的文章順序上不會從基礎開始介紹，會建議先從先前文章開始閱讀。 物件的方法調用 (As an object method)「物件的方法調用」是最常見改變 this 的方法，只要搞懂這一部份就能了解決大部分的 this 運作，大部分的文件介紹此部分說明為：在函式內的 this 值取決於該函式如何被呼叫。而如何被呼叫實在難以被定義，如：callback、閉包、函式內的函式等等其實都與 this 沒有關聯性。 提供另一個比較易懂的中文說明：this 大部分取決於 它在哪個物件下被呼叫，也就是本段落主要介紹的「物件的方法調用」這個觀念佔了 絕大部分 的 JavaScript 實作時的 this 運作（接下來幾篇會陸續介紹其它幾種），版頭圖則是說明這一類型的 This 運作模式，只要找到上層物件就搞定了整個觀念，下述文中產生了一個函式，透過兩個不同的方式取用則有不同的結果： function callName() &#123; console.log(this.name); &#125; var name = &#x27;全域阿婆&#x27;; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: callName // 這裡的 function 指向全域的 callName function &#125; callName() // &#x27;全域阿婆&#x27; auntie.callName() // &#x27;漂亮阿姨&#x27;，呼叫是在物件下調用，那麼 this 則是該物件 前者是稱為「純粹的呼叫」，此種情況相對單純下個段落會有完整介紹，而另一個物件呼叫 auntie.callName() 則會將 this 指向 “漂亮阿姨”，這個部分相信大家就能有基本的體會，物件下呼叫會影響 this 的指向。 概念如同下圖，在物件下的函式 this 為前者物件。 而 this 這個詞就可以思考成 這一個「物件」，它會隨著在哪一個物件下被調用而影響結果，在此情境下如果有更深層的 this 依然是當下這一個物件。 function callName() &#123; console.log(this.name); &#125; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: callName, watch: &#123; name: &#x27;Magic Watch&#x27;, callName: callName &#125; &#125; auntie.callName() // &#x27;漂亮阿姨&#x27; auntie.watch.callName() // &#x27;Magic Watch&#x27; 在這個概念下，每一層的函式的 this 都是上一層物件，很簡單吧，所以漂亮阿姨下的每一層物件函式 this，都是指向該上層物件。 Vue.js 下的概念使用 Vue.js 時運作的原理就與上述的接近，我們可以看到以下的程式碼運作時，物件第一層的內容均是指向 myCar 這一個物件。 var myCar = &#123; name: &#x27;長大以後要當保時捷&#x27;, go: function() &#123; console.log(this); &#125;, init: function()&#123; this.go() &#125; &#125; myCar.init() 接下來看一下 Vue.js 的程式碼，你可能會思考這樣的結構比上述的多了一層，理論上 Vue 的 this 的運作會不太一樣才是。 var app = new Vue(&#123; data: &#123; text: &#x27;這是一段話&#x27; &#125;, methods: &#123; go() &#123; console.log(this.text) // 這是一段話 &#125; &#125;, created() &#123; console.log(this) &#125; &#125;) 不過當 Vue 實際運作時，元件內的物件、函式等等均會被向上拉，methods, computed 等等均不會存在，所以並非以原始碼而是以實際運行的狀態為主，如下圖，methods 內的 go() 及 data 內的 text 均在元件物件頂層。 接下來運行的概念如下，元件下的函式的 this 就會直接指向該元件，所以 go() 這個函式的 this 自然就能夠使用元件內的 text 資料囉。 延伸閱讀：陣列內插入函式在 JS 型別中，陣列也是屬於物件的一種，因此將函式插入陣列之中運行，this 的指向會如何呢？ 一般來說不會有人這樣寫，但我們可以從中獲得相同的結果： function callSomeone() &#123; console.log(&#x27;this is&#x27;, this); &#125; var MingFamily = [&#x27;小明&#x27;, &#x27;爸&#x27;, &#x27;媽&#x27;, callSomeone] MingFamily[3]() 同上所述，callSomeone 這一個函式的運作也是接在 MingFamily 陣列後方，所以 this 將會指向 MingFamily 這一個陣列喔！","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"鐵人賽：網頁設計 - 設計的過去、現在、未來","slug":"ironman-final","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T07:42:24.579Z","comments":true,"path":"design/2018/11/13/ironman-final/","link":"","permalink":"https://wcc723.github.io/design/2018/11/13/ironman-final/","excerpt":"","text":"「這張圖幫我美工一下」，讓工作中的設計師聽在耳裡非常的不爽，當下正想立即回嘴：「你才美工，你全家都美工！」才發現說話的是老闆。 過去，許多設計師非常討厭這句話，「美工」原意應該為「美術工藝」的縮寫，在此用法則改為「美術工人」、「美術工作」之意，身為具有創意思維的設計師怎能接受這樣的說法。當然，隨著環境的變遷，會這樣說的老闆、同事也就越來越少，與其它領域合作時應互相尊重。 你是美工嗎？「工人」指從事某種職業的勞動者，多指工業生產領域，依靠出賣勞動獲取報酬的人，通常指「體力勞動者」，因為工作內容大多是重複的行為，所以大多數的人只要透過勞動就能勝任。 因此，設計師如果僅透過相同的行為從事設計，打開 Photoshop 用著相同技法、相同的習慣，將業務所需的圖文排列，沒有太大的變化及成長，其實也就與上述的「美工」無異，高度的可替代性，僅需要美術相關學院畢業都可以勝任。因此，設計師與工程師一樣是必須不斷的學習，擴增自己的視野，多了解不同領域之間的協作關係。 未來發展1111 剛過，這個節慶來自於中國的光棍節，現在則是華人電商促銷折扣的日子，每一年的今天「天貓」電商業績都會不斷的創新高，只要一天時間就可以獲得將近一兆的營業額。 這麼大的活動自然需要有大量的廣告及圖片推動產品的銷售，上千億張的廣告圖片等待產出，必然需要大量的人力來處理。但在 2017 年開始，阿里開發了「魯班」智能圖片產生器，收集資料庫內大量圖片素材中並分析其中的裝飾、配色、構圖，並搭配商品素材自動產生廣告圖，透過深度學習的變化下產生的圖片一般用戶是沒有辦法辨別是自動產出的，僅需要將廣告圖所需的圖片、文案加入，並搭配不同風格變化即可，在 2017 年有 1.7 億張廣告圖是由「魯班」產生。 衝擊在先前的文章其實也有不斷提到「設計規範」，規範本身也是限制設計師行為的工具，為了確保設計結果的可行性，但這樣的過程中設計師也慢慢地轉換回使用相同技法、放置圖文的「工人」，從設計師轉換為「繪製流程圖」的員工（工作是將流程圖依據規範排列出來），那麼也意味著這個流程是否在不久後可能會被類似「魯班」的工具所取代呢？ 當然，這個過程不可能太快，畢竟阿里巴巴的開發能夠帶來大量的利益，一般的中小企業不太可能導入人工智能的方式處理，一方面是成本太高，另一方面則是資料量不足。但可以知道的是未來會出現「通用類型」的商用圖文智能工具，專門來處理重複、簡單的行為。 那麼設計師該如何維持自身的價值呢？ 具備意涵的設計能力智能工具可以辨識畫面構圖、素材、色彩等等，但無法辨識圖片是否具有深層內涵，它可快速排列出具有美感、類似風格、多樣變化的圖片，但無法為任何一張圖賦予「意義」。所以設計師只有排的「美」是不足夠的，還必須思考怎樣讓圖片具有「意義」，讓圖片並非只有圖文的訊息傳遞，還需要帶有機械無法呈現的情感。 訓練 AI 的能力由於 AI 是透過大量資料分析做深度學習，因此「資料來源」非常重要，設計師就必須帶領 AI 創新，瞭解如何訓練 AI 並優化其結果。也如同上面所提的文章一樣，設計師的工作將轉為「學習這套系統（魯班），學習如何訓練機器，同時在美學方面做把控」 分析使用者體驗的能力除此之外，設計師也能做橫向的發展，以視覺為基礎研究使用者的行為，藉此優化人或 AI 所沒有涉及的部分。AI 雖然有極高的效率，但畢竟是由現有的資源做分析，也就是當現有資料具有盲點時 AI 不一定能夠修正，此時必須回到人本身具有的彈性思維。 所以接下來大家更不需要擔心被稱為「美工」，因為這類型的工作將被 AI 所取代。反之，設計師應不斷的學習，避免自己只有在重複的行為上工作。 結語這是第五次參加鐵人賽了！先前的鐵人賽都是撰寫技術相關主題，本次是回到設計的內容，其實撰寫的過程中才發現久沒接觸確實生疏了許多，也包含不少設計觀念其實有些修正，必須重新翻閱文件才能了解 orz。 不管如何，這次也是順利完賽，在此也獻給許多想要進步的朋友們，只要挑戰完 30 天該技能就能突飛猛進，寫文章並非是要寫給他人，更重要的是挑戰自我。最後列出本次的所有連結： 網頁設計基本概念 前端「設計」聖光之路 別使用平面繪圖軟體繪製 UI 設計 設計師思維及工程師思維 網頁設計常用格線系統(上) 網頁設計常用格線系統(下) 文件、規範參考 - Material Design 色彩運用 網頁設計色彩配置概念 你的網頁文字是否足夠清楚呢？ 連結的配色 按鈕的配色 字體 系統字體介紹 網路字體運用 文字大小、行高與空間上的關係 圖片 圖片格式的運用 圖片壓縮方法 SVG 輸出注意事項 Icon fonts 的常見資源 響應式圖片選用技巧 版面 版面視覺動線配置(1) 版面視覺動線配置(2) 規範 網頁設計規範 - 參考來源 一致性的距離（計算方法、水平、垂直） 定義不斷出現的網頁元素 通用視覺效果 其它 實際透過工具測量用戶行為 設計師與開發者的溝通工具 設計「參考」資源 設計「素材」資源 平面設計師轉設計前端的經驗分享 設計的過去、現在、未來","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 平面設計師轉設計前端的經驗分享","slug":"design-to-developer","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T03:30:19.657Z","comments":true,"path":"design/2018/11/12/design-to-developer/","link":"","permalink":"https://wcc723.github.io/design/2018/11/12/design-to-developer/","excerpt":"","text":"平面設計師轉設計前端的經驗分享一開始的文章有提到，我原本也是從事設計，出社會以後開始轉往開發者。學習到目前也能開發到後端（還不會提到是全端工程師，畢竟術業有專攻），學開發觀念與過去學習設計有非常大的差異，也會不斷地反思過去設計思維的價值。 為何要從設計轉前端？原因很簡單，設計師的薪資普遍低於開發者。這也並非台灣特有現象，而是商業的上設計和開發本質就有很大的不同。設計主要的收入都是以專案為概念，雇主或業主提出一個設計案，設計師來完成它，這個過程中設計師是很難主導商業價值的（但並非沒有，產品設計師、漫畫家、插畫家也有很多成功的案例）；相對的，開發則不僅限於專案，開發者較能夠自行主導屬於自己的商業模式。 在學期間就已經開始轉往開發，雖然是 Flash 不過也對於程式碼有基礎的概念（雖然出社會後 Flash 就死掉了），過程中我所學習的是 ActionScript，這個語法是基於 ECMAScript 的標準開發的，因此與 JavaScript 接近許多，出社會後就持續往前端的路邁進。 這之中學到了什麼？轉往開發者的路上也是跌跌撞撞的，運氣不錯的是那幾年「前端」一詞才剛出現，進步上比較能有成就感（薪資 :D），但相對來說資源就會缺少很多，許多技術在研討會聽過，但是周遭能夠找到可詢問的人幾乎沒有，只能自己上網埋頭研究。 這個過程中，剛好廖洧杰創立了「高雄前端社群」，大家還不熟的情況下，也就硬著頭皮上台介紹了幾次，每次簡報都是先挖坑再跳入研究，反覆幾次以後大家就以為我會的不少，但其實也才剛學而已（遮臉）。因此，從中體驗到了挖坑、分享是加速學習的方式，如果要更快則是要增加頻率，後來自己挑戰了連續 100 篇發文，當時 IThome 鐵人賽也剛好開始，在那之後就陸陸續續參加了好幾屆。 這種學習方式是「設計」領域學不到的，設計領域重視創意、概念、自我，而開發領域重視執行、學習、共享。 學習上的建議由於體驗了兩個不同領域更能了解兩個領域間思維上的差異，同時能使用設計師語言與設計師聊天（你才美工、你全家都美工），也能使用資料邏輯和工程師打屁（幫我從第零個衣櫥裡拿衣服）。這段故事也分享給許多人知道，畢竟很多設計師因為現實的原因想轉行到 UI 或工程師，以下分享一些學習上的概念： 分享，是最佳途徑工程師學習時，會建議不斷的分享過程，這會有助於獲得階段性成就，並且在為了分享的過程中，會將細節觀念看得更透徹並將其轉換成文字，所以自然能夠學得更有效果。 學習並掌握一個技巧需要花上不少時間，過程中的煎熬不一定每個人都能體驗其樂趣，但透過階段性學習的分享，會較容易從中獲得成就感。 另外提到，因為寫了不少文章，每日流量也在千人上下，就順手置入廣告於部落格之中，開始做了廣告版面的一些實驗性功能…（地方開發者需要贊助 :D）。 學習不是一時的在轉行的過程中，總是會想選擇一個一勞永逸地工具或方向，比如說前端框架或語言只想挑一個學習，想使用同一個技術挑戰十幾年，但就目前開發領域的高速成長來說是不太可能的，許多技術出現兩三年則沒落。 可能會去想這樣不斷追新技術不就太累？其實不斷的學習過程中，就會不斷的累積基礎概念，接下來厚實的基礎概念就會有助於學習更新的技術，且不斷學習新技術也是開發者的優點及價值，讓開發者更容易適應新事物及學習新觀念。 結語作為設計師轉行開發者，價值觀會有明顯的變化，許多是直接顛覆過去學習設計的思維及價值觀，過程中也會不斷審思過去價值觀是否正確，而這個過程給予想轉工程師的設計師自行從中學習體驗，也歡迎私下與我分享你的過程喔。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 設計「素材」資源","slug":"design-material","date":"2018-11-10T16:00:00.000Z","updated":"2018-11-12T03:31:24.136Z","comments":true,"path":"design/2018/11/11/design-material/","link":"","permalink":"https://wcc723.github.io/design/2018/11/11/design-material/","excerpt":"","text":"做設計總少不了一些圖庫當資源，圖庫資源在網路上非常多，無論免費、付費都可以找到不少，但是設計師在執行時，通常只會挑用一些偏好使用的站點來運用，以下介紹我在開發時比較常利用的素材網站。 素材也有區分類別，先前有介紹的網頁圖示、字體重複的部分就不再列出，本篇另外介紹點陣、向量、日文字體、短影片等幾個類別。 點陣素材一直以來我都是以向量為主做設計、開發，點陣素材如果需要自己來就需要透過攝影，但這個領域已很久沒有接觸，且好的照片並不是那麼容易可以拍出來。 近期最長參考的點陣素材是 Unsplash 這個服務，它所提供的攝影圖片品質 “極高”，且圖片皆是免費並可以做商業運用，在挑選圖片時總是會先逛逛這個站點。 https://unsplash.com/ 雖然 Unsplash 非常好，但同時也變成他的缺點，當需要找一系列的圖片時，就會較難找出相同風格、相同情境的，當一些特定系列圖片就會參考其它的素材網站。 https://stocksnap.io/ https://www.photock.jp/ 以 Photock 來說，搜尋「桜」就會出現許多品質、風格相近的櫻花圖片，Unsplash 則會接近於藝術照。 向量素材大部分向量素材都是需要收費的，而向量素材更重要的是需要一系列的風格，透過付費較能一次取得大量相同風格的授權圖。目前較常使用的是 Flaticon，主要是它另外有提供應用程式，可以直接搜尋圖片並將圖片拖拉至 Illustrator 或 Sketch 等繪圖軟體（剛剛看了一下只有支援 MacOS）。https://www.flaticon.com/ 如下圖，可以直接在應用程式內搜尋圖示並直接加入到繪圖軟體內，如果需要系列圖片，也可以在 Flaticon 網站上搜尋後加入收藏，應用程式也能直接取用。 很多圖片是免費使用的，但是付費的通常都比較精細 :D。 日文字體由於中文字的開發成本高，加上繁體字的用戶只有台灣及香港，所以大多中文字都是需要付費。而「日本漢字」是從繁體中文演化而來，如果需要一些特殊的字體不妨可以參考「日本漢字字體」。 https://www.freejapanesefont.com/ https://fontbear.net/ 優點是風格特殊，但由於不是純中文字體，所以經常會有缺字的問題，此時就只能換詞或是乖乖換回中文字體使用。 影片素材網頁一進入後就展示「全螢幕影片」相對於「靜態圖片」是更吸引人的。但影片素材處理相對複雜，Coverr 就是專門提供免費全屏影片的服務，並且會附上全屏所需要的 CSS 及 JS（但 RWD 支援性還需要自行調整）。 https://www.coverr.co/ 素材網站也會隨著不同工作、經歷不斷地調整選用，過去我還會使用經典「書法字體」，並將歷代書法家的字體轉為向量圖運用，不過現在這類型網站較無維護，加上日文字體相對方便許多，所以就沒有再使用了。 以前學習設計時還有剛出社會的幾年，其實不太喜歡用素材，主要原因如下： 素材資源難以統一 素材資源不一定能夠搭配目前設計 用了素材感覺自己的設計就不是自己的 前面幾個其實是次要原因（但目前還是有此狀況），過去接受美學訓練時，都不斷強調自我的重要性；而在慢慢轉變到工程師後，這樣的思維就不會那麼強烈，因為工程師是偏向共享，這樣的理由下慢慢說服我自己去運用素材，加上後來工作需要加速完成商業運作，與程式碼品質的衡量下就選擇直接使用現有素材。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 設計「參考」資源","slug":"design-reference","date":"2018-11-09T16:00:00.000Z","updated":"2018-11-10T08:14:54.946Z","comments":true,"path":"design/2018/11/10/design-reference/","link":"","permalink":"https://wcc723.github.io/design/2018/11/10/design-reference/","excerpt":"","text":"開始執行設計時，除了要明確了解目標外，另一重點則是需要大量的想法及設計參考，假設需要製作遊戲類型的網站，那麼就需要先了解該類型的風格、配色、變化性等等，缺少這些參考也會難以動手開工。本篇列出經常搜尋的網站，以及這些網站的特性和參考點。 Behancehttps://www.behance.net/ Adobe 旗下的作品張貼網站，相當中規中矩的呈現各設計師作品，上方也可以透過搜尋的方式找尋特定類別。進入作品頁面後會以「專案」來呈現，呈現出作者、點閱人數、推薦人數、使用的工具等訊息。 也可以進入特定設計師、團隊的頁面內，參考特定作者的作品。 Dribbble基本的功能上與 Behance 很接近，近期流行的圖、火紅的設計師、團隊等等過濾方式皆有，不過 Dribbble 我喜歡的點在於它可以使用 “色彩” 作為搜尋的方式。如下圖，每個作品他會抓取部分重要的色彩，如果想看該色彩的延伸作品，點擊後就會出現該色系相關作品。 Pinteresthttps://www.pinterest.com/Pinterest 是 「pin」及 「Interest」兩個單字組成的，白話的意思是釘選有興趣的作品，因此該網站需要註冊登入才能使用，也是因為會主動推薦用戶可能感興趣的作品。 使用搜尋後，他會跳出更多的「詞彙」，試著找尋用戶有興趣的內容，當然接下來的搜尋、釘選都會有助於 Pinterest 提供正確的圖片。 Collect UIhttps://collectui.com/designs這是一個大雜燴收集的網站，圖片都是來自於 Dribbble 上被推薦的內容，在前期沒有特定想做的風格，會先來這個網站找尋想要的「靈感」，有些方向後再去其它網站逛逛。 品牌設計規範http://findguidelin.es/有些時候需要要找各大「經典」來參考時，像是 Airbnb、Facebook、Dropbox、Uber 等等，突然想參考時 Google 也不一定能搜尋到，這時候 FindGuildlin 就打開直接看吧～。 實際網頁參考最後，列出會特別收錄優良作品的網站，像是 Awwwards 及 CSSDA 就會收集國際上優秀的網頁設計作品，並頒發獎章給予該網站。 https://www.awwwards.com/ https://www.cssdesignawards.com/ Onepage 則是收集單頁類型網站，其中包含許多視差滾動的技巧。 https://onepagelove.com/ Mediaqueri 目前較無更新，但再響應式網站剛流行時就很參考這個網站，技巧都很基礎，重點是放在 RWD 的排版上。 https://mediaqueri.es/ 本篇重點在尋找靈感，這些也是常用來搜尋靈感的網站，下一篇則會介紹搜尋「素材」的資源，歡迎大家隨意收錄。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 設計師與開發者的溝通工具","slug":"communication-tools","date":"2018-11-08T16:00:00.000Z","updated":"2018-11-12T03:31:04.887Z","comments":true,"path":"design/2018/11/09/communication-tools/","link":"","permalink":"https://wcc723.github.io/design/2018/11/09/communication-tools/","excerpt":"","text":"溝通非常重要，不好的溝通不只沒有效率，也會造成不同領域間的嫌隙。如同設計師跟業者索取素材資源時，業者提供的是低解析度的 word 檔案，也很難解釋什麼叫做更高解析度的圖片！設計師對上工程師也是相同道理，如果給予的是 .ai、.psd 檔案，工程師會難以從中獲得執行所需要的資訊（需要另外學習如何操作）。 本篇就提供一些好用的工具，讓工程師與開發者可以了解設計師的規範，並且可以即時回饋讓設計師便於修改。 Markmanhttp://www.getmarkman.com/ Markman 是中國廠商開發的 UI 標示工具，可以用於「輸出後」的圖片，只要透過簡單的拖曳就能標記出色彩、距離、輔助說明等，操作上簡單易用。由於是運用在輸出後的圖檔，所以無論是哪一種繪圖軟體都可以搭配運用（另外支持 PSD）。 Sketch Zeplinhttps://zeplin.io/ Zeplin 最早是 Sketch 的擴充功能，目前還支援 Photoshop、Illustrator 等繪圖軟體，算是真正整合設計軟體、設計規範、工程師協作的工具，透過 Zeplin 設計師可以一鍵輸出所有的設計規範，且不需要另外標示尺寸、色彩等。 工程師可以透過該工具直接取得所需要的資訊，如尺寸、間距、色彩，這讓畫面不至於因為過多標示感到凌亂，也能得以呈現更多的資訊。不僅如此，開發者也可以依據所開發的平台（Web、iOS、Android）從中取得所需要的程式碼。 Zeplin 官網有詳細介紹：https://zeplin.io/why-zeplin過去寫過的相關文章：https://wcc723.github.io/tools/2015/04/09/zeplin-intro/ Adobe XD Spec範例設計稿：https://lihi.cc/LAfsC介紹說明：https://helpx.adobe.com/tw/xd/help/design-specs-for-developers.html Sketch 並沒有屬於自己的規範工具（類似 Zeplin 那種），而 Adobe XD 則是有推出 Spec 工具，只要有付費 Adobe CC 都可以直接運用，目前雖然功能並非如 Zeplin 那樣的完整，但在 Web 開發上也是相當足夠使用。 基本的間距、尺寸、色彩資訊皆有呈現。 另外也有討論工具。 SlackSlack: https://slack.com/台灣聊天使用的是 LINE 工具，除了閒聊外還有完整的表情圖片可以運用，非常適合抒發情緒。但在開發上還是建議使用工作用的通訊工具，主要是對於開發有完整的支援性，另一方面也可暫時關閉閒聊用的通訊工具，確保工作上的專注力。 與一般通訊工具一樣，基本的留言、搜尋都沒有問題，除此之外也有重點字詞標示、子討論項目等功能，且可以與各大現有的服務做整合如：Github、Google Drive 等等，使資訊更新時 Slack 都能及時收到。 整合 Adobe Creative Cloudhttps://slack.com/apps/A7P35MCT0-adobe-creative-cloud 透過 Slack 不僅可以傳遞規範網址以及預覽，也可做到設計師更新規範時，Slack 會即時收到規範已更新的訊息。 Dropbox Paper為了不讓 Sketch 專美於前，Adobe XD 不僅有類似於 Sketch 的功能，且還與各大廠商合作（如前面所提到的 Slack 服務），Dorpbox Paper 則是整合文件與 Adobe XD Spec 的功能，使匯出的規範連結貼入 Dropbox Paper 時能夠直接預覽。 詳細說明：https://blogs.dropbox.com/dropbox/2018/10/adobe-xd-dropbox-paper-integration/ 結語好的工具不僅可事半功倍，用在溝通上也可以增進感情，身為設計師不喜歡收到解析度不足的檔案，工程師也希望能夠收到標示明確的文件，本篇介紹的工具都不需要花費太多精力就可以使用（但可能需要花點＄），如果有更好用的工具也歡迎在下留言讓我知道。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 實際透過工具測量用戶行為","slug":"funnel","date":"2018-11-07T16:00:00.000Z","updated":"2018-11-09T03:03:00.494Z","comments":true,"path":"design/2018/11/08/funnel/","link":"","permalink":"https://wcc723.github.io/design/2018/11/08/funnel/","excerpt":"","text":"開發、設計時我們會盡可能站在用戶的導向做思考，當中也會腦補許多行為，如： 字要小才會顯得精緻 輪播 Banner 很吸睛，最新消息放在上面大家都會看 說明要拆很多頁，用戶不喜歡同一頁滾太久 相信以上範例在目前網頁已經少見很多，畢竟這些都是經過許多前人的研究調整而成。但身為設計師，多少都會想透過不同的視覺調整，嘗試是否能夠做出更好的使用者體驗，本篇就透過一些工具介紹，讓大家了解如何「觀察」使用者的體驗。 用嘴巴問!?一個畫面做出來，總是可以透過詢問同事、朋友的方式，了解該畫面是否好看、好用等等，但訪談本身也是極需專業及技巧，如果沒有許多事情準備很難有足夠效益，缺乏正確準備的詢問可能具有以下的問題： 對設計師的情感了解詢問大多會從週遭的人開始，周遭的人也對於設計師、開發者有基礎的認識，此時回答的內容就會受到情感的影響，比如說：友好的稱讚、習慣性的酸言酸語，而這些對於使用者體驗調查本身並沒有任何幫助。 對於詢問內容已有基本的了解接下來，詢問的過程中總是會先介紹問答的目標，也就是目標對象是在「有心理準備的情況下」接受檢測，那麼大部分的行為將不具有參考性，因為真正的用戶並不會有「被觀察」的感受來使用網站。 受眾、用戶可能並非真正網站使用者再者，詢問的對象大多是與自己生活相仿的對象，例如：都居在相同都市、年齡接近、生活習慣接近、價值觀差異小。不同背景、價值觀的人們在瀏覽網站時的目標也會不同。 如：嬰幼兒商品網站，那麼身為媽媽所觀察的點就不會是只有價錢，而是會仔細看產品本身是否能解決他的問題，相關評價是否優良等等，但如果是其它人可能會關注在價格、Banner 的媽媽很漂亮、嬰兒圖片可愛等等。 使用者體驗漏斗如果用戶是具有心理準備下接受訪查，那麼行為將不具有真實性（如：男性受訪者如果看到正妹圖，大多假正經會先跳過不去點擊）。反之，真實的行為是更有價值的。 試著想像：用戶在家中使用電腦時，因為其他人推薦的服務有興趣，不看任何文案、描述立馬按下註冊的情境，但註冊的過程擁有許多關卡，最後一關必須要填寫信用卡才算完成，立馬關閉視窗結束瀏覽… 上述的過程包含了： 進入導覽頁面 點擊註冊 註冊流程填寫資訊 填寫信用卡 註冊完成（假設這步驟有完成） 身為設計師或開發者，就必須從這個流程中尋找問題，這個流程我們會稱為 Funnel（漏斗），上層進入的人數會很多，過程中會不斷流失人，這個形狀就類似漏斗。 會先假定一個目標，接下來列出達到該目標會遭遇到哪些行為，接下來透過工具觀察每個行為的數據，是否在哪個階段有大幅的減少。 工具GAGA 是 Google 旗下的一個服務，大多開發者都會安裝用來監控流量來源、用戶裝置、用戶所在地區等等…，而他也有提供「增強型電子商務」，透過電商的成效呈現 Funnel 數據，不需要額外費用就可以導入 Funnel 的觀念。 MixpanelMixpanel 優點是可以隨著開發者自定義追蹤行為，所以也可以隨著需求調整需要用於各種成效追蹤，如：註冊、購買、填寫表單等等，對於 Google 所提供的 UTM 追蹤碼也能自動套用，所以除了能夠了解 Funnel 成效，更能透過用戶「來源」分析不同用戶的成果。 HotjarHotjar 也同於上述的行為追蹤工具，但更大的特色是可以做到「側錄」，了解每個用戶在網站上的行為軌跡，更能了解用戶操作上是否真的如預期活動。 另外，Hotjar 也能依據使用者點擊的數據產生熱圖，透過此熱圖也能測試各種「詞彙」對於用戶心裡成效的分析（究竟是 “免費” 吸引人還是 “註冊”）。 結語使用者體驗一直是受到重視的議題，好的使用者體驗能將導入的成效翻倍，但另一方面使用者體驗本身也需要大量的「數據」作為支持（沒有量，翻倍也是徒然）。因此關注使用者體驗前，也需要多重視產品本身的價值。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 通用視覺效果","slug":"styleguide-4","date":"2018-11-06T16:00:00.000Z","updated":"2018-11-07T03:24:04.182Z","comments":true,"path":"design/2018/11/07/styleguide-4/","link":"","permalink":"https://wcc723.github.io/design/2018/11/07/styleguide-4/","excerpt":"","text":"規範定義除了元件設計、空間、格線等等外，另外還有經常重複使用的樣式也能夠被預先定義，比要常見的視覺效果如下： 圓角 邊線粗細、邊線色彩 陰影 背景圖樣、裝飾 圓角圓角就有點類似於明體、黑體之間的關係，黑體與明體會有兩者截然不同的個性，明體讓人感受具有人文、藝術氣息；黑體則讓人感受具有科技、現代感，圓角亦是如此，且可以隨著不同的圓角尺寸有著不同感受。如無圓角如同黑體，具有科技、現代感，但同時讓人感受較無情感，反之大圓角則讓人感覺更易於親近。 然而選擇哪一種都應該延續相同的視覺效果，並延伸到所有的視覺元件上。 下圖：這是不好的示範，圓角沒有固定的運用，無法維持一致性的視覺體驗。 陰影陰影在 Material Design 中不斷提到，他是一個呈現「深度」的好技巧，具有相同深度的物件會讓人感受到相同的重要性。 前文所提到的深度：https://wcc723.github.io/design/2018/10/19/grid-system-2/ https://material.io/design/environment/light-shadows.html#shadows 因此，設計時也可以使用不同級距的陰影，表現出不同重要性的元件，當然這些依然要維持固定的級數。 雖然些許差異的陰影變化是難以察覺的，但會增加開發上的許多困擾。 邊線邊線是色彩、線條的延伸，套用在元件的邊緣，邊線運用上特別要注意元件與元件的接合性，因為邊線本身具有空間，所以當並排、小距離間隙邊線的呈現都要注意。究竟是要完全相合、色彩變化差異等等。 結語這些樣式經常會重複定義，且會應用在元件上或網站上的各個地方，就如同是字體一樣，這些通用視覺效果也應該需要被預先定義，避免每次運用只有些為落差，但卻沒有一致性的視覺效果。 這些效果並非是獨立的元件，並沒有實際外觀，但這樣的預先定義有助於統一樣式，以一個卡片來說如果沒有共用的邊線粗細、色彩、陰影等等，視覺感落差就會很大，而這些視覺感受同樣會延伸到其他元件上。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 定義不斷出現的網頁元素","slug":"styleguide-3","date":"2018-11-05T16:00:00.000Z","updated":"2018-11-06T02:28:09.797Z","comments":true,"path":"design/2018/11/06/styleguide-3/","link":"","permalink":"https://wcc723.github.io/design/2018/11/06/styleguide-3/","excerpt":"","text":"定義玩基本要素如文字、色彩、空間等等後，就可以開始定義常用的「元件」，而每一種應用程式、環境都具有固定會不斷出現的 UI 元件，如桌面系統的應用程式會有固定的導覽列、關閉縮小視窗的控制項及固定的外框，雖然這些也是能夠調整，但調整的同時也意味可能會影響操作體驗。 網頁設計、行動 APP 也是如此，本身都會具有固定的 UI，這些 UI 對於一般用戶來說是很容易理解使用的。 表單元件預先設定元件的目的，不外乎是在設計前預先準備完成，限制後續設計的變化，但同時增加開發速度，因此預先定義的元件樣式盡可能可以符合所有情境。當然，最重要的是能夠符合網頁開發的標準。 表單結構在 HTML 中的表單結構如下：form div label Email address input(type=&quot;email&quot; placeholder=&quot;Enter email&quot;) div input(type=&quot;checkbox&quot; placeholder=&quot;Enter email&quot;) label checkbox button(type=&quot;submit&quot;) 最基本的會有一層 form 標籤，表示其內部是需要送出的表單內容（所以表單內容是被限制在 form 區域內），內部會有 label 及 input 對應，label 表示該 input 所需要輸入內容的說明，input 則是用戶實際輸入的內容，兩者會透過 id 互相對應（這屬於前端技術，在此不多介紹）。最後會再補上一個 button 作為最後送出的按鈕。 透過以上的結構可以得到以下的畫面，這也是大家所熟悉的網頁表單，以下我們就針對常被忽視的設計來與大家說明： 缺少 Label雖然網頁中沒有 label 表單依然可以正確運作，但依據網站親和性的概念（label），缺少 label 會難以讓裝置了解該欄位的名稱及用途。 checkbox 及 radio現在 Checkbox 及 Radio 的外觀都能夠客製化，但做這樣的調整時必須確保： 大部分瀏覽器看起來是一致的 不會影響到用戶的操作經驗 如果有搭配 JS，請確保在各種情境下都能運作 不同類型的 inputinput 的類型非常多元，正確地運用可以減少開發者的負擔，並且增加對於行動裝置的支援性。以 type=”date” 來說，Chrome 瀏覽器就會跳出一個行事曆，在行動裝置上用戶就會跳出日期選擇器，而跳出的行事曆是固定外觀不能做樣式的調整。如果要追求符合品牌的外觀，請務必同時兼顧行動裝置的使用體驗。 除此之外，有部分的 input 類型是可以自定義外觀的，如：type=”range”、type=”file”（嚴格說起來 file 也不太修改，但還是有方法）。因此需要先認識所有類型的 input，並預先設計可能會使用到的類型。 提示文字input 中還有一個 placeholder 的屬性可以作為用戶填入文字前的提示，這通常是利用填寫前的提示，另外也可以在 input 下方加上提示文字，這會偏向填寫時或填寫後的提示。 不管如何，請別忘了還有提示文字需要被設計。 與 Button 可以併排設計時，也盡可能與 button 一同設計，因為會有不少情境是兩者併排出現的，如果不能併排還挺尷尬的。 禁用、錯誤狀態最後提醒，設計規範是預先定義所有會利用的情境，所以禁用、錯誤雖然設計中不一定會出現，但請確保工程師執行時能夠了解該外觀為何。 結語定義規範是相當辛苦的，必須熟悉網頁基本運作流程，還要預先思考可能會運用的情境，但有了固定規範後工程師能夠先以規範定義元件庫，設計師更能快速建構頁面所需的內容。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 一致性的距離（計算方法、水平、垂直）","slug":"styleguide-2","date":"2018-11-04T16:00:00.000Z","updated":"2018-11-05T03:48:04.934Z","comments":true,"path":"design/2018/11/05/styleguide-2/","link":"","permalink":"https://wcc723.github.io/design/2018/11/05/styleguide-2/","excerpt":"","text":"一開始的文章有介紹到格線系統，主要是針對水平欄位空間的介紹，而其實垂直空間也是需要有固定的間距，當然一方面是有一致的美感，另一方面則是讓開發者設定全網站可用間距時可以統一帶入。 本篇主要會針對兩個部分做介紹，一是如何定義間距，另一則是針對運用上的介紹。 定義間距（5 的倍數、以文字大小） 統一的運用（文字段落、小元件空間、大區塊的間隔） 定義間距雖說間距需要定義固定的數值，但至於如何定義其實沒有完全固定的規範，如果定義出 2, 4, 6, 8, 10, 12… 等所有雙數數值也算定義，但這麼細的數值再運用上其實非常不便，在此列出常見的定義方式給大家參考。 整數的倍數大多設計師會有個習慣，就是會將色碼、字級等數字抓成整數，如過去使用 CMYK 時，就會習慣 5, 10, 15 的數字依序做色彩定義，字級也會使用雙數 2, 4, 6, 8, 10 等等…。 這個概念也依然可以運用在網頁設計上，可以預先定義一套固定級數的間距作為使用，如：5px 10px 15px 20px 30px 45px 60px 接下來所有的網站也都會用這些數值來設計，並且避免使用到 3, 6, 7, 8 這些未定義的數值。 文字的級數另一種常見的定義方式則是搭配 rem，在 Bootstrap 中就是依據這種級數來做定義，且目前的網頁文字大小大多都以 16px 做為預設，因此延伸的級數則會有以下定義：0.25rem -&gt; 4px 0.5rem -&gt; 8px 1rem -&gt; 16px 1.5rem -&gt; 24px 2rem -&gt; 32px 3rem -&gt; 48px 這種定義方式對於設計師來說沒那麼好理解，但對於工程師來說卻能夠有延伸的運用，假設網站類性不需要 16px 大的文字，他可以調整成 14px，那麼整體的間距也會跟著調整成如下： 0.25rem -&gt; 3.5px 0.5rem -&gt; 7px 1rem -&gt; 14px 1.5rem -&gt; 21px 2rem -&gt; 28px 3rem -&gt; 42px 以上兩種開發中都是很常見的，而設計師僅需選擇其中一種，並與開發者協調好即可（設計圖目前還沒有辦法透過統一設定調整畫面間距）。 統一的運用定義好的間距會視設計需求來調整，但基本上還是會維持小空間使用小間距、大空間維持大間距的概念，如按鈕與按鈕之間就會避免使用 3rem 這種尺寸，而兩個大 section 之間當然也不會只使用 1rem 來做區隔，以下就依據一些常見情境作為範例： 元件之間元件之間盡可能用小數值的間距做設定，透過此方式能夠維持相關內容依然視為一個群組；反之，過大的空間會使群組的觀念被打散。 元件與外層區塊元件與外層區塊雖為同一個群組，但外層區塊大多是背景或單色，不具有訊息內容，因此有些距離更能保持美感。 區塊與區塊區塊與區塊之間就是明確的不同訊息內容，因此要使用更大的空間將群組隔離，避免造成不同的訊息混淆。 如 Evernote 網站就透過垂直空間、背景色彩、排版的差異，將不同訊息的群組明確分離開。 Evernote: https://evernote.com/intl/zh-tw 結語好的空間定義，具有以下特點： 一致性：就算內容改變，全站依然維持相同的空間邏輯 視覺群組：適當的空間區分內容 可被開發運用：具有固定的數值，且是明確具有邏輯，使之便於開發合作 因此，建議設計師會預先定義好所需運用的間隔尺寸，接下來再設計時也便於方便取用，避免開發好幾頁後才發現空間間隔不一致。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 參考來源","slug":"styleguide-1","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-05T03:37:00.220Z","comments":true,"path":"design/2018/11/04/styleguide-1/","link":"","permalink":"https://wcc723.github.io/design/2018/11/04/styleguide-1/","excerpt":"","text":"網頁設計許多概念是受到限制的，因為除了設計外也要同時重視可行性，因此預先定義規範不僅預先了解可執行的限制，對於工程師來說更方便預先建構元件。 但設計規範並不是一件容易的事情，同時必須在意可行性、延展性、穩定性。 可行性：確保規範是可以被執行的 延展性：未來的更新是有預先規劃的 穩定性：不可隨意進行破壞性更新（break change） 本篇提供一些概念給予參考，讓還沒有想法的設計師了解可以從何取得資源，並且慢慢著手加入設計規範。 BootstrapBootstrap 官網：https://getbootstrap.com/繁中版：https://bootstrap.hexschool.com/ Bootstrap 是網頁使用的 CSS 函式庫，內建許多現成樣式可以直接運用，讓不熟 CSS 或設計的開發者都可以做出一定品質的網頁，是目前使用最為廣泛的 CSS 函式庫（沒有之一）。 雖然他預先定義的樣式不一定被設計師所喜歡，但卻是非常標準、符合網頁開發原則的。以下列的標題字來說尺寸的變化具有一定的級數變化，轉換為網站運用的尺寸也是固定的整數。 先前所介紹的固定尺寸級數，也就是從 Bootstrap 所延伸而來，如果沒有預先定義所有標題級數，後期新增時會出現間距不明顯或間距過大等問題。設計師用的尺寸： 工程師所用的尺寸 16px : 1rem 20px : 1.25rem 24px : 1.5rem 28px : 1.75rem 32px : 2rem 40px : 2.5rem 除了標準的文字、色彩的定義外，Bootstrap 在元件設計上也是用盡心力，如下方的 Navbar 為了定義出多種色彩的變化，它則是將文字的顏色設計成具有「透明度」，使他在不同色彩下都能夠自然的呈現，這樣的概念也可運用於設計之中（變化性不只案例中的三種，而是幾乎所有色彩）。 Adobe XD UI KitsAdobe XD Resource: https://www.adobe.com/tw/products/xd/resources.html Adobe XD 目前在拓展階段，為了整合更多資源提供了 plugins、App internrations、UI Kits、Icon sets 等，不乏與各大企業合作或者整合性的服務，其中的 UI Kits 就有一份完整的網頁設計 wireframe 可作為設計規範（此份規範還不斷再更新中）。 本份文件從基礎的色彩、文字、字體開始，並提供完整的按鈕、表單、卡片的常見網頁元件，還提供大範圍的區塊元素如：頁腳、價格表、結帳頁面、資訊陳列區塊。幾乎可以算是設計軟體版本的 Bootstrap，非常值得參考。 雖然本分設計稿是以單色呈現，但是設想了許多情境非常值得參考，以下方到表單來說就包含未填寫、填寫中、離開 focus、錯誤提示等等，而這也是我們設計表單時經常會忽略的部分。 在這份設計文件中，同樣的目標會提供數種排列風格做變化，以價格表來說就提供了十種變化，下圖節選四種。 Material Design當然，最完整的設計規範還是可以參考前方不斷提到的 Material Design，不僅在應用上有完整說明，還有包含完整的設計理念，有機會可以將整份閱讀一次，對於設計規範會有很多的靈感及想法。 結語進入一個新領域時難以在短時間內就掌握所有細節，最好的方式是透過最佳範例來了解該如何運作，如 Bootstrap、Adobe XD UI Kits 都是很棒的案例，這些都具備了前人實作的經驗，並經歷上千、萬人的驗證。參考這些方式會比閉門造車有更好結果，並且增加設計規範的可行性、延展性及穩定性。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 版面視覺動線配置(2)","slug":"weblayout-2","date":"2018-11-02T16:00:00.000Z","updated":"2018-11-05T03:36:40.179Z","comments":true,"path":"design/2018/11/03/weblayout-2/","link":"","permalink":"https://wcc723.github.io/design/2018/11/03/weblayout-2/","excerpt":"","text":"上一篇介紹了版面配置的概念，其中最重要的是「群組」概念，而本篇就透過實際案例來說明各大網站如何運用這些概念，並且看看是否也有運用到交錯、韻律的手法。 這些概念要特別注意僅適合用在「登入頁」（Landing Page），適合用在產品、服務推廣使用，當然也就不適合套用在應用程式的服務上（如：Facebook、Youtube、Google…）。 首先還是要強調從這些網站中是否可以觀察到「群組」概念，並且觀察是否有相關延伸的概念： 群組交錯色彩 左右韻律排版 範例網站介紹以 Adobe 來說，就是標準運用此概念的網站，群組與群組之間均有套用不同的色彩，並且具有一定的左右韻律。 https://www.adobe.com/tw/creativecloud.html Evernote 亦是如此，也是透過群組式的視覺感來做分組，並且加入些許淺灰、白底的方式來做分類，最重要的是會使用深綠底色來做最重要的行動呼籲（Header 及接近底部的區塊使用綠底，其它部分則不會運用）。 Slack 雖沒有左右的韻律式排版，但依然維持最關鍵的「群組」分類，並且也會使用色彩上的變化區分不同的群組，主色的運用也是回顧到先前色彩介紹的章節，僅運用在最重要的「行動呼籲」之中，畫面中僅有 GET STARTED 會使用主色彩（或主色背景），其餘部分用到的色彩僅有到點綴，並不如主色上的凸顯。 結語本篇是延續上篇繼續介紹排版的技巧，讓一些非本科系的開發者，也能掌握一些基礎概念，排出具有基礎美感及正確的訊息傳遞方法。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 版面視覺動線配置(1)","slug":"weblayout","date":"2018-11-01T16:00:00.000Z","updated":"2018-11-02T03:10:32.284Z","comments":true,"path":"design/2018/11/02/weblayout/","link":"","permalink":"https://wcc723.github.io/design/2018/11/02/weblayout/","excerpt":"","text":"本篇主要是描述網頁「登入頁」（Landing Page），這個頁面是用戶一開始接觸的畫面，雖然這個頁面沒有固定的設計方法，但其實可以從各大網頁尋找到雷同的跡象，本篇就去除掉配色概念，單純就依據視覺動線來做說明。 群組首先，我們還是要提到設計本質為「傳遞訊息」，視覺動線也就是引導用戶了解網頁所需要傳達的訊息，而網頁本身需要傳達的訊息非常多，通常難以用少量文字、話語呈現。就像是業務推廣產品時並不會只問一句：「你要買嗎？」，而是會用不同角度切入說明。 這麼多的訊息內容加到網頁中就容易造成混亂，因此可以使用「群組」的方式來分類訊息；而定義成群組的方法可以運用「相同的視覺感」來做分類，如以下提供幾單的幾種類別給予大家參考（實際上可以運用的當然更多）。 左文右圖的群組（或右圖左文） 三欄式上圖下文的群組 左右圖文連續排列的群組 在不同的排列方式後，自然就會讓人感受到內容上的差異，因此將這些不同的群組排列在畫面上可以得到以下的結果。 此時，群組 2 及群組 3 由於具有「類似的視覺感」，會容易被視為同一個群組，如果兩個群組之間的訊息沒有足夠的關聯性，當缺乏連貫性就如同所謂的「跳躍性思考」，難以吸收前後文的訊息。 交錯式排列此時，我們也可透過顏色交錯的方式，將內容以群組的方式隔離，範例如下，群組 1 及 群組 3 是使用白底深色圖文，而群組 2 則是使用深色底、淺色圖文，透過此方式將內容隔離開來。 這種方式不僅可以增加畫面豐富度及有效群組話訊息，亦可強化品牌色彩。範例中的 群組 2 是使用深色背景搭配淺色文字，實作中也可以使用淺色背景搭配深色字（其它維持白底），僅需要與其它樣式有所區隔即可。 閱讀動向除了群組化，由於現在訊息量不斷地膨脹，人們會不斷增加自己的閱讀速度，因此閱讀時會增快由上而下的速度，並且不斷地左右交錯。因此也可以將此慣性加入畫面中，除了增加閱讀性外，也同時讓畫面更有「韻律感」。 如上圖，我們不僅使用「具有底色」及「無底色」的交錯方式，並且重新調整排版為左右交互的韻律方式，藉此增加圖文的閱讀性。 而網頁中也可以適時的透過少量內容（群組 2 及 群組 3 之間）來凸顯部分訊息，這類訊息通常簡短並具與行動呼籲性（call to action）。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 響應式圖片選用技巧","slug":"responsive-images","date":"2018-10-31T16:00:00.000Z","updated":"2018-11-02T03:10:29.525Z","comments":true,"path":"design/2018/11/01/responsive-images/","link":"","permalink":"https://wcc723.github.io/design/2018/11/01/responsive-images/","excerpt":"","text":"網站上總需要圖片來點綴，除了客戶提供解析度不足的圖片外，我們也看從許多素材網站找到不錯的圖片，而選用圖片除了找到合適主題外，也需要花不少時間來比對是否合適於網站。 本篇依據 CSS 的觀念來提供一些選用圖片的技巧，藉此來減少 25% 搜尋素材的時間。 技術限制響應式圖片運用上與技術限制有很大的關係，其中有兩個要點是必須要注意的： CSS 呈現圖片的方法 裝置尺寸變化 CSS 呈現圖片的方法以下圖來說是一張原始比例的圖片，長寬比約為 960:640，在 CSS 中如果需要限制為正方形的尺寸，常見手法是運用 background-size: cover 或 contain 的方式。 以下兩張圖片則是使用這兩種屬性，而前者是使用 cover，後者則是運用 contain(灰色為背景色彩)，運用上更是 cover 被許多設計師、開發者使用，這種方式盡可能在有限空間中呈現最多畫面。 contain：在有限空間中呈現完整圖片，畫面中的灰色部分則是背景。 圖片來源：https://unsplash.com 裝置寬度由於圖片顯示區域會受到裝置寬度的影響，我們將上述的圖片分別放置在不同的尺寸上呈現，會得到如下的結果。 960 * 450 桌面版畫面：由於這張圖片的配置是屬於水平，且 主體 僅有佔少量空間，在橫向畫面上呈現沒有什麼問題。 360 * 450 行動版畫面：雖然畫面偏向水平，但由於 主體 只有一張椅子，畫面縮小後椅子只要能完整呈現，依然沒有什麼問題。 接下來，我們選用另一張圖片來做介紹： 960 * 450 桌面版畫面：畫面中沙發是主體，完整地在畫面中間，在桌面版沒有什麼問題。 360 * 450 行動版畫面：但由於 主體 是橫式的，在行動版的垂直小空間中就顯得明顯不足，這樣導致了畫面左右方被裁切掉，這樣的圖片就不太合適。 快速驗證方法CSS background cover 方式會盡可能的呈現完整圖片，而呈現的空間是可以再透過 x, y 軸線做定位上的為條（通常預設為中間或固定的四個邊角）。 接下來可以先透過繪圖軟體準備好裁切空間，上面包含了桌面版空間及行動版空間，兩個空間的交疊處則是安全區域。 主體必須比重疊安全區域還要小 桌面版空間可以水平呈現 如下圖，既可以呈現完整畫面，也同時可以測試重疊區域是否有足夠空間。 接下來把裁切區域套用在畫面上即可得到以下結果。 結語視覺也有不同的邏輯，而這個邏輯並非能用程式邏輯完整的解釋，本篇直接透過實際的案例解釋圖片選擇方式，讓大家在選圖上可以節省一些時間。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - Icon fonts 的常見資源","slug":"icon-fonts","date":"2018-10-30T16:00:00.000Z","updated":"2018-10-31T05:10:58.593Z","comments":true,"path":"design/2018/10/31/icon-fonts/","link":"","permalink":"https://wcc723.github.io/design/2018/10/31/icon-fonts/","excerpt":"","text":"網站開發加入一些圖示點綴，除了可以增加網頁的豐富度外，同時可以讓用戶從圖示中了解當下的行為為何。過去圖示大多使用 png 來呈現，具有豐富的色彩及尺寸，但隨著設計的概念不斷調整，現在流行單色系的小圖示，以及為了增加圖示可運用性目前大多使用向量的方式呈現。 接續前文所介紹，SVG 是可縮放的向量圖形，作為圖示運用有一定的優勢，本篇會介紹如何取用向量圖示資源，以及 icon fonts 的運用方法。 什麼是 icon fontsIcon 是圖示，fonts 是字體，兩者混在一起就是圖示字體（被揍 簡單來說，我們平常使用的字體會有外觀上的不同，而 icon fonts 就是使用圖示修改掉特定的字體符號，讓他顯示成不同的圖形。如下圖所示，icon fonts 本質就是字體，也能夠像其它字體一樣安裝於系統中。 實際運用在網頁上時，除了圖形顯示外也同時具備文字的特性，如：可縮放、可改變色彩、可套用文字陰影，且只要載入 CSS 即可運作。技術上來說，大多是透過 修改字體 並從偽元素插入特定的 Unicode 的編碼文字來套用圖示，但也有部分的 Web fonts 是採用其它的渲染技巧。 接下來就能如圖中一樣的顯示這個 icon，並且這個 icon 依然具有文字的特性，可參考：https://fontawesome.com/v4.7.0/icon/address-book FontawesomeFontawesome 是目前使用相當廣泛的 icon fonts，目前版本為 5.4.x 版，而除了 icon fonts 以外，現在更有 SVG 動態插入的方式。 5.x 版本：https://fontawesome.com/4.x 版本：https://fontawesome.com/v4.7.0/ 如果要使用 Fontawesome 的圖示做設計，可以直接點選 For the Desktop 下載圖示，下載後就包含大量的圖示 SVG 可以直接運用。 因為有數千組圖示可以運用，下載後難以從字面上直接了解圖示外觀，建議使用時可以搭配官方的 圖示列表 來快速搜尋，開發者也能夠從中快速了解設計師所用的 icon 為何。 Fontawesome 的圖示也有分為免費與付費版，所能套用的 Web fonts 也有所不同，設計師使用時要特別注意，不過也不得不說，雖然付費版僅是粗細上的不同，但付費版的 icon 還是好看許多 :D。 給予開發者的說明雖然 fontawesome 提供兩種方式運用在 icon 上，一則是本文重點 icon fonts，另一種則是透過 js 來插入 SVG。如果你需要使用 fontawesome 做開發建議使用 icon fonts 的方式載入，如果想改用 SVG 的方式，可能會有動態切換上的問題，建議先讀過官方文件是否有合適的解決方案，並且實際測試後沒有問題再使用。 Google Fontshttps://material.io/tools/icons/ Material Design Icon 也是一種字體 icon，也與 Fontawesome 一樣具有大量的 icon 及搜尋功能，並且是完全免費，但比較特別的是使用「連字方法」來做 icon 的呈現。 連字方法(uses a typographic feature called ligatures)：https://google.github.io/material-design-icons/#using-the-icons-in-html 連字方法的特色在於 Icon 本身依然具有「詞彙意義」，它是透過一個單詞的判別轉為一個圖形，如下圖 icon 除了呈現一個臉以外還具有「face」的辭意，並且可以透過搜尋方式找到這個圖形。 自製 Web fonts雖然上述服務已經提供大量的 icon，但設計中有時還是有不夠用的時候，自行開發 icon 也是個選項，以下我有撰寫過 svg 轉 web fonts icon 的方法，給大家參考看看： 自行開發的方法：https://wcc723.github.io/css/2016/12/13/gulp-dev-env/ 結語Web icon fonts 現在網頁開發已很常見的手法，主要原因是只要一個 className 就能輕鬆運用，當然現在也有 svg icon 的運用方法，但相對於 web icon fonts 來說還沒那麼流行。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - SVG 輸出注意事項","slug":"image-svg","date":"2018-10-29T16:00:00.000Z","updated":"2018-10-30T02:40:35.766Z","comments":true,"path":"design/2018/10/30/image-svg/","link":"","permalink":"https://wcc723.github.io/design/2018/10/30/image-svg/","excerpt":"","text":"向量工具、Adobe XD、Sketch 也都能夠輸出 SVG 圖片，但在輸出時有些小地方也需要注意一下，避免在本地端看似沒有問題，但用戶卻看到的卻與預期不同。 首先瞭解一下 SVG 本身其實是 XML 格式的檔案，這是一個類似 HTML 格式的結構標記，如果要繪製一個方形，則會使用 &lt;rect&gt; 的標籤，並定義他的座標、尺寸、填色樣式等等。 &lt;!-- SVG tag --&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;100%&quot; height=&quot;120&quot;&gt; &lt;!-- 矩行 tag --&gt; &lt;rect x=&quot;2&quot; y=&quot;2&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #333; stroke-width: 3; fill: MediumTurquoise;&quot;/&gt; &lt;/svg&gt; 接下來就會出現如下的矩形。 SVG 一些常見的圖形原始碼可以 參考。所以 SVG 輸出後與其它的圖片有很大的不同，他依然是透過一些文字標記組成，再有了基本了解後，我們再透過這些觀念了解輸出的圖片為什麼可能出錯，以及怎麽從輸出後的原始碼發現錯誤。 文字務必轉外框我們在印刷時，給予印刷廠檔案的文字都會外框筆畫，為的就是避免印刷廠沒有特定的字體，導致字體的顯示與預期並不同。 以下圖來說，「Sweetaste」有分為上方的外框字體，下方則是純文字。上方的輸出後會以 “路徑” 的方式來繪製，從圖中可以看到文字周圍都是點與線的結合；而下方的文字則是純文字，只有一條下底線表示而已。 外框字體的原始碼如下，都是由 path 標示路徑組成（下述程式碼參考即考）：&lt;path class=&quot;cls-2&quot; d=&quot;M55.48,40.91H56A6.11,6.11,0,0,0,55.48,43c0,3.28,3.49,5,6.15,5,4.22,0,6.66-2.34,6.66-5.76a5.72,5.72,0,0,0-2.16-4.46l-2.55-2.34c-2.27-2-3.56-3.93-3.56-6.55,0-3.93,4.17-7,9.32-7,3.13,0,4.68,1.3,6.3,1.3a1.28,1.28,0,0,0,1.29-.94l.54.11L75,29.25h-.43a7.21,7.21,0,0,0,.32-2.13c0-3.31-3.2-4.71-5.54-4.71-3.17,0-5.51,1.76-5.51,4.42,0,2.24,1.3,3.64,2.74,4.94l3.2,2.88c1.73,1.54,3,3.09,3,5.79,0,4.07-4,8.06-10.9,8.06-4,0-5.15-1.47-7-1.47a1.43,1.43,0,0,0-1.37,1.15l-.51-.11Z&quot;/&gt;&lt;path class=&quot;cls-2&quot; d=&quot;M90.54,48.22A3.24,3.24,0,0,0,91,46.56a4.9,4.9,0,0,0-.64-2l-.94-2c-.22-.47-.43-.94-.61-1.41-.69.65-1.4,1.23-2.09,1.77l-1.8,1.47c-1.11.94-1.73,1.48-2.45,2.2a10.23,10.23,0,0,0-1.58,1.91l-.43-.25a3.34,3.34,0,0,0,.43-1.66,4.76,4.76,0,0,0-.65-2l-.93-2a8.76,8.76,0,0,1-1-3.35c0-2.52,1.88-4.75,4.4-6.77l.72-.57.32.39a5.58,5.58,0,0,0-2.12,4.5c0,1.62,1,4,1.8,5.62a5.76,5.76,0,0,1,.68,2c3.49-2.84,4.75-4.79,4.75-7,0-1.47-.83-2.05-.83-3.49a1.86,1.86,0,0,1,2-1.8,1.92,1.92,0,0,1,1.83,1.12l.94-.8.72-.57.32.39a5.58,5.58,0,0,0-2.12,4.5c0,1.62,1,4,1.8,5.62a5.56,5.56,0,0,1,.68,2c3.5-2.84,4.54-4.79,4.54-7,0-1.47-.83-2.05-.83-3.49a1.86,1.86,0,0,1,2-1.8c1.62,0,2.19,1.44,2.19,2.81,0,3.27-2.88,6-5.32,8L95,44.36c-1.12.94-1.73,1.48-2.45,2.2A10.35,10.35,0,0,0,91,48.47Z&quot;/&gt;&lt;!-- 省略 --&gt; 純文字的程式碼，僅有直接標示「Sweetaste」的文字，並透過 cls-1 來替換成特定字體，這個情況下如果用戶沒有該字體，那麼就僅會用系統字體顯示，所以請特別注意，盡可能外框所有字體。&lt;text class=&quot;cls-1&quot; transform=&quot;translate(54.65 130)&quot;&gt;Sweetaste&lt;/text&gt; 注意輸出後的原始碼是否正確先前不斷地說明使用工具的重要性，因為輸出原始碼時結果也會不同，如下原始碼是透過 Illustrator 所輸出，圖片是一個正方形，僅有透過 .cls-1 調整色彩。 &lt;svg id=&quot;圖層_1&quot; data-name=&quot;圖層 1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; viewBox=&quot;0 0 73 73&quot;&gt; &lt;defs&gt; &lt;style&gt; .cls-1 &#123; fill: #3f5d45; &#125; &lt;/style&gt; &lt;/defs&gt; &lt;title&gt;tester&lt;/title&gt; &lt;rect class=&quot;cls-1&quot; width=&quot;73&quot; height=&quot;73&quot; /&gt; &lt;/svg&gt; 接下來透過 Illustrator 加上陰影。 然後再重新輸出一次，會出現 data:image/png;base64.... 的 base64 原始碼，也就是說整個陰影都是透過 “點陣圖” 的方式來呈現，這會導致： SVG 檔案大小會增加不少 尚失向量圖的特性（縮放、再編輯等） SVG 檔案普遍來說都非常小，如果檔案有不正常的增大時（明顯比其他同類型檔案大數倍），那麼請透過文字編輯工具打開 SVG 檔案（注意 image 那行），確實了解檔案是否有問題。&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; viewBox=&quot;0 0 73 73&quot;&gt; &lt;defs&gt; &lt;style&gt; .cls-1 &#123; isolation: isolate; &#125; .cls-2 &#123; mix-blend-mode: darken; &#125; .cls-3 &#123; opacity: 0.75; mix-blend-mode: multiply; &#125; .cls-4 &#123; fill: #3f5d45; &#125; &lt;/style&gt; &lt;/defs&gt; &lt;title&gt;tester&lt;/title&gt; &lt;g class=&quot;cls-1&quot;&gt; &lt;g id=&quot;圖層_1&quot; data-name=&quot;圖層 1&quot;&gt; &lt;g class=&quot;cls-2&quot;&gt; &lt;image class=&quot;cls-3&quot; width=&quot;103&quot; height=&quot;103&quot; transform=&quot;translate(-8 -8)&quot; xlink:href=&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGcAAABnCAYAAAAdQVz5AAAACXBIWXMAAAsSAAALEgHS3X78AAAHIUlEQVR4Xu2dW5ebOBCEC49zmczu//+jm8wd9gGXKcotJM+QRGDVOX2EMdiiP6ol/GB1wzCgqU4dcgc0/T0dcwfk1HVdlzvmVjV8six1156fgdFAAcmEXgurGE4ARV9HUG4JVJRE3Td7vxRSERwBk2t9W7UnWKmkRUDCtgTQ4phjbukwh9El9kFa396bUjB820EMzO0SpCSchFs0DontCFD0esu6SLa0jD6xPTuv67ouBSg3W9NEH4LWwwHuEVAExqO36GS/ttwfKoQTlLMIxJ3EEij9nL3Iy1kEpAfwLkFI/ek8AkLKPRdwrJw5GAVyPMWdtA4qVeL2IC1lEZA3ad9kv4qgwvKWKmtemhTMEcAXiaO0hLR3QEtgCONV2sOp9c/QnCw7J/Eso645AviKEcZXAN/s9VEiGof2omh8eZN4wQjjBXGJ9zEKwGV5u9Y5dMt3jGDYMhQQneaftXV5YrWMEczzKfQm1XN1osCc5McczMuQu0Ydc2/x/fQenaQd0/JGbQmUJ87LGcvXyymeADxiujmB+Uytl9eMDvY9Jc5xOHTMPYAHAD8kFFDKPVtXyjUK5gumsZfnLM3gLsAAAicx3igcHXPonB8A/jnFD0wO+oapg4TDjm4ZEBPIu55JfsVYxp4w3Zi8Xp0ovGI+q724YXXcSZU1nqBlSWdpDudfjC56wARH3RN1ZEuQ9K7WcUNdQzi8KSHHsOR9OW1zBnc4vR+6Z+kXAnWOz9ZY2ljOHjAB0vLmU+stjjtL443CIRg6Rt3yLOH5SObA4fidHY07BPQV87HnAaOL6B6fGKTGnZoBRWDUOToRUDC97H/E5Sw2lY+Ze5YmBGwj9zgguojOucc07kTPPFuVT4XVGQ7mO9JgPBdhTnJlja2PPT6tZpmjkzgxuBU4DuYJ8wd05kzzuAgGSE8IdNvd4w4iJIY+nOrMZa9wHIw/67ljikoasOwcKgJ0J62DYmgHk1PHjclnaryWHvPfGnnNmqclMKFKyprvU1B3FsdE7BFOJ/v8WjVyQK4qaylpjSScqOR5+Vt86NqYCEfBvCO+9ihPwBXXn4LjH+Rg3EHepuLqDlYkQhnkdXR93npgoZ2pxDnRiSXQUqHnbVW5ayxJfjYHJXBy0i/JdTY6vnbRKZ1tX3OdH9IacEoV3VFbEPvqY81v1yF3wIJWvUt2plVy8xk4rtJOlB5Xm0r7XXpcVmvCAVbs2Ea16vWvDadpRTU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1Ox1obzR/7ZomKtev1rwintWOlxtam036XHZfUZONqJ1Tq0E62Smz/5x0Spf1+qXZ7oDyf7Wq0BJ+p8FH/t35dWUul1Rsd/SCVwoi8ZgrYktqyPXKu3qmw+UnBSHx51og9aD/2fNS1rW5NecxRRPkqghfkocQ7lgHrbjkL/3nfA5b/5bU16vbrMSgqU5wnSZrUEJ/oQd8y7xZuFgjlgf3D8enXhPIXnzlElYZU4x4GwYwpHF5HTJUh4Pv/ed09weszXZ2M4JM1XDtRMERw9KQLjd40uh8V1ZAimx/7/Lp9rFzxjngcHFZU8z/VMJWXNwTgUrgvj68f0uJ2FJp4xrvjxhAkUYSkkBwQEUKiS2ZqXM36RrlEWgXnFba2f8wTgJ4BfmHLCHEUOUueEgBzOgPkgrh1JgeGCEg7mFlee+oUR0E9MTkoBypa2XFlLdUTLGAEAExhdWO7W1mwjnF+YXMQSt+SeC6UmBDzBxxrOSFhjmXhg/FKuuHTLqx0+YoTy36l9PL2nsznNKz/3AtIZzjAMgy1H6XeI3iXqCGCC52uUKZytTwYoLUeeFy1vDMJR53hpmz68YPnj1HijSygy0Xz/FROYtsLumAsGSxudU/Jwmixr/P2rP20TDpPsD5i0dVubev54wVLn02ofdyDtWddMpQlBHaPljAtlM/zZZg9gKK8szIMC0udAvn5F7Jq8cxLjjrpH9/M9Ps8QTrR4HLA/OGy1vPkvJzqJWnLN+GEy3gB553C7x1zqpjuMX6zLf+0ZDLUEiJAU1rvE9c4BZu7hCSkwDueASzBbfa7JyW9eB+Sg3hPvn8G4awCgC/aNb4yA9M4/BG0KSGqc2QMgT5g7IAVqCFpg5FLmHNOAy5lbtC8a+PcIhooAsVVA0fbZLdKGSjoHOLvn/BLzxEcwIjB7guLS5Dkg3Y72jS8WACzCOR80Qcq1vq3aE6RU0lKwLtolKFQRHODCRUAeyJ5g5BQlMQI1vihMejEcKoA0e3vhvVtRMqGlUKir4bgysG5a18JwfRpO0+/TAU3V6n9/TR8I3kWSrAAAAABJRU5ErkJggg==&quot; /&gt; &lt;rect class=&quot;cls-4&quot; width=&quot;73&quot; height=&quot;73&quot; /&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt; &lt;/svg&gt; 結語先前就有聽過 svg 輸出時檔案居然要數 mb，仔細一問才發現是 Illustrator 輸出帶有了漸層、濾鏡等效果（目前版本漸層不會出錯，但濾鏡、陰影還是會有問題），如果 svg 輸出時發生這樣的問題時，會建議直接改用 png 不要使用有問題的 svg，因為已經失去 svg 原有的特色（檔案小、無縮放限制等）。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 圖片壓縮方法","slug":"image-opti","date":"2018-10-28T16:00:00.000Z","updated":"2018-10-29T03:28:15.530Z","comments":true,"path":"design/2018/10/29/image-opti/","link":"","permalink":"https://wcc723.github.io/design/2018/10/29/image-opti/","excerpt":"","text":"了解基本的格式後，接下來設計師還需要「正確的」輸出圖片並壓縮，網頁上輸出圖片雖然沒有印刷中那麼複雜，但依然有許多眉角需要注意，像是用什麼工具壓縮就很常被詢問到，本篇介紹我再壓縮上常用的一些技巧。 工具輸出繪圖軟體均可輸出圖片（廢話），在此還是比較推薦使用 Sketch 或 Adobe XD，這兩套的圖片輸出功能完整，且可以一鍵大量輸出所有設定的圖片及尺寸。 Sketch 可以直接設定好所有圖片（設定格式、尺寸比例、檔名、尺寸前綴詞…），並且一鍵輸出到特定資料夾。 Adobe XD 再輸出規範時，也可以提供所有圖片的下載連結，讓開發者選用後一次打包下載（Sketch 也有相同功能）。 設計稿參考： https://lihi.cc/LAfsC （請切換到 Download 頁面） 如果是使用 Photoshop、Illustrator 等平面繪圖軟體，當圖片數量多，且規格複雜時將會花去許多時間，且工程師拿到一堆圖片時，也難以對應檔案與位置上的關係。而 UI 繪圖軟體相對於傳統的平面繪圖軟體來說，它讓工程師更能了解每張圖片所在的位置、運用情境、多尺寸的選擇，設計師只需要做好合適的規範設定即可。 圖片壓縮當然，圖片輸出後檔案還能做最佳化壓縮，目前主流的繪圖軟體都無法有效的壓縮圖片，透過合適的工具壓縮可以在不破壞視覺品質的情況下，大幅降低圖片的尺寸（檔案尺寸可降低 30% ~ 50% 不等）。 TinypngTinypng: https://tinypng.com/ Tinypng 是直接上傳檔案後，該服務會自動在後端壓縮，並且打包壓縮後讓用戶下載。使用方法簡單，無需任何設定，缺點是必須 “上傳圖片” 才能壓縮，如果產品是需要隱密性，不得提前公開的將不適合使用。 不過他們也有提供 Photoshop 版本的擴充套件（我沒有使用過），可以花些費用購買工具將可以在本地端壓縮。 ImageOptimImageOptim: https://imageoptim.com/mac 這是目前使用的壓縮工具，優點是離線使用、大量壓縮、免費、簡單操作（也可調整壓縮比），但目前只有 Mac 版本，Windows 僅能使用他另外提供的 Web Service（與 Tinypng 相同）。 且這個工具的壓縮能力相當不錯，如下圖我壓縮了一張 png 原始檔案尺寸為 2.4mb，壓縮後為 1.4mb，降低了 42.1% 約 1mb 左右。 而這個工具是本地端運行的，因此壓縮時會大量用去系統資源，如果電腦的效能沒有很好，建議不要在「工作時間」壓縮大量圖片，這可能會導致你暫時無法作業。 gulp 自動化壓縮https://github.com/hexschool/gulp-demo gulp 到目前為止還是很方便的工具，可以用來處理許多小雜事，這類型的工具只要把圖片放入，部署前輸入一鍵就會全部壓縮。壓縮的效果如下（原圖約為 742kb，壓縮後為 486kb）： 這個工具看似很方便，很適合工程師使用，但其實壓縮的品質不是很穩定，有些圖片加入後甚至不會做任何壓縮，相比較而言我還是傾向使用前面所介紹的那兩款。 結語程式碼需要壓縮，而圖片當然也需要被壓縮，且圖片壓縮效益大幅超過程式碼壓縮，進而加速網頁瀏覽的速度。而設計師交付給與工程師圖片時，也可以討論這段流程因由誰負責（或由伺服器自動壓縮），並將此流程加入到開發與設計之中。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 圖片格式的運用","slug":"image-format","date":"2018-10-27T16:00:00.000Z","updated":"2018-10-28T07:07:22.599Z","comments":true,"path":"design/2018/10/28/image-format/","link":"","permalink":"https://wcc723.github.io/design/2018/10/28/image-format/","excerpt":"","text":"隨著裝置解析度越來越高，如果是以 1:1 的尺寸輸出圖示時，都會明顯地看到圖示邊緣出現鋸齒，這樣的情況下無疑是降低設計的品質，為了避免這樣問題，實作中通常會使用兩種方式來解決： 輸出更高解析度的圖片 輸出向量圖片 更高解析度需要多高？對於網路速度是否有影響？向量圖的使用情境及限制為何？本篇將依據這些概念介紹。 格式選擇參考網頁靜態圖片選擇主要有三種（還有另一種為 base64，這就不在我們討論範圍內）： jpg：是屬於破壞性的檔案壓縮方式，圖片可以大幅降低檔案尺寸，不過也會因此導致品質降低，壓縮的過程中可以依據需求調整壓縮比，藉此控制品質及檔案大小間的平衡。 png：壓縮比較低的圖片格式，相對於 JPG 來說圖片檔案會大不少，但影像品質也相對較佳，除了有更好影像外還同時具有「透明」的特性。 svg：向量的圖片格式，圖形定位皆是使用數學位置，且「沒有解析度」的限制，因此圖片無限放大都不會失真。另外 SVG 由於是一些文字標示而成，所以圖片尺寸普遍來說都很小。 使用情境圖示、商標 SVG：可縮放向量圖形，圖片來源：wiki 由於商標會使用在許多情境，如網頁頁首、頁尾以及行動版等，在不同的尺寸變化下依然要維持高品質的清晰度來維持形象，過去大多都是使用 png 的縮放調整，但在目前的裝置解析度不斷提高的情況下，使用 svg 替代 png 是相對更好的解決方案。 範例網站：甜點電商的上方 Logo 就是使用 SVG 來呈現 目前大多網站均是使用 svg 作為商標顯示的格式。圖中為 Sketch 網站 除了商標外，另一個很常使用 svg 格式則為圖示（icon），過去圖示也是同樣使用 png，但在高解析度的裝置下來說卻顯得不足。使用 svg 替代主要原因在於 icon： 圖形單純 - 不會混用真實圖案 高辨識性 - 需要高解析度 大量使用 - 檔案要小 需要可編輯性 - 依據情境重新賦予色彩 在 Github 的網站中就可以看到大部分圖示均是使用 svg，且可依據情境重新調整色彩。如下圖選擇的 “Code” 選項的 icon 接近黑色，旁邊的 “Issue” 則是顯示淡灰色。 在 Github 中的網站是透過前端工具處理，讓 svg 圖形的引用更為容易，但實戰中 svg 圖形在管理上是有些門檻的，下一個章節會介紹使用 icon fonts 來處理 svg 在圖示上的應用方法。 主要圖片好的圖片能夠增加網站的豐富度，也同時能夠增加訊息傳的效益，現在鮮少有網站是不透過任何圖片來傳達訊息。舉凡是 頁首大圖、商品圖片、輪播、說明圖片等等，這些都是為了增加訊息傳達效益的圖片，會建議使用 png 來作為顯示的格式，主要是 png 具有以下的特性： 高品質 - 確保顯示的品質 點陣 - 增加畫面的真實性 透明特性 - 可採用堆疊的方式呈現 如下圖，為了確保圖片品質及精緻甜點的口感，png 是不錯的選擇。 主要圖片除了有良好的呈現外，必要時還需要兼顧不同裝置的「顯示清晰度」，如一般的螢幕的 PPI 約落在 100 上下（PPI 說明），但到了部分裝置的 PPI 就會達到 320 甚至更高的 PPI（如 Apple 的 Retina Display），此時就會建議使用「雙倍」以上的尺寸做輸出。 以 Sketch 為例，當輸出一張長寬為 1200 * 628 圖片時，如果調整為 2 倍尺寸則會輸出一張 2400 * 1256 的圖片。 此時也要特別注意，圖片的檔案大小將可能成長為四倍，如一張 700kb 的圖片輸出成 2 倍尺寸大小時，檔案可能成長為 2.4mb。因此實際運用時會建議隨需求調整圖片輸出的大小，設計師部分可以規劃不同尺寸的輸出，而前端在此就需要依據需求調整運用的倍數。 使用 png 例外情況： 圖片過多，需要兼顧網路速度時還是會建議轉用 jpg 圖片是人工繪製，向量是更好的選項時會建議使用 svg 手繪向量圖片 svg 依然是好選擇：圖片來源 Github 背景圖另外，背景圖片的運用也是很重要的，相對於主要圖片來說背景圖片的重要性降低很多，如果畫面同時是使用真實景色的圖片，會更建議使用 jpg 來做呈現，藉此降低檔案的尺寸。 Yahoo 氣象的背景會使用當地的風景圖片，藉此來呈現符合情境的資訊，而這麼大張的圖片作為背景，如果使用 png 將會佔去不少流量，所以使用 jpg 將是一個好選項（原圖 1280 * 720，約 170kb）。 大多數來說，真實圖片的背景會使用 jpg 來呈現，這裡也介紹一個圖案類型的背景網站給大家參考，由於這個網站是使用「四方連續」的背景手法，這類型的圖片僅需要小小一張就能不斷重複使用，所以就直接使用 png 來維持背景圖的品質，網址：https://www.toptal.com/designers/subtlepatterns/ 此網站的背景風格非常多，下載可同時選用 2 倍尺寸的圖案，網站的圖案都是可以免費使用，但請注意 使用條款及 FAQ 結語現在工具輸出圖片也越來越方便，只要一鍵就可以大量輸出，因此設計師更需要了解各種圖片格式的差異，並且輸出符合需求的格式以便於工程師作為開發使用。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 文字大小、行高與空間上的關係","slug":"fonts-family","date":"2018-10-26T16:00:00.000Z","updated":"2018-10-27T06:30:33.070Z","comments":true,"path":"design/2018/10/27/fonts-family/","link":"","permalink":"https://wcc723.github.io/design/2018/10/27/fonts-family/","excerpt":"","text":"一般平面設計師再進入網頁環境時，會不清楚網頁設計所用的單位數值，造成設計稿與開發的畫面有嚴重的落差；且網頁設計本身有許多「慣用的數值」，建議一開始也能先使用大家通用的數值，待了解所有數值對於畫面、軟體、技術上等影響後再做調整。 文字樣式屬性由於網頁並沒有像繪圖軟體那麼的自由，所以才會有許多文章提到「設計師需要學程式」，因為之中有許多技術限制需要設計師去理解，這會有助於設計執行上的可行性。 文字單位文字分為絕對單位及相對單位，絕對單位與平面設計概念一致，基本上是設定多少，畫面呈現就是固定大小；而相對單位則是沒有固定大小，所設定的數值會受到外層、HTML 設定、裝置畫面大小等等而定，相對來說靈活很多，但在掌握上也困難許多。 絕對尺寸： px：最常使用的絕對單位，過去會使用略小的數值，目前是以預設的 16px 為主，請避免設定過小的字體導致閱讀上的困難。 pt：很少用到的數值，請不要用印刷的 “pt” 作為「螢幕顯示」時的單位（另一種 pt 為 iOS 上所定義的 pt，是接近於 CSS 上的 px，這段確實很容易搞混，請謹記不要使用印刷及 CSS 的 pt 單位即可）。 相對尺寸： em：1em = 一個字體大小，是相對於父層的單位，所以當父層為 32px 時， 1em 則為 32px 大，而這個數值可以不斷疊加。 rem：目前主流的單位尺寸，1rem = 一個字體大小，相對於 HTML 所定義的文字大小而定，可以在頁面呈現後調整設定值修改畫面的單位尺寸。 %：類似 em，使用上沒有太大差異，細節可參考。 vw, vh：1vw = 瀏覽器的寬度，1vh = 瀏覽器的高度，比較常用在畫面上，但也是有機會用在文字上，如：Header 的主要文字。 延伸介紹：實際展示 EM 與 REM 的差異 文字尺寸目前來說，網頁開發大多都是使用 16px 作為基準字，雖然設計訓練中都習慣將文字縮寫以增加質感，但請別忽略網頁本質是為了傳達訊息，且小字在行動版上閱讀上更為困難，盡可能維持預設值來製作網頁設計。 由於 rem 的出現，我們不再需要行動版與桌面版完全統一相同的字體大小（雖然實作上還是同一為主）。設計時我們依然會以 px 為主，但為了配合開發上的方便，通常會使用固定級數的方式作為大小字的變換，範例如下： 設計師用的尺寸： 工程師所用的尺寸 16px : 1rem 20px : 1.25rem 24px : 1.5rem 28px : 1.75rem 32px : 2rem 40px : 2.5rem 同理，如果將預設尺寸改為 15px，相關的數值也會重新調整（15px = 1rem,30px = 2rem…）。 設計上注意事項當如果使用 rem 為單位時且預設值為 16px 時，應避免出現 17px, 21px, 25px 這種尺寸造成轉換上的困擾（就算不使用 rem 也不該如此 :D），盡可能維持相同邏輯在執行網頁設計。 行高平面設計中，我們習慣使用固定的數值，例如 12pt 的文字大小搭配 16pt 的行高，但在網頁設計中則習慣使用相對的倍數來呈現；如 line-height: 1.5 來代表 1.5 倍的行高，此時文字大小如果設定為 16px，那麼行高則為 24px。 並且行高的設定，通常會設置於網頁的 body 上，也就是全網站套用相同的預設行高，如果有例外再另外條整。 如果 body 行高設定為 1.5 其它文字大小的相對行高 16px : 24px 20px : 30px 24px : 36px 除此之外，行高的設計也會影響到「空間的顯示」，平面設計中的文字空間與其它圖文基本上是毫無關聯性的，但在網頁設計中除了設定成絕對定位，其餘物件的空間都會有彼此的關連性。 下方是行高 1.5 倍的文字段落，所佔用的區塊則使用橘色顯示，後方緊貼著一塊紫色方塊，這個方框並不會與文字產生空間上的交錯。 以下分別使用行高 0.6、1、1.5、3 再呈現一次，如果行高使用 0.6 的情況，文字會超出橘色的空間範圍，並且與紫色產生些微的交錯；而在行高 3 時文字距離橘色邊框距離增加許多，並且會將紫色方框推向後方。 設計上注意事項因此在設計文字時，也要注意繪圖軟體所呈現的範圍，如下圖：當設計 line-height 為 3 倍時，繪圖軟體自然會使用正確的方框尺寸，此時應避免與其它元素產生交錯。 另一個常見的錯誤習慣因為行高會影響到文字呈現的空間，因此會有不少網頁設計師透過 line-height 來製作垂直置中。這會導致文字再多行時也會使用到錯誤的行高，並且會降低 CSS 的設計彈性，因此非常不建議使用 line-height 的數值製作垂直置中。 .vertical-align &#123; line-height: 48px; height: 48px; &#125; 正確應使用 padding、flex 等方法來做垂直置中。 結語本篇的文字設定在畫面上很難找到問題，但會影響該設計師是否易於與工程師配合，所以追求美感的同時，依然要注意畫面的邏輯及可行性。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網路字體運用","slug":"web-fonts","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-26T03:49:42.770Z","comments":true,"path":"design/2018/10/26/web-fonts/","link":"","permalink":"https://wcc723.github.io/design/2018/10/26/web-fonts/","excerpt":"","text":"字體如果沒有授權問題，是否能夠直接嵌入於網頁之中呢？（請注意：大部分中文字體都會有授權的問題） 當然是可以的，英文網站中許多都會使用自訂的字體，但中文字體可就沒有這麼容易。因為英文字體檔案小，直接寫入 CSS 即可運作，而中文字體動輒數十 MB，Noto Sans 整包甚至高達上百 MB，下載這些字體就會花去許多時間且非常消耗網路資源。 英文網頁字體英文字體運用上僅需要注意授權，而最大宗的免費字體就是 Google Fonts，包含襯線、無襯線、裝飾、等寬、手寫等等風格，而這些字體都有完整的預覽及字重選擇。 如果不是對於字體有極端要求者，這個網站已經可以滿足大部分的需求。 選用特定字體後，也能自行調整所需要的字重，避免一次載入過多的字體導致下載速度變慢。 中文網頁字體中文字的網頁字體就沒有那麼容易了，主要原因在於中文字太多導致檔案太大，另外就是中文字的廠商大多不會免費提供（畢竟字太多難以開發，很難免費授權），所以這些就要找專屬的線上字體供應商，如台灣知名的 華康、文鼎 到先前知名的金萱字體開發商 Justfont 都有提供這樣得服務。 這些服務是直接從網頁中透過 JavaScript 取得所用到的中文字體，再從伺服器重新下載這些字型，所以速度會比直接直接下載完整字體檔案快上非常多，但也因為如此這類型服務都需要另外付費才能使用。 另外Google 也有推出 Early Access 的 Noto Sans，在這之中也當然包含繁體中文的 Noto Sans。 這段也有看到 Google 不斷的在優化這段服務，最近一次測試 Noto Sans Regular（中等字重）的下載大小僅需要 1.8MB，實際體驗上速度也比先前快上許多，但畢竟是屬於測試中的服務，使用時還是多虛注意。 網頁設計的注意事項因此，我們在設計網頁時盡可能使用系統預設的字體，系統預設字在網頁上都有經過優化，所以都有很好的閱讀性（大部分系統文字在 12px 都還有不錯的辨識性）。設計時也可以依據主要用戶群（桌面、行動版）、較多人使用的系統作為設計（如微軟的正黑體）。 尤其在中文的部分，未搭配任何 Web fonts 服務時應避免使用特殊的字體，多利用系統的字體來進行設計。有搭配 Web fonts 服務時可多將字體利用在標題上以維持文字的辨識性，如果用在內文，須確保在不同的系統上辨識性依然是足夠的，如其它明體在小字時就不一定比「新細明體」辨識性還高（可參考：https://www.justfont.com/fonts）。 思源明體在 16px 左右的狀態 系統字體 16px 而在更小的字體上落差也會更為明顯，使用前可多利用該服務來做測試，並且選擇合適的字體運用。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：系統字體介紹","slug":"fonts","date":"2018-10-24T16:00:00.000Z","updated":"2018-10-25T03:23:56.674Z","comments":true,"path":"design/2018/10/25/fonts/","link":"","permalink":"https://wcc723.github.io/design/2018/10/25/fonts/","excerpt":"","text":"字體一直是設計師排版的關鍵之一，但由於網頁設計受到技術、法規、網路影響，在網頁上能夠使用的字體非常有限，本篇文章其實並非告訴大家怎麼使用字體才會「美」，而是了解字體運用上的「限制」，避免設計出執行上有困難或是效能極差的網頁。 字體分類字體因為外觀的關係而有不同的名稱，如：黑體、明體、襯線、無襯線等字體，以上或許大家都有聽過名稱，但不清楚外型（如果熟悉可以跳下一段），這裡就來解釋這些字體的分類及常見用途吧。 serif 歐文襯線字體 外觀：中文在末端會有凸起的裝飾線，英文則是在頭尾皆有額外的裝飾線 運用：帶有人文氣息，因此大多會運用在具有歷史、文學、文化的內容。 sans-serif 歐文無襯線字體 外觀：無論中英文皆沒有任何裝飾線 運用：較無個性，帶給人科技、現代、正式的感覺，使用上非常廣泛。 中文部分則是稱為黑體及明體，外觀上明體接近於「歐文襯線字體」；黑體則接近於「歐文無襯線字體」。這兩者有許多文件會視為同類別（如：黑體 == 歐文無襯線字體），但也有許多專業設計師會視為不同類別，在此特別說明。 而系統上也都有包含預設襯線與無襯線所預設的中英文字體，除了上述兩種外系統內還有 cursive、fantasy、monospace，但這些字體就並非有完全對應的中英文，實作上還是以襯線與無襯線兩種為主。 詳細文章：https://wcc723.github.io/css/2014/01/01/font-family/ 必要熟悉的系統字體目前常見的系統包含 Windows、MacOS、iOS、Android、Linux…等（本篇不介紹 Linux 家族。），每一種都還包含了中英文、襯線、無襯線等等（本篇以無襯線為主），而這些系統字體大不相同，更不會有自定的字體出現。 Windows使用人數最多的桌面作業系統（80%），無論是熬夜打電動、做作業、寫程式、畫 3D 都有不錯表現，因此所使用的系統絕對需要熟記～。 英文：在過去是使用 Arial，這款是仿造 Mac OS 的 Helvetica 字體所製作而成的，現在則是使用 Segoe UI。 中文字體：微軟正黑體，相當經典的黑體字，缺點是只有單一字重，缺乏較粗或較細的字體。 另外 Windows 系統預設的中文字體是「新細明體」，這款字體在單級數字級會有比較好的閱讀性（13px, 15px, 17px 字體顯示會較為銳利），但實作中還是以雙數字級（16px, 20px, 24px…）為主，使用上要特別注意。 Mac OS / iOS蘋果一直以來對於字體就非常要求，包含不同解析度、閱讀性、字重等等都很要求，現在的版本更提供專屬的中文字體，讓開發者、設計師、使用者都有很好的使用體驗。 英文：過去是使用 Helvetica Neue 的經典字體，現在無論是 iOS 或 Mac OS 均是使用 San Francisco，這款字體不會直接出現於繪圖軟體之中，如需可用前文連結另外安裝。 中文字體：現在是使用蘋方字體，這款是少見包含「多個字重」的中文系統字體（5 種），設計運用上自然能有更多的發揮空間。 AndroidAndroid 雖然有提供系統字體，但各家廠商製作手機時依然可以調整預設的系統字體，在此僅是提供主要的預設字體。 英文：Roboto ，這一款字體運用上也是非常靈活，擁有 6 種字體且均另有斜體（italic，共 12 種），根據 Google Fonts 的統計，這個字體已經運用在 22,000,000 個網站上。 中文字體：資料上顯示有兩款 Droidsansfallback 及 Noto Sans（我傾向是後者，有錯請指正），Noto Sans 是 Google 與 Adobe 公司共同研發的開源字體，包含 7 種常用字重並且幾乎包含所有中文字，號稱最不會缺字的字體庫，目前是設計師必備的中文字體。 另外提到，Noto Sans 是 Google 及 Adobe 合作的字體，在 Adobe 的服務中稱這套字體為「思源黑體」，在繁體中文的國家中，Noto Sans 基本上也是依據台灣官方規定的筆畫規則，是一款非常優秀的字體。 另外還有推出「思源宋體」（Noto Serif），相關的介紹可以參考 介紹頁面。 結語了解預設字體是非常重要的，原因是「系統字體」是經過系統廠商所優化，普遍來說在各種情境都有較好的閱讀性；此外，每台電腦所安裝的字體也會有所不同，不可能要求一般用戶去下載未授權的字體，或是下載 Noto Sans 來做使用。 因此，使用第三方的字體可能會造成： 可能缺乏良好的閱讀性（小字、色彩不明顯時） 用戶並未安裝該字體，導致畫面不如預期 缺字，導致字體顯示不一 但有些時候，依然會推薦使用其它字體來凸顯網頁的部分關鍵用詞，下一篇將會介紹一些網路服務來運用額外的網路字體。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：色彩運用(3) - 按鈕的配色","slug":"button-color","date":"2018-10-23T16:00:00.000Z","updated":"2018-10-24T02:37:08.379Z","comments":true,"path":"design/2018/10/24/button-color/","link":"","permalink":"https://wcc723.github.io/design/2018/10/24/button-color/","excerpt":"","text":"上一篇透過連結的狀態了解運用，本篇則是探討按鈕再運用上的色彩變化，包含了一般、行動呼籲、外框線、警告意味等常見的類型，當然這些類型介紹上別不會包含上一篇的 “狀態”，實作中依然要記得補上喔。 一般狀態一般狀態通常是最沒有特色的，但使用上也是最為普遍的，這類型的按鈕通常不會帶有太多色彩，並不會特別引人注目，目的也是讓用戶了解的要執行、連結等等。 設計：越普通越好 Call to Action宣傳網頁、登入頁等等都會有一個按鈕引導用戶到達特定目標，行為上我們稱為「Call to Action」，因此這類型的按鈕都會特別顯眼，配色上則會使用「主色」或「次要色」，並且以「填滿」的方式配置。 也因為這類型按鈕非常重要，所以相似的按鈕一個畫面中不會出現太多次，如以下範例所示，大多服務都是使用在「註冊」上（Airbnb 則是用在搜尋，所以對他們來說搜尋比註冊更為重要），必須謹慎配置這類型的按鈕，請把它用在最重要的地方。 https://github.com/ https://azure.microsoft.com/zh-tw/ https://www.airbnb.com.tw/ 設計：主色或次要色，並且填滿它 Outline幾年前開始出現的一種按鈕風格，當時有一種暱稱為 Ghost button，相對於填滿的按鈕來說它的顯眼程度沒有那麼高，但依然能夠符合網頁的主題配置，所以重要性也是介於普通按鈕及 Call to Action 之間，很適合用在宣傳網頁、登入頁的次重要性按鈕。 如下 Uber 的網頁來說，最重要的是引導人們註冊成司機，其次則是引導乘客註冊。因此這個網頁的動機是尋找引導駕駛比引導乘客更為重要。 https://www.uber.com/zh-TW/tw/ 在 Palantir 的登入頁來說，並不需要引導用戶註冊或購買，重要的是傳遞訊息、故事，因此沒有使用 Call to action 的按鈕，取而代之的是 outline 按鈕來引導用戶觀看他們的故事。 https://www.palantir.com/ 警告警告意味的按鈕是傳達此按鈕的危險性，所以與 Call to action 是相反的概念，警告是避免用戶點擊，Call to action 則是期望用戶點擊（許多電商都是使用橘色、紅色填滿作為 Call to Action。）。配色上大多會使用紅色，並且以「白底紅字」的方式避免過於顯眼，所以無論主色或是次要色選擇了紅色，都會避免使用紅底白字的方式在呈現，因為這樣的配置會吸引用戶點擊。 以 Github 的 Danger Zone 來說就是使用細紅框搭配紅字按鈕呈現，除了提醒用戶這個區域的安全性外，也避免吸引用戶目光。 避免使用紅色的按鈕，他會吸引用戶目光點擊（警告都不警告了）。 以上是常見的情境，大家可以依據這些概念看看國內外網站，是不是有很多符合這樣的情境，這些概念同時也可以運用在自己開發上並思考以下事情： 網站最重要的行為是什麼？ 當下按鈕的重要性？ 當下按鈕所傳達的情緒（警告、興奮、買買買）？ 藉此來調整網頁的行動配色喔 :D。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：色彩運用(2) - 連結的配色","slug":"link-color","date":"2018-10-22T16:00:00.000Z","updated":"2018-10-23T02:07:15.137Z","comments":true,"path":"design/2018/10/23/link-color/","link":"","permalink":"https://wcc723.github.io/design/2018/10/23/link-color/","excerpt":"","text":"除了親和性的配色外，訊息的傳遞也是很重要的，與平面設計不同的是訊息並非只有圖文的傳遞，還包含了狀態、互動、提示等等訊息，訊息也同時可以用許多不同色彩表示，增加訊息所能表示的情感、急迫性、引導性等等。 連結色彩（包含不同狀態）網頁設計中的 &lt;a&gt; 除了本身的預設樣式外，另外還包含以下幾種 “狀態” a:link - 未拜訪過的連結。 a:visited - 已拜訪過的連結。 a:hover - 滑鼠回入的連結。 a:active - 按下狀態的連結。 a:focus - 鍵盤專注的狀態。 a:link - 未拜訪過的連結及 a:visited 已拜訪過的連結，這兩種並非在所有網站都有這樣的需求，通常會運用在「需要紀錄已讀取」的網頁上，像是搜尋引擎就是很好的例子（但現在很多都改用 JavaScript 來設計）。 設計：可視專案需求來決定是否加入這個樣式。 a:hover - 滑鼠回入的連結，這個樣式普遍都會製作，主要讓用戶滑鼠滑入時了解「這是一個可互動的按鈕」，如果少了這個樣式用戶可能會誤以為沒有連結。但要特別注意，這個樣是在行動版無法正確的呈現（因為手機沒有滑鼠 hover 的事件）。 設計：在文本中的設計中大多會使用略深的主色或次要色，然後加上下底線作為呈現。 如果以按鈕呈現，也會使用略深為按鈕原色的設計 a:active - 按下狀態的連結，這是滑鼠按下的樣式，通常會與 .active 一起製作，而 .active 可以透過後端或 JavaScript 直接套用在按鈕之上，表示目前啟用中的按鍵。 設計：通常會使用略深於普通狀態的色彩，設計時可以與 .active（啟用樣式）一起設計（文本有時不會設計，或同 hover 樣式）。 a:focus - 鍵盤專注的狀態，許多用戶會使用鍵盤搭配 tab 來瀏覽網頁（也有一部分是屬於視覺障礙者），這個專注狀態可以讓用戶了解目前「專注」的按鈕，如果用戶需要按下此按鈕，則可以按下 Enter 鍵。 設計：文本中會使用瀏覽器預設的外框，主要是因為文本中不一定能調整高度，視覺上可能會干擾到其他文字的閱讀，因此不一定會另外設計。 按鈕會在原本按鈕外增加一圈類似色彩，如果沒有另外設計則會套用瀏覽器預設的樣式。 瀏覽器預設的 focus，每個瀏覽器略有不同（下圖為 Chrome 的樣式），預設樣式不會隨著網站設計改變，大多會使用藍色外框，因此會建議自行設計。 部分網頁設計師由於沒有程式開發的經驗，所以會忽略許多行為上的樣式狀態，除了 link, visited 外，其餘都是設計時必備的項目，一開始就必須加入喔。 結語按鈕互動對於使用者回饋相當重要，如果缺乏足夠回饋，用戶時常會以為該連結是否無法運作。而設計師為了追求畫面上的完美，有時會疏忽掉用戶操作的回饋，執行上則會建議一開始預先定義相關元素的互動狀態、錯誤行為等等，避免後續開發上的疏忽。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：色彩運用(1) - 你的網頁文字是否足夠清楚呢？","slug":"accessibility","date":"2018-10-21T16:00:00.000Z","updated":"2018-10-22T03:19:01.859Z","comments":true,"path":"design/2018/10/22/accessibility/","link":"","permalink":"https://wcc723.github.io/design/2018/10/22/accessibility/","excerpt":"","text":"上一篇介紹了整體色彩選擇，按造該概念完成一個網頁相信不是什麼問題，不過色彩到底怎麼選？運用上有什麼需要注意的？本篇就來介紹一下吧。 Accessibility：這個單字翻譯有很多意思，如：「無障礙」、「親和性」、「可訪問性」，其中我最喜歡的是親和性的翻譯，因此把它作為此篇文章的標題，而在 Google 的相關文件中翻譯為「可訪問性」，在本文中看到「親和性」、「可訪問性」都是指此單字喔。 網頁可訪問性分數網頁配色時除了要好看之外，色彩所造成的訊息傳遞功能依然不可降低，如黑底白字、白底黑字是普遍來說閱讀性佳的色彩組合，但這個組合並不一定適合所有的品牌配色，如果品牌顏色為綠色（#509955）那麼這樣的顏色作為文字色彩閱讀性是否足夠呢？ 網站內容親和性規範 The Web Content Accessibility Guidelines (WCAG 2.0) 將文字與背景對比度區分為不同等級，在主要的內文排版中至少要有 4.5:1 的對比度（AA 級），除了一些情境之外可以不需要達到這樣的標準： 較大的文字：超過 18px 或 14px 的粗體文字對比度可降為 3:1 附屬的文字：裝飾或者圖片一部分的文字可以不遵循此標準 品牌文字：如果文字為品牌一部分，也可不遵循此標準 Google 的 Web Fundamentals 有完整一篇文章說明該如何實踐這個概念（可訪問的樣式），下圖也演示了不同對比度的視覺關係，4.5:1 則是大部分可輕鬆閱讀的對比度，如果您的網站需要給予老年人或視力不佳的人閱讀，建議可以將標準提高到 7:1。 回到前文所說：「如果品牌顏色為綠色（#509955）那麼這樣的顏色作為文字色彩閱讀性是否足夠呢？」，以下簡單介紹該如何檢視此段文字是否符合標準。 這次透過該色彩所展示的一段文字，無論現在肉眼看起來是否足夠清晰，我們來透過工具說明是否符合標準。 接下來透過開發者工具，點選該文字 -&gt; 右鍵 -&gt; 檢查 可以看到如下的介面，然後再點選色彩就能看到以下資訊。（如果不知道如何使用開發者工具，可以參考我們的免費課程：https://www.udemy.com/chrome-devtools/） 接下來，點選 Contrast ratio 右方的箭頭 icon，展開看更多細節，接下來可以直接透過上方的色版調整色彩，色版中也給予建議的標準線，只要超過標準線就至少通過 AA 級，下方也有標示是否符合 AAA 級的對比度。 接下來我選擇一個 #458449 的色彩至少符合 AA 級（4.54:1）。 再重新查看此文字是否符合網站的標準色，我們也可以用此方法作品牌色的延伸，套用至所有的網站文字之中。 另外，這個工具也可針對不同色彩的背景做調整，如下圖我選擇另一個藍綠色作為背景色， 此時對比度也會顯示不足夠。 結語色彩的親合度使用上也必須注意不同的背景色變化，以及互動連結、按鈕等等的搭配，甚至還有針對目標群眾調整更高對比（年邁、視力不佳者），符合品牌的同時，我們還有很多的細節可以處理喔 :D。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計色彩配置概念","slug":"color","date":"2018-10-20T16:00:00.000Z","updated":"2018-10-21T06:53:51.039Z","comments":true,"path":"design/2018/10/21/color/","link":"","permalink":"https://wcc723.github.io/design/2018/10/21/color/","excerpt":"","text":"根據上一篇介紹的設計規範參考，實戰中有許多需要事先定義，而色彩是使用者打開網站最先體驗到的部分。好比說 Facebook 的深藍色、Google 的紅色、LINE 的綠色，Yahoo 的紫色，這些色彩都深深的存在我們腦海裡，所以在決定這些色彩絕不能馬乎，如果換了色彩用戶還可能會想「我進錯網站了嗎？」。 除此之外，每個色彩也帶有不同的行動意味，因此顏色要怎麼選、怎麼配才會好看、好用呢？畢竟五顏六色的網站經常讓人找不到重點且美感難以控制。 簡單的方法：選一個主色貫穿全場吧講古中…在過去，Material Design 是選擇雙色，一個主色（primary color）另一個強調色（accent color）的配置方式；主色是全畫面的主要色彩配置，這也是帶給用戶主要觀感的色彩，佔去畫面的主要區塊。而強調色只在部分的區域，目的是增強部分重點的視覺性，如：重要的互動性元件、重點文字等等。 重點：兩個顏色，一個稱為「主色」另一個為「強調色」 主色：主要是品牌色彩，除了底色為是最容易被記憶的部分，會運用在網站大多地方，除了本身的色彩外，也會依據明度的調整來做相關的延伸。 強調色：凸顯的色彩，可以使用主色的對比色，這類的色彩通常強烈、明顯如：紅色、黃色等等，大多用在互動性的元件或需要特別重要的文字。當然，除了本身的色彩外，也會依據明度的調整來做相關的延伸。 案例如下，主色為整個畫面中的核心色彩，除了底色外另一個會被使用者所關注的色彩即是「主要色」。而強調色則是運用在「互動」、「重點標示」，且要避免強調色運用在網站上過多的地方（否則就失去強調的意味）。 現在Material Design 目前則是使用一個主色（primary color）及一個次要色（secondary color），在名稱上就可以看出和過去的不同，且文件中也說明到：「如果你並沒有次要色，你的主要色同樣可以用在主要的元素上」（If you don’t have a secondary color, your primary color can also be used to accent elements.）。 而這兩個顏色作用上與過去的主色、強調色觀念一致，但在選擇上確有所不同，次要色改成「非必要」的存在。 如下圖，這個網頁中選擇一個紫色作為主色調，並且透過明度調整增加豐富性並利用在所有的地方，這個網頁也並沒有使用到次要色。 另外一個包含次要色的範例，除了剛剛的紫色外，也可以選擇一個次要色作為重點的強調，這裡的次要色類似先前版本的「強調色」。 實際案例而無論是過去或現在的選擇一組「主色、強調色」或者是僅選擇「主色」，在網頁設計上都是很常被運用。 Evernotehttps://evernote.com/intl/zh-tw 單一主色貫穿全部，僅有主色的明度調整，互動元件上也沒有額外的次要色，在畫面上也顯得乾淨一致。 Airbnbhttps://www.airbnb.com.tw/ 單一主色，僅把主色放在品牌及最重要的互動按鈕上，其餘地方則會使用不明顯的色彩來標示。 Udemyhttps://www.udemy.com/ 同樣是單一主色套用在品牌色、重要的互動按鈕上。 Shopify 電商版型https://themes.shopify.com/themes/empire/styles/supply/preview現在使用主色、強調色的配色方式已經比較少了，但還是會有電商類型的網站會用這樣的配色來增加轉換率。 Sketch APPhttps://sketchapp.com/這也算是單一主色（橘色），特別的是有搭配一個粉紫色漸層作為背景、文字配色，但整體的互動還是圍繞在橘色上。 簡單回顧一下配色的選擇方法： 選擇一個主色，盡可能用它來作為全網站的配色延伸 選用一個次要色，作為網站強調性文字、按鈕的配色，但這個選擇是非必要的。 經驗上，過去有許多雙色（主色、強調色）的案例，而在最近有趨向轉為單主色，所以這樣的觀念並非長久不變，我們可以從文件、國內外的網站觀察變化，並且依據我們製作的專案需求調整設計，而設計除了做的美，還要學會從固定的規則中尋求變化。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：文件、規範參考 - Material Design","slug":"design-guide","date":"2018-10-19T16:00:00.000Z","updated":"2018-11-13T02:41:01.221Z","comments":true,"path":"design/2018/10/20/design-guide/","link":"","permalink":"https://wcc723.github.io/design/2018/10/20/design-guide/","excerpt":"","text":"程式領域裡面非常重視文件，當然 UI 中也是如此，為了確保設計可以被執行，大型應用程式、系統都會推出屬於自己的規範，如： iOS 的 Human Interface Guidelines Google 的 Material Design 而除了上述的作業系統 / 應用程式外，網頁開發也是有相關的概念，在 Styleguide 這個網站中就可以查詢到許多相關的範例。 規範可以帶給我們什麼？簡單來說就是限制設計師的風格，一般來說設計師都會有屬於個人的個性及風格，而網站開發都並非少數人即可完成，就有可能出現同一個顏色各自表述的情況，可能會發生的狀況有： 色彩不統一：我的紅與你的紅不同 間距不同：有些設計師偏好雙數的間距，也有設計師喜歡 5 的倍數 字體、字級、字重不同：就算是相同字體、字級，設計師也可能選擇不同字重 插畫風格不同：每個設計師的手繪能力也不同，所以也會造成插畫風格上的差異 格線定義不同：這個在上一章也有提過，設計稿如果格線不同也就難以對齊 動態轉換不同：雖然在網頁中比較少演示這一段，但轉換速率、漸變函式 （ transition timing function ）不同，使用者體驗也會有不一致的問題。 就以 Material Design 來說，建立網站色表時也可以同時產生 主色、次要色、延伸色、背景色、錯誤、文字應用色等等，那麼接下來做延伸設計時也可運用相同觀念。 色彩選定後 Material Design 也會提供許多案例供設計師了解這配色該如何運用，以下圖來說錯誤訊息應使用 Secondary Color，而不是使用帶有緊告意味的色彩或是其它品牌色作為強調色 Material Design 的優點除了 iOS、Material 這兩大系統的規範外，製作網頁其實也有很多規範可以參考（Styleguide ），此時可能會思考為何要閱讀 Material 這樣的規範呢？ 除了有固定的樣式外， Material Design 提供了許多優良概念值得去思考，這部分列出一些我認爲很棒的概念給大家參考： 「紙」的風格https://material.io/design/iconography/product-icons.html#design-principles相對於目前主流的設計風格，大多強調簡潔、色塊，而 Material Design 卻在此基礎之上帶入「紙與墨」的概念，本段就以圖示來介紹是如何呈現紙的風格在內。 為了呈現出紙的風格，所以繪製 icon 時會直接製作出實體，並且觀察實體的光影變化（根本就是在畫素描水彩），透過實際觀察了解紙的切面、陰影、反光等視覺特性。 透過手工製作的 icon，這也是我們熟悉的 Gmail 雛形 打光，我們可以看到陰影的變化，除此之外也可以關注切面所產生的反光，這會讓紙的呈現包含厚度。 實際繪製及上色。 透過這樣的案例，對於圖示也定義了繪製的規範，使所產生的圖示具有一致性。如卡片的邊緣就使用如下的規範定義： 上邊緣： 高：1dp 透明度：20% 色彩：White (#FFFFFF) 下邊緣： 高：1dp 透明度：20% 色彩：參考相關色調及陰影 陰影所代表的 「深度」網頁是平面的，但內容在城線上還是會有前後的順序，如「操作中的物件」為了讓用戶了解他是正被操作的，可以使其更明顯些；而除了外框、修改色彩的方式，深度也是凸顯物件的好技法。 下圖中，拖曳的物件所產生的陰影，會讓物件感覺比較前面。 實際演示的動畫 下圖兩個物件有著不同陰影，因此會感覺深度不同。 深度的概念：下圖中 A 與 B 視覺上會感覺具有相同深度，從正面來看因為 A 具有 8dp 的陰影深度，B 與 C 各有 4dp 的深度，總合上與 A 相同，就會讓用戶感受到兩者的高度（重要性）是接近的。 結語本篇僅是概述設計規範所帶來的觀念，在此非常建議可以親自閱讀這些觀念，身為設計師會不斷的追求「創造力」及「獨特性」，Material Design 說明如何將一個實體的概念轉化為規範，其中的過程更能激發設計師的思考，除了學習符合開發的需求外，更從中了解如何創新。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計常用格線系統(下)","slug":"grid-system-2","date":"2018-10-18T16:00:00.000Z","updated":"2018-11-13T02:43:40.372Z","comments":true,"path":"design/2018/10/19/grid-system-2/","link":"","permalink":"https://wcc723.github.io/design/2018/10/19/grid-system-2/","excerpt":"","text":"上一篇介紹了格線系統的概念及計算方式，擁有了這些觀念後會如何運用在繪圖軟體上呢？無論你是使用 Sketch 或是 Adobe XD 都可以快速建立如前文所提到的格線，本篇不會著重在軟體的操作，而是網格如何運用在網頁的設計上。 實際運用 格線與響應式的搭配 實際運用假設我們的網頁內容包含了以下元素： 頂部的大 Banner（頁首） 側邊選單 主要內容區域 頁腳 我們一樣先依據下圖的數據打開格線系統，如果有必要也可用更大或更小的數值調整。 接下來可以依據這個概念將元素一個一個繪製到畫面上，所有的相對位置大約會如下圖呈現（選單佔 3 欄寬，內容佔 9 欄寬，中間保留一個 Gutter 寬）。透過格線系統的限制下，將不需要花太多精力去思考“水平空間” 及 “水平間距” 需要多大，只要貼的格線繪製都會顯得整齊。 這個概念下，如果有額外的需求也能跟著調整，假設需要增加三個廣告欄位在畫面上，那麼我們可以將三個廣告做 4 欄寬的設計（12 / 3 = 4），也可以如下圖的呈現： 雖然廣告欄位與選單、主要內容區塊的垂直線並沒有完全對應上，但因為具有固定的間隔，還是感受到它具有一定的規範。 額外問題：如果廣告欄位與欄位數不一致怎麼辦？雖然格線系統限制了思維模式，但如果同時熟悉網頁開發技巧其實可以做這樣的變化，廣告欄位維持 4 欄寬度，超過 100% 寬度後將會自動換行，並且以置中的方式來繼續做排列。 格線系統與行動版網頁現在行動版網頁盛行的情況下，網站支援手機瀏覽也是很正常的，而格線系統當然也可以應用在行動版網頁，觀念上大致上差異不大，僅需要調整一些數值即可。先假設需要預覽的寬度為 320px，那麼我們可依據公式將數值調整為如下：公式：((320 - 20) - 20 * 3) / 4Total Width: 320Number of Column: 4 -&gt; 行動版建議不要有太細的欄位數，建議以單欄為主Gutter Width: 20 -&gt; 不變Gutter on outside: 10 -&gt; 不變Column Width: 60 -&gt; 由於欄位數大幅的減少，因此欄寬度也維持在 60px 行動版網頁在瀏覽時會以單欄為主，因此會將原本的內容轉為 100% 寬度，次要的內容會轉為 50% 寬度，甚至是 25% 寬度。 轉換的結果如下圖，元件還是依然的緊貼於格線之上，主要內容佔有 100% 的寬度，保有最大的空間讓用戶可以輕鬆地閱讀。 而在這樣的格線轉換，設計師不需要花費太多心力去計算寬度的轉換，雖然僅製作了 320 寬度的版型，工程師也能從「相同的邏輯延伸出不同尺寸下的變化」，且這樣的公式也能透過 CSS 來得以實踐。 Bootstrap 框架除了設計軟體隨著網頁發展有了新工具，網頁本身在開發時也有許多現成工具可運用，如 Bootstrap 就是網頁開發中最廣泛運用的 CSS 框架，提供了許多現成的組件直接運用，當然也有網格系統在其中。 Bootstrap 的網格系統中包含了多種裝置的設計，對照它所提供的數值其實與剛剛所運用的差異不大，除了 Gutter 為 30px 並非 20px。所以本篇所介紹的內容，只要將格線間隔調整為 30px（實際上維持 20px，Bootstrap 本身也能配合執行），也可以使用 Bootstrap 來執行，並且同時包含桌面版及行動版。 實例接下來你或許會思考「這個概念是否有被廣泛運用」？其實可以從網站中的原始碼尋找一些蛛絲馬跡（因此必須要有查看原始碼的能力），最簡單的方式可以在網頁上按下右鍵 -&gt; 選擇「檢查」。 接下來使用畫面上的小工具來選擇網頁中的區塊。 範例網頁：https://events.google.com/io/畫面中我選擇到了一個區塊，上面的程式碼 grid__item--12-cols grid__item--6-cols--gt-sm中的訊息為： grid__item–12-cols：預設為 12 欄寬 grid__item–6-cols–gt-sm：在小裝置以上時，改使用 6 欄寬 接下來我們可以用相同手法在各個網站尋找，這些概念目前已被廣泛的運用。不過由於網頁技術不斷的跟進，並不一定需要像過去定義欄位數才能完成這樣的排版，甚至可依據內容數量自動排列等寬的格線，製作出類似 Grid System 概念的排版。 以上介紹的網格系統是屬於通用的概念，在熟悉這些概念依然可以做許多延伸，設計並沒有絕對不變的，而是在了解通則及可行性後再來加以變化。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計常用格線系統(上)","slug":"grid-system","date":"2018-10-17T16:00:00.000Z","updated":"2018-10-18T02:30:51.124Z","comments":true,"path":"design/2018/10/18/grid-system/","link":"","permalink":"https://wcc723.github.io/design/2018/10/18/grid-system/","excerpt":"","text":"學習設計的時候，一定會討論到網格系統，透過網格可將圖片、文字做有條理的編排，只要有了網格做支撐，就算是複雜的圖文都會有規矩的排列。相反的，如果平面設計缺乏網格系統，就算簡單的圖文要排列整齊也並非容易的事情。 本篇分別介紹幾個部分： 960gs 名詞解釋 格線設定 及 計算方法 實例 實際運用 格線與響應式的搭配 960gs當然網頁設計也不例外，我們通常稱為 Grid System。在 RWD 盛行起來之前最著名的網格系統稱為 960 Grid System，主要是因為早期的電腦螢幕寬度約為 1024，扣除瀏覽器的捲軸及邊框，960 則是許多數值的最小公倍數，所以被廣泛的討論及使用，直到現在許多 CSS 框架也是有 960 的設定值在內。 https://960.gs/demo.html 960 Grid System 的概念是將 960 區分為 12 欄（也可設定為 16, 24，依據需求不同會有不同的欄位數），接下來網頁中的元素就依據欄位數來排列內容，在 960gs 的網頁中也有提供許多範例是依據這個概念所執行的。 雖然範例中的網頁都有些年代，在網格系統的引導下具有固定的欄寬及間隔，資訊的呈現依然整齊、清楚，並不會感受到雜亂難以閱讀。 名詞解釋介紹 Grid System 名詞時，我喜歡使用 Sketch 的工具，它列出我們在使用 Grid System 的常用設定。 Total Width: 總寬，網頁主要內容呈現的範圍Offset: 推移，這是屬於 Sketch 畫布的設定可以無視Number of Column: 總欄位數，12 是常用的數值，16、24 也是許多開發者使用，這些數值同時是許多數值的最小公倍數。Gutter Width: 間隔寬度，欄與欄的間距。Gutter on outside: 外部間距，設定的間隔寬度是否要加在外層。Column: 單一欄的寬度，總欄位數、間隔寬度及單一欄的寬度數值會有連帶的關係。 實際的結果會如下，960 是一開始設定的總寬度，但如果有加上 Gutter on outside 就會將 (間隔寬度 / 2) 加到畫面的左右外層上，Gutter on outside 的用途是避免網頁主要內容過於貼近瀏覽器邊緣，所以會預先保留一些寬度，但直接保留一個 間隔寬度 會顯得過寬。 一個欄的寬度是 60px，但兩個欄位數的寬度並非是 120px，會再加上兩者之間的欄位間隔，所以數值會是 60 + 60 + 20 = 140px。欄位寬公式：欄寬 * 欄位數 + (欄位數 - 1) 除此之外每個欄寬的數值也是受到「總欄位數、間隔寬度」的影響，實際上會建議自行繪製看看，搭配公式來了解這些產生的原理。單一欄寬公式：(總寬度 - Gutter on outside) - 欄位寬度 (欄數 - 1)) / 欄數範例：((960 - 20) - 20 11) / 12 以上都是觀念，如果了解的話其實透過工具產生即可，並不需要記憶這些公式。 接下來回到這個網頁上，相信你就能理解這些數值的設定分別包含哪些內容，試著思考：假設下方網頁為 960px、欄寬 60px、間距 20px，並且包含外部間距的情況下，請問四籃寬度的內容約佔多寬？ 到這部分相信你對於基本網格系統有基本得了解，雖然在設計時不會一格一格去數多少寬度（通常是直接拉欄位數），不過在具備以上觀念後，我們再來介紹時暫時我們會如何的運用這些觀念。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：設計師思維及工程師思維","slug":"design-vs-developer","date":"2018-10-16T16:00:00.000Z","updated":"2018-10-17T02:25:05.599Z","comments":true,"path":"design/2018/10/17/design-vs-developer/","link":"","permalink":"https://wcc723.github.io/design/2018/10/17/design-vs-developer/","excerpt":"","text":"我接觸設計的時間也非常長了，從大學、研究所到剛出社會，都是維持著設計的思維，直到開始認真學習 Sass、JavaScript 思維才慢慢偏向工程師（不得不說，Sass 真的讓我革新了許多觀念），雖然現在不敢說是完全的工程師的思維，但中間的許多轉換是很值得與大家分享，建議設計師在執行時，不妨試試幾次以工程師為導向的概念來設計網頁，會有很大觀念變化。 以下我列出幾個常見的差異，而這些差異並非全部，僅是我個人在發展中的感想，左方的詞句是設計師，右方則是工程師： 從美好中思考 - 從錯誤中思考 從情境進入畫面 - 從資料進入畫面 喜歡手工打造 - 不重複造輪子 你也這麼認為嗎？我們先繼續看下去 美好與錯誤設計師在學習的過程中，都是以「美」這個字為開頭，整齊、乾淨、沒有錯誤，所以設計稿中都是用最完美的狀態做呈現。 以下是 Azure 的聯絡表單，一般設計師會用最完美的方式呈現，但可能會忽略表單 “出錯” 的狀態。 就業後與工程師合作的過程，工程師與我反映他總是會先製作錯誤的流程；反向思考這一段，我們可以與工程師學習先將錯誤加入設計稿內，而這個樣式加入也可能會造成跑版、突兀、不對稱等問題，也可以優先藉此修正 「完美」設計稿，以配合錯誤中的流程。 範例網站：https://azure.microsoft.com/zh-tw/overview/sales-number/ 從情境進入畫面 - 從資料進入畫面在執行設計時，我們不免會上網搜尋一些素材及資訊，並且透過這些素材拼湊出所需要的網頁。因此圖片選的美、字數要正確、資訊靠拼湊就是設計師的工作了，那麼有可能拼湊出以下的網頁資訊。 對於工程師來說，這些資訊必須要有資料欄位去儲存，最常見用於網頁上的資料格式稱為 JSON，大概長得像下面這樣子。 &#123; &quot;Ticketinfo&quot;: &quot;免費參觀&quot;, &quot;Zone&quot;: &quot;三民區&quot;, &quot;Px&quot;: &quot;120.30211&quot;, &quot;Py&quot;: &quot;22.63961&quot;, &quot;Add&quot;: &quot;高雄市三民區建國二路318號&quot;, &quot;Gov&quot;: &quot;397000000A&quot;, &quot;Website&quot;: &quot;&quot;, &quot;Opentime&quot;: &quot;週二至週日10:00-18:00，每週一公休&quot;, &quot;Description&quot;: &quot;高雄願景館的前身是日治時期興建的高雄市舊火車站，外觀是”和洋混合式建築”氣勢雄偉...。&quot;, &quot;Remarks&quot;: &quot;&quot;, &quot;Name&quot;: &quot;高雄願景館&quot;, &quot;Level&quot;: null, &quot;Picture1&quot;: &quot;http://khh.travel/FileArtPic.ashx?id=705&amp;w=1280&amp;h=960&quot;, &quot;Toldescribe&quot;: &quot;高雄願景館的前身是日治時期興建的高雄市舊火車站，外觀是”和洋混合式建築”氣勢雄偉...。&quot;, &quot;Changetime&quot;: &quot;2015-06-10T15:40:33&quot;, &quot;Tel&quot;: &quot;886-7-2363357&quot;, &quot;Picdescribe1&quot;: &quot;高雄願景館?&quot;, &quot;Travellinginfo&quot;: &quot;&quot;, &quot;_id&quot;: 1, &quot;Id&quot;: &quot;C1_397000000A_000009&quot; &#125; 每一個都包含了 “屬性” 及 “值”，就像是表格中的垂直、水平欄位的對應，而這些值在每一份資料中都會有些許的落差，以 Ticketinfo（票價資訊） 來說可能就包含了以下幾種可能性： 免費參觀 的文字 純數值 的價格 沒有提供這個欄位 這些就會影響到實際呈現的情境，如 免費參觀 的文字出現時，我們就附上 icon 及 免費參觀的字眼；純數值 就必須補上 icon 及 NT$ xxx 元（包含字體樣式及色彩），如果沒有提供此欄位就忽略 icon 的呈現。 所以下次執行前，也不妨先打聽看看是否有提供資料，如果有試著去閱讀每個資料中的差異，接著將所有可能性呈現出來。 喜歡手工打造 - 不重複造輪子設計師的學習過程中總是會提倡創意的重要性，盡可能自行創造且避免抄襲其它人的作法，我在剛出社會時還是從事網頁設計的工作，當時很排斥圖庫、模板、Bootstrap 的工具，會認為這些工具無疑就是抹滅了設計師的價值。 而工程師在執行時恰巧是相反的，會先搜尋是否有合適的資源、套件、案例，接著了解這個案例是否符合專案情境（當然也會注意授權），如果沒有問題就會試著加入到專案內。從他人的經驗上繼續建築，不僅可以減少開發上的時間，並且可以增加專案的可維護性。 如果是剛入門的網頁設計師，會建議多閱讀設計文件，如：Material Design、Bootstrap 這類型的規範，這些規範會限制設計師的思維，但同時會給予合適的執行概念，避免重複造輪子（且輪子每次規格都不同），慢慢的加入模組化及規範的概念，增加設計及合作上的效率。 結語如果決定踏上 UI 或網頁設計這條路，除了精進原有的設計美感外，建議多花些時間學習不同領域的思維，如工程師與設計師不同之處，用戶使用時在想什麼（後續章節也會提到使用者體驗的驗證法）等等。透過這些學習讓設計不再僅限於「美」，而是真正能夠傳達訊息的「好」設計。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：別使用平面繪圖軟體繪製 UI 設計","slug":"dont-use-graphic-design-tool","date":"2018-10-15T16:00:00.000Z","updated":"2018-10-16T02:45:47.410Z","comments":true,"path":"design/2018/10/16/dont-use-graphic-design-tool/","link":"","permalink":"https://wcc723.github.io/design/2018/10/16/dont-use-graphic-design-tool/","excerpt":"","text":"除了前端課程外，自己也是有辦一些額外的活動，而這些都會說到我是一名設計師轉職的前端工程師，除了介紹前端外，我也會介紹一些設計觀念。介紹時我大多都會使用 Sketch 來進行說明，主要原因是 Sketch 的工具非常貼近於網頁及 UI 上的開發。 而這些活動結束後，都會有些朋友詢問到：「一定要用 Sketch 來做設計嗎？Illustrator 或 Photoshop 不足夠嗎？」，我總是會不厭其煩的回答此問題，告訴這些工具可以糾正的事項，本篇也會依據這些問題來回答為何要替換工具。（除了 Sketch 外，Adobe XD 也是個好選擇） 在過去僅有 Sketch 是主要的 UI 設計工具，且該軟體只有在 Mac 上才能運行，而現在 Adobe XD 趨近成熟，且大多用戶都有使用 Adobe 工具，所以轉換上並非有太大問題。而好的工具能夠協助設計師正確學習，而不好的工具無法學習正確觀念，還同時浪費共事者的時間。 為何不使用 Illustrator 及 Photoshop首先，這兩套軟體設計上是平面設計為導向，許多設定都不是給予 UI 使用的，所以非 UI 出身的設計師（如：平面設計師）很容易將平面設計的觀念帶到網頁設計上，這導致「無法學習正確觀念」、「造成溝通上的問題」、「浪費多餘的開發時間」，也直接的影響團隊之間的協作關係，所以不太推薦設計師使用這兩套軟體做開發。 當然也有許多例外，也是有設計師能夠透過這兩套工具完成許多驚艷的 UI 設計，上述的起因在於「對於網頁開發不熟悉」所造成的，如果具有以下能力，就非必要使用 Sketch 或 Adobe XD 的繪圖軟體。 熟悉網頁設計規範者 設計與前端開發都是同一人 正確的工具能糾正觀念由於 AI 與 PS 這兩套工具是以平面設計為導向，所以這些設定與網頁中能運用的數值差異頗大，以下我列出常見的不同點： 網頁都是 RGB 模式，沒有 CMYK 的選項 不好意思舉例了，如果犯了這個錯請自行默默調整 色彩中是運用 RGBA，A 是指色彩透明度，但實際運用與 opacity （物件透明度）是不同的 請不要使用 opacity 調整顏色的透明度 網頁設計時的尺寸單位都是使用 px 部分設計師會使用 pt 來作為文字單位 陰影的設定參數並非使用角度、長度、模糊比例來計算 實際是使用：x、y 的距離及模糊尺寸來計算 現代網頁設計並非只有點陣的選項 網頁設計也很常使用向量的圖形 示意圖：Adobe XD 中的陰影就是使用 色彩、X、Y 及 模糊尺寸的參數，這樣的參數設定對於工程師來說才能執行。 除此之外，所有的介面繪圖軟體都必備網頁格線系統，無需複雜的設定就可以立即使用。 而參數的設定與網頁開發所使用的名稱是一致的，設計師不僅可以從參數中了解各項數值的意義藉此學習格線的運作，也可以透過將這些參數交付給予前端工程師執行。 以上僅是列出常見的部分，工具透過介面、參數的設定限制設計師的行為，除了可以從中學到許多實際執行的觀念外，也可減少開發上錯誤，避免豐富的設計稿卻淪落的無法執行的窘境，而這樣也容易造成開發者與設計師的溝通衝突。 無法執行的設計稿，對設計來說是一種打擊，工程師也不一定了解設計師所遭遇的問題，而透過工具的矯正是相對有效的方法。 正確的工具能減少溝通上的障礙設計後的稿件會輸出給工程師來執行，如果設計稿中可以越明確的標示訊息，工程師在執行上也會更為順利，如： 字體、文字大小 色彩、背景圖 陰影尺寸、類型（向外 or 向內） 物件之間的間距 邊線的寬度、色彩、形式… 在傳統的設計中必須輸出多張圖稿， 每一張標示不同的訊息來說明 “部分” 訊息；而實際中，設計師所標示的訊息都是不足夠的，工程師必須額外的提供需求反覆地與設計師確認設計稿。當然，也有許多時候工程師會使用通靈的方式想像設計預期表達的情境。 Sketch 就可以透過一鍵發佈以下的網頁（XD 也行），透過滑鼠就可以了解以上訊息，並且還可以了解元件之間的距離，這個介面是屬於互動式的，相對於單一的圖片能容納更多的訊息在內。 工具限制了設計師的行為，讓設計師不能隨意地使用豐富的參數、濾鏡等等來設計網頁，其實也是為了降低溝通上的成本，並且確保輸出的結果是能夠被執行的。 正確的工具能減少開發的時間這些設計工具，都是不斷的依據開發者的需求再做優化，如輸出圖片來說都有提供一鍵大量輸出成 svg、png、jpg 的服務。 除此之外，Sketch、Adobe XD 都有提供完整的設計稿輸出（範例：F2E 前端 PK 賽甜點電商），這些設計稿不僅有完整的的標示，且工程師或 PM 更新需求時，也不需要重新標示，僅需要一鍵再次輸出即可。 設計師是專案中最前方的引導者，接獲需求後，設計師會像領航員一樣率先繪製地圖來讓其它水手（工程師）了解目標，當設計師有足夠的效率來繪製地圖，自然可以加快達到目標；反之，浪費時間在不好的工具上也等同是浪費整個團隊的時間。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：前端「設計」聖光之路","slug":"frontend-design-holy-road","date":"2018-10-14T16:00:00.000Z","updated":"2018-10-15T03:22:55.313Z","comments":true,"path":"design/2018/10/15/frontend-design-holy-road/","link":"","permalink":"https://wcc723.github.io/design/2018/10/15/frontend-design-holy-road/","excerpt":"","text":"我是卡斯伯，本身是設計出身，從高職 -&gt; 大學 -&gt; 研究所都是設計相關領域，出社會後從事網頁設計後來轉職為前端工程師。雖然主要工作是前端，但還是會有不少時間接觸網頁設計，所以相信我的經驗也是能夠帶給大家許多參考，並且完整的前端經驗也會有助於這些概念的實作。 為什麼要寫這系列文？不同領域的人們在協作時都會有些許的紛爭，設計師與工程師一直以來也會有這樣的嫌隙，但其實並非所有「設計師與工程師」都有這樣的對立狀態。 這樣的對立來自於「不了解對方」所造成的，設計師可能會想：「有這麼困難嗎？」，工程師則會想：「是想搞死人嗎？以為幾個標籤就搞定！？」，其實觀念的建立是可以減少這樣的紛爭，比如說「預先定義樣式元件庫」，並具有相同的設計邏輯，那麼工程師就可以依據這樣的邏輯反覆運用，設計師產生新的頁面時也是用相同的尺寸、色彩、元件再做變化，前端工程師如果已經依據設計製作好相關元件庫，那麼接下來也就真的用幾個標籤搞定這些事情。 所以，這次的系列文會有助於具有設計相關經驗的工作者，進入此領域時可以注意到更多的細節，減少溝通上的磨擦；非相關領域者，也可以再這次的系列文章學習美感技巧，文中會介紹很多小撇步如：韻律、配色、格線等觀念，讓大家在設計上可以抓到簡單的準則。 這系列文章適合什麼人看？雖然是設計系列文章，但我會撇除理論概念（美學、什麼是美等等…），會以實際的案例說明，並且以圖文交錯的方式介紹。 平面設計轉網頁設計師：相信你們在進入職場（或者未來進入職場），都會遇到許多溝通上的問題，畢竟我身邊就有許多的案例。所以這些文章會告訴你如何快速了解平面設計與網頁設計有什麼不同，並且了解有哪些資源可以運用，哪些觀念應該拋棄。 初階 UI 設計師：如果你是專職的 UI 設計師，本篇會介紹許多前端開發者在執行上的一些要點，你可以試著將一些觀念融入你的設計之中，相信與您搭配的工程師會體會到你的貼心。 前後端工程師：本篇還會介紹許多美感上的觀念，就算沒有設計師也瞭解畫面該如何配置、圖片如何選擇、色彩的選用等等。不需要太多經驗也能做出具有基礎美感的網頁。 會介紹哪些主題？相關大綱我還不段的調整，有許多章節是不具有連貫性的，畢竟這不是一份完整的 Guideline，而是告訴大家可以怎麼做的系列文章，所以會著重在以下要點： 工具的運用及思維調整 基礎網頁設計概念（格線、色彩、響應式、互動、文字、圖形…） 使用者體驗 - 別挑戰大家的習慣 美感 - 網頁設計大家都這麼做 設計規範 - 具有邏輯的設計 資源分享 相關文章中也會帶入許多設計實例、原始碼、各種規範文件的說明。影片來自於 Material Design 官網，完整說明 以上主題，你們著重瞭解哪部分呢？歡迎留言讓我知道，我盡可能在一些章節準備更多內容喔。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"Github Pages 自訂網域免費升級 https","slug":"gh-pages-https","date":"2018-07-26T16:00:00.000Z","updated":"2018-07-27T08:12:40.782Z","comments":true,"path":"design/2018/07/27/gh-pages-https/","link":"","permalink":"https://wcc723.github.io/design/2018/07/27/gh-pages-https/","excerpt":"","text":"Chrome 在 68 版以後會將沒有 https 連線的網站標上不安全的字樣，如果使用 Github Pages 但又不想花大錢買憑證的朋友，可以參考本篇免費安裝 https 憑證。 現在 Github Pages 免費提供自訂網域核發 HTTPS 憑證，且這段流程是完全自動，不需要額外申請，雖然是全自動的，但也需要符合規範才能自動申請。 需要注意的地方憑證是 Github 代為與 Let’s Encrypt 申請，主要也是推廣 https 的使用。如上所述，申請的流程是完全自動，只要完成以下兩個條件 Github 就會自動申請，並且選擇可免費使用 https (憑證約可使用三年)。 Domain 指向的 ip 替換過去 Github pages domain 設定使用的 ip 是兩組 “192” 開頭的 ip，目前這兩組依然可以運作，但如果需要自動申請 https 則需要將 domain 指向的 ip 替換成以下四組。 185.199.108.153 185.199.109.153 185.199.110.153 185.199.111.153 建議先將 ip 替換好並過一小時後再進行以下流程，稍後會說明原因。 網頁中的所有資源，都必須是 https設定完 ip，可以將網頁中的所有資源 (css、js、圖片、外部連結等等) 全部替換成 https，並且重新上傳至 Github Pages 中，至於相關的替換可以參考 Github 的說明文件 (如下所示)： Asset type HTTP HTTPS CSS &lt;link rel=\"stylesheet\" href=\"http://example.com/css/main.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://example.com/css/main.css\"&gt; JavaScript &lt;script type=\"text/javascript\" src=\"http://example.com/js/main.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://example.com/js/main.js\"&gt;&lt;/script&gt; Image &lt;A HREF=\"http://www.somesite.com\"&gt;&lt;IMG SRC=\"http://www.example.com/logo.jpg\" alt=\"Logo\"&gt;&lt;/a&gt; &lt;A HREF=\"https://www.somesite.com\"&gt;&lt;IMG SRC=\"https://www.example.com/logo.jpg\" alt=\"Logo\"&gt;&lt;/a&gt; 接下再到 Github 專案中如下圖的設定頁面。 圖片中的回饋訊息是已經正確完成的，目前我所知道回饋訊息有三種 (我僅記得大概意思，忘記截圖了 orz)： 網頁不符合 https 規範，所以無法開啟 https (無法 checked 核取方塊)，並且會提供連結 說明修改事項。 如果沒有先換 ip 也會一直卡在這個階段，會較難判斷是資源沒有替換完整或是 ip 沒有換，因此建議先替換 ip 再更新網站。 憑證核發中， 24 小時內即可完成 (無法 checked 核取方塊) 到這個步驟就算完成了，雖然文件是寫 24 小時，但是約 2 ~ 4 小時就可以完成。 HTTPS provides a layer of encryption that prevents others from snooping on or tampering with traffic to your site. 完成，此時可以直接使用 https:// 進入所申請的網址，並且 http 也依然可以繼續使用，如果選擇 Enforce HTTPS 進入網站會自動導向 https。 (開啟後也須等待一段時間) 下圖是最終完成的示意圖： 範例網站：https://bootstrap.hexschool.com/","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"老同學來相找，一同轉行做 UI 設計師","slug":"be-a-ui","date":"2018-05-24T16:00:00.000Z","updated":"2018-05-25T07:05:42.186Z","comments":true,"path":"design/2018/05/25/be-a-ui/","link":"","permalink":"https://wcc723.github.io/design/2018/05/25/be-a-ui/","excerpt":"","text":"最近有些高中、研究所老同學、朋友們看到我在六角學院，也會問到如何轉行 UI、前端，很高興你們來詢問，如果對於此領域有興趣的朋友都可以來聊聊。 在此我推薦一些資訊，可以協助你們(或大家)從網頁設計慢慢轉行到 UI、網頁設計師。不過首先，平面設計的觀念到這個領域不一定受用，有許多邏輯性的概念是不同的。如：單位尺寸、色彩、字體字型、資訊流觀念都還是要重新學習，許多東西簡化了，也有許多複雜化了，可以先花點時間從文件下手，將會少走冤枉路(當作睡前讀本也是不錯)，不囉唆，先列出內容給大家參考： Google Material Design(UI、網頁設計師)https://material.io/ 由 Google 所推出的設計規範，也是近幾年 UI 規範的經典，雖然主要是介紹 Andriod 的設計介面(新的文件涵蓋內容更廣泛)，但裡面許多觀念是非常直得學習的，而這些概念套用在 Web 很受用的，如色彩配置介紹了主色與次要色： 在畫面上的比重 透過次要色強調重要內容的方法 與互動之間的關係等等 圖片來自於 Material Design 官網 另外，我也很喜歡它介紹到關於圖層的部分，透過陰影的強弱來表示圖層之間的關係。陰影越強、代表兩個圖層的關係越弱(像是距離越遠)。 影片來自於 Material Design 官網，完整說明 這也是持續在更新的文件，很建議直接觀看官方所提供的英文版本。我過去也有翻譯 Material Design，不過注意，官方更新太快，所以許多內容已不適用。 Bootstrap 文件(網頁設計師)http://getbootstrap.com/ Bootstrap 是網頁開發的現成框架，裡面許多元件都可以直接拿來用，如果打算進入 Web 開發領域的話，這份文件很值得閱讀，主要原因如下： 非常優秀的格線 圖片來自於 Bootstrap 官網 無論是平面設計或是網頁設計，都會有格線在做支撐，確保我們的畫面具有一定穩定性，這份文件有提到在網頁設計中的格線設計，不過如果覺得 Bootstrap 的文件太難懂，也可以參考：https://960.gs/。 元件設計適合 Web 運用 可以避免繪製畫面的時候，天馬行空的介面讓開發者難以執行，至少這些元件具有一定的規則，能夠確保它的可行性。 我們翻譯的繁體中文文件：http://bootstrap.hexschool.com/ 工具使用(UI、網頁設計師)工具上推薦使用 Sketch 或 Adobe XD，不建議使用熟悉的 Illustrator 及 Photoshop，因為後者在設計上比較偏向印刷使用，許多參數並無法呈現給開發者運用，這也會常常造成設計師與開發者溝通上的障礙，如果堅持使用，則有許多技術上需要克服。 平面轉 UI 會有經歷一些過程，首先應該 “先確保設計能被執行”，這也是大多設計師進入時會遇到的問題。一開始可能會先把平面設計的觀念帶過來如：色彩使用 CMYK、文字尺寸設定 pt、輸出解析度選擇 300dpi…等等，再經過一些練習後，還是會有執行上的問題，工程師無法諒解設計稿的錯誤，此時就能透過 “設計規範” 學習正確的觀念。 進階的 UI 設計師，能夠在工程師執行前就先預期結果，比如：流程動向、產品概念是否正確、資訊呈現是否符合預期…。而這個階段除了上述的基礎要打得穩外，更著要是實戰經驗的累積。 以上，也很歡迎同學們一起來討論 UI、網頁設計喔。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"Github 中的 ssh、https 路徑有什麼差異？ - 如何設定 Github SSH 金鑰","slug":"github-ssh-https","date":"2018-02-11T16:00:00.000Z","updated":"2018-02-13T05:35:46.099Z","comments":true,"path":"git/2018/02/12/github-ssh-https/","link":"","permalink":"https://wcc723.github.io/git/2018/02/12/github-ssh-https/","excerpt":"","text":"再推出 Hexo 介紹影片以後，會有許多同學私下問我關於 https 與 ssh 這兩個有什麼差異？另外會不會影響部署？為什麼看老師是使用 ssh 而自己用 ssh 卻跳出權限不足？ Git 中 https 與 ssh 這兩個有什麼差異？這兩個均是 Git 儲存庫的路徑，Github 官方推薦使用 https 但同時也提供 ssh 的連線方式，兩者差異點在於： https: 在上傳時需要輸入帳密，如果不需要大多是帳密(Key Chain)已存在電腦內。 ssh: 已先在電腦內設定好金鑰，上傳時不需要輸入額外帳密。 所以這個僅是上傳的路徑，所以選擇哪一個都不會影響最終上傳的結果或是 Hexo 部署的結果喔。而我使用 ssh 也是因為有先設定好金鑰，如果沒有設定金鑰也就會跳出權限不足的字樣喔。 如何設定 Github SSH 金鑰Github: 使用 SSH 連線相關文章 本篇文章以 Mac 的為主，如果你使用的是其它作業系統，上述文章也有詳細描述，整體差異不會太大喔。金鑰本身是一對的一個公鑰及一個私鑰，流程會是在本地端產生一組公私鑰，然後將公鑰上傳到 Github 上，接下來再上傳儲存庫時 Github 就會透過公鑰與電腦中的私鑰比對驗證，藉此不需要再輸入帳密。 步驟一：產生金鑰輸入以下指令，來產生新的 SSH Key。 ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot; $ Enter file in which to save the key (/Users/casper/.ssh/id_rsa): # 這行只是確定存在哪 $ Overwrite (y/n)? # 如果原本就有金鑰會跳出此問題，覆蓋嗎？ (是) $ Enter passphrase (empty for no passphrase): $ Enter same passphrase again: # 輸入密碼 此密碼與 Github 密碼無關，只是使用這個金鑰的密碼，為了寫這篇文章，我真的覆蓋了 Q_Q 步驟二：設定金鑰代理 (Adding your SSH key to the ssh-agent)啟用 SSH 代理伺服器，這個步驟可以讓之後使用此金鑰不需要再輸入額外的密碼(剛剛的自訂密碼)，如果跳過此步驟，之後就要輸入自訂密碼。 $ eval &quot;$(ssh-agent -s)&quot; 將私鑰及加入到 SSH 代理上，並且同時儲存剛剛的自訂密碼： $ ssh-add -K ~/.ssh/id_rsa 步驟三：上傳公鑰Mac 內的個人目錄下可以找到 .ssh/ 資料夾，以下會分別有 id_rsa、id_rsa.pub 兩個檔案，也分別為私鑰及公鑰，此步驟就是將 id_rsa.pub 檔案的內容上傳到 Github 上。 請用文字編輯器打開以上檔案並複製其內容。接下來到 Github &gt; Settings &gt; SSH and GPG keys 的設定頁面，選擇 New SSH Key。 接下來會出現設定頁面，上方標題可以自訂名稱，下方則可以貼上剛剛所複製的 Key，都確定後再輸入 Github 密碼則完成綁定， 然後進行一次 git push，如果可以進行推送就完成了，在剛剛所設定頁面重新整理後也會看到 Last used within the last week 最近一週有使用的字眼。 雖然官方是推薦使用 https，但不用輸入帳密真的很方便。","categories":[{"name":"git","slug":"git","permalink":"https://wcc723.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"鐵人賽：邁向 JavaScript 的勇者","slug":"javascript-ironman-ending","date":"2018-01-01T16:00:00.000Z","updated":"2018-01-02T03:26:34.522Z","comments":true,"path":"javascript/2018/01/02/javascript-ironman-ending/","link":"","permalink":"https://wcc723.github.io/javascript/2018/01/02/javascript-ironman-ending/","excerpt":"","text":"這次是第四次參加鐵人賽，先前參加的主題分別為兩次 CSS 及一次 JavaScript (D3.js)。 因為原本是視覺設計師，在過去曾經打算專精於 CSS 就好，所以不斷專精 CSS 的表現模式以及他的開發模式，我還曾經開發過幾次的 CSS Framework (有實際運用過)，不過隨著時間發展這個概念有了改變 :D。 撇開 CSS 不說，對於多變的 JavaScript 還是有一些自己的看法，在最後一篇就寫寫我對於此的一些看法。 目前還有持續學 CSS 嗎？CSS 很重要，但如果在良好的架構下，定義好的 CSS 基本上不太需要去做調整，一個專門的前端開發者 (需要包含 CSS、JavaScript 開發)，絕大多的時間都會把開發精神放在 JavaScript 上，且 CSS 的變化性不像是 JavaScript 那麼快，學個幾招夠用好幾年，所以就現在來說只會先略為研究新的語法 CSS Grid，但目前不會使用在主要的產品網站上，等有被實際運用在主要網站上後再觀察也不遲。 以 Flex 來說，我在 4 ~ 5 年前就已經有研究了，2 ~ 3 年前已經有許多知名網站已經開始套用(我自己實際是在 2016 在產品頁面上套用 Flex，發生錯誤的回饋並不多)，但實際被接受也是近一兩年，CSS 變化挺慢的且應用變化不多，所以新語法研究一段時間後就把時間拿去研究 JavaScript 了。 先學 jQuery 還是先學 JavaScript先說，我是先學 ActionScript 的，後來開始工作後開始學 jQuery，後來才開始花更多的時間學習 JavaScript 。 這個議題也是看過很多人討論，但就目前而言我會比較推薦先學「jQuery」，除了你可以啃得下 JavaScript 基本指南 不會覺得難以閱讀(如果沒問題，可以跳過 jQuery)。會先說學習 jQuery 的原因在於它容易學習且容易有成就感，並不是所有人在學習 JavaScript 就有程式背景，而 jQuery 將許多複雜的概念用簡單的方式去執行。 雖然如此，在了解 jQuery 後，還是需要精進 Native JavaScript 能力，畢竟糖吃太多對身體不太好。學了 JavaScript 後可以再回頭看看 糖 的成分是什麼，也會有所茅塞頓開的感覺。 要不要接觸後端我主要的工作是前後端均有參與的，雖然不到專精於後端的全端工程師，但基礎的 Router、API、部署 也都沒有問題，如果對於 JavaScript 掌握度有一定的朋友，或工作上有很長時間需要接觸 JavaScript 的開發者，非常建議花時間玩玩 Node.js，原因如下： 了解前後端協作的眉角前端並不了解後端，也並非所有後端了解怎麼與前端配合，在這兩個專業領域之間就產生了一個隔閡，許多誤會、溝通成本就在此部分出現。所以身為前端如果了解後端的運作原理，自然也能夠多為對方著想。 像是一個新的開發需求產生，如果前端在等待後端的 API 過程中就只能刻刻畫面、假裝研究新技術!?但如果有些經驗後，也可以先與後端先討論 資料欄位、API 發送時機、後端需配合的額外欄位 (很多是為了配合畫面而開的)，這樣的討論下，後端甚至能在腦中勾勒出：「啊，原來這樣做就好了喔～」(情境二：靠北，怎麼這麼麻煩)，然後預先產出可用的資料結構供前端先行運作，最後等待兩人完成的介接。 更豐富的運用瀏覽器端的 JavaScript 通常稱為 “客戶端”，主要是讓使用者有更好體驗所存在的，但 Server 端就不僅僅是為了服務客戶端，除了服務公司外，也能成為自己的好幫手。 像是 好想工作室的 Howard: 爬蟲始終來自於墮性 就是一個例子，最近聽到一個學生看完他的爬蟲教學後，也嘗試來爬 PTT 表特版 (優秀)。除此之外像是金流服務、Bot，甚至到個人創業的 idea 都可以執行。好後端，不試試嗎？ 穩定的環境在瀏覽器端寫 ES6 (甚至部分 ES5) 都要不斷的注意相容性，有些語法寫得很開心，實際測試卻不能運行；不然就是要透過 Babel 來編譯，把純 JavaScript 都搞得像前置語言一樣 (CoffeeScript、TypeScript…)。在 Node.js 環境下，可以直接看 Node.js Support ES6 了解目前的伺服器可以運行哪些語法，不行直接掛點，一翻兩瞪眼毫不囉唆。 JavaScript 多面向的運用情境JavaScript 可以被運用的層面相當廣，就目前所認識的程式語言來說，他是最廣的一種(很抱歉，這裡我就不去查相關資料囉)。從前面所介紹的前端、後端，他亦可運行在許多不同的環境下，如果地球上最多人使用的是印歐語系，那麼 JavaScript 就是開發界的印歐語系，搭配不同的工具，讓同一個語言到處都能通。 桌面應用程式 代表工具：https://electronjs.org/ 應用程式：Slack、Atom、Github Desktop、VSCode Electron 是基於 Chromium 和 Node.js (簡單來說就是一個 Chrome 的應用程式)，因此只要瀏覽器做得到的事情，基本上他都能辦到，並且可以與作業系統的環境整合(最近文件、自訂選單、縮圖、提示訊息…)，也有許多官方應用程式現在都是直接使用 Electron 做開發，透過此工具可以一次開發符合 Windows、Mac OS、Linux 等平台，相對能減少許多的開發成本。 缺點：一個應用程式相當於一個 Chrome 分頁，資源相對消耗比較高。 行動應用程式 代表工具：Crodova 相關支援工具：Ionic、Adobe PhoneGap Crodova 與 Electron 類似，但亦有些不同。Electron 是基於 Chromium 上開發(運行在 Chrome 上)，而 Crodova 基於瀏覽器的 Web View(是使用裝置的瀏覽器)，另外 Electron 除了 Web 技術外，另外還包含 Node.js，而 Crodova 僅使用 Web 技術。 使用 Web 技術開發行動應用程式發展許久，但因為每家的瀏覽器都略有些不同，要做到跨裝置的呈現還是有些困難，效能、呈現上也似乎還離原生應用還有段距離， IOT 代表工具：Webduino 相關教學：https://ithelp.ithome.com.tw/users/20091306/ironman/1161 Webduino 是台灣所開發的應用服務，可以使用 Web JavaScript 呼叫雲服務的 API 控制 Arduino，也因為可以使用 Web 技術，無論是什麼框架都沒有限制(jQuery, polymer 都可使用)。先前有參加過他們活動，當第一次透過自己寫的程式碼控制燈泡亮起來是真的非常有成就感。 他們先前釋出的影片，透過 Web 操作氣球，就如同遙控飛機一樣。 鐵人賽結束當然，很開心在幾年前學到一個應用層面這麼廣的程式語言，到目前還有許多都還不斷的在學習中。除了開發以外，今年依然期許自己能夠有更多的發展(區塊鏈、智能合約等等)。 那麼，感謝大家三十天來的觀看，有機會可以來我粉絲團聊聊喔 :D 卡斯伯粉絲團：https://www.facebook.com/WccCasper","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：透過 ESLint 學習 JavaScript ES6","slug":"javascript-eslint","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-01T02:38:15.845Z","comments":true,"path":"javascript/2018/01/01/javascript-eslint/","link":"","permalink":"https://wcc723.github.io/javascript/2018/01/01/javascript-eslint/","excerpt":"","text":"至於 ES6 該怎麼學比較好!?很建議安裝 ESLint 來邊學邊修正觀念。ESLint 是一個團隊統一程式碼結構的工具，如果程式碼不符合規範，則會出現相對應的提示，而其中有三大主流規範是許多開發者愛用的： Google Airbnb JavaScript Standard Style 三個都有各自的擁護者，風格上 Airbnb 較為嚴謹，每一種語法都有嚴格的規範；而 JavaScript Standard Style 感受上較為輕鬆，像是每行的最後方也不需要加上分號，也不至於強制要求每一種語法的寫法，簡單來說：整齊就好。 以下面這個範例來說是屬於 Airbnb 的錯誤，沒有符合規範的語法會出現紅色提示，裡面也有完整的描述說明該如何修正。 在此依據提示將範例修正了一下，包括： 不會再修改的請用 const 能寫單行請別寫那麼多行好嗎？ 一個參數而已，幹麻用小括號包起來 每行後面都要有分號 console.log 記得移除 修改完後當然提示文字也就會消失，而 console.log 上的提示是 Unexpected console statement. (no-console)，記得在發布前移除這個東西。 安裝 ESLintESLint 可以運行在許多文字編輯器，而 VSCode 中非常容易整合這樣的工具，這邊提供兩個方法給大家參考，不過記得兩者不能混用，使用時請擇一即可。 ESLint：比較正式的方法，有完整的文件規範，適合團隊使用 JavaScript Standard Style 插件：比較簡單的方法。 方法一：ESLint先開啟 / 安裝 VSCode 中的 ESLint 套件，記得預設的 VSCode 是有安裝此套件的，套件中也有提到如何運行。 安裝 ESLint 的 npm 套件，目的是可以使用 eslint 的指令，方便建立規範使用的。npm install -g eslint 開啟 Terminal 後，輸入 eslint --init 接下來會出現一連串的問題，你想要怎麼建立 ESLint 的規範文件？Q: How would you like to configure ESLint? Answer questions about your style Use a popular style guide Inspect your JavaScript file(s) 建議選擇 使用主流的 Style Guide (第二個)，如果使用此選項，他會要求先建立 package.json，如果專案中沒有 package.json 可以輸入：npm init 其中的問題可以 Enter 到底即可，接下來再回到上一步 eslint --init 繼續選擇建立規範。 選擇 Use a popular style guide 後，會出現三個主流的規範。 Google Airbnb：如果選擇此選項，會多問一個是否使用 React Standard 接下來會選擇要哪一種格式 YAML、js、json 來儲存規範，這個規範是能夠讓其他專案使用的，只要團隊討論好即可。 安裝完後，在專案內會增加一個 eslint.js (或者其他，依據上述選擇的而定)，此時可以先關閉 VSCode 專案再重啟一次，接下來選擇 “輸出” 可以看到 ESLint server is running.，並且沒有其他錯誤訊息表示已成功運行 (如下圖)。 接下來會看到畫面上都了很多紅色提示，滑鼠移到紅底線上方會提示該如何修改。 目標就是減少畫面上的紅字 T_T，如果有未定義的變數也會跳紅字，目標當然是去除專案中的紅字來符合規範。 上圖選的是 Airbnb 的規範，相關可參考：GitHub - airbnb/javascript: JavaScript Style Guide 其它注意事項： 如果無法順利進行，可嘗試重新安裝 node_modules 試試看。 如果有替換規範，也要重新安裝 node_modules。 重開 VSCode、重裝 node_modules 都是解決問題的好方法。 方法二：JavaScript Standard Style這是使用 Standard JS 提供的 VSCode 套件，不要與 ESLint 混合使用，也可以直接在工作區關閉 ESLint 只執行 Standard JS 接下來安裝 JavaScript Standard Style 的 VSCode 套件，安裝完後直接重起就能使用了，沒有額外的設定檔。 套件路徑：https://marketplace.visualstudio.com/items?itemName=chenxsan.vscode-standardjs 啟用後再右下方一樣會出現 JavaScript Standard Style 的字樣，Standard 相對於其他規範來說寬鬆很多，最大的特點是沒有分號。 寫起來長得像這樣 (未定義或定義但未使用的仍然會跳錯)，另外還有繁體中文的文件 (standard/README-zhtw.md at master · standard/standard · GitHub)。 我自己是比較喜歡 Standard，但缺點就是沒有分號，如果用在教學中同學可能會誤以為 JavaScript 不用分號。Airbnb 比較不習慣的則是物件裡的逗號，一般物件的最後一個是沒有逗號，但在 Airbnb 則是逗號到底。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 建構式語法糖","slug":"javascript-constructor","date":"2017-12-30T16:00:00.000Z","updated":"2017-12-31T03:21:22.641Z","comments":true,"path":"javascript/2017/12/31/javascript-constructor/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/31/javascript-constructor/","excerpt":"","text":"這一段與先前介紹的建構式概念接近連結，單篇觀看可能無法理解為何 JavaScript 要加入 Class 的概念，而 Class 在 JavaScript 只是個語法糖，讓建構式及原型更容易被表現而已。 ES6 建構式這裡我們先將先前章節的程式碼整理過來，除了順序有些調換外，觀念上是沒有差異的，最後產生的值包含了物件屬性及原型的方法。 function PhoneTemplate(brand, modal, withCamera) &#123; // 定義基本屬性 this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; // 原型方法 PhoneTemplate.prototype.takePhoto = function (someone) &#123; if (this.withCamera) &#123; console.log(this.modal + &#x27; 照相&#x27;); &#125; else &#123; console.log(this.modal + &#x27; 這台沒有照相功he能&#x27;); &#125; &#125; PhoneTemplate.prototype.callSomeone = function (someone) &#123; console.log(&#x27;打通電話給 &#x27; + someone) &#125; var sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); var nokiaPhone = new PhoneTemplate(&#x27;Nokia&#x27;, &#x27;3310&#x27;, false); 接下來使用 class 來改寫，你可以對應著上方的原始碼與下方的一起看，僅有三個小地方要稍作修改： function PhoneTemplate 定義名稱 -&gt; class PhoneTemplate 初始化物件屬性寫在 constructor ()內，一個 class 也只能有一個 constructor。 原型方法直接寫在 class 內就可以了 // ES6 Constructor class PhoneTemplate &#123; // 定義基本屬性 constructor (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; // 原型方法 takePhoto () &#123; if (this.withCamera) &#123; console.log(this.modal + &#x27; 照相&#x27;); &#125; else &#123; console.log(this.modal + &#x27; 這台沒有照相功he能&#x27;); &#125; &#125; callSomeone (someone) &#123; console.log(&#x27;打通電話給 &#x27; + someone); &#125; &#125;; var sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); var nokiaPhone = new PhoneTemplate(&#x27;Nokia&#x27;, &#x27;3310&#x27;, false); 結果： constructor 定義了原本在物件內的屬性及值，其中也包含外部傳入的參數。 原型原本是 prototype 的方法，在 Class 的類別方法是直接寫在 constructor 的後方，這樣的好處讓程式碼閱讀更為容易。 static 靜態方法靜態方法屬於原型專屬的方法，它並不會繼承到物件上。像是陣列原型中有一個 of() 的方法，但一般陣列是無法使用專屬於原型的陣列方法。 Array.of(1,3,4,5,6); // [1, 3, 4, 5, 6] [1, 3, 4, 5, 6].of(); [1,3,4,5,6].of is not a function 靜態方法只能被原型使用，無法在創立的物件上使用。 class PhoneTemplate &#123; // 定義基本屬性 constructor(brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; // ... // 靜態方法 static info() &#123; console.log(&#x27;這是手機原型&#x27;); &#125; &#125;; var sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); sonyPhone.info(); // sonyPhone.info is not a function PhoneTemplate.info(); // 這是手機原型 Setter, GetterGetter, Setter 顧名思義，一者是傳入、另一則是讀出，兩者可以同時對 “相同的變數” 進行操作，如以下範例來說，我們可以傳入 1，但讀出為 2。set 同時修改傳入的變數，讓 get 的資料不同。 // ES6 Constructor class PhoneTemplate &#123; // 定義基本屬性 constructor (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this._core = 1 this.withCamera = withCamera || false; &#125; // get, set get core () &#123; return this._core &#125; set core (coreNum) &#123; let num = Number.parseInt(coreNum) this._core = num * 2 &#125; // 其它原型方法 // ... &#125;; const sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); console.log(sonyPhone.core); // 1，預設的 _core sonyPhone.core = 4; // 傳入 4 console.log(sonyPhone.core); // 會透過 set core * 2，結果會是 8 另外特別是傳入的方式是使用 等號，而不是 function 的參數。 如果只有 getter 則不能修改 setter 則只能傳入一個參數 ES6 建構式 + extends先前已經使用一個建構式建立基本的原型，在先前我們也有提到，原型概念中還有一個是原型鍊。也就是原型可以不斷地繼承，但到目前為止的範例我們都只有創造一層原型。 手機模板是一個基本的原型，這個原型不夠使用時我們可以在上新增方法，但有些時候我們擔心會干擾到其它已建立的原型，我們可以使用 extends 來擴增新的方法。 有個品牌總是要做出最屌最潮的手機，他可以以目前手機作為基礎再加以擴增。 這裡會看到兩個新的單字 extends、super： extends: 繼承於另一個原型之下 super : 使用上層的值(屬性)// 第一層 class PhoneTemplate &#123; constructor (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; takePhoto () &#123; if (this.withCamera) &#123; console.log(this.modal + &#x27; 照相&#x27;); &#125; else &#123; console.log(this.modal + &#x27; 這台沒有照相功能&#x27;); &#125; &#125; callSomeone (someone) &#123; console.log(&#x27;打通電話給 &#x27; + someone); &#125; &#125;; // 利用上一個建構式作為延伸 class ApplePhone extends PhoneTemplate &#123; constructor (brand, modal) &#123; super(brand); // 繼承原本的建構式中的變數 this.modal = &#x27;iPhone&#x27;; // 直接賦予變數 &#125; // 直接寫入新的方法 hiSiri () &#123; console.log(&#x27;hi Siri&#x27;); &#125; &#125; var iPhone = new ApplePhone(&#x27;Apple&#x27;); console.log(iPhone); // 這個與先前的建構式有接近的格式 iPhone.takePhoto(); // 由於沒有傳入相機功能，所以沒辦法 iPhone.callSomeone(&#x27;小明&#x27;); // 能使用上一個建構式的方法 iPhone.hiSiri(); // 能使用新建構式方法 這個概念下也能夠繼承於現有的原型，如以下範例就是將 MyPhones 繼承於 Array 之下，這種繼承方法可以讓新的建構式擁有陣列的全部方法，也可以藉此增加新的方法。 class MyPhones extends Array &#123; constructor(name, ...phones) &#123; super(...phones); // 繼承原本陣列的值 this.name = name; &#125; add (phone) &#123; // 自訂的方法 this.push(phone); &#125; &#125; const JayPhones = new MyPhones(&#x27;杰倫&#x27;, &#123; name: &#x27;iPhone&#x27; &#125;, &#123; name: &#x27;Z&#x27; &#125;); console.log(JayPhones.length); // 傳入兩個值作為陣列，所以長度確實是 2 JayPhones.add(&#123;name: &#x27;G&#x27;&#125;); // 再增加一個值 console.log(JayPhones.length); // 陣列長度改為 3 console.log(JayPhones.name); // &#x27;杰倫&#x27;：除了陣列外，名字也在裡面，因為陣列本質就是物件 JavaScript 中許多觀念很重要，其中之一則是原型。許多時候一些語法上的錯誤或是概念一時轉不過去，打開 console 看看物件的圓形，或許就能明白。 另外…，剩兩篇了!?","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript Await 與 Async","slug":"javascript-async-await","date":"2017-12-29T16:00:00.000Z","updated":"2017-12-30T02:52:43.878Z","comments":true,"path":"javascript/2017/12/30/javascript-async-await/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/30/javascript-async-await/","excerpt":"","text":"不知道上一篇大家對於 Promise 概念如何，本篇介紹的內容與 Promise 依然有相關性，因為這兩者就是建構於 Promise 之上的，如果直接從原始碼看可能不是很好瞭解這語法怎麼使用，不過可以先直接用 Google 翻譯了解大概意思： await: 等待 async: 非同步 Await 等待Promise 中完成會透過 then 來回傳，在 await 中他則是會等待這段函式完成後在往下繼續執行，這是一個卡住的概念。 以下這段是上一個章節建立的 Promise，在這個非同步的方法下他並不會影響其他函式的運行。 小明開始跑後，並不會影響其它運行。 let runPromise = (someone, timer, success = true) =&gt; &#123; console.log(`$&#123;someone&#125; 開始跑開始`); return new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 if (success) &#123; setTimeout(function () &#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(`$&#123;someone&#125; 跑 $&#123;timer / 1000&#125; 秒時間(fulfilled)`); &#125;, timer); &#125; else &#123; // 回傳失敗 reject(`$&#123;someone&#125; 跌倒失敗(rejected)`) &#125; &#125;); &#125; // 此段函式並不會影響其它函示的執行 runPromise(&#x27;小明&#x27;, 3000).then(someone =&gt; &#123; console.log(&#x27;小明&#x27;, someone) &#125;); // 以下這段 console 會在 promise 結束前就執行 console.log(&#x27;這裡執行了一段 console&#x27;); Await 顧名思義就是等待，在這個 Promise 結束前後面的程式碼都無法被執行。所以以下結果會出現： 立即執行：小明 開始跑開始 兩秒後：跑完了: 小明 跑 2 秒時間(fulfilled) 立即接續執行：漂亮阿姨 開始跑開始 2.5 秒後：跑完了: 漂亮阿姨 跑 2.5 秒時間(fulfilled) // 此段函示會中斷其它函式的運行 let mingRun = await runPromise(&#x27;小明&#x27;, 2000) console.log(&#x27;跑完了:&#x27;, mingRun); let auntieRun = await runPromise(&#x27;漂亮阿姨&#x27;, 2500); console.log(&#x27;跑完了:&#x27;, auntieRun); 以上範例並不是像 Promise 中的 race() 或 all() 的全部一起執行的方式，而是一段執行後才執行下一段。 在 await 特性下，會等 promise 任務完成後才會讓程式繼續往下執行，所以小明沒有跑完以前，漂亮阿姨都會在原地等待。 同時進行雖然 await 是逐一執行的概念，不過它也是能夠與 Promise.all() 同時使用。 let allRun = await Promise.all([runPromise(&#x27;小明&#x27;, 3000), runPromise(&#x27;漂亮阿姨&#x27;, 2500)]); console.log(allRun); // [&quot;小明 跑 3 秒時間(fulfilled)&quot;, &quot;漂亮阿姨 跑 2.5 秒時間(fulfilled)&quot;] 錯誤出錯了會怎樣？ 小明如果跌倒，漂亮阿姨會無法得知他完成，於是在原地苦苦的等待。 let mingRun = await runPromise(&#x27;小明&#x27;, 2000, false); // 小明 開始跑開始 // 小明 跌倒失敗(rejected) // 以下錯誤不執行 console.log(&#x27;跑完了:&#x27;, mingRun); 喔嗚，如果遇到錯誤就會造成停止讓後方程式碼不執行，這樣的話 await 還挺危險的 :(。但其實我們可以從許多文件發現 await/async 都是同時使用的，await 的錯誤會讓 async 拋出錯誤，而不會造成終止。 Async在解決上述問題之前，我們先來了解一下 async，它的結構非常類似 Promise，只不過他能夠將 await 包在裡面，被包在裡面的 await 就如同先前的結構一樣，他會依序地執行。 async 本身也是類似 Promise，在正確執行的情況下 return 會傳回 resolved 的狀態，也可以使用 then 來接收正確的資料。 const asyncRun = async () =&gt; &#123; let mingRun = await runPromise(&#x27;小明&#x27;, 2000); let auntieRun = await runPromise(&#x27;漂亮阿姨&#x27;, 2500); return `$&#123;mingRun&#125;, $&#123;auntieRun&#125;` &#125; asyncRun().then(string =&gt; &#123; console.log(string) &#125;).catch(response =&gt; &#123; console.log(string) &#125;) 錯誤當 async 被呼叫時他會回傳一個 Promise，如果正確的運行這個 Promise 會回傳一個 resolved (正確的運行)，如果函式無法正確地完成，則會拋出錯誤的 rejected。 const asyncRunFail = async () =&gt; &#123; let mingRun = await runPromise(&#x27;小明&#x27;, 2000, false); let auntieRun = await runPromise(&#x27;漂亮阿姨&#x27;, 2500); return `$&#123;mingRun&#125;, $&#123;auntieRun&#125;` &#125; asyncRunFail().then(string =&gt; &#123; console.log(string); &#125;).catch(response =&gt; &#123; console.log(response); // 小明 跌倒失敗(rejected) &#125;) 這段錯誤就如同我們在使用 Promise 一樣，可以使用 catch() 得知小明跌倒了，且並不會影響到其他函式的運行，在這樣包裝下我們可以在 async 函式內做更多的 Promise 變化，並且程式碼更為精簡且容易閱讀。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：使用 Promise 處理非同步","slug":"javascript-proimse","date":"2017-12-28T16:00:00.000Z","updated":"2017-12-29T02:24:20.287Z","comments":true,"path":"javascript/2017/12/29/javascript-proimse/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/29/javascript-proimse/","excerpt":"","text":"JavaScript 中有很多非同步的事件，而這些事件我們很常使用 callback，在一層包一層後就會出現知名的 callback 地獄，而 Promise 就是為了解決此問題而生的，因此每次介紹到 Promise 都會先下以下這張圖鎮鎮樓。 上一篇所介紹到的 Fetch() 就是使用 Promise，資料接收後才會繼續跑 then() 的內容。而 fetch() 是已經包裝好的 Promise，本篇介紹如何自己運用 Promise 以及自行建立 Promise 實體。 Promise 的狀態與流程Promise 中主要有以下幾個狀態，從一進入 Promise 就進入 pending (等待事件完成)，接下來會依據事件的成功與否回傳成功或拒絕理由，通常我們會使用 resolve、reject 兩個變數來傳送成功與失敗的訊息。 pending: 等待中的初始狀態 fulfilled: 正確完成 rejected: 已拒絕，操作失敗 以下圖來說，我們可以假想跑步的過程就是 pending 的狀態，如果成功到達目的地就是成功，也就是上方那條綠色線 (fulfilled)；過程中如果失敗也會說明失敗理由(rejected: 跌倒、累了、想找媽媽…)。 回到程式碼架構如下，我們會建立 Promise 的事件，等待需要調用的時候呼叫它，而這類型的事件也有可能失敗或成功，因此會透過 resolve 及 reject 來帶入成功與否的訊息；與此相對應的會有 then() 及 catch()來接收。 製作自己的 Promise 很久沒出現的小明，今天與 杰倫、漂亮阿姨 相約一起來跑步，小明笨手笨腳常常在跑步過程中跌倒，不過如果路途順利他應該會在三秒內跑完。 在以下函式就建立了小明跑步的 Promise，如果他成功跑完就會回傳他跑了多久，失敗則會回傳他跌倒。 let mingRunPromise = (someone) =&gt; &#123; let ran = parseInt(Math.random() * 2); // 隨機成功或失敗 console.log(`$&#123;someone&#125; 開始跑開始`); return new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 if (ran) &#123; setTimeout(function()&#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(`$&#123;someone&#125; 跑 3 秒時間(fulfilled)`); &#125;, 3000); &#125; else &#123; // 回傳失敗 reject(new Error(`$&#123;someone&#125; 跌倒失敗(rejected)`)) &#125; &#125;); &#125; mingRunPromise(&#x27;小明&#x27;).then((data)=&gt; &#123; // 成功訊息 (需要 3 秒) console.log(data); &#125;).catch((err)=&gt; &#123; // 失敗訊息 (立即) console.log(err) &#125;); Race 與 All 接下來小明與漂亮阿姨一起跑，在這次的比賽中只會回傳第一個到達終點的人，而另一個成功與否倒不是很重要(哭哭)。 首先先建立一個可以多人一起跑的事件，可以傳入人、時間、是否成功 等參數。 let runPromise = (someone, timer, success = true) =&gt; &#123; console.log(`$&#123;someone&#125; 開始跑開始`); return new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 if (success) &#123; setTimeout(function () &#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(`$&#123;someone&#125; 跑 $&#123;timer / 1000&#125; 秒時間(fulfilled)`); &#125;, timer); &#125; else &#123; // 回傳失敗 reject(new Error(`$&#123;someone&#125; 跌倒失敗(rejected)`)) &#125; &#125;); &#125; 可以使用 Promise.race 傳入多個 promise 事件，這個方法僅會回傳第一個完成的事件。 // Race Promise.race([runPromise(&#x27;小明&#x27;, 3000), runPromise(&#x27;漂亮阿姨&#x27;, 2500)]).then((data) =&gt; &#123; // 僅會回傳一個最快完成的 resolve 或 reject console.log(&#x27;race&#x27;, data); // 漂亮阿姨 跑 2.5 秒時間(fulfilled) &lt;- 因為漂亮阿姨跑得快 &#125;).catch(err =&gt; &#123; // 失敗訊息 (立即) console.log(err) &#125;); 當然，每次都跑輸的小明不希望每次都沒被記錄到，他希望就算最後一名也能一起紀錄 Promise.all() 會 同時執行 以下 Promise，在全部完成後統一回傳陣列，這個陣列的內容也是 promise 中 resolve 的內容。 // All Promise.all([runPromise(&#x27;小明&#x27;, 3000), runPromise(&#x27;漂亮阿姨&#x27;, 2500)]).then((data) =&gt; &#123; // 僅會回傳一個最快完成的 resolve 或 reject console.log(&#x27;race&#x27;, data); // [&quot;小明 跑 3 秒時間(fulfilled)&quot;, &quot;漂亮阿姨 跑 2.5 秒時間(fulfilled)&quot;] &#125;).catch(err =&gt; &#123; // 失敗訊息 (立即) console.log(err) &#125;); 不過如果 all() 其中有事件 reject，那麼此 promise 也均視為失敗 (catch)。 Chain 鏈接方法 接下來他們三人想要依序跑，等一個人跑到定位後，下一位會接續著跑 在一開始有提到波動拳的概念，如果不斷的使用 callback 就會出現超級深的巢狀，那麼此時就可以善用 Promise 的 then()。 then() 所 turn 的資料內容會在下一個 then 接收，用此方法就可以減少 Callback 問題，也可以依序執行不同的 promise 事件。 runPromise(&#x27;小明&#x27;, 3000).then(mingString =&gt; &#123; console.log(mingString); // 小明 跑 3 秒時間(fulfilled) return runPromise(&#x27;漂亮阿姨&#x27;, 2500); &#125;).then((autieString) =&gt; &#123; console.log(autieString); // 漂亮阿姨 跑 2.5 秒時間(fulfilled) return runPromise(&#x27;杰倫&#x27;, 2000) ; &#125;).then((jayString) =&gt; &#123; console.log(jayString); // 杰倫 跑 2 秒時間(fulfilled) &#125;); 以上就是對於 Promise 的介紹，不過非同步的主題還沒結束，明天還有喔。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 原生 Fetch 遠端資料方法","slug":"javascript-fetch","date":"2017-12-27T16:00:00.000Z","updated":"2017-12-28T02:11:52.000Z","comments":true,"path":"javascript/2017/12/28/javascript-fetch/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/28/javascript-fetch/","excerpt":"","text":"如果不透過框架，要如何寫出一個 GET 請求呢？在 JavaScript 中可以使用 XMLHttpRequest 的方法，但其實我平常也不太會這樣寫，主要原因也是難以閱讀及撰寫，我們大多都會使用框架來處理這段，如 jQuery, Axios…，以下略為介紹如何製作一個原生的 GET 請求： 本篇使用的是 https://randomuser.me/ 隨機用戶產生器，這很適合用來作為 AJAX Get 的範例。 function reqOnload () &#123; const data = JSON.parse(this.responseText); console.log(data) &#125; function reqError (err) &#123; console.log(&#x27;錯誤&#x27;, err) &#125; // 宣告一個 XHR 的物件 var Req = new XMLHttpRequest(); // 定義連線方式 Req.open(&#x27;get&#x27;, &#x27;https://randomuser.me/api/&#x27;, true); // 送出請求 Req.send(); // 如果成功就執行 reqOnload() Req.onload = reqOnload; // 失敗就 reqError() Req.onerror = reqError; 當然，在框架的時代我們已經習慣透過框架包裝以上的行為，讓程式碼的更為容易使用及閱讀，以 randomuser 網站所提供的範例來說，以上的行為可以寫成以下 (錯誤方法可參考 jQuery 文件)，不需要在另外自己包裝發送的物件。 $.ajax(&#123; url: &#x27;https://randomuser.me/api/&#x27;, dataType: &#x27;json&#x27;, success: function(data) &#123; console.log(data); // 取得的遠端資料 &#125; &#125;); XMLHttpRequest 在製作時每次都要新建一個請求的實體，而 AJAX 的網站，通常也不會只做一次請求而已，為了讓程式碼更容易維護及開發，大多開發者都會使用框架來包裝這類行為。 FetchFetch 在使用時看似與 jQuery $.ajax 挺相近的，所以在使用上也相對容易上手，不過兩者亦有不同概念之處(可參考)。 這裡提供一個簡單的範例來取得遠端的資料，這裡與 $.ajax 不同點在於： fetch 會使用 ES6 的 Promise 作回應 then 作為下一步 catch 作為錯誤回應 (404, 500…) 回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件。 fetch(&#x27;https://randomuser.me/api/&#x27;, &#123;&#125;) .then((response) =&gt; &#123; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&#x27;錯誤:&#x27;, err); &#125;); fetch 後方會接 then()，這是 Promise 的特性，資料取得後可在 then 裡面接收。return response.json(); 的資料則會傳到下一個 then()，至於詳細的 Promise 方法我們會留下一個章節介紹。 這裡如果刻意將網址打錯，會出現以下錯誤訊息。 fetch(&#x27;https://randomuserkkk.me/api/&#x27;, &#123;&#125;) ReadableStreamFetch API 的 Response 物件中的 body 屬性提供了一個 ReadableStream 的實體，這個階段我們無法直接讀取資料內容，而 ReadableStream 物件中可用以下對應的方法來取得資料 (https://developer.mozilla.org/zh-TW/docs/Web/API/Body)： arrayBuffer() blob() formData() json() text() text()像是以上的範例，我們可以將 response.json() 改為 response.text()，那麼取得的資料格式將會是純字串。 blob()也可以將資料轉為 blob 物件，像是圖片就可以做這樣的轉換 (這裡的圖片並非指圖片路徑，而是圖片檔案本身)。 // unsplash 上的圖片 let url = &#x27;https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&amp;fit=crop&amp;w=634&amp;q=80&#x27; fetch(url) .then((response) =&gt; &#123; return response.blob(); &#125;) .then((imageBlob) =&gt; &#123; let img = document.createElement(&#x27;IMG&#x27;) document.querySelector(&#x27;.newImg&#x27;).appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); &#125;) URL 也是新的 API，可以將 blob 物件轉為網址 // unsplash 上的圖片 let url = 'https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&fit=crop&w=634&q=80' fetch(url) .then((response) => { return response.blob(); }) .then((imageBlob) => { let img = document.createElement('IMG') document.querySelector('.newImg').appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); }) 範例圖片，從 Unsplash 上所截取的圖片實體 小明眼中的漂亮阿姨 POST 方法六角的課程中有提供一個 POST 方法的練習(因為想不到哪裡可以測試 POST)，下方的程式碼就可以對測試的機器發送 POST，然後接受不同的結果 (這段 POST 並不會真的儲存帳密，只會將資料存在伺服器的記憶體，不久後會自動釋放)。 使用 fetch() 做 POST時，由於它並沒有向一些框架一樣包那麼徹底，所以有些地方還是需要做調整，其中 body 所送出的資料必須先轉純字串後才能送出，以下範例就是一個簡單的 POST行為。 let url = &#x27;https://hexschool-tutorial.herokuapp.com/api/signup&#x27;; fetch(url, &#123; method: &#x27;POST&#x27;, // headers 加入 json 格式 headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, // body 將 json 轉字串送出 body: JSON.stringify(&#123; email: &#x27;lovef1232e@hexschool.com&#x27;, password: &#x27;12345678&#x27; &#125;) &#125;).then((response) =&gt; &#123; return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log(&#x27;錯誤:&#x27;, err); &#125;) 所以這是第 25 篇了\b(表示庫存已用完)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：常用陣列方法","slug":"javascript-array-function","date":"2017-12-26T16:00:00.000Z","updated":"2017-12-27T03:30:01.088Z","comments":true,"path":"javascript/2017/12/27/javascript-array-function/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/27/javascript-array-function/","excerpt":"","text":"除了 forEach 外還有非常多實用的陣列方法，上一篇介紹一些注意事項，本篇要來介紹其它常用的陣列方法，這些陣列方法在大部分瀏覽器也都可以運作了，除了少數舊款的 Android Browser, ie 9 等等不能用以外。 接下來都是使用這份資料來實作一些方法： 累加 比大小 分別運算 搜尋特定值等 let people = [ &#123; name: &#x27;小明&#x27;, money: 500 &#125;, &#123; name: &#x27;漂亮阿姨&#x27;, money: 3000 &#125;, &#123; name: &#x27;杰倫&#x27;, money: 60000 &#125;, &#123; name: &#x27;老媽&#x27;, money: Infinity &#125; ]; ForEach 與其它不同之處除了 forEach 以外的幾個方法都會回傳陣列或一個值，在等號的左方如果放置一個變數，那麼此變數會是 undefined (沒有回傳任何值)。 var forEachLoop = people.forEach(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列) &#125;); console.log(forEachLoop); // undefined 其它的方法都會回傳一個值或陣列，以此來說就會回傳原本的陣列值。 var mapLoop = people.map(function(item, index, array)&#123; return item &#125;); console.log(mapLoop); // 與原本陣列資料相同 Filterfilter 可以用來過濾陣列中符合條件的物件，以下範例中搜尋符合大於 5000 元的，只要將該物件中的回傳為 true，那麼就會回傳完整的物件。 // Filter var filterEmpty = people.filter(function(item, index, array)&#123; &#125;); console.log(filterEmpty); // 沒有條件，會是一個空陣列 var filterMoneyThan5000 = people.filter(function(item, index, array)&#123; return item.money &gt; 5000; // 取得大於五千元 &#125;); console.log(filterMoneyThan5000); // 杰倫, 老媽 這兩個物件 findfind 是用來搜尋陣列中符合條件的物件，且僅能有一個，當回傳 true 數量超過兩者以上，那會以第一個為優先，通常會適合搜尋來搜尋特定 id。 var findEmpty = people.find(function(item, index, array)&#123; &#125;); console.log(findEmpty); // 沒有條件，會是 undefined var findMoneyThan5000 = people.find(function(item, index, array)&#123; return item.money &gt; 5000; // 取得大於五千元 &#125;); console.log(findMoneyThan5000); // 雖然答案有兩個，但只會回傳 &#x27;杰倫&#x27; 這一個物件 var findJay = people.find(function(item, index, array)&#123; return item.name === &#x27;杰倫&#x27;; // 找到杰倫 &#125;); console.log(findJay); // &#x27;杰倫&#x27; mapmap 會回傳 return 的物件、值，功用上是用來處理陣列回傳新值產生一個新陣列，要特別注意回傳的值數量與原始陣列長度相同，所以留空的 return 則會產生 undefined。 // 沒有 return 也會產生 undefined var mapEmpty = people.map(function(item, index, array)&#123; &#125;); console.log(mapEmpty); // [undefined, undefined, undefined, undefined] var everyoneAdd = people.map(function(item, index, array)&#123; item.money = item.money + 500; // 每個 money + 500 return item; // 回傳物件 &#125;); console.log(everyoneAdd); // 回傳每個處理後的數值，不過記得這是傳參考特性，會影響到原始的物件 // &#123;name: &quot;小明&quot;, money: 1500&#125; // &#123;name: &quot;漂亮阿姨&quot;, money: 3500&#125; // &#123;name: &quot;杰倫&quot;, money: 60500&#125; // &#123;name: &quot;老媽&quot;, money: Infinity&#125; var mapMoneyThan5000 = people.map(function(item, index, array) &#123; // 錯誤示範，長度不符合時 if (item.money &gt; 5000) &#123; return item; // 取得大於五千元 &#125; &#125;); console.log(mapMoneyThan5000); // [undefined, undefined, &#123;name: &quot;杰倫&quot;, money: 60000&#125;, &#123;name: &quot;老媽&quot;, money: Infinity&#125; ] every驗證全部的結果，當全部的值都為 true 時，則最終會得到 true；只要其中之一為 false，則回傳為 false。 var ans = people.every(function(item, index, array)&#123; return item.money &gt; 10000; &#125;); console.log(ans); // false: 只要有部分不符合，則為 false var ans2 = people.every(function(item, index, array)&#123; return item.money &gt; 300; &#125;); console.log(ans2); // true: 大家錢都有超過 300 some與前者類似，但只要部分為 true，則回傳為 true；全部為 false 則才會為 false。 var ans = people.some(function(item, index, array)&#123; return item.money &gt; 10000; &#125;); console.log(ans); // false: 只要有部分符合，則為 true var ans2 = people.some(function(item, index, array)&#123; return item.money &lt; 300; &#125;); console.log(ans2); // true: 大家錢都不少於 300 reducereduce 是其中最為特別的，首先他回傳的參數與先前的不同，他會接收到前一個回傳的值供下一個物件使用，很適合用在累加與比對上，以下提供不同範例供參考。 accumulator: 前一個參數，如果是第一個陣列的話，值是以另外傳入或初始化的值 currentValue: 當前變數 currentIndex: 當前索引 array: 全部陣列 var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; &#125;); console.log(reduceEmpty); // 沒有條件，會是 undefined 可以透過與前一個相加的方式，累加陣列中所有的值。 people.pop(); // 老媽的錢深不可測，先移除掉 var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; // 分別為前一個回傳值, 目前值, 當前索引值 console.log(accumulator, currentValue, currentIndex); return accumulator + currentValue.money; // 與前一個值相加 &#125;, 0); // 傳入初始化值為 0 console.log(reducePlus); // 總和為 63500 也可以相互比對，取出最高的值。 var reduceBestOne = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log(&#x27;reduce&#x27;, accumulator, currentValue, currentIndex) return Math.max(accumulator, currentValue.money); // 與前一個值比較哪個大 &#125;, 0); console.log(reduceBestOne); // 最大值為 60000 最近許多角色都沒機會出場，要來想點辦法了 :(。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 陣列方法","slug":"javascript-array","date":"2017-12-25T16:00:00.000Z","updated":"2018-05-29T01:52:25.465Z","comments":true,"path":"javascript/2017/12/26/javascript-array/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/26/javascript-array/","excerpt":"","text":"在過去處理陣列的方法不外乎就是使用 for 迴圈，或是使用配合框架的 forEach 像是 jQuery, angular.js 這些過去的框架都會提供 forEach；但到了 ES6 後，許多框架都不再提供 forEach 的語法，主要原因也是因為 ES6 就已經包含許多實用的陣列方法。 過去使用 forEach 的方式過去 JavaScript 並沒有 forEach 這樣的方法，如果是用原生的方式大多會使用 for...，這樣的寫法並不直覺，所以大多開發者會使用 jQuery、underscore 的框架處理 forEach 的方法。 for... 是看陣列數量有多少，就跑幾次的迴圈，程式邏輯很好理解，但在程式碼的呈現並不直覺。 let people = [ &#123; name: &#x27;小明&#x27;, money: 500 &#125;, &#123; name: &#x27;漂亮阿姨&#x27;, money: 3000 &#125;, &#123; name: &#x27;杰倫&#x27;, money: 60000 &#125; ]; for (let i = 0; i &lt; people.length; i++) &#123; let person = people[i]; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`); &#125; // 小明 有 500 元 // 漂亮阿姨 有 3000 元 // 杰倫 有 60000 元 幾年前 jQuery 幾乎是每個 Web 頁面必備的框架，除了很好的 DOM 操作外，裡面已經包含了許多好用的 JavaScript 方法，其中之一當然就是 $.each。 $.each(people, (i, person) =&gt; &#123; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`); &#125;); // 結果同上 不僅 jQuery 會提供這樣的方法，同時期的框架也大多會提供，但到了現在的主流框架(React, Vue, Angular 2+)大多會搭配 ES6 編譯工具，所以就不會另外提供陣列的 Each 方法。 // 過去 angular 1 也有類似方法，不過參數的位置與 jQuery 有點不同 angular.forEach(people, (person, i) =&gt; &#123; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`); &#125;); // 結果同上 除了以上兩個框架外，另外也有一個專門處理物件、陣列的框架 underscore，不管前後端都非常適合使用。 _.forEach(people, (person, i) =&gt; &#123; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`); &#125;); // 結果同上 ES6 一行解決ES6 開始提供了不同的 JavaScript 方法，並且搭配 箭頭函式、Template String 讓程式碼變得更簡短。 people.forEach(person =&gt; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`)); // 結果同上 forEach 傳入的參數有三，大多會只使用前兩者 單一物件 及 物件索引，而最後一個則是完整的陣列本體。 people.forEach((person, i, array) =&gt; &#123; console.log(person, i, array); // person: 單一個陣列的值 // i: 陣列的索引值 0, 1, 2, ... // array: 傳入的陣列本體 &#125;) 另外 forEach 這類型的方法無法中斷，如果想要中斷迴圈的執行會建議使用傳統的 for...loop。 for (let i = 0; i &lt; people.length; i++) &#123; let person = people[i] if (person.money &gt; 500) &#123; break; // 可中斷 &#125; console.log(person); &#125; people.forEach(function (person) &#123; if (person.money &gt; 500 ) &#123; break; // 會跳錯 &#125; console.log(person); &#125;) 無法使用的陣列先前提過物件原型的概念，有很多類陣列有著陣列的外觀，但其實並不是真正的陣列(如：arguments)，這些就無法直接使用 forEach。 const callAll = function() &#123; console.log(arguments) // arguments.forEach is not a function arguments.forEach((arg) =&gt; &#123; console.log(arg) &#125;); &#125; callAll(people[0], people[1], people[2]) 不過可以使用前文介紹的展開語法 ... 將 array-like 轉成 array。 const callAll = function() &#123; console.log(arguments); let thisPeople = [...arguments]; // arguments.forEach is not a function thisPeople.forEach((arg) =&gt; &#123; console.log(arg) &#125;); &#125; callAll(people[0], people[1], people[2]); 但也有部分的類陣列是可以使用 forEach，DOM 的就是屬於其中一種。 let doms = document.querySelectorAll(&#x27;p&#x27;); // 不會跳錯 doms.forEach((ele) =&gt; &#123; console.log(ele); &#125;); 至於類陣列這麼多，怎知道哪些可以哪些不行，其實可以從原型中查找，像是上述的 dom 陣列，我們就可以從 console.log() 查看 __proto__ 找到 forEach 的方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 解構賦值","slug":"javascript-destructuring","date":"2017-12-24T16:00:00.000Z","updated":"2017-12-25T02:40:01.033Z","comments":true,"path":"javascript/2017/12/25/javascript-destructuring/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/25/javascript-destructuring/","excerpt":"","text":"解構賦值這是在 MDN 文件上的翻譯名詞，如果簡單來說他是個語法糖，讓我們在寫 物件、陣列 的時候可以使用縮寫來達到相同的效果，了解其中的規則再運用上最會很便利，且可以有效增加閱讀性 (程式碼短非常多)。 解構賦值可以想像是鏡子的概念，將右方的資料往左邊送，然後會一個位置對一個值 (但沒有像鏡子左右顛倒)。 陣列解構賦值就像是鏡子一樣，將值從右邊鏡射到左邊，所以左邊的陣列基本上就是從右方一個一個對映。因此右方的的五個值(字串)直接對應左方陣列的五個變數。 let family = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;, &#x27;老媽&#x27;, &#x27;老爸&#x27;]; let ming = family[0]; let jay = family[1]; let auntie = family[2]; // ... 略 let [ming, jay, auntie, mom, papa] = family; 如果遇到空的變數，這些值也會跳過。 let family = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;, &#x27;老媽&#x27;, &#x27;老爸&#x27;]; let [ming, , , mom, papa] = family; // ming: 小明 // mom: 老媽 // papa: 老爸 如果左方多於右方，左方的變數會出現 undefined。 let family = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;, &#x27;老媽&#x27;, &#x27;老爸&#x27;]; let [, , , , , who] = family; // who: undefined 至於傳值是否有順序性，在這個範例中直接將右邊的變數交換到左邊，可以看到是同時交換變數，所以在互換變數值時是非常方便的。 let Goku = &#x27;悟空&#x27;; let Ginyu = &#x27;基紐&#x27;; [Goku, Ginyu] = [Ginyu, Goku]; // Goku: &#x27;基紐&#x27; // Ginyu: &#x27;悟空&#x27; 遇到字串則會將字串拆解成一個一個字元，賦予到左方的變數上。 let str = &#x27;基紐特攻隊&#x27;; [a, b, c, d, e] = str; 物件解構物件解構也是和陣列解構有著相同的概念，只不過陣列是使用順序的索引值對應，但物件則是使用物件的屬性名稱來做對應(因此沒有順序性)。在以下範例則是快速將物件值解構在變數上。 let family = &#123; ming: &#x27;小明&#x27;, jay: &#x27;杰倫&#x27;, &#125;; // 一般會這樣寫 let ming = family.ming let jay = family.jay // 縮寫版 let &#123; ming, jay &#125; = family // ming: 小明 // jay: 杰倫 而物件的解構方法，還能重新賦予變數的名稱，如以下 Ginyu 在取得值後，將變數名稱改為 Goku，因此 Goku === &#39;基紐&#39;。 let GinyuTeam = &#123; Ginyu: &#x27;基紐&#x27;, Jeice: &#x27;吉斯&#x27;, burter: &#x27;巴特&#x27;, // ... &#125; let &#123; Ginyu: Goku &#125; = GinyuTeam; // Goku: &#x27;基紐&#x27; 混合使用相同的觀念，只要了解以上的觀念，這題也能了解到最終會產生怎樣的變數。let &#123; ming: Goku, family: [, mom] &#125; = &#123; ming: &#x27;小明&#x27;, family: [&#x27;阿姨&#x27;, &#x27;老媽&#x27;, &#x27;老爸&#x27;] &#125; console.log(Goku, mom); // 請問答案是什麼？ 說明： ming 取得右方的 ‘小明’ 後，將變數名稱改為 Goku family 取得家庭陣列後，再將第二個值套用在 mom (第二個變數上。) 預設值除了使用鏡射的概念外，為了避免值沒有賦予造成 undefined，可以使用預設值避免此問題。如以下左方的陣列都先賦予的預設值，當右方的陣列只有一個值時，左方的陣列剩餘內容將會採用預設值。 let [ming = &#x27;小明&#x27;, jay = &#x27;杰倫&#x27;] = [&#x27;阿明&#x27;] // 第一個會被賦值，第二個會用預設 // ming: &quot;阿明&quot; // jay: &quot;杰倫&quot; 物件的預設值也是相同的概念。 let &#123; family: ming = &#x27;小明&#x27; &#125; = &#123;&#125; // ming: &#x27;小明&#x27; 函式除了以上的方法外，解構也能使用在函式的參數，使用方式如同將傳入的物件對應到函式參數上。這樣參數一樣能夠能夠自訂變數名稱、順序、預設值等。 function callSomeone (&#123;person = &#x27;小明&#x27;, person2&#125;) &#123; console.log(`$&#123;person&#125; 呼叫 $&#123;person2&#125;`) &#125; callSomeone(&#123; person: &#x27;杰倫&#x27;, person2: &#x27;阿姨&#x27; &#125;); // 杰倫 呼叫 阿姨 callSomeone(&#x27;杰倫&#x27;, &#x27;阿姨&#x27;); // 小明 呼叫 undefined callSomeone(&#123; person2: &#x27;阿姨&#x27; &#125;); // 小明 呼叫 阿姨 callSomeone(&#123; person2: &#x27;杰倫&#x27;, person: &#x27;啊罵&#x27; &#125;); // 啊罵 呼叫 杰倫 callSomeone(&#123;&#125;); // 小明 呼叫 undefined","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 展開與其餘","slug":"javascript-spread-operator","date":"2017-12-23T16:00:00.000Z","updated":"2017-12-24T02:22:55.633Z","comments":true,"path":"javascript/2017/12/24/javascript-spread-operator/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/24/javascript-spread-operator/","excerpt":"","text":"這兩個分別稱為 展開運算子(spread operator) 及 其餘運算子 (rest operator，也可稱為其餘參數)，這兩個運算符有個兩個特點，就是都與陣列有關係，除此之外他都是 ...；第一次看到這樣的符號出現在 JavaScript 中，我還認為這是哪個預處理器的語法，不過在此他真的是 ES6 語法，以下內容一樣可以貼到 Chrome 運行。 預處理器：像是 CSS 的 Sass，在編譯前無法直接被讀取，需要透過編譯為 .css 或 .js 才能被瀏覽器使用，常見的 JavaScript 預處理器有 CoffeeScript、TypeScript。 展開展開非常的好用，我們先來看一個簡單的範例，這裡有兩組的陣列，我們想把他合併到同一個變數上，那麼我們可以直接用以下方法接起來。 let groupA = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;]; let groupB = [&#x27;老媽&#x27;, &#x27;老爸&#x27;]; const groupAll = [...groupA, ...groupB]; // [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;, &#x27;老媽&#x27;, &#x27;老爸&#x27;]; 誒…，看到這裡是不是有似懂非懂的感覺，看似那麼容易卻不太容易理解，... 到底做了什麼事情!? 它其實一次又一次的 return 陣列中的值。 console.log(...groupA); // 小明 // 杰倫 // 阿姨 順帶一提，以上的概念如果用傳統的寫法會像是這樣。 let groupA = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;]; let groupB = [&#x27;老媽&#x27;, &#x27;老爸&#x27;]; const groupAll = groupA.concat(groupB); // [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;, &#x27;老媽&#x27;, &#x27;老爸&#x27;]; 淺層複製另外陣列與物件相同都有著傳參考的特性，所以當把陣列賦予到另一個值上時，修改其中一個另一個也會跟著變動。 // 由於傳參考的關係，所以將一個陣列傳到另一個上時 // 兩個的值其實是一樣的 let groupA = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;]; let groupB = groupA; groupB.push(&#x27;阿明&#x27;); console.log(groupA); // [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;, &#x27;阿明&#x27;]; 由於 展開運算子 它是一個一個將值寫入，所以他也有淺層的複製(shallow copy) 。 // 這個屬於淺拷貝，所以不會影響到另一個物件 let groupA = [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;]; let groupB = [...groupA]; groupB.push(&#x27;阿明&#x27;); console.log(groupA); // [&#x27;小明&#x27;, &#x27;杰倫&#x27;, &#x27;阿姨&#x27;]; 類陣列轉成純陣列JavaScript 中有許多類陣列，這類陣列有著陣列的外皮，但卻不能使用陣列的方法，相信先前有參考過原型章節的文章有發現這點，這類陣列由於原型不同，所以 “不能” 使用許多的陣列方法，如： map(), concat() 等等。 其中一種很常見的就是 DOM 陣列，這也可以透過展開運算子轉為純陣列。 // 可以將類陣列轉成陣列 let doms = document.querySelectorAll(&#x27;p&#x27;); console.log(doms); let spreadDom = [...doms]; console.log(spreadDom); 在先前小明儲值的故事中，悠遊卡的儲值是使用 for...in，原因也在於他不是真正的陣列，不過當他如果轉成真正的陣列後，就多了很多方法可以用了 (嘿嘿嘿)。// 同樣道理，arguments 不是真正的陣列，也可以透過 ... 來轉成純陣列 var originCash = 1000; function updateEasyCard() &#123; let arg = [...arguments] let sum = arg.reduce(function (accumulator, currentValue) &#123; // 分別為前一個回傳值, 當前值 return accumulator + currentValue; // 與前一個值相加 &#125;, 0); // 如果使用 arguments 則會出現 `arguments.reduce is not a function` console.log(&#x27;我有 &#x27; + sum + &#x27; 元&#x27;); &#125; updateEasyCard(0); // 我有 1000 元 // arguments = []; updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); // 我有 718 元 // arguments = [10, 50, 100, 50, 5, 1, 1, 1, 500]; 其餘參數其餘參數，顧名思義就是傳入的參數，用途類似 arguments，但不同的是： arguments 不是真的陣列，其餘參數則是 arguments 不能混用自訂傳入的參數 以下就是使用其餘參數改寫以上範例。 let mingCard = &#123; name: &#x27;小明&#x27;, value: 0 &#125;; function updateEasyCard(mingCard, ...money) &#123; console.log(money); // 其餘參數的陣列 mingCard.value = money.reduce(function (accumulator, currentValue) &#123; // 分別為前一個回傳值, 當前值 return accumulator + currentValue; // 與前一個值相加 &#125;, mingCard.value); console.log(`$&#123;mingCard.name&#125; 的卡現在有 $&#123;mingCard.value&#125;`); &#125; let money = [10, 50, 100, 50, 5, 1, 1, 1, 500] updateEasyCard(mingCard, ...money); // 718 updateEasyCard(mingCard, 50, 100, 50, 70, 200); // 小明 的卡現在有 1188 透過其餘參數，我們還能混用其他的變數像是 mingCard，讓這個儲值函式彈性更高，而不受 arguments 依序傳入的限制。 看到目前為止，你會跟我一樣覺得 ES6 的程式碼看起來不像 JavaScript 嗎？","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 的縮寫概念","slug":"javascript-short-hand","date":"2017-12-22T16:00:00.000Z","updated":"2017-12-23T02:44:52.972Z","comments":true,"path":"javascript/2017/12/23/javascript-short-hand/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/23/javascript-short-hand/","excerpt":"","text":"再參加過那麼多次鐵人賽，我自己習慣在週六寫比較簡短的文章，因此本篇也是屬於短文，還要介紹 ES6 偷懶的方法(O)，這讓撰寫 JavaScript 變得更簡化，熟悉這些語法也會讓閱讀性更高 (一開始會有點不習慣啦)，本篇要來介紹一些 ES6 中簡化的 JavaScript 語法。 物件縮寫在過去相同名稱的物件如果要賦予在另一個屬性上，必須寫成 屬性: 物件，這個邏輯很直覺，不過在 ES6 中如果物件名稱與屬性名稱相同時，則不需要寫兩次，可以改成寫一次即可。 let Frieza = &#x27;弗利沙&#x27; const GinyuTeam = &#123; Ginyu: &#x27;基紐&#x27;, Jeice: &#x27;吉斯&#x27;, burter: &#x27;巴特&#x27;, // ... &#125; // 原本寫法 const newTeam = &#123; GinyuTeam: GinyuTeam, Frieza: Frieza &#125; // 縮寫 const newTeam = &#123; GinyuTeam, Frieza &#125; 這段也很常在 webpack, Node.js 引用外部套件時使用，如果有使用相關工具開發應該會常看到如以下： import Vue from &#x27;vue&#x27; import App from &#x27;./App&#x27; import router from &#x27;./router&#x27; // 將套件由 &#x27;./App&#x27; 路徑載入，並使用 App 這個變數名稱 new Vue(&#123; el: &#x27;#app&#x27;, router, template: &#x27;&lt;App/&gt;&#x27;, components: &#123; App &#125; &#125;); // 縮寫方式載入及使用 物件函式縮寫function 這個詞彙如果使用在物件內，也可以省略 :function，省略後的語意是沒有變化的，並沒有轉而使用箭頭函式。 const newTeam = &#123; // ... showPosture: function () &#123; console.log(&#x27;我們是 基紐特戰隊&#x27;) &#125; &#125; const newTeam = &#123; // ... showPosture () &#123; console.log(&#x27;我們是 基紐特戰隊&#x27;) &#125; &#125; 在各大框架也推薦用此方法來撰寫物件函式，不僅可以少寫一些，也讓整體閱讀性更高，如以下是 Vue 的範例。 const xxxComponent = &#123; name: &#x27;hello&#x27;, data () &#123; return &#123; msg: &#x27;Welcome to Your Vue.js App&#x27; &#125; &#125; &#125; 變數作為物件屬性過去變數會使用 xxx. 來定義，而前者本身就是一個字串，無法再轉為變數使用，現在可以直接在宣告變數時使用 []，在 [] 內則是變數，當然也可以搭配 Template String 使用。 let prop = &#x27;Ming&#x27;; let value = &#x27;小明&#x27;; let teamMember = &#123; [prop]: value, [`$&#123;prop&#125;_invert`]: value.split(&quot;&quot;).reverse().join(&quot;&quot;) &#125; console.log(teamMember); // &#123; Ming: &quot;小明&quot;, Ming_invert: &quot;明小&quot; &#125; 搭配解構使用解構 ... 也是 ES6 的新方法，可以執行以下的 const newTeam(執行完一次必須重新整理，因為 const 不能重新宣告)，會看到兩者的物件結果不太一樣。 const GinyuTeam = &#123; Ginyu: &#123; name: &#x27;基紐&#x27; &#125;, Jeice: &#123; name: &#x27;吉斯&#x27; &#125;, burter: &#123; name: &#x27;巴特&#x27; &#125;, // ... &#125; const newTeam = &#123; GinyuTeam &#125; const newTeam = &#123; ...GinyuTeam &#125; // newTeam = &#123; // Ginyu: &#123; name: &quot;基紐&quot; &#125;, // Jeice: &#123; name: &quot;吉斯&quot; &#125;, // burter: &#123; name: &quot;巴特&quot; &#125; // &#125; 到目前介紹的 let、const、template string 及這次的縮寫，在 ES6 都屬於很好上手的部分，不妨找個時間開始試試看這些語法吧 :)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript Template String 樣板字串","slug":"javascript-template-string","date":"2017-12-21T16:00:00.000Z","updated":"2017-12-22T01:27:47.872Z","comments":true,"path":"javascript/2017/12/22/javascript-template-string/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/22/javascript-template-string/","excerpt":"","text":"在過去我們撰寫字串的時候都是使用 &quot; ，這種寫法會讓程式碼變得很攏長且難以閱讀，再多行的時候也必須插入反斜線來換行。 const people = [ &#123; name: &#x27;小明&#x27;, friends: 2 &#125;, &#123; name: &#x27;阿姨&#x27;, friends: 999 &#125;, &#123; name: &#x27;杰倫&#x27;, friends: 0 &#125; ] let originString = &#x27;我叫做 &#x27; + people[0].name; // 過去的寫法 let originUl = &#x27;&lt;ul&gt;\\ &lt;li&gt;我叫做 &#x27; + people[0].name + &#x27;&lt;/li&gt;\\ &lt;li&gt;我叫做 &#x27; + people[1].name + &#x27;&lt;/li&gt;\\ &lt;li&gt;我叫做 &#x27; + people[2].name + &#x27;&lt;/li&gt;\\ &lt;/ul&gt;&#x27;; // 多行的寫法 ES6 借鏡了許多開發工具 (這種寫法真的很像 CoffeeScript，不過在這語言是使用 &quot; + #&#123;&#125; 插入變數)，可以使用 反引號 來插入一段字串，並且可以使用 $&#123;&#125; 來加入變數或函式，如以下範例可以直接輸入字串，並且使用 $&#123;people[0].name&#125; 來插入變數，省去一堆 +來做串接。 let string = `我叫做 $&#123;people[0].name&#125;` // ES6 String Template // &quot;我叫做 小明&quot; 再多行的時候也是直接撰寫即可，不需要額外的符號。 let ul = ` &lt;ul&gt; &lt;li&gt;我叫做 $&#123;people[0].name&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[1].name&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[2].name&#125;&lt;/li&gt; &lt;/ul&gt; ` // &quot; // &lt;ul&gt; // &lt;li&gt;我叫做 小明&lt;/li&gt; // &lt;li&gt;我叫做 阿姨&lt;/li&gt; // &lt;li&gt;我叫做 杰倫&lt;/li&gt; // &lt;/ul&gt; // &quot; 甚至可以在 $&#123;&#125; 內使用函式 (函式內可在使用 Template String)。不過這裡特別注意，單行的箭頭函式會自動 return，所以在這裡是省略了 return。let ul2 = ` &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;我叫做 $&#123;person.name&#125;&lt;/li&gt;`).join(&#x27;&#x27;)&#125; &lt;/ul&gt; ` 也可以在函式內增添更多的判斷式。let ul2 = ` &lt;ul&gt; $&#123;people.map((person) =&gt; &#123; if (person.friends) &#123; return `&lt;li&gt;$&#123;person.name&#125; 有 $&#123;person.friends&#125; 朋友&lt;/li&gt;` &#125; else &#123; return `&lt;li&gt;$&#123;person.name&#125; 邊緣人&lt;/li&gt;` &#125; &#125;).join(&#x27;&#x27;) &#125; &lt;/ul&gt; ` // &quot; // &lt;ul&gt; // &lt;li&gt;小明 有 2 朋友&lt;/li&gt;&lt;li&gt;阿姨 有 999 朋友&lt;/li&gt;&lt;li&gt;杰倫 邊緣人&lt;/li&gt; // &lt;/ul&gt; // &quot; 巢狀 String Template如同上述的方法 $&#123;&#125; 內可以加入函式及其更內層的 Template String，所以也可以在 $&#123;&#125; 插入另一組的函式的 Template String。 const travelers = &#123; leader: &#x27;老媽&#x27;, partner: people &#125; function renderList(people) &#123; return ` &lt;div&gt;上車名單&lt;/div&gt; &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;$&#123;person.name&#125;&lt;/li&gt;`).join(&#x27;&#x27;)&#125; &lt;/ul&gt; ` &#125; let template = ` &lt;div class=&quot;template&quot;&gt; &lt;h2&gt;導遊：$&#123;travelers.leader&#125;&lt;/h2&gt; $&#123;renderList(travelers.partner)&#125; &lt;/div&gt; ` // &quot; // &lt;div class=&quot;template&quot;&gt; // &lt;h2&gt;導遊：老媽&lt;/h2&gt; // &lt;div&gt;上車名單&lt;/div&gt; // &lt;ul&gt; // &lt;li&gt;小明&lt;/li&gt;&lt;li&gt;阿姨&lt;/li&gt;&lt;li&gt;杰倫&lt;/li&gt; // &lt;/ul&gt; // &lt;/div&gt; // &quot; 跳脫字元如果有需要插入特殊字元，一樣可以使用 \\ 反斜線來插入： console.log(`\\\\`); 如果要計算字元數，或是需要將字串做額外處理，跳脫字元是不佔字符數的： console.log(`\\\\`.length); // 1 要取得含特殊字元的字串可用 String.raw()： console.log(String.raw`\\\\`.length) ES6 就是加入了這些好用的功能，讓 JavaScript 在撰寫時變得更容易、快速、易讀，使得用過的人都回不去了 T_T。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：箭頭函式 (Arrow functions)","slug":"javascript-es6-arrow-function","date":"2017-12-20T16:00:00.000Z","updated":"2017-12-21T03:07:08.770Z","comments":true,"path":"javascript/2017/12/21/javascript-es6-arrow-function/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/21/javascript-es6-arrow-function/","excerpt":"","text":"Arrow function 對於它也是又愛又恨的，看似簡約的外型卻有著全新的體驗，它有著更簡短的語法以及重新定義的 this，所以先前學的 this 在此也會有不同的情境。 簡短的語法一般使用箭頭函式與 function 的用法大致一致，可以傳入參數、也有大括號包起來，除此之外箭頭函式也有更簡短的寫法如下： // 正常寫法 var callSomeone = (someone) =&gt; &#123; return someone + &#x27;吃飯了&#x27; &#125; console.log(callSomeone(&#x27;小明&#x27;)) // 縮寫，單一行陳述不需要 &#123;&#125; var callSomeone = (someone) =&gt; someone + &#x27;吃飯了&#x27; console.log(callSomeone(&#x27;小明&#x27;)) // 只有一個參數可以不加括號 var callSomeone = someone =&gt; someone + &#x27;吃飯了&#x27; console.log(callSomeone(&#x27;小明&#x27;)) // 沒有參數時，一定要有括號 var callSomeone = () =&gt; &#x27;小明&#x27; + &#x27;吃飯了&#x27; console.log(callSomeone(&#x27;小明&#x27;)) 不過這個上述有個小地方也要注意一下，在大括號內的 &#123;&#125; 是需要自行加入 return，如果沒有傳入值則會出現 undefined。 var callSomeone = (someone) =&gt; &#123; someone + &#x27;吃飯了&#x27; &#125; console.log(callSomeone(&#x27;小明&#x27;)) // undefined 沒有 arguments 參數在先前有一個小故事，小明要儲值悠遊卡，他投入不同的金額要加值，要使用 arguments 這個參數了解總共傳入了幾次並加總，但在箭頭函式內是沒有此變數的。 let originCash = 1000; const updateEasyCard = () =&gt; &#123; let cash = 0; console.log(arguments); // arguments is not defined &#125; updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); 所以當需要使用 arguments 請維持使用 function。 綁定的 this 不同 傳統函式：依呼叫的方法而定 箭頭函式：綁定到其定義時所在的物件 (這個詞看似簡單，但又充滿了陷阱!?) var name = &#x27;全域阿婆&#x27; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: function () &#123; // 注意，這裡是 function，以此為基準產生一個作用域 console.log(&#x27;1&#x27;, this.name); // 1 漂亮阿姨 setTimeout(() =&gt; &#123; console.log(&#x27;2&#x27;, this.name); // 2 漂亮阿姨 console.log(&#x27;3&#x27;, this); // 3 auntie 這個物件 &#125;, 10); &#125;, callName2: () =&gt; &#123; // 注意，如果使用箭頭函式，this 依然指向 window console.log(&#x27;4&#x27;, this.name); // 4 全域阿婆 setTimeout(() =&gt; &#123; console.log(&#x27;5&#x27;, this.name); // 5 全域阿婆 console.log(&#x27;6&#x27;, this); // 6 window 物件 &#125;, 10); &#125; &#125; auntie.callName(); auntie.callName2(); 綁定到其定義時所在的物件，我們要了解一般函式在建立時是在 window 下，所以在 window 下使用箭頭函式自然會指向 window，要確實將箭頭函式宣告在物件內部，這樣 this 才會指向該物件。 var func = function () &#123; var func2 = function () &#123; setTimeout(() =&gt; &#123; console.log(this); &#125;, 10); &#125;; // 這裡才算真正的建立一個物件 // 因此要在此物件下的箭頭函式才會以此作為基準 var func3 = &#123; func: func2, var4: 4 &#125; func2(); // this = window func3.func(); // func3 Object &#125; func(); // 就算在這裡新增一個 function，也不會影響到內層的箭頭函式 這個範例稍作複雜些，但只是要解釋不同建立方式的差異，注意：如果 不是 建立在物件內的函式，並不會影響箭頭函示的 this： func() 是最外層的函式，他對於內層的箭頭不會有影響。 func2() 是包覆在內層的函式，但由於箭頭函式不是在物件內，所以沒有影響。 func3() 是呼叫在物件內的函式，因此箭頭函式會是使用它所在的物件。 縮寫的函式另外注意：物件縮寫形式的函式也是屬於 function，所以依然能夠產生作用域。 // == var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName () &#123; // 注意，縮寫形式的 function 屬於傳統 function setTimeout(() =&gt; &#123; console.log(this); // auntie 這個物件 &#125;, 10); &#125; &#125; auntie.callName(); 不可使用的情況apply, call, bindthis 在 Arrow function 中是被綁定的，所以套用 call 的方法時是無法修改 this。 let family = &#123; ming: &#x27;小明&#x27; &#125; const func = () =&gt; &#123; console.log(this); &#125; const func2 = function () &#123; console.log(this); &#125; func.call(family); // 箭頭函式的情況，this 依然是 window func2.call(family); // 一般函示 this 則是傳入的物件 不能用在建構式由於 this 的是在物件下建立，所以箭頭函式不能像 function 一樣作為建構式的函式，如果嘗試使用此方法則會出現錯誤 (... is not a constructor)。 const PhoneTemplate = (brand, modal, withCamera) =&gt; &#123; this.brand = brand; this.modal = modal; // ... &#125; const sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); // 錯誤：PhoneTemplate is not a constructor DOM 事件監聽同先前說的， this 是指向所建立的物件上，如果是用在監聽 DOM 上一樣會指向 window，所以無法使用在此情境。 var elements = document.getElementsByTagName(&#x27;div&#x27;); var changeDOM = () =&gt; &#123; console.log(this); // 指向 window Object this.style.border = &#x27;1px solid red&#x27;. // 錯誤 &#125; for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener(&#x27;click&#x27;, changeDOM, false); &#125; Prototype 中使用 this一樣是 this 的問題，如果原型上新增一個箭頭函式，並嘗試使用 this 的話會指向全域。 function PhoneTemplate (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; // ... &#125; PhoneTemplate.prototype.callSomeone = function (someone) &#123; console.log(this.brand + &#x27; 打通電話給 &#x27; + someone) &#125; PhoneTemplate.prototype.callSomeone2 = (someone) =&gt; &#123; console.log(this.brand + &#x27; 打通電話給 &#x27; + someone) &#125; const sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); sonyPhone.callSomeone(&#x27;小明&#x27;); // Sony 打通電話給 小明 sonyPhone.callSomeone2(&#x27;杰哥&#x27;); // undefined 打通電話給 杰哥 善用的方式過去我們在寫物件內的函式時，為了確保 this 能夠正確運作會先將它賦予在另一個變數上 (that, self, vm…)。 var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName () &#123; // 先使用另一個變數指向 this，讓內層函式可以正確使用 var that = this; setTimeout(function () &#123; console.log(that); // auntie 這個物件 &#125;, 10); &#125; &#125; auntie.callName(); 箭頭函式本就會指向他所生成的物件上，所以可以不需要另外指向另一個物件。 var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName () &#123; setTimeout(() =&gt; &#123; // 箭頭函式中會自動指向生成的物件上 console.log(this); // auntie 這個物件 &#125;, 10); &#125; &#125; auntie.callName();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 開始的新生活 let, const","slug":"javascript-es6-let-const","date":"2017-12-19T16:00:00.000Z","updated":"2017-12-20T02:52:56.800Z","comments":true,"path":"javascript/2017/12/20/javascript-es6-let-const/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/20/javascript-es6-let-const/","excerpt":"","text":"接下來本篇開始會介紹 ES6 語法，在很久之前聽到 ES6 這個名詞時我都是保持觀望的態度，裡面有許多語法讓我感覺的不是很真實，像是 ...、=&gt;、class 等等，這些看起來與現有的 JavaScript 很不搭嘎 :(。 ES6 許多語法與現有的觀念有很大的關係，其中也很大一部分是為了改進現有的語法，就以本篇要介紹的 let、const 來說也是如此。這些語法改進目前很多問題，最大的感受在於 Promise()，他可以把非同步的語法處理得更漂亮。 至於該不該了解(或學習) ES6？當然要，這已經是可以用在伺服器端(Node.js)及瀏覽器(Chrome)，就如同 CSS 中的 Flex 是非常好用的語法，在各大主流網站都可以看到他的蹤影，與其不斷的觀望，不如實際體驗一次才能了解。 注意：目前還不是所有語法支援，詳細可參考 MDN 或 Can I use ES6 的變數：letES6 出現以後，為了潮，我自己也是想先從最容易改變的變數開始，如果不了解看文件大致可以了解： let 與 var 差不多 const 是宣告常數，不能再作修改 雖然還是有差異，但直接使用上確實感受不明顯，我們可以將先前的範例使用 let 來試試看： // 原本的範例 var mom = &#x27;老媽&#x27;; // 這是一個立即函式 (function () &#123; console.log(mom); &#125;)(); 將以上的 var 修改成 let。 // 將 var 改成 let let mom = &#x27;老媽&#x27;; (function () &#123; console.log(mom); &#125;)(); 和先前沒什麼不同，這個 console.log 的結果是 老媽，如果不去探究原理，其實還真的沒什麼感覺，不過現在在實戰上已經推薦多用 let 少用 var，接下來我們來看看差在哪裡。 let 與 var先前提到 var 的重要觀念，在於變數的範圍在 function，而 let 的作用域在 block，block 意指 &#123;&#125; 這個符號(許多文件稱它為花括號，我自己則喜歡稱它大括號)，除了 function 以外 if、for 的 &#123;&#125; 都屬於 let 的作用域。 下面的範例可以看到，小明這個變數在兩者的結尾是不同的，因為 &#123;&#125; 所定義的空間並不同。 function varMing () &#123; var ming = &#x27;小明&#x27;; if (true) &#123; var ming = &#x27;杰哥&#x27;; // 這裡的 ming 依然是外層的小明，所以小明即將被取代 &#125; console.log(ming); // &#x27;杰哥&#x27; &#125; function letMing () &#123; let ming = &#x27;小明&#x27;; if (true) &#123; let ming = &#x27;杰哥&#x27;; // 這裡的 ming 是不同的，只有在這個 if block 才有作用 &#125; console.log(ming); // &#x27;小明&#x27; &#125; varMing(); letMing(); let 與 for loop但我們知道，大多時候我們並不會這樣寫，常見的習慣中我們會將變數宣告放在 function 的前方，那麼我們再來看另一個情境： for (var i = 0; i &lt; 10; i++) &#123; console.log(i); setTimeout(function () &#123; console.log(&#x27;這執行第&#x27; + i + &#x27;次&#x27;); &#125;, 10); &#125; 如果先不講結果，你會認為以上出現什麼樣的結果呢？ 這執行第 0 次, 這執行第 1 次, 這執行第 2 次… (延續 10 次) 這執行第 10 次… (延續 10 次) 我先前跟大家一樣都會猜 1，因為 for 幾次不就是幾次嗎 :D。但實際執行時會發現答案其實會是 這執行第 10 次... (延續 10 次)，因為 var 會直接將 i 宣告成全域變數，不斷透過 for 迴圈累加，在 setTimeout 實際執行時只會拿到 10 這個數字。 所以此段要正確地執行，可以使用 let 宣告 i 這個變數，i會被緊緊的鎖在 for… 後方的 &#123;&#125; 內。 for (let i = 0; i &lt; 10; i++) &#123; console.log(i); setTimeout(function () &#123; console.log(&#x27;這執行第&#x27; + i + &#x27;次&#x27;); &#125;, 10); &#125; 用此種方法，就會正確的出現，因為 let 是屬於 block 變數。 這執行第0次 這執行第1次 這執行第2次 這執行第3次 ... 除此之外，在先前有介紹過，var 在全域下的變數會直接再 window 上，可以在這裡使用 console.log() 看看兩者之間的差異： // 這段宣告擇一執行 var mom = &quot;老媽&quot;; let mom = &quot;老媽&quot;; console.log(window.mom); // var 會出現 &quot;老媽&quot; // let 會出現 undefined 這也是 let 的一大特性，他並不會讓整個 window 物件掛上在全域環境所宣告的變數，對於愛乾淨不喜歡污染全域的開發者會是一大福音。 constconst 是宣告一個常數，簡單來說就是不可以再做修改的變數(常數)，以下面這個範例來說，小明如果使用 const 做宣告，那麼就無法再使用 let、const 做調整了。 const ming = &#x27;鐵錚錚男子漢&#x27;; let ming = &#x27;弱雞&#x27;; // 錯誤：Identifier &#x27;ming&#x27; has already been declared const ming = &#x27;弱雞&#x27;; // 錯誤：Identifier &#x27;ming&#x27; has already been declared const 必須一定要有值過去可以先宣告變數 (還記得吧，宣告變數未賦予值會是 undefined)，但 const 在宣告時一定要賦予值。 const ming; // 錯誤：Missing initializer in const declaration 物件依然是參考使用 const 宣告的物件，其內層屬性依然可以做調整，因為物件是傳參考，所以在此依然可以修改屬性。(一家人的成員依然可以更動)const family = &#123; mom: &#x27;老媽&#x27;, me: &#x27;小明&#x27;, sister: &#x27;小橙&#x27; &#125;; family.father = &#x27;爸爸&#x27;; 承上，已經被明確宣告的物件，沒有辦法再調整其參考的物件(一家人的成員並不會被另一家取代)。 let jayFamily = &#123; mom: &#x27;杰哥媽&#x27;, me: &#x27;杰哥&#x27; &#125;; family = jayFamily // 錯誤 var 的額外問題相信上述對於 let、const都有了基本的了解，那麼不管你有沒有開始寫 ES6，請問一下下述問題如何修正： 沒有使用 let 的情況下要如何修正成可以依序執行？ for (var i = 0; i &lt; 10; i++) &#123; console.log(i); setTimeout(function () &#123; console.log(&#x27;這執行第&#x27; + i + &#x27;次&#x27;); &#125;, 10); &#125; 答案在下方 // for (var i = 0; i &lt; 10; i++) &#123; // (function (j) &#123; // setTimeout(function () &#123; // console.log(&#x27;這執行第&#x27; + j + &#x27;次&#x27;); // &#125;, 10); // &#125;)(i); // &#125; 成功了嗎!?或許你能想到更棒的解法喔～","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 建構式與原型","slug":"javascript-constructor-and-prototype","date":"2017-12-18T16:00:00.000Z","updated":"2017-12-19T01:57:25.312Z","comments":true,"path":"javascript/2017/12/19/javascript-constructor-and-prototype/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/19/javascript-constructor-and-prototype/","excerpt":"","text":"還記得先前幾篇的原型鍊嗎？多個物件可以使用相同原型的那個章節，兩個不同的角色但是共用相同的原型，所以當原型增加新的功能，另一個角色一樣會獲得相同功能： 現在已經透過 JavaScript 建構式產生一個獨立的物件，我們接下來會使用原型鍊的概念來創造原型。 範例目前已經使用建構式製作一個簡單手機樣板，但我們會發現作為一個手機似乎少了一個重要的功能 打電話，這個功能是所有手機都具備個功能，無論他是何種型號。因此，這裡要透過 原型 的概念將手機賦予 打電話 這個功能，無論是哪一種型號，都能直接繼承此功能。 以下這段和上一個章節的程式碼是相同的，這裡已經透過手機範本 (PhoneTemplate)建立了兩隻手機。 function PhoneTemplate(brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; this.takePhoto = function () &#123; if (this.withCamera) &#123; console.log(this.modal + &#x27; 照相&#x27;); &#125; else &#123; console.log(this.modal + &#x27; 這台沒有照相功能&#x27;); &#125; &#125; &#125; var sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); var nokiaPhone = new PhoneTemplate(&#x27;Nokia&#x27;, &#x27;3310&#x27;, false); 接下來直接在 手機範本 上使用 prototype 的語法來加入撥打電話的功能 (callSomeone)，加入此功能後這兩隻手機都同時具有撥打電話的功能。 // 加入 prototype PhoneTemplate.prototype.callSomeone = function (someone) &#123; console.log(&#x27;打通電話給 &#x27; + someone) &#125; // 兩者同時共用相同的原型 sonyPhone.callSomeone(&#x27;小明&#x27;); // 打通電話給 小明 nokiaPhone.callSomeone(&#x27;小明&#x27;); // 打通電話給 小明 發生什麼事了？可以透過 console.log() 來看看兩隻手機內有什麼樣的變化，此段的 __proto__ 是 PhoneTemplate 的原型，在 __proto__ 內可以看到 callSomeone() 的方法，我們直接在手機範本上加入就會使透過此建構式生成的物件套用這段原型。 此時我們如果查看另一支手機也會有相同的功能。 在概念上，這段的原型會如下圖顯示，兩者的上層皆是 phoneTemplate，並且共用相同的方法，這也像魂結一樣兩個連向共用的物件，當此物件新增了任何功能，兩個物件也能一起繼承。 記憶體概念除了共用的概念外，我們每次新增一個物件時，物件內的屬性、函式都會需要佔用記憶體空間。也就是一個物件內有 10 個屬性，生成 10 個則會佔用 100 單位的記憶體空間，如果適當地將 5 個屬性轉至原型內，則只會佔用 (5*10) + 5 = 55 的記憶體空間。 這點在開發 Node.js 應用程式時影響更大，由於伺服器端的記憶體不能像瀏覽器隨意關閉釋放，所以記憶體的控制更為重要。 原型觀念如果你了解此段，很容易就能看到任何物件的根本，對於看懂 JavaScript 的文件也會更為容易，就如同以下是 “陣列” 的原型，所以所有陣列都與此原型產生魂結牽連，因此可以用以下的方法。 而為什麼 DOM 方法取得的陣列為什麼不能用很多陣列方法，原因他是屬於 array-like(類陣列)，我們可以從原型中得知它與陣列不是共用的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 建構式","slug":"javascript-constructor","date":"2017-12-17T16:00:00.000Z","updated":"2017-12-18T02:14:16.267Z","comments":true,"path":"javascript/2017/12/18/javascript-constructor/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/18/javascript-constructor/","excerpt":"","text":"了解原型繼承後，可以開始思考這個概念可以用在哪個地方，其中一個就是建構式。我們先不介紹建構式有什麼優點，先了解一下該怎麼透過 JavaScript 來寫建構式，然後再用原型的概念來介紹他的特別之處。 小明到手機行決定挑選一支手機，手機款式很多但基本上都有相同的功能，僅有少部分的規格上有差異，過去那種資料連連看的方式一定會把資料搞得一團亂 (參考先前的 Javascript 物件 “傳參考” 特性)，於是他想到一個新方法，先寫好一個樣板，有需要的格式直接從該樣板取用即可。 手機的規格樣板： 品牌： 型號： 是否能照相： 照相： 一般物件寫法的問題如果使用一般的物件製作手機規格的樣板，就會出現以下的問題，當物件賦予到另一個物件上時，兩者其實是使用相同的資料，當修改後者時前者也會跟著修改 (JavaScript 傳參考的特性)。 var phoneTemplate = &#123; brand: &#x27;xxx&#x27;, model: &#x27;z1&#x27;, withCamera: false, takePhoto: function () &#123; if (this.withCamera) &#123; console.log(&#x27;照相&#x27;); &#125; else &#123; console.log(&#x27;這台沒有照相功能&#x27;); &#125; &#125; &#125; var sonyPhone = phoneTemplate; sonyPhone.brand = &#x27;Sony&#x27;; console.log(phoneTemplate.brand); // &quot;Sony&quot;，原始的 Template 已經被修改到了 雖然先前有介紹到如何將值一一的取出來，但此方法也會完全與樣板斷開關聯性。 建構式使用 JavaScript 建構式寫法，可以先建立一個範本，接下來新增的物件都會依據此範本作為延伸。 JavaScript 建構式中，我們會使用 function 來建立物件樣板 (只能使用 function，亦不能使用箭頭函式)。 這個結構與前方所使用的結構接近，不同的是： this 則是代表此物件的屬性 可以透過參數來傳入數值 使用 new 來套用此樣板，且最終一樣會產生物件 function PhoneTemplate(brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; this.takePhoto = function () &#123; if (this.withCamera) &#123; console.log(this.modal + &#x27; 照相&#x27;); &#125; else &#123; console.log(this.modal + &#x27; 這台沒有照相功能&#x27;); &#125; &#125; &#125; 使用建構式時，盡可能使用大寫開頭，讓合作的朋友也能知道他準備作為建構式之用。 而套用樣板會使用 new 這個方法，並且可以透過傳入參數的方法來改變預設值，接下來會出現兩台手機物件，包含相同的樣板套用上不同的值，但兩者並沒有任何關係。 // 建立兩隻手機，分別傳入 品牌、型號、是否有相機 var sonyPhone = new PhoneTemplate(&#x27;Sony&#x27;, &#x27;Z100&#x27;, true); var nokiaPhone = new PhoneTemplate(&#x27;Nokia&#x27;, &#x27;3310&#x27;, false); // 直接透過 console.log 來觀看其中的值 console.log(sonyPhone); &#123; brand: &#x27;Sony&#x27;, model: &#x27;Z100&#x27;, withCamera: true, takePhoto: function () &#123; // ... &#125; &#125; console.log(sonyPhone == nokiaPhone); // false 兩者也可以獨立運行自己的方法： sonyPhone.takePhoto(); // Z100 照相 nokiaPhone.takePhoto(); // 3310 這台沒有照相功能 我們這裡可以得知是使用相同樣板，但產生兩者毫無關係的物件，並且可以針對其中一個物件新增修改方法。 sonyPhone.call = function () &#123; console.log(this.modal + &#x27; 打電話&#x27;); &#125; sonyPhone.call(); // Z100 打電話 nokiaPhone.call(); // nokiaPhone.call is not a function 到這裡我們可以得知這種建構式可以透過 “同一個物件樣板”，不斷地產生 “不同”的物件，每個物件彼此都是獨立的(不會有參考的問題)，只不過共用相同的原型。 其中一支手機可以看到 __proto__ 是 PhoneTemplate，這就好像是使用同一個模具產生兩個獨立的物件，我們也可以更新這個模具讓產生的物件有更多的功能，接下來我們會再介紹 原型繼承與記憶體 的關係。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的原型繼承","slug":"javascript-prototype","date":"2017-12-16T16:00:00.000Z","updated":"2017-12-17T01:58:50.542Z","comments":true,"path":"javascript/2017/12/17/javascript-prototype/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/17/javascript-prototype/","excerpt":"","text":"許多人在寫 JavaScript 應該多少都會聽過原型鍊、原型繼承…，這個觀念在寫 JavaScript 是否重要呢？實作中會不會常使用到這樣的技巧？這裡可以先回答 “會”，而且我們很常使用到原型，而且了解原型會有助於我們加速理解 JavaScript 的概念。 以下有一個物件，物件裡面只有一個 name 及一個 function run()，所以我們了解以下物件只能執行 run()，因為他沒有其他的函式可以使用。 var person = &#123; name: &#x27;小明&#x27;, run: function () &#123; return this.name + &#x27; 跑向世界的另一端&#x27; &#125; &#125; person.run(); // &quot;小明 跑向世界的另一端&quot; person.hasOwnProperty(&#x27;run&#x27;); // true person.hasOwnProperty(&#x27;friend&#x27;); // false 但除此以外還有一些額外的方法可以使用，像是 hasOwnProperty()，但奇怪的事情是 hasOwnProperty() 這個方法，沒有在 person 這個物件下，為何還可以使用此 hasOwnProperty() 的方法，原因在於 “原型繼承”。 上圖中 person 這個是我們剛剛宣告的物件，它的上層是則是他的原型物件(它是半透明的喔，所以我們平常會沒注意到)，當他在使用 hasOwnProperty() 時，就是在使用它原型物件的方法。 透過錯誤範例了解原型錯誤範例：這裡提供一個觀念上的錯誤範例，實際執行時我們不會用此方法來增加原型方法。JavaScript 中所有的物件、函式都有 __proto__ 的原型屬性，這一個原形屬性會不斷的向上尋找他的上層原型。 var ming = &#123; name: &#x27;小明&#x27; &#125; console.log(ming); 我們在 ming 下的 __proto__ 直接掛上 run 的方法，使其產生在 __proto__ 下 注意：請不要這樣做，只是為了方便理解。var ming = &#123; name: &#x27;小明&#x27; &#125; var run = function () &#123; return this.name + &#x27; 跑向世界的另一端&#x27; &#125; ming.__proto__.run = run; console.log(ming.name); // &#123;name: &quot;小明&quot;&#125; console.log(ming.run()); // &quot;小明 跑向世界的另一端&quot; 雖然直接 console.log(ming) 並不會看到 run() 這個方法，但執行時他會不斷的向上尋找到原型內的 run() 方法來執行它。 共用原型其中原型還有個特性，我們如果在物件原型下直接建立新的方法，就會造成以下的問題，兩個看似沒有關係的物件將會共用相同的原型方法 (因為兩者的原型都是物件)，這種情況會出現管理上的問題。 var ming = &#123; name: &#x27;小明&#x27; &#125; var casper = &#123; name: &#x27;卡斯伯&#x27; &#125; var run = function () &#123; return this.name + &#x27; 跑向世界的另一端&#x27; &#125; ming.__proto__.run = run; console.log(ming.run()); // &quot;小明 跑向世界的另一端&quot; console.log(casper.run()); // &quot;卡斯伯 跑向世界的另一端&quot; 這個範例中，我們強制將函式寫到了 物件 這個原型上，所以新增的物件都會 共用 此屬性。 在後面的章節我們會介紹如何正確地使用原型繼承。 原型鍊的的頂端是物件JavaScript 只有一個建構物：”物件”，如果上述程式碼以下我們繼續往下增加： var mingFamily = [&#x27;ming&#x27;, &#x27;mom&#x27;, &#x27;漂亮阿姨&#x27;]; var casperFamily = [&#x27;卡斯伯&#x27;, &#x27;媽&#x27;]; // 嘗試呼叫先前物件下的原型 mingFamily.run(); &quot;undefined 跑向世界的另一端&quot; //雖然出現錯誤，但依然可以呼叫 這個範例中，我們新增一段陣列，並在陣列中使用先前的物件原型方法，雖然會出錯，但是是可以執行的。 var getFirst = function () &#123; return this[0]; &#125; // 對 陣列原型加入新的方法 mingFamily.__proto__.getFirst = getFirst; mingFamily.getFirst(); // &quot;ming&quot; casperFamily.getFirst(); // &quot;卡斯伯&quot; ming.getFirst(); // ming.getFirst is not a function 在此段，我們對任一陣列原型加入新的函式，此時兩個陣列都可以套用此函式，但對於物件來說卻不能執行此方法，因為在原型鍊上物件屬於陣列的頂端。 由於原型有不斷向上查找的特性，如果在上一層找不到可用的方法，他就會繼續往上找，這個也就稱為原型鍊，所以在 mingFamily 這個陣列才會取用到剛剛物件原型所增加的方法，本篇只是簡單介紹原型的概念，接下來幾篇則會開始讓大家了解這有什麼樣的用處。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript Function 與 Hoisting","slug":"javascript-hoisting","date":"2017-12-15T16:00:00.000Z","updated":"2017-12-16T02:23:42.388Z","comments":true,"path":"javascript/2017/12/16/javascript-hoisting/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/16/javascript-hoisting/","excerpt":"","text":"Hoisting 在 JavaScript 僅是一個觀念，主要是在說明變數、函式在宣告期間就會先建立一個記憶體空間，等到實際運行時再將值放入到該記憶體空間內。不過為了確保程式的穩定性，我們不會在實作中使用這個方法，僅了解觀念即可。 故事說明：小明的筆記本寫了每天要做的事情，但其實他並不是要做事情時，才會翻筆記本。在一早的醒來的時候小明會將全部的內容先看一次，讓腦中先有個印象。這個概念與 JavaScript Hoiting 的概念接近，先在記憶體中準備一個空間，等到執行時再將值、函式置入。 先在腦中了解有多少事情，到時執行時才比較不會忘記的小明。 在變數上如果我們對沒有宣告的變數執行 console.log()，會跳出一個錯誤表示它 “尚未” 被定義過。 console.log(phone); // phone is not defined 如果在 var 的變數前加入 console.log()，這個時候並不會出錯，則是會跳出 undefined，這表示這個變數在記憶體中已經有一個位置，只不過目前並沒有值。 console.log(phone); // undefined var phone = &#x27;myphone&#x27;; 但如果是直接賦予在全域物件上的屬性，因為並不是使用 “宣告”，這已經屬於定義階段，所以在記憶體中他還沒有值。會在 phone = &#39;myphone&#39; 這段直接將值寫在全域物件上。 console.log(phone); // phone is not defined phone = &#x27;myphone&#x27;; 函式的 Hoisting在函式概念中也是一樣的，如果在函式之前使用 console.log() 則會出現 undefined，當然這個函式也無法被使用。這種函式宣告方法稱為：function expression 函式表達式(function 會由 var 定義)。 console.log(callSomeone); // undefined callSomeone(&#x27;杰倫哥&#x27;); // callSomeone is not a function var callSomeone = function (name) &#123; console.log(&#x27;打給 &#x27; + name) &#125; 比較不同的是在 function declaration 函式陳述式中(function 放在最前方的寫法)，整個函式都會被提升到最前方，所以在函式前方直接調用方法也可以運行。 callSomeone(&#x27;杰倫哥&#x27;); // 只有 function 會被提升 function callSomeone(name) &#123; console.log(&#x27;打給 &#x27; + name) &#125; Hoisting 這個觀念主要是要了解 JavaScript 記憶體運作的觀念，實作上也會避免在 function 前方直接呼叫函式，這樣會降低對於程式碼的可維護性。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的嚴格模式 \"use strict\"","slug":"javascript-use-strict","date":"2017-12-14T16:00:00.000Z","updated":"2017-12-15T02:34:01.454Z","comments":true,"path":"javascript/2017/12/15/javascript-use-strict/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/15/javascript-use-strict/","excerpt":"","text":"JavaScript 不斷的演進下，許多不嚴謹的寫法都應該逐漸被修正，但哪些是需要修正的字詞呢!? &#39;use strict&#39; 則是新加入的標準，目的是為了讓編寫「具穩定性的 JavaScript 更容易」，在不穩定的語法或妨礙最佳化的語意都會跳出警告，讓開發者避開這些寫法。 而在傳統的瀏覽器下 &#39;use strict&#39; 僅會被視為沒有用處的字串，所以不會對舊有的瀏覽器產生影響。 使用方法&#39;use strict&#39; 直接加入在程式碼的前方就可以開始運作，特別值得注意的是它也可以單獨使用在 function 下，如果要靠 &#39;use strict&#39; 來修正目前語法上的問題，可以先針對部分的 function 來做調整。 簡單示範一個錯誤 (未定義的變數不能直接賦予值)：&#x27;use strict&#x27;; auntie = &#x27;漂亮阿姨&#x27;; // Uncaught ReferenceError: auntie is not defined 嚴謹模式也能僅用在函式內，這樣將只有此函式套用。 (function () &#123; &#x27;use strict&#x27;; auntie = &#x27;漂亮阿姨&#x27;; // Uncaught ReferenceError: auntie is not defined &#125;)(); 如果使用在函式的開頭，那將只會在此函式套用 “嚴謹模式”，函式的外部將不受影響。 (function () &#123; &#x27;use strict&#x27;; &#125;)(); mom = &#x27;老媽管不到&#x27;; // 不會跳錯 注意只有將 &#39;use strict&#39; 放在函式開頭才會有作用。(function () &#123; var aa; &#x27;use strict&#x27;; // 無效 auntie = &#x27;漂亮阿姨&#x27;; &#125;)(); 常見錯誤基本錯誤如下： 不宣告直接賦予變數 刪除已經宣告的錯誤 物件內有重複屬性 數值使用 8 進位語法 不能使用 ‘with’ 語法 arguments、eval 不能作為變數名稱 新增的保留字也不能被作為變數名稱 implements, interface, let, package, private, protected, public, static, yield，這些是為了 ES6 做得準備。 如果嘗試修改 getter 則不會默默地沒改，而是直接地跳出錯誤： (function () &#123; &#x27;use strict&#x27;; var family = &#123; get mom() &#123; return &#x27;老媽&#x27; &#125; &#125; console.log(family.mom); // 老媽 family.mom = &#x27;老爸&#x27;; // 跳錯 &#125;)(); 不可以嘗試刪除一個不可刪除的屬性(此為原型，在後面的章節會介紹到)： (function () &#123; &#x27;use strict&#x27;; delete Object.prototype; &#125;)(); ‘use strict’ 及 this在先前介紹 this 的時有介紹到不同的呼叫方法，在 ‘use strict’ 的環境下的 純粹的調用 (Simple call) 的 this 不在是全域變數。 window.auntie = &#x27;漂亮阿姨&#x27;; function callAuntie() &#123; &#x27;use strict&#x27;; console.log(&#x27;call:&#x27;, this.auntie); &#125; callAuntie.call(&#123; auntie: &#x27;叫阿姨&#x27; &#125;); // Ok callAuntie(); // 錯誤，此呼叫會導致 this 為全域 但 this 依然可作為 window 的方式傳入。 window.auntie = &#x27;漂亮阿姨&#x27;; function callAuntie() &#123; &#x27;use strict&#x27;; console.log(&#x27;call:&#x27;, this.auntie); &#125; callAuntie.call(this); // Ok，call: 漂亮阿姨 現在會建議寫 JavaScript 的時候加入 &#39;use strict&#39;，這可以改正一些編寫時的不良習慣，但也有可以因此導致專案無法運作，此時可以考慮將 &#39;use strict&#39; 加在函式內，避免影響過去的程式碼及相關套件。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 函式與參數","slug":"javascript-arguments","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T02:45:58.033Z","comments":true,"path":"javascript/2017/12/14/javascript-arguments/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/14/javascript-arguments/","excerpt":"","text":"函式可以將參數傳入，使得函式的可用性提高許多，不過其中也有許多小技巧及方法可以運用，以下我們用 悠遊卡的概念 來說明此段。 小明的悠遊卡裡面有 1000 元，他要儲值一些零用錢進悠遊卡內 (真是優秀青年，這麼多錢還繼續儲)，好讓他可以繼續搭乘捷運。 傳入變數以下是一個簡單的函式，用來更新悠遊卡的金額。小明將錢 cash 投入機器內後，按下執行按鈕 updateEasyCard() 就會回傳更新後的悠遊卡金額。 var originCash = 1000; // 悠遊卡內原有的現金 function updateEasyCard (cash) &#123; // 傳入儲值金進入悠遊卡 var newCash = cash + originCash; console.log(&#x27;我有 &#x27; + newCash + &#x27; 元&#x27;); &#125; updateEasyCard(1000); // 我有 2000 元 updateEasyCard(2000); // 我有 3000 元 但如果機器沒有設定好，小明還沒有投入任何金額就按下 updateEasyCard() 就會跳出 NaN (Not a Number) 的錯誤 。 updateEasyCard(); // 我有 NaN 元 所以有些函式會透過 || 來加入預設值，在沒有輸入任何值的情況下會使用預設值代替，這邊就先將預設值設為 100 (佛心機器，沒投錢也會給 100)。 var originCash = 1000; function updateEasyCard(cash) &#123; var money = (cash || 100) + originCash; console.log(&#x27;我有 &#x27; + money + &#x27; 元&#x27;); &#125; updateEasyCard(); // 我有 1100 元 這樣，至少不會出現錯誤了，但會出現另一個問題，假設函式中真的需要使用 0、false 這種值傳入時，他一樣會使用前者所套用的值。 updateEasyCard(0); // 我有 1100 元 0 會被強制轉型成 false，所以兩者都會被替代。 複雜的判斷式|| 本身就是一個判斷式，如果簡單的判斷式沒辦法滿足需求，那麼就使用更複雜的判斷式來寫，以下範例：如果 cash 是 false，且 cash 不等於 0 的情況， cash = 100。 var originCash = 1000; function updateEasyCard(cash) &#123; if (!cash &amp;&amp; cash !== 0) &#123; cash = 100; &#125; var money = cash + originCash; console.log(&#x27;我有 &#x27; + money + &#x27; 元&#x27;); &#125; updateEasyCard(); // 我有 1100 元 updateEasyCard(0); // 我有 1000 元 當然，還有一種情況就是傳入的並非數值而是字串，這樣則會造成金額也自動轉換成字串。 updateEasyCard(&#x27;1000&#x27;); // 我有 10001000 元 那麼就需要先將文字轉成數值，避免原始的數值被轉換為字串。 var originCash = 1000; function updateEasyCard(cash) &#123; cash = Number.parseInt(cash); if (!cash &amp;&amp; cash !== 0) &#123; cash = 100; &#125; var money = cash + originCash; console.log(&#x27;我有 &#x27; + money + &#x27; 元&#x27;); &#125; updateEasyCard(&#x27;100&#x27;); // 我有 1100 元 updateEasyCard(&#x27;這不是錢&#x27;); // 我有 1000 元 (無法被轉換) ES6 預設函式變數在 ES6 中提供更簡潔的方式來解決此問題，可以直接在傳入的參數賦予預設值，此預設值也不需要額外的帶入判斷式就能達到以上效果(但文字問題依然要自己修正喔)。 var originCash = 1000; function updateEasyCard(cash = 100) &#123; var money = cash + originCash; console.log(&#x27;我有 &#x27; + money + &#x27; 元&#x27;); &#125; updateEasyCard(); // 我有 1100 元 updateEasyCard(0); // 我有 1000 元 arguments 假設小明零錢很多，他要一個一個投進去機器內儲值，這樣參數該如何設計？ 除此之外，JavaScript 有預設的參數 arguments 可直接帶入，這種參數不須預先設定，所有函式都內建此參數，他會將呼叫函式所帶入的參數一並透過陣列的方式傳入。 var originCash = 1000; function updateEasyCard() &#123; var cash = 0; console.log(arguments); // 這裡可以看到 arguments 的結構 for (var i = 0; i &lt; arguments.length; i++) &#123; cash += arguments[i]; &#125; var money = cash + originCash; console.log(&#x27;我有 &#x27; + money + &#x27; 元&#x27;); &#125; updateEasyCard(0); // 我有 1000 元 // arguments = []; updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); // 我有 1718 元 // arguments = [10, 50, 100, 50, 5, 1, 1, 1, 500]; 不過 arguments 實際在使用時會有一些小問題，像是範例中為何是使用 for 迴圈，而不是使用 forEach (forEach 可以使用在陣列上)，主要原因是 arguments 並非真正的 陣列，它是 類陣列(Array-like) 的物件，因此無法使用許多陣列相關的方法。 相關文件可查閱：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：另一種方式介紹 JavaScript 閉包","slug":"javascript-closure","date":"2017-12-12T16:00:00.000Z","updated":"2017-12-13T01:52:01.860Z","comments":true,"path":"javascript/2017/12/13/javascript-closure/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/13/javascript-closure/","excerpt":"","text":"閉包解釋非常多，這裡先透過幾個方式說明一下閉包是什麼： 運作原理：就是呼叫 Function 內的 Function 這樣有什麼用：內層 Function 作用域變數只會存在內層 然後勒：內層 Function 變數可以不被釋放，重複使用 卡斯伯會常用此方法嗎：沒注意，好像會不經意的使出來 那幹麻學：理解作用域 範例這個範例用花錢的概念來說明，我們每次都會傳入不同的金額，並且把剩餘的金額存在內部作用域。 直接呼叫內層函示閉包就是存取內部的函式，所以直接使用 buyItem()(100) 兩個括號就是呼叫內部的函式。 function buyItem() &#123; var myMoney = 1000; return function (price) &#123; // 這裡就是一個閉包，不過目前只會使用一次 myMoney = myMoney - price; return myMoney; &#125; &#125; let balance = buyItem()(100); // 存取內部函式的變數 console.log(balance); 幹麻要這樣？ 外層 myMoney 此時的變數可以被內層的 function 存取 內層的 myMoney 後來是私有的變數，外層無法讀取 運行 buyItem()(100) 時，等同於呼叫一次外層，在呼叫一次內層，最終將內層的值回傳給 balance 的變數。 這樣還沒完，目前只是一次性運作，來調整一下程式碼。 這個的行為是直接去操作內部的錢包，就像是直接花費一樣，接下來我們會用扣款的概念，不斷的使用錢包內部的金額。 將外層函式賦予到另一個變數上接下來不要直接呼叫，而是將函式賦予在另一個變數上，這樣的方式就會將 myMoney 這個變數存在內層的作用域，然後每次執行後不斷更新此值。 function buyItem() &#123; var myMoney = 1000; return function (price) &#123; // 這個閉包目前會被重複呼叫 myMoney = myMoney - price; // myMoney 第一次由外部傳入，接下來在這個 function 內不斷更新 return myMoney; &#125; &#125; var balance = buyItem(); // 存取內部函式的變數 balance(100); // 900 balance(100); // 800 balance(100); // 700 // 每次執行都是跑內層的函式，因此也只更新內層的函式變數 然後勒？ buyItem() 直接執行會出現 function ...，所以沒辦法直接使用。 balance 現在指向 buyItem() 使其可以不斷的反覆呼叫，且內層記憶體不會被釋放。 balance() 每次執行時，只會執行內層的函式，在內層記憶體沒有被釋放的情況下，myMoney 變數會不斷的被更新。 多個具私有變數的函式 小明拜訪完漂亮阿姨以後，接著遇到 Rich 的朋友 “杰倫哥”，杰倫哥與小明去四處揮霍，小明也想趁此機會計算一下杰倫哥的花費狀況。透過閉包的方法，小明可以用同一個公式算出兩個人剩餘多少錢。 // 使用閉包產生兩個作用域 // 這裡的 money 代表身上帶的錢 function buyItem(money) &#123; var myMoney = money; console.log(this); // 趁機偷問，此地的 this 指向誰？ return function (price) &#123; console.log(this); // 趁機偷問，此地的 this 指向誰？ // myMoney 第一次由外部傳入，接下來在這個 function 內不斷更新 myMoney = myMoney - price; return myMoney; &#125; &#125; let MingCost = buyItem(1000); // 存取內部函式的變數，這個是小明錢包內的錢 let JayCost = buyItem(10000); // 杰哥拿出的小錢 // 小明的內層作用域變數，也就是小明剩的錢 console.log(MingCost(100)); // 900 console.log(MingCost(100)); // 800 console.log(MingCost(100)); // 700 // 杰哥的內層作用域變數，這裡是杰哥剩的錢 console.log(JayCost(1000)); // 9000 console.log(JayCost(1000)); // 8000 console.log(JayCost(1000)); // 7000 以上片段建議分段執行，更能理解其中的過程： let MingCost = buyItem(1000); 此時 buyItem 已經執行過一次，並且 myMoney 的變數已經依傳入的變數做調整。 每次執行 MingCost(100) 時，調整的則是傳至內層的 myMoney 變數。 要了解閉包，就要多了解函式的作用域，掌握 變數 的作用域及函式的運作原理，此篇章難度就不會很高。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的 this 到底是誰？","slug":"javascript-this","date":"2017-12-11T16:00:00.000Z","updated":"2019-03-19T06:23:45.687Z","comments":true,"path":"javascript/2017/12/12/javascript-this/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/12/javascript-this/","excerpt":"","text":"This 的在 JS 使用上非常頻繁，但一個 this 每個 function 都各自表示，這裡就直接用範例說明 This 有哪些情境，不過請注意一點，影響 this 的是在於函式的呼叫方法，並非宣告的時機： 純粹的調用 (Simple call)如果直接調用函式，此函式的 this 會指向 window，以下兩個範例都是直接調用含式，所以都是指向 window。 window.auntie = &#x27;漂亮阿姨&#x27;; function callAuntie() &#123; console.log(&#x27;call:&#x27;, this.auntie); // this == window // 所以此時的 this.auntie 一樣可以取得 window 下的 auntie &#125; callAuntie(); 這裡將 function 內在包覆著 function，但只要是直接呼叫，this 都是屬於全域。 window.auntie = &#x27;漂亮阿姨&#x27;; function callAuntie () &#123; console.log(&#x27;call:&#x27;, this.auntie); // function 內的 function function callAgainAuntie () &#123; console.log(&#x27;call again:&#x27;, this.auntie); &#125; callAgainAuntie(); &#125; callAuntie(); 無論在哪一層，純粹的調用方式 this 都會指向 window。 物件的方法調用 (As an object method)如果 function 是在物件下調用，那麼 this 則會指向此物件，無論 function 是在哪裡宣告。以下的範例中一個是純粹的調用，另一個則是使用物件的方法調用，物件的方法調用時 this 會指向調用的物件。 function callName() &#123; console.log(this.name); &#125; var name = &#x27;全域阿婆&#x27;; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: callName // 這裡的 function 指向全域的 function，但不重要 &#125; callName() // &#x27;全域阿婆&#x27; auntie.callName() // &#x27;漂亮阿姨&#x27;，呼叫是在物件下調用，那麼 this 則是該物件 相同的道理，宣告的位置不重要，重要的是呼叫的方法。如果將物件內的函式賦予在一個純粹的變數上並調用它時，這個 this 將會指向全域。 var name = &#x27;全域阿婆&#x27;; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: function () &#123; console.log(this.name); &#125; &#125; // 將 function 指向物件內的 function，不過不重要 callThisName = auntie.callName; callThisName() // &#x27;全域阿婆&#x27; DOM 物件調用 (As a DOM event handler) 同此方法DOM 搭配 addEventListener 時，此 this 所指向的則是該 DOM。以下這段程式碼可以貼在任何網頁下的 Console，接下來點擊畫面上任何一區域，該區域則會加上紅線。 var elements = document.getElementsByTagName(&#x27;div&#x27;); function changeDOM() &#123; console.log(this); // 指向當前的 DOM this.style.border = &#x27;1px solid red&#x27; &#125; for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener(&#x27;click&#x27;, changeDOM, false); &#125; 建構式的調用 (As a constructor)在建構式下會 new 一個新物件，此時的 this 會指向新的物件。建構式在後續的章節會介紹，此部分只要了解建構式的 this 也是指像物件本身即可。 function FamilyConstructor () &#123; this.mom = &#x27;老媽&#x27; &#125; var myFamily = new FamilyConstructor(); console.log(myFamily.mom); 這一個 this 不會是全域且可以在生成的物件上重新定義 (所以他指向的是該生成的物件)。 var mom = &#x27;全域老媽&#x27;; function FamilyConstructor(newMom) &#123; this.mom = newMom || &#x27;老媽&#x27;; &#125; var myFamily = new FamilyConstructor(&#x27;希望是漂亮阿姨&#x27;); var realFamily = new FamilyConstructor(); console.log(&#x27;我的&#x27;, myFamily.mom); // 我的 希望是漂亮阿姨 console.log(&#x27;現實&#x27;, realFamily.mom); // 現實 老媽 使用 Call 來呼叫 functioncall 調用的函式可以直接傳入新的物件，使其作為 this 所指向的物件。 var name = &#x27;全域阿婆&#x27;; function callName() &#123; console.log(this.name); &#125; callName(); // &#x27;全域阿婆&#x27; callName.call(&#123;name: &#x27;漂亮阿姨&#x27;&#125;); // &#x27;漂亮阿姨&#x27; call, bind, apply 這三者均可，都可以傳入新的 this 給予函式使用，三者僅是使用方法不同，可參考：Function.prototype.apply() - JavaScript | MDN。 重新指向 this在實際運作時，立即函式 (IIFE) 或是非同步的事件 (setTimeout) 大多都會指向全域，如果需調用的則是物件本身的話，可以先用一個變數指向 this，等到調用後再重新使用它。 function callName() &#123; console.log(&#x27;區域&#x27;, this.name); var that = this; setTimeout(function () &#123; console.log(&#x27;全域&#x27;, this.name); console.log(&#x27;區域&#x27;, that.name); &#125;, 10); &#125; var name = &#x27;全域阿婆&#x27;; var auntie = &#123; name: &#x27;漂亮阿姨&#x27;, callName: callName // 這裡的 function 指向全域的 function，但不重要 &#125; auntie.callName(); 這個變數名稱可以自己定義，常見有 that、vm、self 等等，可以使用自己或團隊習慣的為主即可。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的文法學","slug":"javascript-grammar","date":"2017-12-10T16:00:00.000Z","updated":"2017-12-11T01:31:47.506Z","comments":true,"path":"javascript/2017/12/11/javascript-grammar/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/11/javascript-grammar/","excerpt":"","text":"大多數國家的語言都是由左到右、由上而下的閱讀方式，中文、拉丁語系就是屬於這類型，但也有部分國家是由右到左的，像是阿拉伯語系就是如此。而 JavaScript 是由左到右，還是由右到左呢？大多情況下我們會認為 JavaScript 是由左到右，但部份時候則會由右到左的喔。 運算子用簡單的一點的方式說明， +、=、== 都是運算子，本身這也是屬於函式的一種，是用來將它本身 前後方的值 做計算，然後回傳一個新的值。 3 + 3; // 回傳 6 所以中間的 + 即是運算子，這些運算子都屬於一個函式，但他只要寫在兩個值的中間(或是前、後的其中一方)，不需要完整函式即可運作，所以稱為運算子。運算子可以用來賦予值、數學運算、比較等等，如果想知道有哪些運算子可看：運算式與運算子 - JavaScript | MDN 方向及優先性我們在寫 JavaScript 時也是習慣由左到右撰寫，但其實 JavaScript 文法並不是只有由左到右，而是依據 結合性 (Associativity) 決定它是由左至右，還是由右至左閱讀。 一個簡單的例子： a = b = 5; console.log(a); 請問以上這段是從哪個方向開始閱讀!? 上述的例子，將 5 的數值賦予給 b ，再由 b 賦予給 a，所以 a 的值會得到 5。除此之外，JavaScript 還有一個優先性，高優先性 (Precedence) 的運算子會被優先執行，在看以下範例： 3 + 3 * 3 // 得到 12，因為 * 的優先值高於 + (3 + 3) * 3 // 得到 18，因為 () 內的優先計算 我們都了解先乘除後加減，所以乘號的優先值基本上是高於加的；而如果括號則是括號內的優先計算，所以很好理解。 所以下方兩個 a 分別會是什麼？哪一個運算子會先被執行？ a = 3 * 3 a = 9 === 3 * 0 || 3 所以這段只要了解優先性就可以知道答案，MDN 有提供完整的表可以參考：運算子優先等級，表中的 Precedence 數值越高代表優先度高，也會被優先執行，而 Associativity 則是文法閱讀的順序，大家也可以直接貼到 Chrome Console 看看以上答案。 第二個 a 的說明 9 === 3 * 0 // 得到 false false || 3 // 由於前者是 false，所以用 3 取代 陷阱因為綜合性 (閱讀順序)及優先性的關係，就會產生一些怪異的問題，以下兩個案例非常接近，但卻出現相反的結果，以正確來說以下兩者應該都出現 false，但卻出現一個 true，另一個 false 的結果 (正常專案盡可能不要做連續的判斷)。 1 &gt; 2 &gt; 3 // false 3 &lt; 2 &lt; 1 // true 上面的後者來說，他會依據以下方式來執行： 因為文法是由左至右，所以先執行 3 &lt; 2 得到 false 接下來會執行 false &lt; 1 不過此時的 false 會被轉型成 0 0 &lt; 1 所以是 true 這段因為太燒腦，所有小明沒有出場。 延伸問題，請問以下解答是什麼？ 1 &gt; 2 == 0","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 物件的連連看!? 兩個物件的值居然會一樣","slug":"javascript-reference","date":"2017-12-09T16:00:00.000Z","updated":"2017-12-11T01:34:21.465Z","comments":true,"path":"javascript/2017/12/10/javascript-reference/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/10/javascript-reference/","excerpt":"","text":"承上集，小明現在在漂亮阿姨 (陳小美) 家裡，漂亮阿姨還有一個雙胞胎姐姐 - 陳美美，陳美美的各方面與雙胞胎妹妹都很接近，除了名字以外。因此，偷懶的小明決定將兩個人的名字畫線連再一起，然後改個名字就好了。 var auntie = &#123; name: &#x27;陳小美&#x27;, ages: 22, bwh: &#123; strength: 34, agility: 25, intelligence: 96 &#125;, single: true &#125;; var auntie2 = auntie; // 將漂亮阿姨得值 連到姊姊上 接下來，調整一下姊姊的名字 auntie2.name = &#x27;陳美美&#x27; console.log(auntie.name); // 請問這裡會輸出什麼？ 小明將兩個人的名字，對應到相同的資料結構上，阿姨與她的姊姊都是同一份資料。因此，小明將阿姨姊姊的名字寫到阿姨的名字上了 (明天醒來就會搞不清楚是誰了!?)。 傳值與傳參考一般而言，我們在傳遞變數的時候，如果是單一的值賦予到另一個變數後，兩者是毫無關係的。 var a = &#x27;a&#x27;; var b = a; b = &#x27;c&#x27;; console.log(a); // a 依然是 &#x27;a&#x27;，不受影響 但就上面小明故事來說，會發現兩者的物件好像是綁定再一起的，改動其中一個，另一個物件也會跟著更動，這個因為在 JavaScript 中的物件是 “傳參考(by Reference)”，其結果就像是小明筆記本所發生的狀況。 如果使用資料表的概念在思考，可以想像資料表的 Address 就是變數，Value 就是值，一個 Address 只能對應一個值，那麼物件在組成的時候就會產生另一個表，然後透過 address 來做傳遞，所以才會兩個變數共用同一個資料表。 這樣的結果有好處也有壞處，好處是我們在操作物件時，可以輕易地用更短的變數來操作，以下面範例來說，我們可以將 DOM 物件賦予在一個更精簡名稱的變數上，然後修改其中的值。 var input = document.getElementById(&#x27;sb_ifc0&#x27;); input.style.backgroundColor = &quot;red&quot;; // 在 Google 首頁的 Console 套用此段程式碼，可以將 input 背景改成紅色 壞處可以參考小明所遭遇到的問題，操作資料格式時將兩份資料給搞混了，所以在處理資料時，如果他實際並非 “同一份”，而僅是相似時就要特別注意此問題。 複製物件不含參考我們來介紹不同方式來複製物件且不含參考，而以下是基礎的資料格式。 var auntie = &#123; name: &#x27;陳小美&#x27;, ages: 22, bwh: &#123; strength: 34, agility: 25, intelligence: 96 &#125;, single: true &#125;; 另外複製也會有區分 深度 (Deep Copy)及淺度 (Shallow Copy)，差異在於一層傳值，還是所有層級皆傳值，在 bwh 這一層就可以做此測試。 手動賦值這是很直接的觀念，把物件的參考賦予方式改用值的方式來傳遞，此時手動傳值的部分將會完全獨立。不過注意，在內層物件還是依據參考的方式傳遞 (bwh 的物件)。 auntie2 = &#123; name: auntie.name, ages: auntie.ages, bwh: auntie.bwh, single: auntie.single &#125; for…in和手動賦值的方式接近，不過是使用 for...in 的語法將原本的物件屬性，傳到新的物件上，這種方式同上也是屬於淺層賦值。 var auntie3 = &#123;&#125;; for (var prop in auntie) &#123; auntie3[prop] = auntie[prop]; &#125; 轉字串將物件轉換為一個不相干的字串，再將字串轉回物件，這種方式就會使兩個物件毫無關聯，屬於完全複製沒有深度限制。 var str = JSON.stringify(auntie); var auntie4 = JSON.parse(str); 使用套件jQuery 套件中的 extend 可以複製物件，他也可以將加入參數使用深度複製 (deep copy)，不虧是萬年 jQuery，各種好用工具都在其中。 var auntie5 = jQuery.extend(&#123;&#125;, auntie); // 淺複製 var auntie6 = jQuery.extend(true, &#123;&#125;, auntie); // 深度複製 jQuery extend 詳細文件: jQuery.extend() | jQuery API Documentation ES6原生 ES6 中也有提供類似 jQuery 的複製方法，但此方法僅適用於淺複製，並沒有提供深度複製。 const auntie6 = Object.assign(&#123;&#125;, auntie); By Reference, By Value 在 JavaScript Object 中一值屬於很常見的問題，不管新手老手都曾經錯在其中 T_T。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 就是一堆物件的概念","slug":"javascript-object","date":"2017-12-08T16:00:00.000Z","updated":"2017-12-09T03:08:53.410Z","comments":true,"path":"javascript/2017/12/09/javascript-object/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/09/javascript-object/","excerpt":"","text":"在 JavaScript 中，除了上一篇所介紹到的原始型別以外的都是物件，包含陣列、函式…甚至全域本身都是物件，物件本身可以一層包著一層，其內層可以是字串、數值、陣列、物件，甚至是函式。 故事說明 小明的記事本都是用物件的概念在做紀錄，他會將要做的事情、筆記分門別類的做巢狀紀錄，這樣的好處可以讓他在尋找資料時比較好處理，並且可以自由地新增屬性及值。 那麼小明筆記本資料如果使用 JavaScript 寫的話會如下，可以發現其實大家做筆記的方式也是這樣的巢狀概念： var note = &#123; &#x27;聯絡人資料&#x27;: &#123; &#x27;阿姨&#x27;: &#123; name: &#x27;陳小美&#x27;, ages: 22, bwh: &#123; // 三圍 strength: 34, agility: 25, intelligence: 96 &#125;, single: true &#125;, &#x27;杰倫&#x27;: &#123; name: &#x27;陳小美&#x27;, ages: 19, bwh: &#123; // 三圍 strength: 87, agility: 87, intelligence: 87 &#125;, single: false &#125; &#125; &#125; 我們簡化一下資料內容，紀錄單人資料時也是用巢狀的方式在記錄，如果要尋找一個人的特定屬性時也會比較快。(ex: 漂亮阿姨的力量值在 auntie -&gt; bwh -&gt; strength 可以找到)。 var auntie = &#123; name: &#x27;陳小美&#x27;, ages: 22, bwh: &#123; // 三圍 strength: 34, agility: 25, intelligence: 96 &#125;, single: true &#125;; 如何存取物件物件本身的組成是由一個 &#123;屬性(property) / 值(value)&#125; 組成的，可以透過 JavaScript 的規則定義一個物件的名稱，舉例來說上述的阿姨可以用以下方式定義： var auntie = &#123;&#125;; auntie.name = &#x27;陳小美&#x27;; auntie.ages = 22; auntie.single = true; 相同的概念，我們能夠使用一樣的方式取出物件的值，但如果是未定義的屬性則會出現 undefined，嘗試取出未定義屬性的子屬性則會出錯： console.log(auntie.name); // &#x27;陳小美&#x27; console.log(auntie.name); // 22 // 假設以下值位定義 console.log(auntie.bwh); // undefined console.log(auntie.bwh.strength); // 錯誤 另外也可以使用中括號來取用變數的值： var str = &#x27;name&#x27; auntie[&#x27;name&#x27;]; // 使用純字串 auntie[str]; // 使用變數 auntie[0]; // 使用數字，就如同存取陣列一樣 (如果有此值) auntie[&#x27;some-name&#x27;]; // 使用字串，就算此名稱不符合 JS 的變數命名規則 (如果有此值) 列舉物件有時候，我們無法預設了解物件內有什麼屬性，此時我們可以使用列舉 (for ... in) 來取出物件內的屬性及值。 var auntie = &#123; name: &#x27;陳小美&#x27;, ages: 22, bwh: &#123; strength: 34, agility: 25, intelligence: 96 &#125;, single: true &#125;; for (prop in auntie) &#123; console.log(auntie[prop]); // 陳小美, 22, &#123;bwh&#125;,true &#125; 除了原始型別以外都是物件JavaScript 本身可以運行在瀏覽器、伺服器端，以瀏覽器來說全域本身就是一個大物件 (window)，裡面包含許多瀏覽器的 API、開發者定義變數、DOM 物件… 、方法等，只要在開發者工具下輸入 console.log(window) 就可以看到。 上圖可以看到剛剛宣告的物件也存在於 window 的物件下。 接下來可能會思考到為何陣列、函式都是物件？如果說陣列本身是物件可能也許好理解，他的存取方式與物件是非常相似的 (下方範例)： var auntie = [&#x27;陳小美&#x27;, 22, &#123; strength: 34, agility: 25, intelligence: 96 &#125;, true]; auntie[0]; // &#x27;陳小美&#x27; 但偏偏他還多了許多陣列方法 (像是：push, shift, unshift)，為何還會說是陣列呢？ 這段都與原型繼承有關，我們在更後續的章節再來介紹這一段。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：動態型別的 JavaScript","slug":"javascript-typeof","date":"2017-12-07T16:00:00.000Z","updated":"2017-12-08T03:15:28.037Z","comments":true,"path":"javascript/2017/12/08/javascript-typeof/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/08/javascript-typeof/","excerpt":"","text":"JavaScript 是屬於動態型別，它定義了七種資料型別，分別為六種原始型別 (ES6 新增一種原始型別)及 Object 型別。在開始之前先用小明來說明一下型別是怎樣的東西。 故事說明： 承先前故事，小明每天早上醒來都會忘記所有事物，但會在睡覺前把要做的事情先記錄下來，筆記本上會分門別類寫出要做的事情。 小明有時會將要詢問的事情留空白，等到知道結果後再填上數值，像是某一個商品的價格如果再詢問前無法得知，就會先定義變數，等到有值後寫入： var porkPrice; // Undefined porkPrice = 200; // Number 小明也不是嚴謹的人，常常在筆記本上塗抹修改的地方，像是亂加漂亮阿姨的姓名、年齡等。 var auntie = &quot;漂亮阿姨&quot;; // String auntie = &#123; name: &#x27;陳小美&#x27;, ages: 22 &#125;; // Object 以上僅是說明動態型別，請不要學小明這樣做。 如果要查看型別，可以使用 typeof auntie 來驗證型別，可以透過 typeof 看看以下變數分別屬於哪些型別，其中會發現有趣的事情。 var family = &#123; mom: &#x27;老媽&#x27;, me: &#x27;小明&#x27;, sister: &#x27;小橙&#x27; &#125;; var money = 100; var isEdge = true; var attributes = &#x27;邊緣&#x27;; var variable; var nullVariable = null; // 猜猜這個是什麼型別 六種原始型別原始型別分別為以下六種： Boolean：僅有 true, false 兩個值 Null：僅有 null 的值 Undefined：沒有被定義的變數 String：字串型別 Number：下述說明 Symbol（於 ECMAScript 6 新定義，以後再說明） 除此之外還有一個 物件型別。 Undefined 與 Null這兩個就翻譯上會有點接近，但實際上會有一些差異，首先建議：”不要將變數手動設為 undefined，這可能會造成未預期的結果。 Undefined 是在定義了一個變數，但是沒有給值 Null 則是在一個變數上給予了 “空值” JavaScript 本身不會自動給予值 Null，這是讓開發者來設定變數沒有值的。 強制轉型 Number(undefined) -&gt; NaN、Number(null) -&gt; 0 typeof(undefined) -&gt; undefined、typeof(null) -&gt; Object null 是有效的 JSON 值，undefined 不是 為什麼 null 是 Object，自從有 JavaScript 開始就是這樣了，而這個錯誤不能修正，他會導致不可預期的錯誤 (來源：The history of “typeof null”)。 另外原本也預期在未來會給予 typeof null === &#39;null&#39; 的正確結果，但後來也被拒絕。 Number數字型別是一種 浮點數)，這種數值在極大值時會有精準度的問題，範例： 10000000000000000 - 1; // 一樣是 10000000000000000 所以有些文章會提到不要用 JavaScript 來算錢，可是也要先有這麼多錢再說啊 QQQQ。另外還有以下三種都屬於此 Number 型別。 +Infinity -Infinity NaN (not a number，但屬於數字型別，強制轉型有時會出現此錯誤) 物件型別除了上述的六種原始型別，其餘都是物件型別，包含很常使用的 “陣列”、”函式” 都屬於物件型別。 下一個章節會開始來介紹 JavaScript 的物件，了解物件的概念有助於了解整個 JavaScript 的架構及運作喔 :)","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：一次只能做一件事情的 JavaScript","slug":"javascript-event-queue","date":"2017-12-06T16:00:00.000Z","updated":"2017-12-07T03:06:33.000Z","comments":true,"path":"javascript/2017/12/07/javascript-event-queue/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/07/javascript-event-queue/","excerpt":"","text":"在 JavaScript 中，一次只會執行一段程式碼，相信看到這段大家心中都會有所疑惑，我們實作中可以大量發出許多事件，並重複執行不同的函式，這樣為何還是單執行緒 (single threaded) 的程式語言呢？ 這段如果用純文字解釋較為困難，所以本篇會加入動畫讓大家更容易了解原理。 故事說明小明故事：小明在完成早上的事情後，他會準備做以下事情： 打電話給漂亮阿姨 等待漂亮阿姨回覆 清理碗盤… 接下來他會有以下動作 打電話給漂亮阿姨 心中掛念著 漂亮阿姨 回電 (Event Queue) 去清理碗盤 接到阿姨的回電 小明並沒有再打給阿姨後就守在電話旁，而是先去做其他事情等待，並且把漂亮阿姨回電這件事情先放在心中，等待回電後再去接聽。 function doWork() &#123; var auntie = &quot;漂亮阿姨&quot;; (function () &#123; console.log(&#x27;打給阿姨&#x27;) setTimeout(function () &#123; console.log(auntie + &#x27;回電&#x27;) &#125;, 3000) &#125;)(); (function () &#123; console.log(&#x27;洗碗&#x27;); &#125;)(); &#125; doWork(); // 執行 // 打給阿姨 // 洗碗 // // 漂亮阿姨回電 Event queue (事件佇列)像小明先把事情擱置在心中，等待條件觸發在 JavaScript 稱為 Event queue。像是 setTimeout, addEventListener, XMLHttpRequest 等等，這些方法在執行時會先將事件放到這地方，並將所有的事件堆疊完成後，才會開始讓 event queue 內的事件被觸發。 我們透過以下的短影片來了解一下 event queue 是怎麼樣概念 (影片下方是時間軸，用來解釋事件堆疊)。 Your browser does not support the video tag. 影片中我們可以看到 事件堆疊會逐一執行 等到執行到不會立即執行的行為，就會放到 event queue，event queue 的事件在 所有事件完成前 不會被執行。 等到所有事件堆疊完成後 event queue 內的事件才能被觸發。 這裡將 setTimeout 修改成 0 試試看，確認是不是所有事件堆疊都完成後，才會執行 event queue 的事件。 function doWork() &#123; var auntie = &quot;漂亮阿姨&quot;; (function () &#123; console.log(&#x27;打給阿姨&#x27;) setTimeout(function () &#123; console.log(auntie + &#x27;回電&#x27;) &#125;, 0) // 修改成 0 秒 &#125;)(); // ... console.log(&#x27;洗碗&#x27;); return &#x27;完成事件堆疊&#x27;; &#125; doWork(); // 執行 他一樣會將所有事件完成後，再讓 setTimeout 完成，以上這段程式碼也可以貼在 Chrome 開發者工具內試試看。 打給阿姨 洗碗 // &quot;完成事件堆疊&quot; 漂亮阿姨回電 在所有非同步事件如 click、setTimeout、ajax…，都不會立即執行這些行為，而是將這些行為放到 event queue 中，等待事件觸發後再回來執行。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 變數的宣告與他的作用域","slug":"javascript-variables","date":"2017-12-05T16:00:00.000Z","updated":"2017-12-06T03:14:15.977Z","comments":true,"path":"javascript/2017/12/06/javascript-variables/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/06/javascript-variables/","excerpt":"","text":"變數分為全域與區域變數，差異點在於宣告 (var) 的方式，就 MSDN 上的說明 在函式定義之外宣告的變數就是全域變數，其值可在整個程式中存取和修改。 所以我們可以使用函式來做兩個的分隔點，函式之內宣告的稱為區域，函式以外宣告的稱為全域。 全域性的變數在函數外宣告的變數則是具有全域性(或是包含全域物件之內)，在瀏覽器下的全域物件是 window，有以下方式所產生的變數都會在 window 內。 // 在函示外宣告 var mom = &#x27;老媽&#x27;; // 沒有使用 var mom = &#x27;老媽&#x27;; (function () &#123; // 或是在函式內，但沒有使用 var mom = &#x27;老媽&#x27;; &#125;)(); 以上方式都可以在 console.log(window); 後找到 `mom 這個變數，這個變數也屬於 全域物件，因此所有函式也都能取用此變數。 另外，也可以直接產生在 window 物件下。window.mom = &#x27;老媽&#x27;; 這幾種方式都會在 window 物件下產生 mom，並且所有函示都能取用，但還是有些差異 (後面會介紹)，但就實際使用來說，建議無論如何都宣告你的變數。 變數與他的作用域每個變數在宣告時，都只會在執行環境內建立記憶體，這個就是他的作用域，單如果此作用域內沒有可用的變數時，他則會參照外圍的。 function doMorningWork() &#123; var mom = &quot;老媽&quot;; function sayHi() &#123; var greeting = &#x27;hi&#x27;; return greeting + &#x27; &#x27; + mom; &#125; console.log(sayHi()); &#125; doMorningWork(); // 執行 回到上一集的故事：小明會將每一天的要做的事情寫在記事本內，並且記錄著許多工作內容。小明在 doMorningWork() 工作下建立了 mom 變數，這個 mom 就僅屬於 doMorningWork() 內，其它外部的函式都無法取用這個函式。 (旁白：小明出門後就可以不認這個媽媽了!?) 外層 doMorningWork(); 具有 mom 的變數 內層 sayHi(); 可以使用 mom 這個變數，讓小明可以跟媽媽說早安 另一個函式就無法取用 mom 這個變數。 其中內層沒有 mom 的變數，他就會向外層尋找，找到有相同名稱的就直接拿來使用。(旁白：小明啊，你應該把媽設為全域啊!?) 變數與記憶體關係使用 var 宣告一個變數時，記憶體會先準備一個空間給予此變數，所以在實際運行前調用此變數並不會出現錯誤，只會出現 undefined (已經有記憶體空間，但沒有值)。 console.log(mom); // undefined var mom = &#x27;老媽&#x27;; 故事：小明本身記性就不好，他會採取先整個看一次的方式，將整個印象存在腦中 (開啟記憶體空間)，實際開始後再把實際把當天人、事、物整個記在腦內。 宣告與不宣告MDN 文中提到 其中差異在於, 已宣告的變數是全域物件裡的一個無法變更 (non-configurable) 的屬性, 而未宣告的變數則是可變更的 (configurable) ，可以嘗試刪除產生的變數，觀察其差異。 案例：var mom1 = &quot;老媽1&quot;; mom2 = &quot;老媽2&quot;; (function () &#123; mom3 = &quot;老媽3&quot;; &#125;)(); delete mom1; delete mom2; delete mom3; console.log(window.mom1); // 僅剩此有值 console.log(window.mom2); console.log(window.mom3); 提醒如果使用 var 則會先在記憶體準備一個空間給他，所以執行以前使用這個變數還不至於跳錯。 console.log(mom); // undefined var mom = &#x27;老媽&#x27;; 但如果沒有使用 var，則會跳出錯誤。console.log(mom); // mom is not defined mom = &#x27;老媽&#x27;; 所以無論你的變數或函式是否要使用全域，都盡可能地去宣告它。至於 Let、Const 請容許我到後面 ES6 章節再來介紹它 :)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：執行環境與堆疊","slug":"ironman-2017","date":"2017-12-04T16:00:00.000Z","updated":"2017-12-05T01:49:59.820Z","comments":true,"path":"javascript/2017/12/05/ironman-2017/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/05/ironman-2017/","excerpt":"","text":"JavaScript 一次只能做一件事情，他會依據 執行環境 (Execution Context) 來一一執行工作內容，本篇系列文會用舉例的方式，讓大家用簡單的方式瞭解這些艱深詞彙。 全域執行環境與函式在一開始會登記一個函式在全域環境下(global context)，然後這個全域環境下可以登記其他函式，然後每一段執行環境下會有屬於他的變數以及物件，如果找不到該執行環境的變數或物件，則會向外層尋找。 故事說明：小明是本作的主角，早上時固定會做幾件事情，一個是與老媽說早安，另一個則是吃早餐，老媽與早餐可能會換(?)，所以他是可能會變動的，但大致上來說是說完早安，再去吃早餐。於是會在紙上紀錄下早上要做的事情。 早上要做的事情： 變數 媽：”老媽” 早餐：”麵包” 要做的事情 (function context) 吃早餐 說 ‘hi’ function doMorningWork() &#123; // 從此 function 的大括號是另一個執行環境 var mom = &quot;老媽&quot;; var breakfast = &quot;麵包&quot;; function sayHi() &#123; // 說早安執行環境 return &#x27;hi &#x27; + mom; &#125; function eatBreakfast() &#123; // 吃早餐執行環境 return &#x27;吃 &#x27; + breakfast; &#125; console.log(&#x27;早安,&#x27; + sayHi() + &#x27;, &#x27; + eatBreakfast()); &#125; doMorningWork(); // 執行 這個地方我們得到了三個執行環境(Execution Context)，其中一個是 (global context)，另外兩個則是在 global 下的 doMorningWork 內。 故事說明：小明得了一個症狀，每天早上都是全新的一天，他會忘記先前的人事物(簡直電影故事劇情，細節不重要)，他會將每天該做的事情記錄下來，也分為主要任務及主要任務下的次要任務，並且把任務的相關人等寫下，並且一件一件事情完成它 (小明只有一個，一次只能做一件事情)。 他會依序將工作完成： 檢視一下工作任務有哪些 看完早上的任務後開始執行 doMorningWork() 接下來將會面對的人事物先存在大腦內 var ... 接下來他會面對第一個工作 sayHi() 這個工作沒有專屬的變數，於是他找主要任務的變數 mom 執行完成 做下一個任務… 他會將所有的任務完成，才會開始做下一個主要任務 (這個範例只有一個) 要做的事情往後會越來越多，小明會把要做的事情存在腦內，然後依據順序來執行。 糟糕的事情是，遇到他不知道該怎麼做下去的事情，他會卡在那邊一整天 (xxx is not defined)。 小明的筆記本與 JavaScript 有著接近的邏輯，有著一件一件要做的事情等待他去完成。 執行堆疊在這個故事中也可以說明 JavaScript 的執行堆疊，一開始會先進入 global 執行環境，接下來再進入內層的環境，執行完的堆疊就會被釋放掉 (function 內的 return 即是完成)，然後逐步地完成所有堆疊，最後將控制權交還給 Global。 每個執行堆疊都會一層一層地向內執行，等到都執行完以後才會回到外層執行下一個任務。 這段概念影響了什麼？ JavaScript 由外而內執行，執行完才會進行下一個動作 如果其中一個環境卡住，那麼 JavaScript 就會掛掉(小明想不通) 另外，變數的作用域也與此有很大的關係，我們到下一章節來繼續介紹關於作用域 :)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：邁向 JavaScript 勇者之路 - 開始","slug":"ironman-2017","date":"2017-12-03T16:00:00.000Z","updated":"2017-12-04T01:47:34.310Z","comments":true,"path":"javascript/2017/12/04/ironman-2017/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/04/ironman-2017/","excerpt":"iT邦幫忙的鐵人賽到目前是第四次參加，前幾次參加有兩次是 CSS，而本次是 JavaScript，主要原因當然是 JavaScript 即將要統治世界 (!?)，僅只有 CSS 的能力很難體會這個世界的險惡美好。 JavaScript 能做的事情非常多，Web 端的應用僅是其中的一小部分，現在包含後端、自動化、IOT、區塊鏈…許多軟體運用都可借助 JavaScript 的語言來開發，雖說不一定是最適合所有情境的，但學一個語言做更多何樂而不為呢？ 這次所介紹的 JavaScript 不限於瀏覽器上的運用，而是 JavaScript 運作上的概念，主要的文章內容包含： 執行環境 文法與陷阱 型別與物件 函式 原型 ES6 的語法說明","text":"iT邦幫忙的鐵人賽到目前是第四次參加，前幾次參加有兩次是 CSS，而本次是 JavaScript，主要原因當然是 JavaScript 即將要統治世界 (!?)，僅只有 CSS 的能力很難體會這個世界的險惡美好。 JavaScript 能做的事情非常多，Web 端的應用僅是其中的一小部分，現在包含後端、自動化、IOT、區塊鏈…許多軟體運用都可借助 JavaScript 的語言來開發，雖說不一定是最適合所有情境的，但學一個語言做更多何樂而不為呢？ 這次所介紹的 JavaScript 不限於瀏覽器上的運用，而是 JavaScript 運作上的概念，主要的文章內容包含： 執行環境 文法與陷阱 型別與物件 函式 原型 ES6 的語法說明 原型以前的章節約莫佔 15 ~ 20 篇，剩下的章節會介紹 ES6，文章內的語法都可運行在 Chrome Browser 及 Nodejs 環境(詳細需參考版本)。 系列文章適合誰我希望這篇文章適合給有基礎 JavaScript 觀念，但非相關科系的朋友。 對於具有相關背景的朋友來說，閱讀 MDN 的文件已經非常容易，但如果你和我一樣是屬於半路出家，完全不懂 Hello World 是什麼梗的話，那麼相信本系列文章能夠幫助到您。 本系列文章將會去除許多艱澀難懂的詞彙(但會盡可能附上原文)，用我們平常聊天的語彙來了解 JavaScript。 案例說明文章中的範例都可以直接貼在 Chrome Browser Console 內，所以你可以打開 Chrome 的開發者工具 &gt; Console，接下來複製以下程式碼貼上，就可以得到如註解的結果。 var originCash = 1000; function updateEasyCard(cash) &#123; var money = (cash || 100) + originCash; console.log(&#x27;我有 &#x27; + money + &#x27; 元&#x27;); &#125; updateEasyCard(); // 我有 1100 元 除此之外，文章中也會用許多圖例、故事範例，舒緩閱讀上的壓力!? 歡迎交流如果對於文中有任何疑慮或有錯誤也歡迎指正，JavaScript 博大精深，是即將要統治世界的語言 (X)，透過交流我們也更能了解其中的奧妙，哪麼我們就準備開始吧～。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"在 VSCode 啟用程式碼規範工具 (ESLint)","slug":"coding-style","date":"2017-11-08T16:00:00.000Z","updated":"2017-11-10T01:06:26.656Z","comments":true,"path":"tool/2017/11/09/coding-style/","link":"","permalink":"https://wcc723.github.io/tool/2017/11/09/coding-style/","excerpt":"","text":"許多同學會詢問到程式碼怎樣寫可以比較整齊且符合規範，在 VSCode 中非常容易整合這樣的工具，這邊提供兩個方法給大家參考，不過記得兩者不能混用，使用時請擇一即可。 ESLint：比較正式的方法，有完整的文件規範，適合團隊使用 JavaScript Standard Style 插件：比較簡單的方法。 方法一：ESLint先開啟 / 安裝 VSCode 中的 ESLint 套件，記得預設的 VSCode 是有安裝此套件的，套件中也有提到如何運行。 安裝 ESlint 的 npm 套件，目的是可以使用 eslint 的指令，方便建立規範使用的。npm install -g eslint 開啟 Terminal 後，輸入 eslint --init 接下來會出現一連串的問題，你想要怎麼建立 ESLint 的規範文件？Q: How would you like to configure ESLint? Answer questions about your style Use a popular style guide Inspect your JavaScript file(s) 建議選擇 使用主流的 Style Guide (第二個)，如果使用此選項，他會要求先建立 package.json，如果專案中沒有 package.json 可以輸入：npm init 其中的問題可以 Enter 到底即可，接下來再回到上一步 eslint --init 繼續選擇建立規範。 選擇 Use a popular style guide 後，會出現三個主流的規範。 Google Airbnb：如果選擇此選項，會多問一個是否使用 React Standard 接下來會選擇要哪一種格式 YAML、js、json 來儲存規範，這個規範是能夠讓其他專案使用的，只要團隊討論好即可。 安裝完後，在專案內會增加一個 eslint.js (或者其他，依據上述選擇的而定)，此時可以先關閉 VSCode 專案再重啟一次，接下來選擇 “輸出” 可以看到 ESLint server is running.，並且沒有其他錯誤訊息表示已成功運行 (如下圖)。 接下來會看到畫面上都了很多紅色提示，滑鼠移到紅底線上方會提示該如何修改。 目標就是減少畫面上的紅字 T_T，如果有未定義的變數也會跳紅字，目標當然是去除專案中的紅字來符合規範。 上圖選的是 Airbnb 的規範，相關可參考：GitHub - airbnb/javascript: JavaScript Style Guide 其它注意事項： 如果無法順利進行，可嘗試重新安裝 node_modules 試試看。 如果有替換規範，也要重新安裝 node_modules。 重開 VSCode、重裝 node_modules 都是解決問題的好方法。 方法二：JavaScript Standard Style這是使用 Standard JS 提供的 VSCode 套件，不要與 ESLint 混合使用，也可以直接在工作區關閉 ESLint 只執行 Standard JS 接下來安裝 JavaScript Standard Style 的 VSCode 套件，安裝完後直接重起就能使用了，沒有額外的設定檔。 套件路徑：https://marketplace.visualstudio.com/items?itemName=chenxsan.vscode-standardjs 啟用後再右下方一樣會出現 JavaScript Standard Style 的字樣，Standard 相對於其他規範來說寬鬆很多，最大的特點是沒有分號。 寫起來長得像這樣 (未定義或定義但未使用的仍然會跳錯)，另外還有繁體中文的文件 (standard/README-zhtw.md at master · standard/standard · GitHub)。 我自己是比較喜歡 Standard，但缺點就是沒有分號，如果用在教學中同學可能會誤以為 JavaScript 不用分號。Airbnb 比較不習慣的則是物件裡的逗號，一般物件的最後一個是沒有逗號，但在 Airbnb 則是逗號到底。","categories":[{"name":"tool","slug":"tool","permalink":"https://wcc723.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://wcc723.github.io/tags/tool/"}]},{"title":"從設計轉職工程師的原因及過程","slug":"from-starter","date":"2017-07-26T16:00:00.000Z","updated":"2017-07-27T03:34:35.000Z","comments":true,"path":"life/2017/07/27/from-starter/","link":"","permalink":"https://wcc723.github.io/life/2017/07/27/from-starter/","excerpt":"跟很多人說過過去是 “設計師” 而現在轉職成前端工程師，這個轉換過程有兩個問題很多人長問到： 為什麼會想做工程師 設計師是怎麼轉成工程師的 先前都會一一的回答，但相關的故事其實挺多的，所以整理成一篇給大家參考囉。","text":"跟很多人說過過去是 “設計師” 而現在轉職成前端工程師，這個轉換過程有兩個問題很多人長問到： 為什麼會想做工程師 設計師是怎麼轉成工程師的 先前都會一一的回答，但相關的故事其實挺多的，所以整理成一篇給大家參考囉。 為什麼會想做工程師我在學的時候是從純美術到平面設計，過去對於相關產業有美好的憧憬，事實應該大家也略有所聞；但最終設計不能滿足我的則是以下幾點： 薪資：工作主要分為兩個層面，一則是獲得薪資，另一面則是獲得成就感，設計市場在業界普遍不會有太高的價值，這並不是台灣不重視設計，而是供需問題；開設計學院好像是每間學校洗科系數量的最快方法時，設計這種依主觀偏好定價的市場環境，加上難以用量化來評斷價值，人力資源過多的情況下自然難以提高薪資。盡早轉換一個專業來提高自己的市場價值是當時的主要想法。 成就感：以前我一直在思考一個問題，如何證明自己的價值；除了每個月發的薪資條，如何計算為了公司或是一個產品的貢獻值。這個在設計行業是很難計算的，以平面廣告來說，張貼在路邊的平面廣告如何計算出他拉了多少客人？獲得多少轉換值？無法了解就會變成用欺騙來說服自己，其實本質還是無法獲得成就感的。 恩…，不過直白點轉職後收入大幅提升，且過著更愉快的生活，你們會心動嗎？ 答案是不一定的，因為中間充滿了不確定性，以及「堅持」的毅力。 但在這樣長時間的學習後，其實對於設計也有很大不同的看法，畢竟當初的觀念是有很多不成熟的思想在內。現在有幸認識許多業界的設計高手，像是從銷售面來介紹設計、從數據分析改善 UI 流程、專注於台灣文化風格表現、將設計規範融合企業精神等等，這邊就不細說了。 設計師是怎麼轉成工程師的奇異博士的導師問奇異博士：「你是如何成為一名醫生的？」 奇異博士：「經過多年的學習和實際演練。」 要轉換一個跑道並非沒有捷徑，但還是免不了大量的學習以及實際演練，而捷徑則是「正確方向的學習」及「高密度的實際演練」；正確的方向也是新手遇到最大的問題，因為在尋找的過程中會不了解「正確的方向」在哪？ 從社群中學習：如果能遇到好導師當然是很棒的，另外還有一股很強的能量在軟體圈很盛行，那就是技術社群，找不到好導師，人多的地方或許也能找到答案，所以我從就業後沒多久就開始參加技術社群。 每天發文，持續百日：持續練習是相當有效的，而發文是在公眾下證明自己，心態上也會更重視內容，呈現決心上也不容易中斷(大多數人對於公開的承諾都會盡可能的去達到)。不過雖說如此，很建議在開始時別去思考太多細節，重點在 開始 與 堅持，如果沒有開始所有都是白說的。 A share a day：持續一百天的發文 這個網站是用當時所了解的技術完成的： 超過 100 篇文章 (約 110)，每天發文不中斷 (左邊選單有個 more 可以展開) 當初建構時只花了幾個小時，只為了快速開始 網站是使用 Ajax 呼叫其他頁面內容 網站沒有 SEO 的觀念，因為內容都是透過 Ajax 導入 前面幾乎都是 CSS，後面導入了較多 JavaScript 文章 學習成果： 更熟練的 CSS 技巧，如：animation, CSS 3D, Flexbox 對於 Canvas 有一定的概念 還拿到 ITHome 鐵人賽優選 隔年薪資提高 20%+ 自信 而後還另外再參加兩次的的 ITHome 的鐵人賽，分別是 D3.js 及 CSS 的主題，參加還多一份自己的筆記，有人問相關問題直接丟給他多棒！ 結語以上就是個人在出社會後的學習經歷，這個環境其實是不太會看一個人的過去及生長背景，出社會後的努力遠大於在學期間的課業，如果對於現階段生活不滿意，何不試試大量學習翻轉一把呢？","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"圖解：CSS Flex 屬性一點也不難","slug":"css-flex","date":"2017-07-20T16:00:00.000Z","updated":"2020-10-17T01:59:17.007Z","comments":true,"path":"css/2017/07/21/css-flex/","link":"","permalink":"https://wcc723.github.io/css/2017/07/21/css-flex/","excerpt":"前幾篇有介紹過 CSS Grid Layout 的使用方法，當我們學習排版類型的 CSS 時，最好的方式是先作分類，以 Flex 與 Grid Layout 來說都有共同的特徵，就是他們有分為外容器屬性與內元件屬性。","text":"前幾篇有介紹過 CSS Grid Layout 的使用方法，當我們學習排版類型的 CSS 時，最好的方式是先作分類，以 Flex 與 Grid Layout 來說都有共同的特徵，就是他們有分為外容器屬性與內元件屬性。 Flex 的外容器與內元件屬性放錯地方就沒有作用(廢話)，學習的過程中如果可以先了解正確的擺放位置，可以減少許多除錯的時間；Flex 中分為外容器與內元件，下方這張圖就是解釋這兩個的差異。 Flex 外容器屬性： display flex-flow flex-direction flex-wrap justify-content align-items Flex 內元件屬性： flex flex-grow flex-shrink flex-basis order align-self 類別分清楚，至少在練習的時候已經對了一半，接下來就可以開始做屬性的練習與介紹。 外容器display一開始要宣告為 flex 才能使用，如果沒有宣告為 flex，本篇大部分的屬性都無法作用，不過除了 flex 外，還有一個 inline-flex，作用類似於 inline-block + flex。 .flex-container &#123; display: flex | inline-flex; &#125; flex-directionFlex 決定內元件排序方向的重要屬性，這也直接影響了 flex 的軸線 (主軸及交錯軸)，flex 中的對齊屬性都與此有很大的相關聯，下圖中是預設狀態的軸線方向。 flex-direction 就是來改變上圖中的軸線方向，可以將軸線做水平反轉、轉為垂直、垂直反轉等，下圖是四種軸線排列的示意圖： .flex-container &#123; flex-direction: row | row-reverse | column | column-reverse; &#125; 這個範例則是將主軸線設定為垂直的方向，所以 flex 的內容都是以垂直做排列。 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex-direction) by Wcc723 (@Wcc723) on CodePen. flex-wrap超出範圍時是否換行的屬性，分為換行、不換行、換行時反轉。 .flex-container &#123; flex-wrap: nowrap | wrap | wrap-reverse; &#125; 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex-wrap) by Wcc723 (@Wcc723) on CodePen. flex-flow這僅僅是 flex-direction 與 flex-wrap 的縮寫，所以只要在這前後帶上相對應的值即可。 .flex-container &#123; flex-flow: &lt;&#x27;flex-direction&#x27;&gt; || &lt;&#x27;flex-wrap&#x27;&gt; &#125; justify-content這個屬性和下方屬性很像，很接近水平對齊的設定，但嚴格說來是稱為主軸對齊，主軸的設定是上方的 flex-direction；所以實際是水平或垂直，要依主軸的方向而定喔。 .flex-container &#123; justify-content: flex-start | flex-end | center | space-between | space-around; &#125; align-items相對於上一個屬性，這是交錯軸的對齊設定。 .flex-container &#123; align-items: flex-start | flex-end | center | baseline | stretch; &#125; 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex-justify) by Wcc723 (@Wcc723) on CodePen. align-content上一個屬性的多行版本，排列方式也有多一些，但注意 stretch 在高度被限制的情況下不會正常伸展。 .flex-container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch; &#125; 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (align-content) by Wcc723 (@Wcc723) on CodePen. 內元件內元件的設定其中之一 flex 是這當中最特別的，只要搞懂 flex 的設定就了解了 flex 最困難的部分，所以我們就從這部份開始介紹喔。 flexflex 是縮寫，裡面依序包含三個屬性 flex-grow、flex-shrink 和 flex-basis，如果只設定一個則是 flex-grow。 flex-grow: 元件的伸展性，是一個數值，當空間分配還有剩餘時的當前元件的伸展性，預設值為 0，如果設置為 0 則不會縮放。 flex-shrink: 元件的收縮性: 元件的伸展性，是一個數值，當空間分配還不足時的當前元件的收縮性，預設值為 1，如果設置為 0 則不會縮放。 flex-basis: 元件的基準值，可使用不同的單位值。 以下圖為例，伸展值為 2 的空間會佔更多。 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex) by Wcc723 (@Wcc723) on CodePen. align-selfalign-self 可以調整內元件交錯軸的對齊設定(主軸線則不能另外做設定)，且可以個別設定單一元件的值。 See the Pen Flex 介紹 (align-self) by Wcc723 (@Wcc723) on CodePen. Order這是一個相當特別的屬性，可以重新定義元件的排列順序，順序會依據數值的大小排列。 See the Pen Flex 介紹 (order) by Wcc723 (@Wcc723) on CodePen. 和過去不同，Flex 已經是主流的 CSS 屬性，現在許多 CSS 框架也都是使用 Flex 來作網格排版。搭配著範例，動手玩玩看能夠更快速的了解 Flex 喔。 延伸介紹：Flex 空間計算規則","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()]","slug":"es6-native-array","date":"2017-06-28T16:00:00.000Z","updated":"2017-06-29T07:40:29.000Z","comments":true,"path":"javascript/2017/06/29/es6-native-array/","link":"","permalink":"https://wcc723.github.io/javascript/2017/06/29/es6-native-array/","excerpt":"陣列處理技巧是 JavaScript 中非常重要的一塊，現在框架大亂鬥的時代，框架基本上對於 DOM 的處理都有屬於自己一套良好的方法。只要能夠對於陣列資料操作熟悉，配合框架就能夠將開發效率更上層樓。 本篇介紹到的方法有： filter() find() forEach() map() every() some() reduce()","text":"陣列處理技巧是 JavaScript 中非常重要的一塊，現在框架大亂鬥的時代，框架基本上對於 DOM 的處理都有屬於自己一套良好的方法。只要能夠對於陣列資料操作熟悉，配合框架就能夠將開發效率更上層樓。 本篇介紹到的方法有： filter() find() forEach() map() every() some() reduce() 直接點上方連結就能跳到指定區域 初始資料本篇都是使用同一份陣列資料，當然你也可以把相關的函式直接貼在 jsbin 或 codepen 上就能看到結果，因為篇幅已經很長了，所以就不在另外補上範例檔。 // 相同的陣列 var people = [ &#123; name: &#x27;Casper&#x27;, like: &#x27;鍋燒意麵&#x27;, age: 18 &#125;, &#123; name: &#x27;Wang&#x27;, like: &#x27;炒麵&#x27;, age: 24 &#125;, &#123; name: &#x27;Bobo&#x27;, like: &#x27;蘿蔔泥&#x27;, age: 1 &#125;, &#123; name: &#x27;滷蛋&#x27;, like: &#x27;蘿蔔泥&#x27;, age: 3 &#125; ]; Array.prototype.filter()filter() 會回傳一個陣列，其條件是 return 後方為 true 的物件，很適合用在搜尋符合條件的資料。 var filterEmpty = people.filter(function(item, index, array)&#123; &#125;); console.log(filterEmpty); // 沒有條件，會是一個空陣列 var filterAgeThan5 = people.filter(function(item, index, array)&#123; return item.age &gt; 5; // 取得大於五歲的 &#125;); console.log(filterAgeThan5); // Casper, Wang 這兩個物件 var filterDouble = people.filter(function(item, index, array)&#123; return index % 2 === 1; // 取得陣列中雙數的物件 &#125;); console.log(filterDouble); // Wang, 滷蛋 這兩個物件 Array.prototype.find()find() 與 filter() 很像，但 find() 只會回傳一次值，且是第一次為 true 的值。 var findEmpty = people.find(function(item, index, array)&#123; &#125;); console.log(findEmpty); // 沒有條件，會是 undefined var findAgeThan5 = people.find(function(item, index, array)&#123; return item.age &gt; 5; // 取得大於五歲的 &#125;); console.log(findAgeThan5); // 雖然答案有兩個，但只會回傳 Casper 這一個物件 var findLike = people.find(function(item, index, array)&#123; return item.like === &#x27;蘿蔔泥&#x27;; // 取得陣列 like === &#x27;蘿蔔泥&#x27; &#125;); console.log(findLike); // 雖然答案有兩個，但只會回傳第一個 Bobo 物件 Array.prototype.forEach()forEach 是這幾個陣列函式最單純的一個，不會額外回傳值，只單純執行每個陣列內的物件或值。 var forEachIt = people.forEach(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列 return item; // forEach 沒在 return 的，所以這邊寫了也沒用 &#125;); console.log(forEachIt); // undefined people.forEach(function(item, index, array)&#123; item.age = item.age + 1; // forEach 就如同 for，不過寫法更容易 &#125;); console.log(people); // 全部 age + 1 Array.prototype.map()使用 map() 時他需要回傳一個值，他會透過函式內所回傳的值組合成一個陣列。 如果不回傳則是 undefined 回傳數量等於原始陣列的長度 這很適合將原始的變數運算後重新組合一個新的陣列。 var mapEmpty = people.map(function(item, index, array)&#123; &#125;); console.log(mapEmpty); // [undefined, undefined, undefined, undefined] var mapAgeThan5 = people.map(function(item, index, array)&#123; return item.age &gt; 5; // 比較大於五歲的 &#125;); console.log(mapAgeThan5); // [true, true, false, false] var mapAgeThan5_2 = people.map(function(item, index, array)&#123; // 錯誤示範 if (item.age &gt; 5) &#123; return item; // 回傳大於五歲的 &#125; return false; // 別以為空的或是 false 就不會回傳 &#125;); console.log(mapAgeThan5_2); // [&#123;name: &#x27;Casper&#x27;...&#125;, &#123;name: &#x27;Wang&#x27;...&#125;, false, false] var mapEat = people.map(function(item, index, array)&#123; if (item.like !== &#x27;蘿蔔泥&#x27;) &#123; return `$&#123;item.like&#125; 好吃`; &#125; else &#123; return `$&#123;item.like&#125; 不好吃`; &#125; &#125;); console.log(mapEat); // [&quot;鍋燒意麵 好吃&quot;, &quot;炒麵 好吃&quot;, &quot;蘿蔔泥 不好吃&quot;, &quot;蘿蔔泥 不好吃&quot;] Array.prototype.every()every() 可以檢查所有的陣列是否符合條件，這僅會回傳一個值 true or false，可以用來檢查陣列中的內容是否符合特定條件。 var array = [ &#123; name: &#x27;Casper&#x27;, like: &#x27;鍋燒意麵&#x27;, age: 18 &#125;, &#123; name: &#x27;Wang&#x27;, like: &#x27;炒麵&#x27;, age: 24 &#125;, &#123; name: &#x27;Bobo&#x27;, like: &#x27;蘿蔔泥&#x27;, age: 1 &#125;, &#123; name: &#x27;滷蛋&#x27;, like: &#x27;蘿蔔泥&#x27;, age: 3 &#125; ]; var ans = array.every(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列 return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true &#125;); console.log(ans); // false: 只要有部分不符合，則為 false var ans2 = array.every(function(item, index, array)&#123; return item.age &lt; 25 &#125;); console.log(ans2); // true: 全部 age 都小於 25 Array.prototype.some()some() 與 every() 非常接近，都是回傳 true or false，差異僅在 every() 需完全符合，some() 僅需要部分符合。 var ans = people.some(function(item, index, array)&#123; return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true &#125;); console.log(ans); // true: 只要有部分符合，則為 true var ans2 = people.some(function(item, index, array)&#123; return item.age &lt; 25 &#125;); console.log(ans2); // true: 只要有部分符合，則為 true var ans2 = people.some(function(item, index, array)&#123; return item.age &gt; 25 &#125;); console.log(ans2); // false: 全部都不符合則為 false Array.prototype.reduce()reduce() 和其他幾個差異就很大了，他可以與前一個回傳的值再次作運算，參數包含以下： accumulator: 前一個參數，如果是第一個陣列的話，值是以另外傳入或初始化的值 currentValue: 當前變數 currentIndex: 當前索引 array: 全部陣列 var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; &#125;); console.log(reduceEmpty); // 沒有條件，會是 undefined var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; // 分別為前一個回傳值, 目前值, 當前索引值 console.log(accumulator, currentValue, currentIndex); return accumulator + currentValue.age; // 與前一個值相加 &#125;, 0); // 傳入初始化值為 0 console.log(reducePlus); // 總和為 46 var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log(&#x27;reduce&#x27;, accumulator, currentValue, currentIndex) return Math.max( accumulator, currentValue.age ); // 與前一個值比較哪個大 &#125;, 0); console.log(reducePlus); // 最大值為 24 reduce() 的使用方法更為豐富，想認識更詳細可參考 MDN。 其它預設的陣列行為內的 this 是指向 window (本篇中除了 reduce() 是傳入初始資料)，如果要改，可以在 function 後傳入。 // arr.forEach(function callback(currentValue, index, array) &#123; // your iterator // &#125;[, thisArg]); var ans3 = people.forEach(function(item, index, array)&#123; console.log(this) // 這邊的 this 就會使用後方傳入的 return item.age &lt; 25 &#125;, people); // 傳入的物件，替代 this，如果無則是 window","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"JavaScript ES6 Promise","slug":"promise","date":"2017-05-24T16:00:00.000Z","updated":"2020-02-27T03:22:03.694Z","comments":true,"path":"life/2017/05/25/promise/","link":"","permalink":"https://wcc723.github.io/life/2017/05/25/promise/","excerpt":"","text":"本文章有提供新的版本，可參考：JavaScript Promise 全介紹 Promise 一直都是 JavaScript 夢寐以求的功能，非同步的處理如果沒有使用 Promise 經常導致函式或資料無法正常的運作。本篇避開許多深度的詞彙，直接透過範例來瞭解怎麼運行。 簡單的 Promise 範例： // 宣告 promise 建構式 let newPromise = new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 let ran = parseInt(Math.random() * 2); // 隨機成功或失敗 console.log(&#x27;Promise 開始&#x27;) if (ran) &#123; setTimeout(function()&#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(&#x27;3 秒時間(fulfilled)&#x27;); &#125;, 3000); &#125; else &#123; // 回傳失敗 reject(&#x27;失敗中的失敗(rejected)&#x27;) &#125; &#125;); newPromise.then((data)=&gt; &#123; // 成功訊息 (需要 3 秒) console.log(data); &#125;).catch((err)=&gt; &#123; // 失敗訊息 (立即) console.log(err) &#125;); 以上就是一個基本的 Promise 範例，執行 Promise 建構式時還會再帶入 resolve 與 reject 的 callback function。 resolve: 完成的 callback reject: 失敗的 callback Promise 的生命週期 pending: 等待中的初始狀態 fulfilled: 正確完成 rejected: 已拒絕，操作失敗 上圖就是一個轉化中的圖 (一開始是 Pending，等我展開的時候已經 resolved 了… )。 這個建構式另外還提供兩種調用 promise 的方法 race() 與 all()： Promise.all(): 此方法可以同時執行大量 Promise 物件，並且在 “全部” 完成後回傳陣列。 Promise.race(): 此方法執行大量 Promise 物件，但僅會回傳最快回應的結果。 範例： // 宣告 promise 建構式 let newPromise1 = new Promise((resolve, reject) =&gt; &#123; let ran = parseInt(Math.random() * 5000); // 隨機成功或失敗 setTimeout(function()&#123; resolve(&#x27;隨機時間完成&#x27;); &#125;, ran); &#125;); let newPromise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve(&#x27;2 秒完成&#x27;); &#125;, 2000); &#125;); let newPromise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve(&#x27;3 秒完成&#x27;); &#125;, 3000); &#125;); let newPromise4 = new Promise((resolve, reject) =&gt; &#123; reject(&#x27;失敗&#x27;); &#125;); Promise.all([newPromise1, newPromise2, newPromise3, newPromise4]).then((data)=&gt; &#123; // 一次性同時回傳成功訊息，回傳以上三個數值的陣列 console.log(data); &#125;).catch( err =&gt; &#123; // 失敗訊息 (立即) console.log(err) &#125;); Promise.race([newPromise1, newPromise2, newPromise3]).then((data)=&gt; &#123; // 僅會回傳一個最快完成的 resolve 或 reject console.log(&#x27;race&#x27;, data); &#125;).catch( err =&gt; &#123; // 失敗訊息 (立即) console.log(err) &#125;); 這個案例較長，前面主要是宣告幾個 Promise 建構式，差異在時間與刻意的失敗；後面介紹 Promise.all() 與 Promise.race() 的差異。 Chain 鏈接方法Promise 一個很重要的方法 then()，其實是可以不斷的做鏈接。基本的概念就是前一個 return 會是下一個 then() 傳送的變數。 // 前面宣告的不重要 let newPromise1 = new Promise((resolve, reject) =&gt; &#123; let ran = parseInt(Math.random() * 5000); // 隨機成功或失敗 setTimeout(function()&#123; resolve(&#x27;隨機時間完成&#x27;); &#125;, ran); &#125;); let newPromise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve(&#x27;2 秒完成&#x27;); &#125;, 2000); &#125;); let newPromise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve(&#x27;3 秒完成&#x27;); &#125;, 3000); &#125;); // 這段以前不重要 // 鏈接方法 newPromise1.then((data1) =&gt; &#123; console.log(&#x27;data1&#x27;, data1); return newPromise2.then((data2) =&gt; &#123; return `$&#123;data2&#125; + $&#123;data1&#125;` // 回傳 Promise 內的值，讓下一個 then 可以接收 &#125;); &#125;).then((data3) =&gt; &#123; console.log(&#x27;data3&#x27;, data3); return newPromise3.then((data4) =&gt; &#123; return `$&#123;data4&#125; + $&#123;data3&#125;` // 回傳 Promise 內的值，讓下一個 then 可以接收 &#125;); &#125;).then((data5) =&gt; &#123; console.log(`最後的 + $&#123;data5&#125;`) &#125;); 用文字不好表達這段，直接看圖。Promise 執行時可以使用 then 做串接，串接的方法在於需要使用 return 來做下一個 then() 的傳入值，透過這個方法可以避免 JavaScript 原始碼過巢導致難以閱讀。 以上程式碼皆可直接複製貼到 Chrome 開發者工具內的 console 運行。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"CSS3 Grid Layout","slug":"css-grid","date":"2017-05-23T16:00:00.000Z","updated":"2017-05-24T02:25:30.000Z","comments":true,"path":"life/2017/05/24/css-grid/","link":"","permalink":"https://wcc723.github.io/life/2017/05/24/css-grid/","excerpt":"CSS gird layout 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，這和 Bootstrap 或是 960 Grid 沒有任何關係，而是新的 CSS 語法。","text":"CSS gird layout 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，這和 Bootstrap 或是 960 Grid 沒有任何關係，而是新的 CSS 語法。 在 5/18 與線上讀書會合作時，有針對 CSS Grid 做一個概略性的解說，並另有提供範例，以下是直播活動時的簡報內容。 直播連結：https://www.facebook.com/WccCasper/videos/377986119264284/ Css3 Grid Layout from Chih-cheng Wang 相關連結： 範例一：https://codepen.io/Wcc723/pen/jmzJWY 範例二：http://codepen.io/Wcc723/pen/bWKgPY 線上 Grid 工具：http://wcc723.github.io/WorkShop-gh-pages/cssGridDisplay/ 蒙德里安範例：https://codepen.io/Wcc723/pen/zwaZm","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"剛出社會要存錢嗎？","slug":"save-money-or-not","date":"2017-04-13T16:00:00.000Z","updated":"2017-04-14T01:24:39.000Z","comments":true,"path":"life/2017/04/14/save-money-or-not/","link":"","permalink":"https://wcc723.github.io/life/2017/04/14/save-money-or-not/","excerpt":"這個標題不是針對全聯老闆的，只是有感而發，因為我是反對靠存錢來增加存款(資產)的。","text":"這個標題不是針對全聯老闆的，只是有感而發，因為我是反對靠存錢來增加存款(資產)的。 先講一個例子： 月薪三萬跟月薪五萬花起來感覺差多少，就目測是差不到兩倍，但實際上五萬是三萬的兩倍以上。 簡單算一下必要花費： 孝親費: $5,000 水電、房租、網路: $10,000 固定生活費: $8,000 這樣同時使用五萬跟三萬去扣除 月薪三萬剩 $7000 月薪五萬剩 $27000 這樣兩者就差了近四倍，就算月薪三萬不給孝親費，月薪五萬每個月再多幾次聚餐，這差距都還是存在(公式隨便調都是差兩倍以上)。 在剛出社會的時候，不是很建議靠存錢來增加資產，建議提高學習、生活體驗的預算，這樣不僅有助於薪資的成長，身為一個人也能活得更充實。 增加學習的預算一開始我花不少時間、錢去上技術課程或書，認為上課是最乾脆的，講師將大量的知識濃縮到短時間讓學生吸收，雖然價格會比書籍貴一些，但就時間成本來說相對划算許多，到現在還是會看看有什麼有趣的課程去學習。 增加生活體驗一個人的價值並不是只有看到收入，豐富的生活體驗更能彰顯一個人的價值，生活體驗更能夠激發個人的慾望與動力，慾望自然能個轉化成目標，沒有想要發財的人怎會想去賺很多錢呢？ 薪水太少不如投資自己 以長線來說投資自己最有價值","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"CSS Grid 屬性介紹","slug":"css-grid-layout","date":"2017-03-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2017/03/22/css-grid-layout/","link":"","permalink":"https://wcc723.github.io/css/2017/03/22/css-grid-layout/","excerpt":"CSS gird 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，開始之前還是來介紹一些語法。 與 CSS Flex 一樣，CSS Grid 用兩個部分來看比較快，一個是屬於外部容器的屬性，另一個是屬於內部容器的屬性；從外開始向內看可以加快理解的速度。","text":"CSS gird 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，開始之前還是來介紹一些語法。 與 CSS Flex 一樣，CSS Grid 用兩個部分來看比較快，一個是屬於外部容器的屬性，另一個是屬於內部容器的屬性；從外開始向內看可以加快理解的速度。 CSS Grid 可以做什麼呢？這邊提供一個簡單範例給大家看看，相同的 Grid System 如果使用 float 需要多很多層，還要注意清除浮動等等。在 CSS grid 的加持下每個 class 都僅需少量的屬性就可做到相同的效果。 See the Pen CSS Grid Layout by Wcc723 (@Wcc723) on CodePen. 本篇內容有許多參考 https://css-tricks.com/snippets/css/complete-guide-grid/ 外部容器dispaly和 Flex 一樣，需要定義容器的顯示類型。 .container &#123; display: grid | inline-grid | subgrid; &#125; grid-template-columns, grid-template-rows看完這個屬性，對於 CSS Grid 就會有基礎的了解。 Grid 和 flex 最大不同之處，透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排。 圖片來源：https://css-tricks.com/snippets/css/complete-guide-grid/ .container &#123; grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; &#125; track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位) line-name: 可自行命名的名稱 圖片：自己畫的 .wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; height: 100vh; width: 940px; margin: 0 auto; &#125; 粉紅色的部分就是 grid-template-columns，黃色部份則是 grid-template-rows，隔線排版就能靠上面一張圖了解！grid-template-columns 定義水平方向的空間，grid-template-rows 定義垂直方向的空間，且可以使用大部分的單位數值。 .wrap &#123; grid-template-columns: repeat(2, 1fr 2fr) 100px; /* grid-template-columns: repeat(&#123;次數&#125;, &#123;格線...&#125; | &#123;格線...&#125;) | &#123;格線...&#125;; */ &#125; 這個地方在介紹兩個新東西，一個是 fr 這個單位，這個單位能夠將可用的 剩餘空間 做比例分割，以上面的 1fr 2fr 為例，空間將被分割成 1/3、2/3 兩個大小。另一個是 repeat，可以重複隔線。 grid-template-areas透過 area 定義區塊在 template 上的位置，概念就是在畫面上登記屬於該元素的空間，此部分要內外元素一起看。 內元素 grid-area：定義空間的名稱 外元素 grid-template-areas：定義空間的位置，是透過幾組字串的組合，組合方式可以參考下圖及程式碼。 假設我們需要繪製如上的空間配置，上方出現 5 * 3 那麼會透過 grid-area 來命名小空間的名稱，再透過 grid-template-areas 來表示整體空間的配置，配置的方式是透過字串的方式組合。 .wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; grid-template-areas: &quot;header header header header header&quot; &quot;side main main main main&quot; &quot;side footer footer footer footer&quot;; height: 100vh; width: 940px; margin: 0 auto; &#125; .item-a &#123; grid-area: header; background-color: purple; &#125; .item-b &#123; grid-area: main; background-color: orange; &#125; .item-c &#123; grid-area: side; background-color: green; &#125; .item-d &#123; grid-area: footer; background-color: gray; &#125; 注意： 空間不能分離且是唯一的，錯誤範例: &quot;side main side&quot; grid-auto-columns, grid-auto-rows簡單版的 Grid，如果版型較為簡單，可以直接使用 grid-auto-{ cols or rows}。如果是簡易的 960 12欄 grid 設定如下即可。 .row &#123; display: grid; grid-auto-columns: 60px; grid-auto-flow: column; grid-gap: 20px; width: 940px; min-height: 100vh; margin: 0 auto; &#125; grid-auto-flowGrid 的排列方式，以上面 12 欄排列 grid 來說，如果沒有設定 column，就會變成垂直排列。 .row &#123; grid-auto-flow: row | column | row dense | column dense &#125; grid-gap, grid-column-gap, grid-row-gap格線的間隔包含垂直及水平，可參考如下。 grid-column-gap: &#123; grid-column-gap &#125;; grid-row-gap: &#123; grid-row-gap &#125;; grid-gap: &#123; grid-row-gap &#125; &#123; grid-column-gap &#125;; justify-items, justify-content, align-content與 flex 的使用方法一樣，先跳過之後再補充 內部容器grid-column-start, grid-column-end, grid-row-start, grid-row-end物件所佔的空間位置，Column 及 Row 所到的起始點及終點 .item &#123; grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto &#125; &lt;line&gt; - 用數字表示 物件 所在的線，可參考上一段的 template span &lt;number&gt; - 物件所佔用的欄位數 span &lt;name&gt; - 物件所在的 grid 名稱 auto - 自動的啦 .item &#123; grid-column-start: 2; /* 物件起始線 */ grid-column-end: span 4; /* 終點線 = 物件所佔的空間數 */ grid-row-start: 3; /* 物件起始線 */ grid-row-end: auto; /* 不設定終點線 */ background-color: red; z-index: 999; /* 欄位重疊可用 z-index 設定前後順序 */ &#125; grid-column, grid-row上面那段的縮寫，使用斜線 (/) 隔開屬性。 .item &#123; grid-column: 2 / span 4; &#125; grid-area &lt;name&gt;: 使用命名的方式，透過 grid-template-areas 來套用 &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;: 指定 grid 線數或 grid 名稱來定位 .item-a &#123; grid-area: 2 / 2 / 4/ 4; &#125; justify-self, align-self內容器的定位模式，與 flex 使用方式一樣。 Grid 目前想到的運用方面有： 滿版的排版，適合拿來做平面設計風格的排版 輕量的 grid system，或許下次 Bootstrap 就改用 Display grid 在排版了 ~_~。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"grid","slug":"grid","permalink":"https://wcc723.github.io/tags/grid/"}]},{"title":"VSCode 快速推坑介紹文","slug":"vscode-for-mac","date":"2017-03-02T16:00:00.000Z","updated":"2017-03-03T08:47:03.000Z","comments":true,"path":"javascript/2017/03/03/vscode-for-mac/","link":"","permalink":"https://wcc723.github.io/javascript/2017/03/03/vscode-for-mac/","excerpt":"","text":"用過的 Editor 很多，常常出現新款的 Editor 都會嘗試一下，雖然主流的不一定會喜歡，但多嘗試也不是壞事，這邊稍微列出個人主觀的意見供大家參考參考： Dreamweaver這是早期在使用的 Editor，特色是所見即所得，但這個也成為 Dreamweaver 的致命傷，畢竟做網頁精準的還是瀏覽器上的呈現，過度依賴所見即所得對於學習會有所限制，後來開始精進 CSS 後就不太使用這個工具。 Sublime Text目前相當主流的 Editor，到現在偶爾會打開使用，主要原因是速度極快，搭配良好的套件可以快速完成大量的程式碼，作為一個 Editor 是非常優秀的，但在開發上總是會期待更多的功能 (嘿嘿嘿。 Atom算是 Sublime Text 的升級版，優秀的套件管理及更豐富的延伸套件，能夠達到 Sublime Text 沒有的功能，像是快速啟動 Webserver、內嵌終端機都不是問題。缺點是非常消耗硬體資源，對於較大的檔案可能會有 Crash 的問題，除此之外算是遇到 VSCode 之前的主要開發工具。 VSCode在一開始使用時對於操作不是很習慣，但隨著套件越來越多以及更新改版，也很貼近先前使用的幾套工具，開始嘗試使用開發 Node.js 專案是非常棒的，除了前幾套開發工具有的功能外，內建的 Git、debug tool 都非常的實用，且能夠與 iTerm、Gulp、Webpack 整合，算是 Node.js 開發的神器 (2017年初來說的話啦)。 VSCode 的好用功能內建 Terminal按下 Ctrl + \\` 後， VSCode 就會開啟預設的 Terminal 工具，如下圖所示，個人通常是使用 iTerm 在開發，按下之後下方會有 iTerm 分頁直接使用。如果說有需要修改預設字體，可以打開設定檔加入以下： &quot;terminal.integrated.fontFamily&quot;: &quot;Monaco for Powerline&quot;, Git 整合懶人使用的 Git 工具，只要勾一勾直接就可以 Commit。 在 Commit 前需要做程式碼比對也是相當容易的，點擊檔案名稱自動會出現比對，過去需要仰賴其他 GUI 工具才能做到，現在 VSCode 就內建此功能，可以大幅減少 Code Review 的時間。 Debug Mode 偵錯工具針對 Node.js 或其他後端的開發 (目前僅有測試過 Node.js)，VSCode 可以做到服務啟動、中斷點、一鍵重啟的功能，按下 cmd + shift + D 可以開始建立組態檔。 預設的組態檔其實都寫好了，存檔後就可以啟用服務。 設定中斷點，觸發時會列出當下的變數狀態，讓後端開發搞得跟用 Chrome 一個樣 (有嗎？ 啟用後畫面上會出現這樣的工具，可以暫停、重啟、停止服務。 Gulp、Webpack … 整合如果專案中有 gulpfile.js，按下 cmd + shift + P 呼叫 task run，VSCode 會自動撈出 gulpfile 內的 Task 讓開發者選擇執行。 停止方式：Terminate Running Task 尋找錯誤程式碼程式碼有錯，卻找不到在哪裡 (隱藏在茫茫 Code 海中的全行字元啊～)，按下 shift + cmd + m 就會標出目前錯誤的問題，但其實平常打錯他就會有標示囉。 程式碼提示完整的 Javascript 程式碼提示，像下面這個功能不需要多解釋，隨便按都會看起來很專業。 設定檔雖然說他沒有 Atom 那樣的 GUI 設定工具，但這樣的設計反而讓工程師更容易去搜尋想要的設定，左邊是設定的預設值，複製到右邊的個人設定檔就可以修改參數，且設定檔包含完整的中文說明，透過搜尋列可以輕鬆找到要修改得值。 VSCode 的功能相當多，相信不是一兩篇短文推坑就能摸熟，如果有興趣可以參考 Will 保哥介紹的影片，不到一個小時就能讓你從其他 Editor 轉來使用 VSCode。影片：https://www.youtube.com/watch?v=CAQdar3JGEU 圖片目前放在 Dropbox Paper 上，如有遺失會再更新。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://wcc723.github.io/tags/promise/"},{"name":"es6","slug":"es6","permalink":"https://wcc723.github.io/tags/es6/"}]},{"title":"Javascript Promise 範例","slug":"javascript-promise","date":"2017-03-01T16:00:00.000Z","updated":"2017-03-02T14:03:53.000Z","comments":true,"path":"javascript/2017/03/02/javascript-promise/","link":"","permalink":"https://wcc723.github.io/javascript/2017/03/02/javascript-promise/","excerpt":"Promise 現在已經被大部分瀏覽器所支援 (IE 以外)，在處理非同步的操作是一大助力，最近在寫 Node.js 也不需要再仰賴其它套件就能夠直接處理非同步問題，以下就提供一個範例來介紹簡單的 Promise 的操作過程。","text":"Promise 現在已經被大部分瀏覽器所支援 (IE 以外)，在處理非同步的操作是一大助力，最近在寫 Node.js 也不需要再仰賴其它套件就能夠直接處理非同步問題，以下就提供一個範例來介紹簡單的 Promise 的操作過程。 See the Pen ES6 Promise by Wcc723 (@Wcc723) on CodePen. (function() &#123; let epaAPI = &quot;http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&amp;$skip=0&amp;$top=1000&amp;format=json&amp;callback=?&quot;; let errorUrl = &quot;http://opendata.epa.gov.tw/ws/Data/UL/?$orderby=PublishAgency&amp;$skip=0&amp;$top=1000&amp;format=json&amp;callback=?&quot;; let _DefaultContry = &#x27;臺北市&#x27;; var getData = (url)=&gt; &#123; // 傳入的 URL return new Promise((resolve, reject) =&gt; &#123; // return promise $.getJSON( url, function()&#123; format: &quot;json&quot; &#125;).done(function(data) &#123; if (data) &#123; resolve(data); // 成功後透過 resolve 回傳值 &#125; else &#123; reject(&#x27;Error&#x27;); &#125; &#125;).fail(function() &#123; reject(&#x27;Error&#x27;); &#125;); &#125;); &#125; getData(epaAPI) // 傳入的 url .then((data)=&gt;&#123; // then 接受回傳的值 console.log(data); $.each( data, function( i, item ) &#123; console.log(item); let list = `&lt;li&gt;$&#123;item.SiteName&#125; $&#123;item.PublishTime&#125; $&#123;item.SiteName&#125; $&#123;item.UVI&#125;&lt;/li&gt;` //利用item.值，把每一個值取出，並寫成一個html存在list的變數內 $(&#x27;.itemlist&#x27;).append(list); //最後把剛剛的html放到表格內 &#125;); &#125;); getData(errorUrl) // 傳入錯誤的 url .then((data)=&gt;&#123; // then 接受回傳的值 (錯誤的狀況不會跑這段) console.log(data); &#125;) .catch((response)=&gt; &#123; // 錯誤狀態的回傳 console.log(&#x27;errorUrl:&#x27;, response); &#125;); &#125;)(); 說明new Promisevar getData() 裡面包含非同步的 Ajax，如果直接套用 getData() 會無法確實取得資料後再執行其他 function，所以這時候在內部加上 new Promise() 確保 Ajax 完成後再回傳資料。getData(epaAPI) 套用時可以傳入 url，在後方的 .then 表示任務完成第一段後取得 resolve() 內的值，接下來就如同 jQuery Ajax 回傳後得處理方式一樣，。 let list = `&lt;li&gt;$&#123;item.SiteName&#125; $&#123;item.PublishTime&#125; $&#123;item.SiteName&#125; $&#123;item.UVI&#125;&lt;/li&gt;` 題外話：這一段則是 ES6 中的字串處理方式，用 符號框住整個字串，再透過類似 jQuery 的 selector ($&#123;&#125;) 就能帶入字串中的變數，取代過去使用 &quot; &quot; + variable + &quot; &quot; 撰寫起來輕便許多。 錯誤回傳getData(errorUrl) // 傳入錯誤的 url .then((data)=&gt;&#123; // then 接受回傳的值 (錯誤的狀況不會跑這段) console.log(data); &#125;) .catch((response)=&gt; &#123; // 錯誤狀態的回傳 console.log(&#x27;errorUrl:&#x27;, response); &#125;); 後面包含另一個 getData(errorUrl) 刻意傳入錯誤的連結使其產生錯誤，這時候的 .then 沒有辦法接受到資料，後方的 .catch 則可以接到由 reject() 回傳的訊息。 參考文件：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/all","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://wcc723.github.io/tags/promise/"},{"name":"es6","slug":"es6","permalink":"https://wcc723.github.io/tags/es6/"}]},{"title":"鐵人賽 30 - CSS 鐵人賽的結束與接下來的研究","slug":"ironman-ending","date":"2016-12-29T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/30/ironman-ending/","link":"","permalink":"https://wcc723.github.io/css/2016/12/30/ironman-ending/","excerpt":"相較於 Javascript 來說，CSS 的演進速度算是非常緩慢的，主要原因當然是瀏覽器的相容性，瀏覽器不太能因為新的特色加入而毀了以前所建置的網站。 在這個相對穩定的程式語言，精通一個的手法就可以活用的相當久，像是 Sass 來說，到目前為止他還是相當流行的前置語言。","text":"相較於 Javascript 來說，CSS 的演進速度算是非常緩慢的，主要原因當然是瀏覽器的相容性，瀏覽器不太能因為新的特色加入而毀了以前所建置的網站。 在這個相對穩定的程式語言，精通一個的手法就可以活用的相當久，像是 Sass 來說，到目前為止他還是相當流行的前置語言。 就算如此，CSS 依然有許多有趣的新穎功能，以 Flex 來說就能輕鬆排出許多豐富的版型，恰巧這幾天朋友考我 flex，就將這排版獻醜給大家看看，條件如下： 用 flex 排版 navbar 固定在上方 主要內容分為三欄 中間欄內容長的時候可以 scroll ，左右不需要 scroll 右側欄分為三列 右上欄有獨立的 scroll JS Bin on jsbin.com body, html &#123; margin: 0; padding: 0; &#125; .flex-h &#123; height: 100vh; &#125; .flex &#123; display: flex; &#125; .flex-1 &#123; flex: 1; &#125; .flex-3 &#123; flex: 3; &#125; .flex-col &#123; flex-direction: column &#125; .scroll &#123; overflow-y: scroll; &#125; .navbar &#123; height: 60px; background-color: red; &#125; .bg-blue &#123; background-color: blue; &#125; .bg-gray &#123; background-color: gray; &#125; 在這些條件下，相信大家也使用過 position、float 等排版手法，而 flex 僅需要簡短的語法就能達到接近的效果。不過雖然如此 flex 目前不是大家主要排版的首選，需要上線的產品我也不會使用 flex 做為主要排版的語法(會使用在次要的內容)，主因還是 flex 在於目前相容性還不夠高，就算捨去了 IE 還是有部分的瀏覽器在呈現上略有不同(說個鬼故事，很多人的 iOS、Mac OS 都不愛更新的)。 為了讓自己可以更熟悉 Flex，我也做了一個簡單的工具，讓自己可以透過互動的方式查詢 Flex 的語法。 連結：http://wcc723.github.io/WorkShop-gh-pages/cssFlex/ CSS column和 Flex 一樣屬於排版的語法 CSS column，去年的時候也有花很多時間研究，也有製作類似的語法互動研究工具，和 flex 也遭遇相同的問題，不同瀏覽器雖然都支援，卻顯示出不同的結果，以下連結請玩～ 連結：https://wcc723.github.io/css/2015/07/23/css-column/ 據說很猛的 display: grid第一次研究 flex 是在 2013 年，至今也三年左右了… Q_Q，到現在使用上還是有所顧忌，現在對於排版有新的屬性：display: grid，依據 flex 的概念他可以等我花三年的時間慢慢研究 &gt;O&lt;。 以下為圖文參考的文件，就目前看來有許多語法與 flex 是共用的，期望 webkit 能統一瀏覽器世界，讓這些語法能夠快速進入實際運用。 https://css-tricks.com/snippets/css/complete-guide-grid/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 29 - CSS 實戰小技巧 - 不使用 important 的高優先值技巧","slug":"one-class","date":"2016-12-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/29/one-class/","link":"","permalink":"https://wcc723.github.io/css/2016/12/29/one-class/","excerpt":"在維護舊的專案很多必須放下自尊，用一些手段來維持成果的運作，但有些作法如果過於殘暴可能會影響到未來的維護，CSS !important 就是一個很好用的手段，他可以直接將 CSS 的優先值拉到最高，並且超過標籤的 style 屬性樣式，那麼在未來就變成要修正這一段樣式無法再用 style 的方式覆蓋。 這邊介紹一招只需要用 className 就能夠大幅提升優先值的手法，讓想快速結束這回合，但又怕傷了未來萌新的善良人參考。","text":"在維護舊的專案很多必須放下自尊，用一些手段來維持成果的運作，但有些作法如果過於殘暴可能會影響到未來的維護，CSS !important 就是一個很好用的手段，他可以直接將 CSS 的優先值拉到最高，並且超過標籤的 style 屬性樣式，那麼在未來就變成要修正這一段樣式無法再用 style 的方式覆蓋。 這邊介紹一招只需要用 className 就能夠大幅提升優先值的手法，讓想快速結束這回合，但又怕傷了未來萌新的善良人參考。 情境現在 CSS 的樣式如下，有一個 blue 的藍色字體，另外還有一組 ul, li，先前的開發者為了讓呈現綠色的 ul, li 中的 .blue 改成橘色，所以用很多階層的手法拉高優先值。 .blue &#123; color: blue; &#125; ul.green li ul li &#123; color: green &#125; ul.green li ul li.blue &#123; color: orange &#125; .demo &#123; border: 1px dashed orange; padding: 15px; &#125; 前一個開發者使用了許多巢狀的 CSS 來提高優先值，進而改變 .blue 的色彩。 &lt;div class=&quot;demo&quot;&gt; &lt;p class=&quot;blue&quot;&gt;這是一段藍色的話&lt;/p&gt; &lt;ul class=&quot;green&quot;&gt; &lt;li&gt; &lt;span&gt;這是一段話&lt;/span&gt; &lt;ul&gt; &lt;li class=&quot;blue&quot;&gt;&lt;span&gt;這是一段話&lt;/span&gt;&lt;/li&gt; ... &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; .blue { color: blue; } ul.green li ul li { color: green } ul.green li ul li.blue { color: orange } .demo, .demo2 { border: 1px dashed orange; padding: 15px; } 這是一段藍色的話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 此時，如果身為 .blue 的藍色 (ul.green li ul li.blue)，如果想改變回藍色且不能修改原有的 CSS 程式碼情況下，這邊就提供一個小撇步來提高 CSS 權重。 .demo2 .blue.blue.blue.blue.blue.blue.blue.blue.blue.blue { color: blue; } 這是一段藍色的話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 只要將 .blue 這一個 className 不斷堆疊就能做到這樣的效果。 .blue.blue.blue.blue.blue.blue.blue.blue.blue.blue &#123; color: blue; &#125; 這個手法是不斷提升堆疊單一個 className 的權重，並使它可以超過其它巢狀元素的優先值，所以並不會影響到標籤的 style 及 !important 的權重。 那麼，如果這個情況下還需要更高的權重呢？那…就慢慢加長吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 28 - 實戰小技巧 - iOS 表單的使用者體驗優化","slug":"ios-input","date":"2016-12-27T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/28/ios-input/","link":"","permalink":"https://wcc723.github.io/css/2016/12/28/ios-input/","excerpt":"最後幾篇再來額外介紹一些小技巧，這些小技巧都是非常冷門的卻是實用的手法，分享給大家參考看看。","text":"最後幾篇再來額外介紹一些小技巧，這些小技巧都是非常冷門的卻是實用的手法，分享給大家參考看看。 先前有一位朋友詢問到 iOS 表單有個小問題讓他困擾，就是用戶在點擊的時候，畫面都會略微的放大，這會讓用戶在填寫表單的時候非常的不順手，狀況如下： 這種強制放大一個不明白的尺寸，實在是非常的惱人，尤其是在畫面這麼小的情況下。於是這位朋友希望可以做一些調整，讓用戶在點擊的時候直接放到全螢幕，這樣在正常全螢幕的情況下點擊就不會有縮放的感覺；如果是放大看的用戶，也是一率拉滿全屏。成果如下： 用戶在點擊時，只會有些微的位移。 CSS 修正以上的解法，我一開始以為是使用 Javascript，透過各種方式解析，其實只要做一點點調整就可以了，就是將 input 的文字大小設定超過 16px (完)，那麼在點擊的時候就直接拉滿全屏，以下範例可用 iOS 手機點點看。 See the Pen auto fullscreen by Wcc723 (@Wcc723) on CodePen. .autofullscreen &#123; input, select, textarea, button &#123; font-size: 16px; &#125; &#125; 結果如上，只要調整 CSS 就能大幅改善使用者體驗。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 27 - CSS 框架自幹心得 - 失敗三次的框架建構經驗","slug":"over-my-dead-body","date":"2016-12-26T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/27/over-my-dead-body/","link":"","permalink":"https://wcc723.github.io/css/2016/12/27/over-my-dead-body/","excerpt":"先前提到過有自幹過框架，主要的經驗是兩次，第三次就不再完全重新自幹了，每次到了最後都會發現有些概念不夠完美，然後修正前一版的錯誤再出發一次!?後來發現自幹本身就有很大的風險在…。","text":"先前提到過有自幹過框架，主要的經驗是兩次，第三次就不再完全重新自幹了，每次到了最後都會發現有些概念不夠完美，然後修正前一版的錯誤再出發一次!?後來發現自幹本身就有很大的風險在…。 第一次距今約 36 個月以前(這樣說比較久)。 剛開始接觸 Sass 時發現他的 @mixin 真的很神，發現很多樣式可以先準備好 @mixin 等到需要使用的時候在載入，所以當時就以產生 樣式庫 的概念做設計，當時還沒有參考主流的框架，單純以自己的觀念做開發，包含按鈕、表單、jQuery 套件等常見的樣式庫都有設計。 當時文件只要輸入 +divider($gap: 1.5em) 就可以引用上方的範例樣式。 且設計上都是用當時主流的漸層效果在做，只要輸入一個色彩就會運算出各種狀態的漸層，真的是好潮好潮～。當時這些都是自己在維護、使用，久而久之發現每個專案都要重新 @include 這些樣式也真的很麻煩，心想不如直接寫一款都預設 @include 的好了。 第二次距今約 24 個月以前。 已經經歷過一次的框架歷練的我，等級已經是翻倍再翻倍，這時候是以一個完整可運用的框架去執行，所以執行時也有考慮到框架的文件、運用、擴充等問題。 樣式文件，命名還要帶點叛逆。 包含延伸運用都有製作在內。 這樣的架構其實並沒有太大問題，但是發現 CSS 檔案大小上升略快 &gt;O&lt;，所以每次加入新元件都要不斷的檢查問題點在哪，後來發現 @extend 的問題以及 OOCSS 的架構。 第三次後來仔細研究了 Bootstrap 文件原始碼及 OOCSS 的概念，清楚了解到自己開發的框架問題點，所以就很乾脆的將 Bootstrap 給 fork 惹…。現在主要都是以 Bootstrap 作為基底來當作樣式框架開發的底層，並且依據自己喜愛的設計風格、專案需求去做調整。 色彩相對於當時的 Bootstrap 3 來說更為鮮豔，且圓角更小。 還有很愛的 outline button，在 Bootstrap 4 的版本也有加入，很開心的是當時很多概念在 Bootstrap 4 都有提供，如 Card、Spacing…。 還以 Material Design 為概念的 jQuery UI，當然這是選用的，預設的情況下是不需要載入的。 結語現在，許多情況下 Bootstrap 4 能滿足基礎的開發需求，再以 Sass 的特性結合需要的元件開發就能節省許多時間。除了公司專案外，我大多情況不會重頭開始寫 CSS 或是另外開發框架。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 26 - 實戰心法 - 應避免的 Sass @extend","slug":"sass-extend","date":"2016-12-25T16:00:00.000Z","updated":"2017-07-26T06:38:18.000Z","comments":true,"path":"css/2016/12/26/sass-extend/","link":"","permalink":"https://wcc723.github.io/css/2016/12/26/sass-extend/","excerpt":"Sass 的 @extend 可以將相同的樣式整理再一起，在其他語言來說是非常帥氣的技法，但在 CSS 中請警慎使用。 就如同本篇鐵人賽一開始所介紹到的 OOCSS 概念，在撰寫 CSS 時要盡可能符合兩個原則，結構與樣式分離、容器與內容分離，所以到這邊為止還是要貫徹這個概念，當使用 @extend 時如果會造成這個缺陷時，請避免使用。","text":"Sass 的 @extend 可以將相同的樣式整理再一起，在其他語言來說是非常帥氣的技法，但在 CSS 中請警慎使用。 就如同本篇鐵人賽一開始所介紹到的 OOCSS 概念，在撰寫 CSS 時要盡可能符合兩個原則，結構與樣式分離、容器與內容分離，所以到這邊為止還是要貫徹這個概念，當使用 @extend 時如果會造成這個缺陷時，請避免使用。 帥氣的 @extend@extend 能夠將重複的樣式整理再一起，以下面的範例來說，我就將 .clearfix 與 .row 中所需要的清除浮動做整理。 編譯前： %clearfix &#123; &amp;:after &#123; content: &quot; &quot;; display: table; clear: both; &#125; &#125; .clearfix &#123; @extend %clearfix; &#125; .row &#123; @extend %clearfix; &#125; 編譯後：.clearfix:after, .row:after &#123; content: &quot; &quot;; display: table; clear: both; &#125; See the Pen clearfix sass extend by Wcc723 (@Wcc723) on CodePen. 這手法可以有效減少散落在各處的樣式，無論他在第幾行，都會被往前統一整理。 錯誤的案例本篇繼續上一篇的範例，上一篇中我們是將 .btn 作為獨立的 Class，且此 Class 身負作為按鈕結構的重任。 在 Sass 中，我們會先新增一個 %btn 來作為 placeholder selectors，而後再 Class 的部分透過 @extend 將 %btn 合併，那麼結構的部分也會合併到每一個按鈕內。 %btn &#123; // 結構 display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; text-align: center; vertical-align: middle; cursor: pointer; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; &amp;:hover, &amp;:focus &#123; color: #333; background-color: #e6e6e6; &#125; &#125; @each $name, $value in $btn-config &#123; $class: map-get($value, class); $color: map-get($value, color); $bg: map-get($value, bg); $border-color: map-get($value, border-color); .btn-#&#123;$class&#125;&#123; @extend %btn; @include button-variant($color, $bg, $border-color); &#125; &#125; 此作法 HTML 會看起來相當簡潔。 &lt;div class=&quot;section&quot;&gt; &lt;button class=&quot;btn-default&quot;&gt;這是一個按鈕&lt;/button&gt; &lt;button class=&quot;btn-primary&quot;&gt;這是一個按鈕&lt;/button&gt; &lt;button class=&quot;btn-accent&quot;&gt;這是一個按鈕&lt;/button&gt; &lt;/div&gt; See the Pen 應該避開的 @extend by Wcc723 (@Wcc723) on CodePen. 雖然說，這樣的在寫的時候看似非常簡潔，但其實所產出的 CSS 檔案非常之肥大，所有樣式結構的 Class 會被拉到前面在寫再一起，無形之中會重複大量的 Class name，如以下所產出的 disabled 的樣式。 .btn-primary.disabled, .btn-primary.disabled:hover, .btn-primary.disabled:focus, .btn-primary.disabled.focus, .btn-primary.disabled:active, .btn-primary.disabled.active, .btn-primary[disabled], .btn-primary[disabled]:hover, .btn-primary[disabled]:focus, .btn-primary[disabled].focus, .btn-primary[disabled]:active, .btn-primary[disabled].active, fieldset[disabled] .btn-primary, fieldset[disabled] .btn-primary:hover, fieldset[disabled] .btn-primary:focus, fieldset[disabled] .btn-primary.focus, fieldset[disabled] .btn-primary:active, fieldset[disabled] .btn-primary.active &#123; background-color: #009AFF; border-color: #009AFF; &#125; 結語其實學到現在，要安全點其實是避開 @extend 不使用，就連 Bootstrap 的原始碼中也不怎麼使用 @extend 這手法，但為什麼本篇會特別提出呢…!?因為我以前就是敗在這上的啊 Q_Q。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 25 - 實戰心法 - Sass Map 快出產出大量樣式","slug":"sass-map","date":"2016-12-24T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/25/sass-map/","link":"","permalink":"https://wcc723.github.io/css/2016/12/25/sass-map/","excerpt":"上一篇介紹了很短的程式碼產生一整組 Grid System，然後還提供變數讓 Grid 還有額外的參數可以設定，手寫的 CSS 如果要重新計算 12 組以上的計算也太苦了 T_T，這也就是 Sass 的魅力所在。 Sass 的運用上手法非常多，這次來介紹透過簡單的變數，即可大量產生相似的模組。","text":"上一篇介紹了很短的程式碼產生一整組 Grid System，然後還提供變數讓 Grid 還有額外的參數可以設定，手寫的 CSS 如果要重新計算 12 組以上的計算也太苦了 T_T，這也就是 Sass 的魅力所在。 Sass 的運用上手法非常多，這次來介紹透過簡單的變數，即可大量產生相似的模組。 Sass MapSass map 是類似 json 的一種變數，json 中包含的陣列、物件、屬性在 Sass map 都能有相似的寫法，所以首先要先使用 Sass Map 來定義基礎的元件變數。 $btn-config 裡面包覆的就是 Sass map，與 json 最大的差異是使用 () 取代 &#123;&#125;，這樣的手法可以大量的產生樣式的變數。 $gray-light: #777; $brand-primary: #009AFF; $brand-accent: #D84315; $btn-config:( default:( class: &#x27;default&#x27;, color: $gray-light, bg: #fff, border-color: #ccc ), primary:( class: &#x27;primary&#x27;, color: #fff, bg: $brand-primary, border-color: $brand-primary ), accent:( class: &#x27;accent&#x27;, color: #fff, bg: $brand-accent, border-color: $brand-accent ) ); 接下來我們在製作 @mixin 與 button 的基本樣式，@mixin 可以將產出的 CSS 先寫成公式，在後續的流程在套用，這個公式我是直接抓 Bootstrap 所寫好的。 另外 .btn 則是先前提過好幾次的結構，而這個結構是不包含樣式 (色彩、大小…)，樣式的部分是在 @mixin 內。 // @mixin 運算 @mixin button-variant($color, $background, $border) &#123; color: $color; background-color: $background; transition: background-color .15s; border-color: $border; &amp;:hover, &amp;:focus, &amp;.focus, &amp;:active, &amp;.active, .open &gt; &amp;.dropdown-toggle &#123; color: $color; background-color: darken($background, 6%); border-color: darken($border, 8%); &#125; &amp;:active, &amp;.active, .open &gt; &amp;.dropdown-toggle &#123; background-image: none; &#125; &amp;.disabled, &amp;[disabled], fieldset[disabled] &amp; &#123; &amp;, &amp;:hover, &amp;:focus, &amp;.focus, &amp;:active, &amp;.active &#123; background-color: $background; border-color: $border; &#125; &#125; .badge &#123; color: $background; background-color: $color; &#125; &#125; // 基本 btn 結構 .btn &#123; // 結構 display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; text-align: center; vertical-align: middle; cursor: pointer; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; &amp;:hover, &amp;:focus &#123; color: #333; background-color: #e6e6e6; &#125; &#125; Sass @eachSass @each 也是像 javascript 中的 each，將 $btn-config 中的物件一一讀出(使用 map-get($value, value))，然後在 @include 上一段所產生的 @mixin。 這樣就能一次產生出大量的 CSS 樣式，所依據的就是先前所設定好的 Sass map，這範例僅使用三種樣式，相同的觀念下我們可以用這方法產出更多的樣式在內，只需要修改 Sass map 即可，不需要改其他部分。 @each $name, $value in $btn-config &#123; $class: map-get($value, class); $color: map-get($value, color); $bg: map-get($value, bg); $border-color: map-get($value, border-color); .btn-#&#123;$class&#125;&#123; @include button-variant($color, $bg, $border-color); &#125; &#125; 範例如下： See the Pen 透過 Sass map 製作多個樣式 by Wcc723 (@Wcc723) on CodePen. 結語現在的 CSS 大多會使用 Sass、Less、PostCSS 來做管理，使用哪一種語言倒是無所謂，但建議先從一種入門到熟悉，會發現省去許多不必要的時間，且在管理上會容易許多。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 24 - 實戰心法 - 自幹 Grid System","slug":"grid-system","date":"2016-12-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/24/grid-system/","link":"","permalink":"https://wcc723.github.io/css/2016/12/24/grid-system/","excerpt":"自己本身是不常自幹 Grid，但透過自幹會了解更細的運作原理，grid system 和其他元件不太一樣，他是屬於外容器型的元件，一層包覆著一層變化性相當高，如果不熟悉的情況下會容易造成跑版。","text":"自己本身是不常自幹 Grid，但透過自幹會了解更細的運作原理，grid system 和其他元件不太一樣，他是屬於外容器型的元件，一層包覆著一層變化性相當高，如果不熟悉的情況下會容易造成跑版。 Grid System 結構以下的 Grid System 是類似 Bootstrap 3 以後的結構，這結構最難以理解的部分是網格之間的 $gutter 運作，它透過反覆的 margin、 padding 補回空間，讓此 grid 的彈性發揮到最高。 灰色部分是網格中欄的區域，以下面這範例來說佔了 4 欄，為了呈現 欄 與 欄 之間的間隔，欄會左右增加 padding 讓內容保留左右的間隔。 但是 欄 所增加的 padding ，最終會影響到最外層的 .row、.container 向外擴增，所以 .row 與 .container 一則使用負值的 margin，另一則用 padding 補回這段空間。 結構分為以下 .container: 最外層的容器，作為限制最大寬度用，另外還有 padding 補回部分的寬度 .row: 包覆 欄(.col) 的容器，除了提供負值的 margin 補回間隔空間外，還有清除 欄(.col) 的浮動之功用 .col-{num}: 所有的欄位，可以從 1 ~ 12，透過 Sass 可以自訂所需的欄數。 Sass 與 Grid如果要快速產生 Grid System，建議使用 Sass 的運算，許多重複、迴圈的部分可以輕鬆很多。 技巧說明： 透過 %grid-system-col 及 @extend %grid-system-col; 可以將 col 重複的部分合併在一起 @for $i from 1 through 12 這段可以直接運算出 col 從 1 到 12 (最終的數值可以另外修改) @media (max-width: 767px) 在小於 767 的裝置下版型會做改變 $gird-end: 12; $gutter: 30px; %grid-system-col &#123; position: relative; min-height: 1px; padding-left: $gutter / 2; padding-right: $gutter / 2; float: left; &#125; * &#123; box-sizing: border-box; &#125; .container &#123; padding-left: $gutter / 2; padding-right: $gutter / 2; margin: 0 auto; max-width: 960px; @media (max-width: 767px) &#123; float: none; width: auto; &#125; &#125; .row &#123; margin-left: - ($gutter / 2); margin-right: - ($gutter / 2); &#125; .row:after &#123; content: &quot;&quot;; display: table; clear: both; &#125; @for $i from 1 through $gird-end &#123; .col-#&#123;$i&#125; &#123; @extend %grid-system-col; width: (100% *($i/$gird-end)); @media (max-width: 767px) &#123; float: none; width: auto; &#125; &#125; &#125; .box&#123; height: 100px; background-color: #ccc; &#125; 原始碼範例: http://codepen.io/Wcc723/pen/ENMEqY/ 結語在套用其他人開發的 grid system 之前，不妨先自己是寫看看，然候修改其中的程式碼這樣更能夠知道每個環節的用途。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 23 - 實戰心法 - 常見的垂直置中手法","slug":"vertical-align","date":"2016-12-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/23/vertical-align/","link":"","permalink":"https://wcc723.github.io/css/2016/12/23/vertical-align/","excerpt":"上一章節介紹了各種 Utilities ，唯獨垂直置中不介紹，因為在製作、使用垂直置中時要先思考 “支援的瀏覽器”，就算現在全部 IE 的使用率低於 2% 的情況下，還是會有很多小兄弟會希望網站優先支援 IE。 本篇會介紹幾種垂直置中手法(不包含舊瀏覽器)，每一種手法的寫法都不大一樣，所以使用時要特別注意使用規則。","text":"上一章節介紹了各種 Utilities ，唯獨垂直置中不介紹，因為在製作、使用垂直置中時要先思考 “支援的瀏覽器”，就算現在全部 IE 的使用率低於 2% 的情況下，還是會有很多小兄弟會希望網站優先支援 IE。 本篇會介紹幾種垂直置中手法(不包含舊瀏覽器)，每一種手法的寫法都不大一樣，所以使用時要特別注意使用規則。 條件這篇文章所介紹的垂直置中方式，都不會使用絕對值(px)，大多可以運用在各種環境，但實際上還是需要配合CSS的特性去做選用。 這次用鳴人的圖片來做介紹，這張圖片是用背景的方式載入。 .naruto &#123; background-image: url(/images/narutoR.png?1372854973); background-color: orange; background-repeat: no-repeat; width: 107px; height: 207px; background-size: cover; margin: 0 auto; &#125; .box-wrap &#123; height: 350px; &#125; .naruto { background-image: url(/images/narutoR.png?1372854973); background-color: orange; background-repeat: no-repeat; width: 107px; height: 207px; background-size: cover; margin: 0 auto; } .box-wrap { height: 350px; border: 1px dashed red; } display table此 table 不是真 table，這是 IE8 以上才支援的 CSS 語法，將 div 的屬性轉成 table，再套用垂直置中的方式來完成。 優點：概念簡單、支援度高(IE8+) 缺點：html 結構較多層、有 table 的特性 .d0116 .table { display: table; width: 100%; } .d0116 .table-cell { display: table-cell; vertical-align: middle; } &lt;style&gt; .d0116 .table &#123; display: table; width: 100%; &#125; .d0116 .table-cell &#123; display: table-cell; vertical-align: middle; &#125; &lt;/style&gt; &lt;div class=&quot;demo d0116&quot;&gt; &lt;div class=&quot;table box-wrap&quot;&gt; &lt;div class=&quot;table-cell&quot;&gt; &lt;div class=&quot;naruto&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; translateY以前常會用一種方式做垂直置中 top: 50%; margin-top: -(元素高 / 2);，先用 top 往下推 50% 的距離，再利用 margin-top 拉回元素的一半高度，這方式雖然很好用，但是必須用在元素有明確高度上。 而這邊所介紹是相同的道理，但是是用 transform: translateY(-50%) 將元素垂直向上 50% 的距離，這 50% 則是元素的高度，且語法都集中在元素上。 優點：超簡單 缺點：並非所有情境都適用 .vertical-center { position: relative; top: 50%; margin: 0 auto; transform: translateY(-50%); } &lt;style&gt; .vertical-center &#123; position: relative; top: 50%; margin: 0 auto; transform: translateY(-50%); &#125; &lt;/style&gt; &lt;div class=&quot;demo d0116&quot;&gt; &lt;div class=&quot;box-wrap&quot;&gt; &lt;div class=&quot;naruto vertical-center&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; flexFlex 是這幾年我經常使用的語法，這讓 CSS 排版的彈性大幅提升，不過在使用時還是有些瀏覽器的差異，像是舊版的 iOS Safari 就會略有不同，另外在實戰上的注意事項也較多。 優點：很潮 缺點：建議熟悉flex概念 .flex-center { display: flex; align-items: center; justify-content: center; } &lt;style&gt; .flex-center &#123; display: flex; align-items: center; justify-content: center; &#125; &lt;/style&gt; &lt;div class=&quot;demo d0116&quot;&gt; &lt;div class=&quot;box-wrap flex-center&quot;&gt; &lt;div class=&quot;naruto&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 結語這三種是我在實戰上比較常使用的，其中最常用的是 translate ，因為只需要一個 class 就能套用，相容性略高於 flex，相當簡單易用。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 22 - 實戰心法 - 經常使用，但卻容易被忽視的 CSS","slug":"css-utilities","date":"2016-12-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/22/css-utilities/","link":"","permalink":"https://wcc723.github.io/css/2016/12/22/css-utilities/","excerpt":"Bootstrap 3 載入以後其實就有包含大部分的元件，原本的設計概念上是希望透過一套框架就能滿足大多的需求，但實際在專案運作時有許多客製化需要微調，而很多微調的項目如下： 左邊一點、右邊一點、間格大一點 文字色彩 背景色 對齊方法 垂直置中方法 CSS 屬性：顯示屬性、背景屬性、Position … 這些雜七雜八的，通常會運用在每個元件上，但每個元件都補上重複性又高，這一個部分我們通常會用另一個元件 _utilities.scss 來管理。","text":"Bootstrap 3 載入以後其實就有包含大部分的元件，原本的設計概念上是希望透過一套框架就能滿足大多的需求，但實際在專案運作時有許多客製化需要微調，而很多微調的項目如下： 左邊一點、右邊一點、間格大一點 文字色彩 背景色 對齊方法 垂直置中方法 CSS 屬性：顯示屬性、背景屬性、Position … 這些雜七雜八的，通常會運用在每個元件上，但每個元件都補上重複性又高，這一個部分我們通常會用另一個元件 _utilities.scss 來管理。 Utilities在 Bootstrap 第四版這一兩個月的改版也有這樣的設計，而且數量多到有細項分類；就算如此，還是建議了解有哪些項目建議可以自行設計，因為這使用率非常高，就算用了第四版還是有不足的可能。 以下我就來介紹一下常用的 Utilities 分類 Spacing間格分為兩大類，一則是 margin，另一則是 padding，兩者的使用頻率都非常高，所以別想偷懶只做一種。另外依據 OOCSS 的概念，間格要避免直接使用數值命名，如： .mb-5 &#123; margin-bottom: 5px; &#125; 所以這部分都會用 s、m、l 或是倍數型的 1、2、3，實作範例如下 (僅列出部分的範例…)。 /* 實作範例 */ .mb0 &#123; margin-bottom: 0 !important; &#125; .mbs &#123; margin-bottom: $gap-small; &#125; .mbm &#123; margin-bottom: $gap-base; &#125; ... .pdm &#123; padding: $gutter; &#125; 文字色彩 與 背景色文字色彩也是經常使用的，除了品牌色 (Bootstrap 中有提到) 另外經常使用的色彩就是灰階、白色，這段的問題比較小，只是建議要使用 !important 來確保色彩覆蓋(僅列出部分的範例…)。 .text-primary &#123; color: $brand-primary !important; &#125; .text-danger &#123; color: $brand-danger !important; &#125; .text-white &#123; color: white !important; &#125; 背景色如同文字色彩，但是背景色有些會有更多延伸，如： 是否包含不同明暗度 是否要額外製作漸層 在製作漸層時，如果專案維護的人不多(或者只有自己)，很建議先寫需要使用的色彩即可，不用的色彩可先不寫，因為很多色彩真的不會去用…。 .bg-primary &#123; background-color: $brand-primary &#125; .bg-primary-lighter &#123; background-color: lighten($brand-primary, 12%) &#125; .bg-primary-darken &#123; background-color: darken($brand-primary, 12%) &#125; 對齊方法這邊主要是文字的對齊，文字分為三種對齊置左、置中、置右，一般來說也是這三種即可，但是在 Bootstrap 4 之中還特別製作了不同的裝置尺寸的對齊方式。 垂直置中的部分在後面會有獨立章節介紹。 CSS 屬性CSS 很多屬性都是經常性的會運用到，這邊列出常用的： float background-size cover contain display block inline-block none position relative absolute fixed overflow overflow-y overflow-x 這些都屬於零碎的 CSS 屬性，使用頻率說高不高、說低不低，但是要用實在另外寫 CSS 也是挺麻煩的，所以我也會將它獨立出來。 .bg-cover &#123; background-size: cover &#125; .bg-contain &#123; background-size: contain &#125; .p-relative &#123; position: relative; &#125; .p-absolute &#123; position: absolute; &#125; .p-fixed &#123; position: fixed; &#125; 結語除了垂直置中以外，其他常見的雜項我都已經在本篇列出，在製作第二次框架時，我就將大量的 Utilities 加入，導致我上班不太需要寫 CSS @_@，也很高興第四版 Bootstrap 加入了大量的 Utilities 讓我寫的 CSS 更少了…。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 21 - Bootstrap 透過 Sass 新增自定義元件","slug":"bootstrap-add-component","date":"2016-12-20T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/21/bootstrap-add-component/","link":"","permalink":"https://wcc723.github.io/css/2016/12/21/bootstrap-add-component/","excerpt":"許多人在使用 Bootstrap 時，如果有需要新增、調整，都是寫在 CSS 的後方或是另開一個新檔透過 “覆蓋” 的特性來新增、調整。先前的文章已經介紹了如何調整 Bootstrap 的 CSS，透過變數的方式，我們可以調整整體的樣式設定，而 “新增” 我們也應該用相同的方法來製作，這樣的方法更有一致性，且能夠調用 Bootstrap 原有的變數及 @mixin。","text":"許多人在使用 Bootstrap 時，如果有需要新增、調整，都是寫在 CSS 的後方或是另開一個新檔透過 “覆蓋” 的特性來新增、調整。先前的文章已經介紹了如何調整 Bootstrap 的 CSS，透過變數的方式，我們可以調整整體的樣式設定，而 “新增” 我們也應該用相同的方法來製作，這樣的方法更有一致性，且能夠調用 Bootstrap 原有的變數及 @mixin。 新增一個元件範例連結https://github.com/Wcc723/ironman-gulp-sass/tree/v.0.7.component 先前的文章介紹到 Sass 的架構，所以我們的專案結構會做些許的調整，目前已經有了 all.scss 以及 helpers/_variables.scss 這兩隻 .scss 檔案，接下來新增 components 資料夾，預計新增的元件就會放在這裡。 scss/ |- all.scss | |– helpers/ | |– _variables.scss # Sass Variables | |– components/ | |– _card.scss # 預計新增的模組 元件來源：https://github.com/doabit/semantic-ui-sass/blob/master/app/assets/stylesheets/semantic-ui/views/_card.scss 我在 Sematic UI 上找到了一個現成的 Card 模組，這個模組所使用的變數不多，刪除後面的段落後，就可以直接加入 components/_card.scss 內。 參考加入內容：https://github.com/Wcc723/ironman-gulp-sass/blob/v.0.7.component/source/scss/components/_card.scss /*-------------- Card ---------------*/ .ui.cards &gt; .card, .ui.card &#123; max-width: 100%; position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; width: 290px; min-height: 0px; background: #FFFFFF; padding: 0em; border: none; border-radius: 0.28571429rem; box-shadow: 0px 1px 3px 0px #D4D4D5, 0px 0px 0px 1px #D4D4D5; -webkit-transition: box-shadow 0.1s ease, -webkit-transform 0.1s ease; transition: box-shadow 0.1s ease, -webkit-transform 0.1s ease; transition: box-shadow 0.1s ease, transform 0.1s ease; transition: box-shadow 0.1s ease, transform 0.1s ease, -webkit-transform 0.1s ease; z-index: &#x27;&#x27;; &#125; /* 略 .. */ 新增元件的心法在前面幾個章節有詳細的描述，本篇就直接運用半成品來說明，在 _card.scss 加入後，如果直接運行 gulp 是不會看到 card 加入至你的 CSS 內，所以必須要在 all.scss 補上以下內容確認載入才行。 @import &quot;helpers/variables&quot;; @import &quot;bootstrap&quot;; @import &quot;components/card&quot;; 此時，執行 gulp 沒有出錯的情況下就會看到 Card 模組已經載入了。以下範例為調整後的按鈕色彩及卡片模組。 結語透過這一段的教學，大家能夠更靈活的使用 Bootstrap，其實這段流程並沒有那麼複雜，只要稍作練習，就能夠彈性的運用這些技能，且能有效地增加工作效率。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 20 - Sass 資料夾結構","slug":"sass-folder","date":"2016-12-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/20/sass-folder/","link":"","permalink":"https://wcc723.github.io/css/2016/12/20/sass-folder/","excerpt":"對於 Bootstrap 有一定了解後，我們即將要開始新增元件，不過在新增前我在分享一下 Sass 開發時的資料結構。 Sass 資料夾結構相信大家也聽說 SMACSS 等，不過我們我們已經加入了 Bootstrap ，在開發時也要思考如何結合不同的開發概念 (自己的元件與 Bootstrap 元件的結合)，並且還有往後的 Bootstrap 框架更新、專案的樣式更新等問題。","text":"對於 Bootstrap 有一定了解後，我們即將要開始新增元件，不過在新增前我在分享一下 Sass 開發時的資料結構。 Sass 資料夾結構相信大家也聽說 SMACSS 等，不過我們我們已經加入了 Bootstrap ，在開發時也要思考如何結合不同的開發概念 (自己的元件與 Bootstrap 元件的結合)，並且還有往後的 Bootstrap 框架更新、專案的樣式更新等問題。 以元件為主的開發觀念直觀的概念下，樣式通常會是用到哪寫到哪，這樣的開發下 CSS 的可用性較低，且開發到後期，前期的樣式都不太會再次使用(甚至不敢修改)，所以如果在開發時以元件作為出發點，就可以避免樣式可用性不高的問題。 架構參考：http://www.sitepoint.com/architecture-sass-project/ 這架構是我很喜歡的 Sass 開發架構，目前開發都是以此為基礎作延伸，但由於會搭配 Bootstrap 所以還是略有調整。 這架構也並非每次都全開，會依據專案需求來做調整(用到哪開到哪)，以 layout、pages 來說，開發都是以元件為基礎，不太會使用到 layout 及 pages，所以這兩個資料夾開啟的機率不高(這兩者通常會用在活動型的網頁)。 sass/ | |– base/ | |– _reset.scss # Reset/normalize | |– _typography.scss # Typography rules | ... # Etc… | |– components/ | |– _buttons.scss # Buttons | |– _carousel.scss # Carousel | |– _cover.scss # Cover | |– _dropdown.scss # Dropdown | |– _navigation.scss # Navigation | ... # Etc… | |– helpers/ | |– _variables.scss # Sass Variables | |– _functions.scss # Sass Functions | |– _mixins.scss # Sass Mixins | |– _helpers.scss # Class &amp; placeholders helpers | ... # Etc… | |– layout/ | |– _grid.scss # Grid system | |– _header.scss # Header | |– _footer.scss # Footer | |– _sidebar.scss # Sidebar | |– _forms.scss # Forms | ... # Etc… | |– pages/ | |– _home.scss # Home specific styles | |– _contact.scss # Contact specific styles | ... # Etc… | |– themes/ | |– _theme.scss # Default theme | |– _admin.scss # Admin theme | ... # Etc… | |– vendors/ | |– _jquery-ui.scss # jQuery UI | ... # Etc… 而我的開發流程就是依據以上再作為調整，開發的心法如下 all.scss 載入開發模組 (Bootstrap 或自行開發的模組庫)。 透過 helper 內的變數重新定義專案專屬的變數。 增加專案所需要的元件 (元件庫所缺乏的元件)。 增加區域性的元件如 header、footer (這部分的元件有可能再轉換成 components)。 依據頁面需求撰寫 Pages 的 css。 撰寫權限用的主題 如果有載入外部 Javascripts ，會將外部的Javascript 的 css 檔名改成 _xxxx.scss 丟到vendors。 結語大多情況下，我都是以 all.scss、/helpers/、/components/ 作為開場，如果是中小型的專案甚至從頭到尾的架構都是如此，大家也可以試試看用這個架構作為開發，可以從中思考到很多 CSS 架構管理的方法，以減少大型專案的樣式失控的問題。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 19 - Bootstrap 一次看懂元件的使用組合","slug":"bootstrap-component","date":"2016-12-18T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/19/bootstrap-component/","link":"","permalink":"https://wcc723.github.io/css/2016/12/19/bootstrap-component/","excerpt":"Bootstrap 的官方文件有完整的說明以及範例，就算是如此，還是會有許多朋友希望有快速入門的介紹，本篇就來介紹絕大部分 Bootstrap 元件的組合手法，搞懂一次後就能快速運用到其他模組上，甚至 Bootstrap 4 也是用相同的概念就能夠運用唷。","text":"Bootstrap 的官方文件有完整的說明以及範例，就算是如此，還是會有許多朋友希望有快速入門的介紹，本篇就來介紹絕大部分 Bootstrap 元件的組合手法，搞懂一次後就能快速運用到其他模組上，甚至 Bootstrap 4 也是用相同的概念就能夠運用唷。 元件組合Bootstrap 是標準的 OOCSS 概念下所設計的框架，也就如同樂高一樣可以反覆的堆疊，不過前提也是要在正確的卡楯上才能順利的接上。 以按鈕為例，一般來說會看到長長的一段說明怎麼使用，以及有哪些樣式、大小、狀態等等使用方法(除了按鈕以外，大部分的文件皆是如此)，如果是要熟悉 Bootstrap 一個一個邊看邊使用也需要很長的時間，這邊來介紹一下基本的運用： Bootstrap 在使用時，都會有個 &#123; 模組 &#125; 作為元件的架構，所以按鈕就會有 .btn 然而這段也會混用在其他的延伸樣式上，如配色、樣式皆是如此，不過狀態就不會帶上 .btn 囉，這段要多注意一下。 這邊我們在列出常見的按鈕表格模組，這樣是不是一目了然呢？ 模組 配色 樣式 狀態 btn btn-primary btn-sm active btn-default btn-lg disabled btn-success btn-xs btn-info btn-block … 這時候如果在製作一個流程表單，要呈現用戶尚未填寫完成，需要一個較大的下一步按鈕並且加上不能點選的按鈕，我們就可以依上表格挑選。 模組 配色 樣式 狀態 v btn btn-primary btn-sm active btn-default v btn-lg v disabled v btn-success btn-xs btn-info v btn-block … 組出來的結果會是 class=&quot;btn btn-success btn-lg disabled&quot; 這樣就能出現一個綠色，且不能點擊的大按鈕。 結構以上案例可以套用在絕大部分的 Bootstrap 元件上，另外在介紹一下 Bootstrap 的元件模組結構，絕大部分如 btn、nav、navbar、progress、pagination… 都是用模組名稱在前，後方使用 - 帶入各種延伸的配色、樣式，而第一個模組名稱其實就是 模組的結構 ，這個設計概念也是不斷的反覆出現結構與樣式分離，讓 Bootstrap 如此靈活的主要原因。 結語本篇的概念可以快速使用 Bootstrap 3 的模組，且對於往後的 Bootstrap 4 版本更是如此，這個概念會更加的明顯。當然我們在製作元件時如果能夠帶入這些觀念，也助於我們的元件開發。。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 18 - Bootstrap 元件分類概觀 (content, container)","slug":"bootstrap-component","date":"2016-12-17T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/18/bootstrap-component/","link":"","permalink":"https://wcc723.github.io/css/2016/12/18/bootstrap-component/","excerpt":"接下來我們依循著 OOCSS 與 Bootstrap 的設計模式繼續擴資、修改元件，不過在繼續下一個階段以前，我們先來了解一下 Bootstrap 的設計模式。","text":"接下來我們依循著 OOCSS 與 Bootstrap 的設計模式繼續擴資、修改元件，不過在繼續下一個階段以前，我們先來了解一下 Bootstrap 的設計模式。 Bootstrap 檔案結構還記得我們一開始所說到的 OOCSS 中結構與樣式、容器與內容這兩者的概念嗎？無論是哪一個版本，Bootstrap 所有樣式模組都是以元件為基礎作為設計，基於這個概念我們可以很快得了解 Bootstrap 3 的結構。 Bootstrap Sass 版本的檔案結構：https://github.com/twbs/bootstrap-sass/tree/master/assets/stylesheets/bootstrap /bootstrap |- /mixins/ |- _variables.scss |- _buttons.scss |- ....scss |- _components.scss |- _utilities.scss 主要資料夾如上，這邊略為介紹： /mixins/ 資料夾：樣式運算的函式庫，這部分可以先忽略他 _variables.scss：變數檔案，上一篇有介紹過，大部分的 Bootstrap 樣式變數都從這檔案設定。 _button.scss ~ _components.scss：剩下這層的檔案幾乎都是元件。 _utilities.scss：雖然說是元件，但又沒有完整的形體，像是 .clearfix 清除浮動就被歸在此類。 而這篇要介紹的就是廣大的 Components 類別，從官方的文件及 OOCSS 混合來看，又可以將它作為兩大類的區分，一則是易於修改樣式的 元件 (OOCSS 的內容)，另一則是包覆個許多子元件專用的 容器；這段很熟悉吧，我們在一開始所介紹到的 OOCSS 與此部分又開始產生連結。 容器作為外層的容器，主要就是要包覆著在其內的內容及元件，在網頁上的功能偏向於排版用途，通常不會有滑鼠事件互動，所以在設計上會遵循著以下概念： 不設定高度且具有彈性 寬度以百分比為主 可以有 theme (主題) 狀態不是必須的 元件 (內容) 元件的特色在於包含許多樣式、狀態，是使用者在觀看網頁時主要互動的物件；以按鈕來說，使用者會滑過按鈕、按下按鈕，並且按鈕可能會回饋訊息給用戶了解，所以除了不同樣式上，元件所傳達得狀態訊息狀態也相同重要： 有固定的外型 有許多的樣式 設計需要包含回饋狀態 容器型 元件型 grid-system form button-group buttons panel breadcrumbs 這設計在 Bootstrap 4 更為明顯，但本篇還是以 Bootstrap 作為介紹。 結語樣式雖然不是一定為哪種容器或是元件，但我們在設計一項新的物件時，一定要去思考他是傾向于哪種類型的物件，假設我們需要新增一個容器型物件，我們就要測試他有內容物及無內容物時的差異，甚至在大量的內容時是否會造成破版的問題。反之，設計元件型的樣式時則要思考在不同情境下使用的狀態，基本上就要補上 啟用中、無法使用 的狀態，這樣的設計會影響往後樣式在套用時的靈活性，與其在後續補上，不如在初期則做到一定的彈性。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 17 - Bootstrap 自定義樣式超簡單","slug":"bootstrap-custom","date":"2016-12-16T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/17/bootstrap-custom/","link":"","permalink":"https://wcc723.github.io/css/2016/12/17/bootstrap-custom/","excerpt":"在導入框架至網站時，還要考慮框架是否符合網站風格以及往後的維護性。Bootstrap 雖然設計上是要給開發者直接運用的，但實際上他所設計的彈性非常之高，也很適合做客製化，甚至 fork 作為公司團體的 Style Guide。","text":"在導入框架至網站時，還要考慮框架是否符合網站風格以及往後的維護性。Bootstrap 雖然設計上是要給開發者直接運用的，但實際上他所設計的彈性非常之高，也很適合做客製化，甚至 fork 作為公司團體的 Style Guide。 本篇範例：https://github.com/Wcc723/ironman-gulp-sass/tree/v.0.7.component 複製 VariablesBootstrap 所有設定都是放在 _variables.scss 這隻檔案下，但要學會怎麼修改其實沒有那麼困難，最簡單的方式就是將以下路徑的 _variables.scss 複製到專案目錄下的 ./source/scss，這邊我個人是更習慣放在 helpers 資料夾內，算是寫 Sass 的習慣。 bower_components/bootstrap-sass/assets/stylesheets/bootstrap/_variables.scss // 複製到 /source/scss 接下來我們將 ./source/scss/all.scss 打開後加入 @import &quot;helpers/variables&quot;; 再次執行 gulp ，如果沒有跳任何錯誤代表正確。 @import &quot;helpers/variables&quot;; @import &quot;bootstrap&quot;; 修改 變數打開 Bootstrap 變數稍微閱讀一下其實會發現非常好懂，以下色彩這段來說，分為灰色系列色與品牌系列色，而品牌系列色就是我們看到 Bootstrap 各個元件的主要配色。 //== Colors // //## Gray and brand colors for use across Bootstrap. $gray-base: #000 !default; $gray-darker: lighten($gray-base, 13.5%) !default; // #222 $gray-dark: lighten($gray-base, 20%) !default; // #333 $gray: lighten($gray-base, 33.5%) !default; // #555 $gray-light: lighten($gray-base, 46.7%) !default; // #777 $gray-lighter: lighten($gray-base, 93.5%) !default; // #eee $brand-primary: darken(#428bca, 6.5%) !default; // #337ab7 $brand-success: #5cb85c !default; $brand-info: #5bc0de !default; $brand-warning: #f0ad4e !default; $brand-danger: #d9534f !default; 然後每一個變數的後方都會接上一個 !default 在後方做為預設，所以在修改變數時需要同時將 !default 移除，請參考以下範例： $brand-primary: #0275d8; //darken(#428bca, 6.5%) !default; // #337ab7 $brand-success: #5cb85c !default; $brand-info: #5bc0de !default; 加入一個新色彩 #0275d8 並將原本色彩註解在後方，這時候在執行 gulp 就能看到結果。 原色彩 經調整，類似於 Bootstrap 4 的色彩 像這樣的配色就比較接近於 Bootstrap 4 的色彩，用這個方法就可以輕易地修改 Bootstrap 中各個元件中的樣式變數，修改就是這麼樣的容易，只要修改一些變數就能完成。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 16 - 將 Bootstrap 導入自動化流程","slug":"bootstrap-include","date":"2016-12-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/16/bootstrap-include/","link":"","permalink":"https://wcc723.github.io/css/2016/12/16/bootstrap-include/","excerpt":"先前的流程我們將 Gulp 的基礎流程已經建立起來了，現在我們要將 Bootstrap 導入自動化流程，讓接下來的客製化更為容易。","text":"先前的流程我們將 Gulp 的基礎流程已經建立起來了，現在我們要將 Bootstrap 導入自動化流程，讓接下來的客製化更為容易。 Bower本範例是使用大家所習慣的 Bootstrap 3，如果想用 4 的朋友可以自行修改，手法是幾乎一致的。 範例：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.6.bootstrap Bower 是前端的套件管理工具，也有許多開發者會使用 NPM 來一起管理，但我個人除了使用 Webpack 以外還是習慣用 Bower 在管理前端套件。 Bower: https://bower.io/ 使用 Bower 以前要先安裝 Bower 的工具，而它分為兩個部分，全域的 Bower 指令與專案的 bower.json： 首先，先在電腦內安裝 bower (需使用先前的 npm 環境)：npm install -g bower 接下來打開本篇範例，本篇範例已經準備好了 bower.json，這時候只要下 bower install 就能夠開始安裝 bower.json 內的套件檔案。 bower install 接下來專案內會新增對應的檔案，Bootstrap 的套件需要使用到 jQuery ，此時也會一並出現。 Gulp這時候已經將 Bootstrap 下載到本地端的資料夾，當然我們也可以用 HTML 直接 &lt;LINK&gt; CSS，不過這樣就無法自定義樣式，先打開 gulpfile.js 看看修改了什麼吧 var path = &#123; source: &#x27;./source/&#x27;, public: &#x27;./public/&#x27;, bower: &#x27;./bower_components/&#x27; // 新增 Bower 的路徑 &#125; gulp.task(&#x27;sass&#x27;, function () &#123; var processors = [ autoprefixer(&#123;browsers: [&#x27;last 5 version&#x27;]&#125;) ]; return gulp.src(path.source + &#x27;scss/**/*.scss&#x27;) .pipe(plumber()) .pipe(sass( &#123;outputStyle: &#x27;expanded&#x27;, includePaths: [path.bower + &#x27;bootstrap-sass/assets/stylesheets&#x27;]&#125; // 新增 includePaths 將 Bootstrap 載入 ).on(&#x27;error&#x27;, sass.logError)) .pipe(postcss(processors)) .pipe(gulp.dest(path.public + &#x27;stylesheets&#x27;)); &#125;); includePaths 是 Sass 的功能，他可以載入其他路徑的 .sass 作為擴充載入，這部分就是將 Bower 中的 Bootstrap 載入。 完成打開 all.scss 做以下的調整，直接用 @import &quot;bootstrap&quot;; 就可以將 Bootstrap 載入。 $primary-color: blue; body &#123; color: $primary-color; &#125; @import &quot;bootstrap&quot;; 最後的結果如上，一開始的 color: blue 是我們自己定義的，而後方開始就是完整的 Bootstrap，接下來我們再來了解如何去調整 Bootstrap 的樣式。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 15 - 為什麼 Boostrap","slug":"gulp-bootstrap","date":"2016-12-14T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/15/gulp-bootstrap/","link":"","permalink":"https://wcc723.github.io/css/2016/12/15/gulp-bootstrap/","excerpt":"Bootstrap 是目前主流的 CSS 框架，先前也有提到，在起初我是很不喜歡 Bootstrap 的框架，認為他搶走我大部分的工作且缺乏特色，但在研究後會發現他並非我想的那麼缺乏特色，完全看開發者的使用及熟練度。 我們也可以看到網路上有相當多的 HTML Template 都做的非常美，但其實底層都是 Bootstrap，有些已經調整得相當不像是原有的 Bootstrap 樣式。所以在熟練的情況下，Bootstrap 也是能做出超乎水平的網頁版型。","text":"Bootstrap 是目前主流的 CSS 框架，先前也有提到，在起初我是很不喜歡 Bootstrap 的框架，認為他搶走我大部分的工作且缺乏特色，但在研究後會發現他並非我想的那麼缺乏特色，完全看開發者的使用及熟練度。 我們也可以看到網路上有相當多的 HTML Template 都做的非常美，但其實底層都是 Bootstrap，有些已經調整得相當不像是原有的 Bootstrap 樣式。所以在熟練的情況下，Bootstrap 也是能做出超乎水平的網頁版型。 Bootstrap 哪裡好用通常來說，後端會比前端開發者更喜歡 Bootstrap，因為以下徵狀會是想用 Bootstrap 的起因： 覺得 float 超難搞定 希望不要花那麼多時間在美編上 不想花太多時間學習主要技術以外的內容 RWD 真心難搞 過去的經驗… 使用冷門框架找不到相依套件 自幹框架真心不如 Bootstrap (泣) 對於熟悉 CSS 的網頁設計師來說，到會覺得自己就能解決這樣的狀況，所以 Bootstrap 在起初就不認為那麼的必要，但對於大型網站、系統來說，自己寫 CSS 也會產生幾個問題： 持續性的維護：架構是否良好將影響 CSS 是否好維護 套件的使用：再引用其他第三方套件時，是否能夠依據需求調整 CSS 符合風格 (很多套件相容於 Bootstrap)。 對於 CSS 的熟練度 Bootstrap 令人喜愛的地方Bootstrap 不能算是具有特色的前端框架，但也就和 jQuery 一樣好上手，在框架裡沒有太多浮誇的效果，大多是基於 HTML 規範去做樣式的調整。也因為如此，大多略有經驗的開發者僅需看過文件就能學會如何使用。解決問題如下： 不需要重頭開始寫 降低學習曲線 開源框架，Bug 少 延伸插件多 快速自定義 本篇系列作要介紹什麼Bootstrap 本身在使用上難度並不高，就基於元件如何使用官方文件上介紹以非常完整，本篇會開始會介紹 Bootstrap 的進階使用及設計模式去介紹，讓 Bootstrap 可以依據專案需求去做調整及延伸(Bootstrap 甚至能作為大型開發專案的基底)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 14 - Gulp - Webserver","slug":"gulp-webserver","date":"2016-12-13T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/14/gulp-webserver/","link":"","permalink":"https://wcc723.github.io/css/2016/12/14/gulp-webserver/","excerpt":"Gulp 很適合搭配任何其他的前後端結構，就先前介紹的幾個章節，只要略為修改輸入及輸出的路徑即可；除了搭配其他後端結構外，Gulp 也有適合直接開發的方法，本章會在介紹 Gulp Webserver，這樣就能夠直接在 Gulp 中開啟 Webserver。","text":"Gulp 很適合搭配任何其他的前後端結構，就先前介紹的幾個章節，只要略為修改輸入及輸出的路徑即可；除了搭配其他後端結構外，Gulp 也有適合直接開發的方法，本章會在介紹 Gulp Webserver，這樣就能夠直接在 Gulp 中開啟 Webserver。 gulp webserver範例程式碼：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.4.icon-fonts Gulp webserver 能夠在 gulp 運行的期間開啟 webserver，並且包含著 Livereload 的功能，只要修改專案中的資料夾檔案，就能夠自動的更新瀏覽器上的畫面，讓開發更迅速。 package.json: 僅有新增一個 gulp-webserver。 &quot;dependencies&quot;: &#123; &quot;async&quot;: &quot;^2.1.4&quot;, &quot;autoprefixer&quot;: &quot;^6.5.3&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-consolidate&quot;: &quot;^0.2.0&quot;, &quot;gulp-iconfont&quot;: &quot;^8.0.1&quot;, &quot;gulp-plumber&quot;: &quot;^1.1.0&quot;, &quot;gulp-postcss&quot;: &quot;^6.2.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-webserver&quot;: &quot;^0.9.1&quot; &#125; gulpfile.js 可以依據以下的方法設定。 var webserver = require(&#x27;gulp-webserver&#x27;); // 載入 webserver // webserver gulp.task(&#x27;webserver&#x27;, function() &#123; setTimeout(function()&#123; gulp.src(path.public) // 預設開啟路徑 .pipe(webserver(&#123; // 啟動 webserver livereload: true, // Livereload 的功能 open: false, // 是否自動開啟 瀏覽器 host: &#x27;0.0.0.0&#x27;, // 如果使用 0.0.0.0 的 ip，還會另外開啟 wifi 等對外網路 port: 10000, // 開放通訊埠 &#125;)); &#125;, 1000); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;others&#x27;, &#x27;sass&#x27;, &#x27;iconfonts&#x27;, &#x27;watch&#x27;, &#x27;webserver&#x27;]); 設定完成後，一樣輸入 gulp 就會依序執行先前所設定的內容，而 Webserver 放在做後是確保所有流程完成後再開啟 Webserver ，使第一次執行專案的開發者也能夠執行。 結語Gulp 介紹的目前為止，其實已經掌握大部分 Gulp 所使用的手法，接下來僅需要調整到合適的搭配環境即可；如果在開發上遇到 Gulp 不足的地方，可以到 NPM 的網站上透過 gulp 作為關鍵字，搜尋是否有其他套件可以使用。 到目前所介紹的內容，也都只要略作修改，觀念都可以運用在任何的套件上，如果遇到任何問題，也歡迎來詢問我喔～。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 13 - Gulp - 在本地端製作 Icon Fonts","slug":"gulp-dev-env","date":"2016-12-12T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/13/gulp-dev-env/","link":"","permalink":"https://wcc723.github.io/css/2016/12/13/gulp-dev-env/","excerpt":"網頁設計都會需要大量的小 icon，現在的 icon 都傾向使用 web fonts 來處理，因為 web font 所製作的 icon 有以下的好處： 載入容易，HTML 只要載入一隻 CSS 就搞定 套用容易，只要透過 Class 就能套用 可自由調整大小、色彩","text":"網頁設計都會需要大量的小 icon，現在的 icon 都傾向使用 web fonts 來處理，因為 web font 所製作的 icon 有以下的好處： 載入容易，HTML 只要載入一隻 CSS 就搞定 套用容易，只要透過 Class 就能套用 可自由調整大小、色彩 雖然只能使用單色，但在開發的便利性上還是有不少人選擇 icon font，目前大家所選擇主流 icon fonts 有以下： FontAwesome：http://fontawesome.io/ 相當完整的 web font icons 可滿足大多的開發需求 我還參與 Font Awesome 的募資 &gt;O&lt;：https://www.kickstarter.com/projects/232193852/font-awesome-5?ref=1oakzw IcoMoon：https://icomoon.io/ 可以自選 icons 可以自定義 icons 付費可以使用它們的 CDN Google Material Icon：https://material.io/icons/ 很潮，Google 出的 icon 可以被搜尋、選取 除了以上幾種不同選擇外，大家應該也會想知道 “如果想自己做呢!?”，這次就來介紹怎麼用 Gulp 來自定自己的 icon fonts。 gulp iconfont這一個套件會將 .svg 的檔案轉換成字體，接下來在轉換成 CSS 供開發者使用。 範例程式碼：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.4.icon-fonts 使用套件：https://www.npmjs.com/package/gulp-iconfont 經過這幾次的練習，相信大家應該了解 gulp 的開發順序，我們會先打開 package.json 將所需要的套件載入，這次新增的套件有 async、gulp-consolidate、gulp-iconfont。 &quot;dependencies&quot;: &#123; &quot;async&quot;: &quot;^2.1.4&quot;, &quot;autoprefixer&quot;: &quot;^6.5.3&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-consolidate&quot;: &quot;^0.2.0&quot;, &quot;gulp-iconfont&quot;: &quot;^8.0.1&quot;, &quot;gulp-plumber&quot;: &quot;^1.1.0&quot;, &quot;gulp-postcss&quot;: &quot;^6.2.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot; &#125; 接下來打開 gulpfile.js 加入以下的 Task。 // icon fonts gulp.task(&#x27;iconfonts&#x27;, function(done)&#123; var iconStream = gulp.src([path.source + &#x27;icons/*.svg&#x27;]) // 載入 svg .pipe(iconfont(&#123; fontName: &#x27;icon&#x27; &#125;)); // 定義 fontName async.parallel([ function handleGlyphs (cb) &#123; iconStream.on(&#x27;glyphs&#x27;, function(glyphs, options) &#123; gulp.src(path.source + &#x27;css_template/iconfonts.css&#x27;) // 取用要輸出的 CSS 樣板 .pipe(consolidate(&#x27;lodash&#x27;, &#123; glyphs: glyphs, fontName: &#x27;icon&#x27;, fontPath: &#x27;../fonts/&#x27;, // CSS 對應的字體路徑 className: &#x27;all-my-class&#x27; // CSS Class 的前輟詞 &#125;)) .pipe(gulp.dest(path.public + &#x27;stylesheets&#x27;)) // CSS 輸出資料夾 .on(&#x27;finish&#x27;, cb); &#125;); &#125;, function handleFonts (cb) &#123; iconStream .pipe(gulp.dest(path.public + &#x27;fonts/&#x27;)) // 字體輸出資料夾 .on(&#x27;finish&#x27;, cb); &#125; ], done); &#125;); 除了 SVG 以外，在 gulpfile.js 還有列出一個 css template，這是用來產出 iconfont 所需的 CSS 檔案樣板，在我所提供的範例中已包含 template 的樣板，大家可以直接參考。 |- /source # 專案資料夾 (sass 位置) |- css_template # webfont 需要的 css 樣板 |- icons # .svg 原始檔位置 |- /mode_modules # node.js 套件資料夾 |- /public # 專案匯出的資料夾 |- .gitignore |- gulpfile.js # gulp 腳本檔案 |- package.json # 套件管理 json 接下來執行 gulp iconfonts public 就會產生一個字體檔以及 CSS 檔案，接下來我們在 HTML 中載入 CSS 檔案，就可以開始使用 icon font 囉～。 結語在使用這功能時，要思考團隊中是不是有專門的設計師能繪製 icon ，以及 icon 不足時能不能有專人提供，避免用了這個功能，卻無法做良好的維護。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 12 - Gulp - 定義預設開發環境","slug":"gulp-dev-env","date":"2016-12-11T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/12/gulp-dev-env/","link":"","permalink":"https://wcc723.github.io/css/2016/12/12/gulp-dev-env/","excerpt":"今天的進度來做個小調整，讓大家在使用 Gulp 時就能相容於目前的環境，目前使用的主要套件有：gulp-sass、gulp-postcss，這次調整後會有一個主要的前端專案資料夾，可以配合各個後端語言做調整，大家也可用相同的概念加入習慣的開發環境。","text":"今天的進度來做個小調整，讓大家在使用 Gulp 時就能相容於目前的環境，目前使用的主要套件有：gulp-sass、gulp-postcss，這次調整後會有一個主要的前端專案資料夾，可以配合各個後端語言做調整，大家也可用相同的概念加入習慣的開發環境。 定義輸入及輸出範例程式碼：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.3.gulp-default 為了優化前端的效能會使用工具再將前端的內容編譯一次，如壓縮合併 Javascript、CSS；這時候會有一個原始碼以及壓縮後的程式碼，主要作業都是在原始碼，壓縮後的程式碼是用來部署使用。 在 gulpfile.js 內可以準備以下的變數： var path = &#123; source: &#x27;./source/&#x27;, // 原始碼 public: &#x27;./public/&#x27; // 輸出位置 &#125; 這些變數可以依序套用在先前準備的 Task 上，開發時無論是配合什麼後端語言，只要調整原始碼、輸出位置就能夠配合各種語言。 gulp.task(&#x27;sass&#x27;, function () &#123; return gulp.src(path.source + &#x27;scss/**/*.scss&#x27;) // 輸入點 /* Task 的其他工作 */ .pipe(gulp.dest(path.public + &#x27;stylesheets&#x27;)); // 輸出點 &#125;); 複製主要工作項以外的檔案原始碼之中有許多檔案是不需要編譯的，但為了方便整理，我們可以將全部原始碼先放在 source資料夾，再透過 gulp 一起輸出到另一個資料夾。 透過 ! 可以避掉特定的檔案，所以我們可以匯入全部檔案後，再排除不需要複製檔案，以下程式碼就可以直接完成以下流程。 // 其它不編譯的物件 var objs = [&#x27;./source/**/**.*&#x27;]; var others = [ &#x27;**/*.scss&#x27;, &#x27;**/*.sass&#x27;,]; // 不複製的檔案 for (var i = 0; i &lt; others.length; i++) &#123; objs.push(&#x27;!&#x27; + path.source + others[i]); &#125; gulp.task(&#x27;others&#x27;, function()&#123; return gulp.src(objs) .pipe(plumber()) .pipe(gulp.dest(path.public)); &#125;); 這個步驟會新增一個 Task，所以我們需要使用 gulp others 來執行這段流程，此時我們也有幾個 Task，這時可以加入一個整合性的 Task 將所有的任務串接再一起。 default 是預設 gulp 會執行的 Task，後方的陣列內在加入要一起執行的 Task 即可。 gulp.task(&#x27;default&#x27;, [&#x27;others&#x27;, &#x27;sass&#x27;, &#x27;watch&#x27;]); 完成到這個步驟，只要執行 gulp 就會自動將以上流程一次完成，並且監聽相關的檔案是否有異動。 到目前為止，基本的 Gulp 運用已經足夠應付 CSS 在前端上的需求，在後面的章節會介紹更進階的 Gulp 套件運用。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 11 - Gulp - 透過 PostCSS 加入 CSS Prefix","slug":"gulp-postcss","date":"2016-12-10T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/11/gulp-postcss/","link":"","permalink":"https://wcc723.github.io/css/2016/12/11/gulp-postcss/","excerpt":"說到 CSS prefix 相信大家都不是很清楚當下主流版本的 prefix 有哪些是必要？又有哪些是不必要的？ 以往都是使用 Sass 的 Compass 來加入 prefix，這種增加方式就是無差別的加入，但其實現在的 CSS 有 9 成以上的 prefix 都沒有加入的必要，相信在短期內除了測試的 CSS 以外，都不需要再加入 prefix。","text":"說到 CSS prefix 相信大家都不是很清楚當下主流版本的 prefix 有哪些是必要？又有哪些是不必要的？ 以往都是使用 Sass 的 Compass 來加入 prefix，這種增加方式就是無差別的加入，但其實現在的 CSS 有 9 成以上的 prefix 都沒有加入的必要，相信在短期內除了測試的 CSS 以外，都不需要再加入 prefix。 現在寫入 prefix 以後還要移除也是個大工程，這時候推薦使用 PostCSS 的 autoPrefixer。PostCSS 類似 Sass，但是他是直接編譯 .css 檔案，另外他的套件都是用插件的方式載入，並不是像 Sass 已經有固定的寫法。這邊特別推薦他的 autoPrefixer 套件，使用上也非常容易，對於往後的維護也是無痛更新。 PostCSS範例：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.2.postcss 延續前一篇的進度，這篇加入兩個新套件 gulp-postcss、autoprefixer，在 package.json 的檔案內可以找到這段： &quot;dependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^6.5.3&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-postcss&quot;: &quot;^6.2.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot; &#125; 接下來修改 gulpfile.js 內的 sass task，直接將 PostCSS 加到原有的 Sass 流程上就能運行了。 var autoprefixer = require(&#x27;autoprefixer&#x27;); var postcss = require(&#x27;gulp-postcss&#x27;); gulp.task(&#x27;sass&#x27;, function () &#123; var processors = [ // 定義 postCSS 所需要的元件 autoprefixer(&#123;browsers: [&#x27;last 5 version&#x27;]&#125;) // 使用 autoprefixer，這邊定義最新的五個版本瀏覽器 ]; return gulp.src(&#x27;./source/scss/**/*.scss&#x27;) .pipe(sass( &#123;outputStyle: &#x27;expanded&#x27;&#125; ).on(&#x27;error&#x27;, sass.logError)) .pipe(postcss(processors)) // 將 PostCSS 插入流程 .pipe(gulp.dest(&#x27;./public/stylesheets&#x27;)); &#125;); autoPrefixer 的瀏覽器版本可以自行定義，文件可參考：https://github.com/postcss/autoprefixer 這個範例是選擇 &#39;last 5 version&#39; (最新的五個版本瀏覽器)，如果是調整 &#39;last 2 version&#39; 那需要加入 prefix 的還真的沒幾個，大家也可以修改看看這段與編譯結果的差異。 編譯這時候的開發流程不會有太多的改變，一樣是在 all.scss。 // 編譯前 $primary-color: blue; body &#123; color: $primary-color; filter: blur(5px); &#125; 編譯後 (含 PostCSS)。 body &#123; color: blue; -webkit-filter: blur(5px); filter: blur(5px); &#125; 原有的 .scss 我略作些微調整，補上了 filter，這時候執行 gulp sass 就能看到 filter 加上了 -webkit- 的 prefix，如果說你看到的結果沒有加入 prefix，想必這篇文章年代已久遠，如果你堅持要使用 autoprefixer，可以參考文件，將 autoprefixer 的版本拉到 ie 7 那個年代 @_@。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 10 - Gulp 與 Sass 開發環境","slug":"gulp-init","date":"2016-12-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/10/gulp-init/","link":"","permalink":"https://wcc723.github.io/css/2016/12/10/gulp-init/","excerpt":"Gulp 是我目前最使用的自動化工具，在先前一篇也有介紹有哪些自動化工具，這篇開始會介紹 Gulp 自動化工具如何使用、有哪些推薦的工具以及一些經驗上的分享。而本次系列文都是著重在 CSS 的開發，所以不會介紹 Javascript 的自動化工具。","text":"Gulp 是我目前最使用的自動化工具，在先前一篇也有介紹有哪些自動化工具，這篇開始會介紹 Gulp 自動化工具如何使用、有哪些推薦的工具以及一些經驗上的分享。而本次系列文都是著重在 CSS 的開發，所以不會介紹 Javascript 的自動化工具。 Gulp 可以做什麼？Gulp 是一個前端任務管理工具，它可以做到如Fire.app、Prepros、Grunt等等所能做的事情，簡單內容如下： 編譯 SASS、Coffeescript 壓縮 .CSS, .JS, 甚至圖檔 web server with Livereload 享受自己動手做Task工具的快感 others.. 雖然很多工具，都能做到類似的功能，但是如果需求不足的時候，就要開另一個工具來幫忙；另外許多專案已經在執行中或者是老專案，有些工具就會顯得限制太多，那麼就可以用gulp客製化屬於該專案使用的工具。 快速建置在開始使用 Gulp 前，需要先安裝 Node.js，Node.js 是一個讓 Javascript 運行在服務端的開發平台。另外還有 npm，是由 Node.js 官方提供的第三方管理工具，並且是一種在 Node.js 應用程式中建立、分享、重複使用模組，而 npm 在目前的版本，都會隨著 Node.js 的安裝同時安裝好 npm。 簡而言之，我們使用 Node.js 的服務以及透過 npm 管理工具。 這一部分網路上有相當多的文章，本篇就不再贅述。 透過範例來了解如何運行這邊我準備了一個很簡單的 Gulp Sass 案例： https://github.com/Wcc723/ironman-gulp-sass/tree/v0.1.sass 下載後，在 Terminal 打開這個專案，並輸入以下指令： npm install gulp -g npm install 這就是透過 npm 來安裝相關所需的套件，npm install gulp -g 會在全域環境下安裝 gulp，npm install 則是會安裝專案內的 package.json 所列出的需要元件。 package json 如下，這範例中只會安裝 gulp、gulp-sass。 &#123; &quot;name&quot;: &quot;gulp-sass&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo \\&quot;Error: no test specified\\&quot; &amp;&amp; exit 1&quot; &#125;, &quot;author&quot;: &quot;&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;dependencies&quot;: &#123; &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot; &#125; &#125; 接下來在執行： gulp sass 執行後就會將 source/scss/all.scss 編譯到 public/stylesheets/all.css ，此時整個範例流程也就結束。 解說在一開始下載時檔案結構如下： |- /source/scss # 專案資料夾 (sass 位置) |- .gitignore |- gulpfile.js # gulp 腳本檔案 |- package.json # 套件管理 json 執行完以上步驟後，資料夾結構會如下，node_modules 是運行 gulp 的套件資料工具資料夾，public 就是前端匯出的專案資料夾，在這個範例中我們可以將 public 指定任何的資料夾名稱與後端結構配合。 |- /source/scss # 專案資料夾 (sass 位置) |- /mode_modules # node.js 套件資料夾 |- /public # 專案匯出的資料夾 |- .gitignore |- gulpfile.js # gulp 腳本檔案 |- package.json # 套件管理 json gulpfile.js 是整個 gulp 的核心，相當於一齣戲的劇本，開發者可以在腳本中定義自動化的運行流程，這邊用相當簡單的 gulp-sass 來介紹怎麼撰寫一份 gulpfile。 var gulp = require(&#x27;gulp&#x27;); // 將 node_modules 的檔案載入 var sass = require(&#x27;gulp-sass&#x27;); gulp.task(&#x27;sass&#x27;, function () &#123; // 定義 sass 的任務名稱 return gulp.src(&#x27;./source/scss/**/*.scss&#x27;) // sass 的來源資料夾 .pipe(sass( // 編譯 sass &#123;outputStyle: &#x27;expanded&#x27;&#125; // sass 的輸出格式 ).on(&#x27;error&#x27;, sass.logError)) .pipe(gulp.dest(&#x27;./public/stylesheets&#x27;)); // sass 編譯完成後的匯出資料夾 &#125;); gulp.task(&#x27;sass:watch&#x27;, function () &#123; gulp.watch(&#x27;./source/scss/**/*.scss&#x27;, [&#x27;sass&#x27;]); // 監控資料夾，當有變化時執行 &#x27;sass&#x27; 任務 &#125;); 範例中的 watch 資料夾有誤，請稍做調整如本文 所以開發者可以定義相當多的 Task，就以本範例中還有一個監控的任務可以使用 gulp sass:watch，如果不想要一直重啟 gulp 來編譯 sass 可以使用此指令。 結語接下來連續幾篇都會介紹 gulp 以及與 CSS 相關的套件給大家參考。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 9 - CSS 實戰心法 搶到決定權，開發環境自己來","slug":"css-dev","date":"2016-12-08T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/09/css-dev/","link":"","permalink":"https://wcc723.github.io/css/2016/12/09/css-dev/","excerpt":"前端工程師一般來說只要搞定 HTML、CSS、Javascript 就可以了，所以後端的環境上不用太在意，但在這幾年的體悟下，這是一個不負責任的想法。 我用過的前端自動化開發環境有： Fireapp：這用了有兩年之久，算是一個超級入門 GUI 自動化工具，但在 compass 不維護以後 Fireapp 也不再維護了。 Prepros：當時 GUI 的自動化工具另一個選擇，到現在還有持續在更新，但一直有些小問題所以沒有想用在專案上，但對於入門來說是個不錯的選擇 Middleman：為了與 Ruby on Rails 專案做整合，算是不錯的 Command line 工具，也是使用很長的一段時間，現在懶得自己開環境還是會使用。 *gulp：相當推薦的自動化工具，易學且可以與任何環境結合，缺點是肥了點。 *webpack：很潮的自動化工具，但與 gulp 觀念差異很大，適合製作 SPA(sigle page application) 的網站。","text":"前端工程師一般來說只要搞定 HTML、CSS、Javascript 就可以了，所以後端的環境上不用太在意，但在這幾年的體悟下，這是一個不負責任的想法。 我用過的前端自動化開發環境有： Fireapp：這用了有兩年之久，算是一個超級入門 GUI 自動化工具，但在 compass 不維護以後 Fireapp 也不再維護了。 Prepros：當時 GUI 的自動化工具另一個選擇，到現在還有持續在更新，但一直有些小問題所以沒有想用在專案上，但對於入門來說是個不錯的選擇 Middleman：為了與 Ruby on Rails 專案做整合，算是不錯的 Command line 工具，也是使用很長的一段時間，現在懶得自己開環境還是會使用。 *gulp：相當推薦的自動化工具，易學且可以與任何環境結合，缺點是肥了點。 *webpack：很潮的自動化工具，但與 gulp 觀念差異很大，適合製作 SPA(sigle page application) 的網站。 以下我再將開發流程分為以下三種： 後端工程師人肉整合流程：前端工程師射後不理，將 Code 交給後端工程師處理。 前後端整合的開發流程：前後端共用相同的開發環境。 前後端分離：前後端作業完全分離，後端負責資料庫、API，前端負責頁面結構、API 介接。 後端工程師人肉整合流程這是很常見的流程，網頁設計師、前端工程師將圖片切完後，交給後端的工程師做整合，後端也許是 PHP、.net、node.js。這樣的缺點在於如果版型不符合後端的需求，後端會直接用 style 的方式直接調整版型，且如果前端發現了問題，也不好修正。 前後端整合的開發流程有些框架如 Ruby on Rails，就是適合做前後端整合的框架，本身就具有編譯 Sass 的能力，並且有大量的套件可以輔助前端工作。除了 Rails 以外，Gulp 或 Grunt 這樣的自動化工具可以讓前端與後端整合在一起。 這樣的開發流程，前後端的合作會更為密切，大多前端在接觸後也會更深入的了解後端架構，甚至能夠依據需求略為調整資料結構。 前後端分離自從 Ajax 越來越普遍的情況下，前後端分離漸為許多公司開發的架構，同一個專案會在拆分成前端與後端，這樣完全的分離可以讓職責分得更清楚，但也同時需要更重視 “溝通”。 結語雖然 CSS 與後端看似關係不大，如果對於開發環境有一定掌控度，也更能掌握元件的細節。最常見的就是設計的結構與資料結構不合需要調整，前端如果對於開發環境掌控度不足，整個在修改所花的時間成本就會相當大。 經常會有前後端或者設計師抱怨其他不同領域的開發者，很多時候在於不夠了解對方，也許會思考 “我時間都不夠了” ，為什麼還要花時間去學對方的領域呢？ 換個層面思考，如果了解對方的領域(對方領域的基礎運作即可)，是不是能夠減少更多的溝通成本，進而節省時間。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 8 - CSS 框架架構參考 Bootstrap","slug":"framework-bootstrap","date":"2016-12-07T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/08/framework-bootstrap/","link":"","permalink":"https://wcc723.github.io/css/2016/12/08/framework-bootstrap/","excerpt":"Bootstrap 是目前我最喜歡的 CSS 框架。 雖說如此，我以往可是很討厭 Bootstrap 的，身為一名設計師希望能夠有更多自己發揮的空間，所以早期一直在避免使用 Bootstrap 這樣的框架，總認為這些框架做出來的設計都很像，還因此自己寫一個 CSS 框架。 經歷過了一段自幹的歷程，從新再研究了 Bootstrap 的框架才發現自己很多觀念上的不足如： 過度的 sass @extend (良好的 CSS 架構，不太需要使用 @extend) OOCSS 觀念不夠強 (結構與樣式並未良好的分離) 框架可用套件不足 (自幹的怎會有套件 @_@) Bug 發現慢 (多人開發的框架 bug 自然少)","text":"Bootstrap 是目前我最喜歡的 CSS 框架。 雖說如此，我以往可是很討厭 Bootstrap 的，身為一名設計師希望能夠有更多自己發揮的空間，所以早期一直在避免使用 Bootstrap 這樣的框架，總認為這些框架做出來的設計都很像，還因此自己寫一個 CSS 框架。 經歷過了一段自幹的歷程，從新再研究了 Bootstrap 的框架才發現自己很多觀念上的不足如： 過度的 sass @extend (良好的 CSS 架構，不太需要使用 @extend) OOCSS 觀念不夠強 (結構與樣式並未良好的分離) 框架可用套件不足 (自幹的怎會有套件 @_@) Bug 發現慢 (多人開發的框架 bug 自然少) Sass 架構簡介Bootstrap 第三版是使用 LESS，到了第四版改用 SASS，但不管用哪一個開發工具，其實整個架構的差異都不大，只要了解其中一種觀念，就可以套用在每個版本上。 Bootstrap 的架構其實並不複雜，整個核心都圍繞在 “模組” 上，我們可以視 Bootstrap 每一個部件都是一個模組： |- bootstrap.scss # 主檔案，負責載入所有模組 |- _variables.scss # 變數，如果要修改整體樣式可從這裡調整 |- _buttons.scss # 從這以下都是模組 |- _tables.scss |- _alert.scss |- _utilities.scss |- ... |- /mixins # 樣式運算函式庫 |- _buttons.scss |- _forms.scss |- _grid.scss |- ... bootstrap.scss這隻檔案相當的單純，主要是載入全部的樣式表，除了這隻以外還有以下幾個分支： bootstrap-flex.scssbootstrap-grid.scssbootstrap-reboot.scss 這些的功能都是一樣的，只是差異在載入的檔案不同，如果第一次想了解 Bootstrap 的同學，可以先看看這隻檔案 “依序” 載入了哪些的檔案。 _variables.scss在 scss 中，前方帶有下底線的代表該檔案不會被輸出(所以上一段落的 bootstrap.scss 會被轉成 css)，Bootstrap 主要的樣式也都是在這隻檔案做設定。 以色彩來說，檔案裡面可以看到以下的設定，開發者可以修改以下變數，在編譯時自然會套用到所有的模組上。 $brand-primary: #0275d8 !default; $brand-success: #5cb85c !default; $brand-info: #5bc0de !default; $brand-warning: #f0ad4e !default; $brand-danger: #d9534f !default; $brand-inverse: $gray-dark !default; _buttons.scss, _tables.scss, _utilities.scss …這個部分就是整個 Bootstrap 的結構重點了，除了以上的 bootstrap.scss、_variables.scss 及稍後提到的 _mixins 資料夾，其他都是屬於 “模組”。 Bootstrap 將模組檔案拆分得相當細，官方的文件也是依據這個架構所呈現： Bootstrap 的說明文件 每個元件拆離以後有以下優點： 元件各自獨立，互不影響 (僅少部分有相依關係 如：buttons, button-group) 易讀性高：開發者可以輕易地找出元件檔案，並且在開發新元件不影響其他元件 開發者可以依據 bootstrap.scss 自行決定載入哪些元件 元件之間影響變小了，全部是由 bootstrap.scss 串接，由 _variables.scss 決定樣式。 元件的設計除了有 Pure CSS 的結構與樣式分離外，Bootstrap 在容器與內容分離也是做得相當徹底，加上 Bootstrap 有大量的元件，彼此之間的組合變化也相當多元，就 Bootstrap 現有的架構下其實我們可以將元件分為兩大類型： 一則是在外的容器，另外則是在內的元件(內容)；像是 grid-system 就是屬於在外的容器，在外側的容器並不會影響內部的元件樣式，按鈕來說他就是屬於在內部的元件，他可以依附在任何的容器內。 以下是簡單的 Bootstrap 容器與元件分類： Bootstrap 就如同前文 OOCSS 所介紹的包含結構與樣式分離、容器與內容分離，在這架構下 Bootstrap 的可用性就會相當高，而且在後續的新增元件也會更為容易。 說句坦白話，拆解 Bootstrap 讓我更能了解 OOCSS。 _mixins 資料夾_mixins 資料夾是元件的運算函式，在大部分的情況下不需要做調整，只要修改 _variables.scss，就能運算出新的樣式表，本篇就不細說了。 結語一般來說閱讀 Bootstrap 的結構方法如下： 找出 bootstrap.scss (了解整體架構) 找出變數檔案 _variables.scss 尋找、閱讀 各元件 了解整體架構後，如果需要自行修改或自幹(?)也會相對容易很多。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 7 - CSS 框架架構參考 PURE CSS","slug":"framework-pure-css","date":"2016-12-06T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/07/framework-pure-css/","link":"","permalink":"https://wcc723.github.io/css/2016/12/07/framework-pure-css/","excerpt":"在瞭解完 OOCSS 後，可以看看主流框架是不是有帶入其中之概念，接下來會介紹兩篇 PureCSS 與 Bootstrap，這兩者的簡單架構概念讓大家參考參考。 Pure CSS 算是很老牌的 CSS 框架，到目前使用者已少了許多，但架構到現在都很是非常直得學習，不需倚靠太多的工具，就能夠將 CSS 可用性發揮到最高，如果有朋友說要參考 CSS 的架構，相當值得學習的就是 PureCSS 及 Bootstrap。","text":"在瞭解完 OOCSS 後，可以看看主流框架是不是有帶入其中之概念，接下來會介紹兩篇 PureCSS 與 Bootstrap，這兩者的簡單架構概念讓大家參考參考。 Pure CSS 算是很老牌的 CSS 框架，到目前使用者已少了許多，但架構到現在都很是非常直得學習，不需倚靠太多的工具，就能夠將 CSS 可用性發揮到最高，如果有朋友說要參考 CSS 的架構，相當值得學習的就是 PureCSS 及 Bootstrap。 架構簡介Pure CSS 分為以下模組，每個模組都是獨立的 CSS 檔案，並沒有透過 Sass 或 Less 進行編譯，所以可以依據自己需求載入需要的模組。 Base Buttons Forms (Responsive) Forms (Non-Responsive) Grids (Responsive) Menus (Responsive) Menus (Non-Responsive) Tables 除此之外，他只有透過 grunt 這個工具將檔案串接在一起，並沒有做額外的編譯；如果需要做修改，由於沒有太複雜的編譯流程，對不熟悉編譯工具的開發者來說也是相當容易的。 另外還有 COMBO 版本，是已經合併以上全部的模組，官方有提供兩種 COMBO，分為有 RWD 、無 RWD 兩個版本。 樣式架構Pure CSS 的樣式架構是我最喜歡的部份，他用相當精簡的 CSS Code 來呈現一個模組，到底有多神就使用 Button 模組來做介紹。 Button 原始碼連結：https://unpkg.com/purecss@0.6.0/build/buttons.css 這是非壓縮版的原始碼，全部的按鈕行數不到 100 行(不壓縮，且包含註解)，在這些行數下也包含了不同的狀態。 一般載入的狀態： See the Pen Pure CSS Button by Wcc723 (@Wcc723) on CodePen. 範例中，我們在載入 CSS 後，只要參考文件就能夠將樣式呈現出來，所以就以上的兩個按鈕，只要各一行 HTML 就能解決了。 &lt;a class=&quot;pure-button&quot; href=&quot;#&quot;&gt;A Pure Button&lt;/a&gt; &lt;a class=&quot;pure-button pure-button-primary&quot; href=&quot;#&quot;&gt;A Primary Button&lt;/a&gt; Pure CSS 自訂樣式 - Pure CSS 巧妙地使用 透明度 在處理元件的樣式，就以按鈕來說可以用以下方法來調整： 複寫原有的樣式 設定元件色彩，透過原有的透明度樣式來呈現按鈕狀態 See the Pen Pure CSS Button by Wcc723 (@Wcc723) on CodePen. Pure CSS 修改樣式、新增樣式的範例如上，每個樣式都僅需一個 CSS selector 就能搞定，而且不需要編譯。 /* 複寫樣式 */ .pure-button &#123; border-radius: 4px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.16); &#125; /* 設定元件色彩來自定義樣式 */ .pure-button-accent &#123; color: white; background: #FF5E45; &#125; 這種透過透明度的方法在切換樣式能將 CSS 所需的程式碼降低非常多，而這也是 結構與樣式 分離的最佳案例。在最新版的 Bootstrap v4 中的 Navbar 也有用相同的技巧在切換色彩，有興趣的朋友可以參考以下連結。 Bootstrap Navbar color theme: http://v4-alpha.getbootstrap.com/components/navbar/#color-schemes 結語在現在 Sass、PostCSS 盛行的情況下，在製作多種樣式時都是透過工具去做運算，Pure CSS 僅提供 CSS 並運用 CSS 的特性讓其他開發者也能輕易自訂樣式，這也是我喜歡 Pure CSS 的部分。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 6 - CSS 的元件狀態","slug":"css-status","date":"2016-12-05T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/06/css-status/","link":"","permalink":"https://wcc723.github.io/css/2016/12/06/css-status/","excerpt":"CSS 元件狀態重點可以分為兩部分，一個是原生的 CSS 偽類(Pseudo-classes)，另一則是配合 Javascript 所提供的 Class，在這部分相當在元件的初始時，就同時完成兩個部分。","text":"CSS 元件狀態重點可以分為兩部分，一個是原生的 CSS 偽類(Pseudo-classes)，另一則是配合 Javascript 所提供的 Class，在這部分相當在元件的初始時，就同時完成兩個部分。 元件狀態的套用方式狀態再套用時，有兩種常見的手法，一則是使用 CSS 偽類(Pseudo-classes)，另一則是提供 Class 供 javascript 作切換。 一般在撰寫 CSS 時，就會將偽類規劃進去，最常見的就是 連結，其常用的偽類有： :active 滑鼠按下的樣式 :focus 鍵盤聚焦的樣式 :hover 滑鼠滑過的樣式 :link 還沒被訪問的樣式 :visited 被訪問過的樣式 假設是 a:hover 有製作以下的狀態，那麼用戶在滑鼠滑過後就能改變色彩。 a:hover &#123; color: blue; &#125; 但有時在呈現狀態時，並不是需要與用戶互動，而是回饋一個狀態讓用戶理解目前發生了什麼事。 如按鈕要表達已經被按下了，用戶不需要再按下一次，那麼我們可以用 .active 來說明這個狀態。或者用戶並沒有滿足按下按鈕的條件，我們可以用 .disabled 來呈現。 .btn:active, .btn.active &#123; color: blue; &#125; .btn:disabled, .disabled &#123; cursor: not-allowed; &#125; 一次做足元件狀態元件狀態是初學網頁設計師經常忽略的內容，就以 input 來說就有以下常見的狀態 一般狀態 focus 用戶選取的狀態 disabled 無法選取的狀態 feedback 輸入錯誤或正確的回饋狀態 如果在設計時，僅有提供 input 的一般狀態及 Focus 的狀態，那麼在開發時就會因為元素狀態不足，需要不斷的增加，如果增加時又沒有依據原有邏輯新增，就容易讓程式碼變得難以維護。 /* 125 行 */ .input &#123; /* input style*/ &#125; .input:focus &#123; border-color: blue; &#125; /* 800 行 */ .input:disabled, .input.disabled&#123; cursor: not-allowed; &#125; 所以建議在一開始時，就將常見的狀態先一次補足： /* 125 行 */ .input &#123; /* input style*/ &#125; .input:focus &#123; border-color: blue; &#125; .input:disabled, .input.disabled &#123; cursor: not-allowed; &#125; /* success feedback */ .input.success &#123; border-color: green; &#125; /* error feedback */ .input.success &#123; border-color: red; &#125; 結論 在寫偽類的時候別浪費，順便補上 .class 的樣式 在一開始寫的時候請順便規劃各種狀態","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 5 - CSS 的命名技巧","slug":"css-naming","date":"2016-12-04T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/05/css-naming/","link":"","permalink":"https://wcc723.github.io/css/2016/12/05/css-naming/","excerpt":"程式語言的命名一直是個麻煩課題，除了要有良好邏輯外，還必須有大量的英文詞彙能力。CSS 雖然不需要有太深的邏輯，但由於上手容易，團隊合作的命名就容易被其他小夥伴所影響。 本篇透過圖文及小故事來介紹 CSS 命名概念，讓你與小夥伴的命名協作能力更順暢。","text":"程式語言的命名一直是個麻煩課題，除了要有良好邏輯外，還必須有大量的英文詞彙能力。CSS 雖然不需要有太深的邏輯，但由於上手容易，團隊合作的命名就容易被其他小夥伴所影響。 本篇透過圖文及小故事來介紹 CSS 命名概念，讓你與小夥伴的命名協作能力更順暢。 除了不需要維護的網站以外， CSS 命名都是前端工程師的痛，因為很容易踩到先前所寫的坑，久而久之就會發生權重的問題。 案例：/* 100 行 */ .tab &#123; color: red; &#125; /* 300 行 */ a.tab &#123; color: blue; &#125; /* 600 行 */ .card a.tab &#123; color: green; &#125; /* 1200 行 Joe 1203 修正錯誤 */ a.tab &#123; color: red !important; &#125; 相信在維護過去的專案時，不少人有遇過這樣的經驗，當下的網站樣式是正常的，新的需求要調整目前的樣式，前一個離職同事用巧妙的手法安裝了未爆彈，為了證明你的實力只好再多一層 !important。 前人的債我們只能補，新的路我們可以自己鋪，除了前面所提到的兩個 CSS 分離方法，這邊要介紹好的 CSS 命名，讓 Class 複用性更高，這邊介紹幾個基本原則： 抽象化命名 (避免使用具體的色彩、單位尺寸等) 用元件形體命名 (不使用頁面上的功能做命名) 抽象化命名一般來說，品牌會定義色彩，網站也是一樣會定義色彩，比如說網站會定義主要色、次要色、強調色、警告色等。 主要色：藍色 強調色：紅色 網站上可以依據這樣的色彩直接命名，就如同下方這個範例，將色彩直接作為名稱 /* 避免 */ .text-blue&#123; color: blue; &#125; .text-red &#123; color: red; &#125; 但是，好景不常，設計師和老闆總是能夠合力起來做 “微調”，先前的藍色想改成綠色，紅色想改成橘色，畢竟這樣比較有質感。為了避免新人不知道紅為什麼是橘，還要跟他說一篇故事來介紹，其實我們可以將名稱做以下的調整。 /* 建議 */ .text-primary &#123; color: blue; &#125; .text-accent &#123; color: red; &#125; 除此之外，還有許多會使用單位尺寸做名稱，如： /* 避免 */ .m-t-50 &#123; margin-top: 50px; &#125; .m-t-30 &#123; margin-top: 30px; &#125; .m-t-10 &#123; margin-top: 10px; &#125; 為了避免發生 “50px 太大了，改 44px 可以嗎？”。 (小劇場等以下略)所以也是避免直接用數值來命名，我們可以用抽象畫的尺寸來做調整。 /* 建議 */ .m-t-l &#123; margin-top: 50px; &#125; .m-t-m &#123; margin-top: 30px; &#125; .m-t-s &#123; margin-top: 10px; &#125; 如果這時候他需要在兩個數值中間再插入一個值呢？我也不知道，因為這真的太欠揍了。 用元件形體命名一般來說命名都會很直白，像是 左側的選單 就叫做 left-menu，產品列表稱為 .product-list。 這樣的以後選單只能放在左邊，如果放到右邊去又是一個小劇場了；產品列表也是相同道理，誰知道哪天會不會放產品以外的內容呢!? 這邊用一個範例來介紹命名的方法： 這是一個排版的範例，左側是選單，右側比較大的空間是主要文章，一開始可能直接會用他所在的位置或功能性來命名，如 .menu、.article。 實際上呢，側面欄不會只有放選單；右方的主要內容可能也不是文章，可能會有產品、廣告、文件等其他內容，所以我們可以將命名做一些調整，用頁面上所在的位置命名，例如側面叫做 .side，主要內容區域叫做 .content 。 接下來，下方增加了 .ad 的區塊，寬度佔 1/3 和 .side 相同，由於是後來新增的區塊，直接稱為 .side 不太適合，所以就直接命名為 .ad。 這個時候，如果直接用 12欄的命名方法來命名，這樣網格的可用性就會變得更高。 所以我們在命名的時候，如果只能用在當下，沒有思考到未來的發展就可能會有大量相同的模組，或者是命名與實際運用的不搭，在這邊提供幾個命名概念給大家參考： 元件的外型命名 避免限制性的命名：.product-list 建議：.list 色彩的命名 避免直接用色名：.text-blue 建議：.text-primary Layout 的命名 避免直接用位置命名：.left-menu 建議：col-4 這篇嘗試使用小劇場的方式來介紹 CSS，自我感覺良好，但需要花雙倍的時間啊啊啊啊～。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 4 - OOCSS 容器與內容分離 (最佳實踐)","slug":"oocss-three","date":"2016-12-03T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/04/oocss-three/","link":"","permalink":"https://wcc723.github.io/css/2016/12/04/oocss-three/","excerpt":"結構與樣式分離，對於網頁的樣式設計是一種解放，所有元件的樣式組合搭配及擴增變得更自由。 這篇要介紹的是容器與內容分離，簡單來說我們可以把元件分為兩大類型： 容器型元件：如 grid、card、form 內容型元件：如 button、input、progress-bar 而不同類型的元件設計上應當分離，避免混寫限制元件的搭配。","text":"結構與樣式分離，對於網頁的樣式設計是一種解放，所有元件的樣式組合搭配及擴增變得更自由。 這篇要介紹的是容器與內容分離，簡單來說我們可以把元件分為兩大類型： 容器型元件：如 grid、card、form 內容型元件：如 button、input、progress-bar 而不同類型的元件設計上應當分離，避免混寫限制元件的搭配。 容器：白話文來說是盛裝物品的器具，在這邊我們可以思考成可以裝其它元素的外元件。內容：這裡解釋在容器內的元素。 以下圖來說，我們就區分為三個模組 容器 A 與 元件 A：這兩者是一體的，元件 A 無法獨自在 容器 A 以外的環境單獨出現，他是 容器 A 的繼承。 容器 B：這是一個單獨的容器，沒有額外的設定 元件 B：這是一個單獨的元件(內容)，可以在任何容器下。 在這個範例下，我們可以了解到 元件 B 不受到任何限制，可以自由的組裝在其他容器下，這也是 OOCSS 提到的元件就像是樂高一樣，可以依據任何需求做組裝，元件 B 正好符合這個概念。 Bootstrap 的容器與內容Bootstrap 是相當好的案例可以來說明容器與內容。以下圖來說按鈕與頁籤都是屬於 內容，而卡片是屬於容器，在 Bootstrap 的設計中都是屬於個別的元件，這些元件不會互相干擾，而且可以依據需求去組合。 接下來這張範例圖就是將按鈕、頁籤放到卡片這個容器內。 所以在設計元素的時候，如果是用以下的方式繼承就會限定元件的可用性，就以 OOCSS 的概念是需要避免這樣的設計，盡可能不要讓元件被限制在特定的容器下。 /* 盡量不要這麼做 */ .card &#123; … &#125; .card .btn &#123; … &#125; /* 好的作法 */ .card &#123; … &#125; .btn &#123; … &#125; 案例上一回我們用結構與樣式分離的概念製作出一組按鈕，接下來在製作另一組模組 card ，按鈕模組除了可以獨立使用外，在 Card 內也是可正常運用。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. /* card */ .card &#123; padding: 2rem; border: 1px solid #ccc; border-radius: 2px; box-shadow: 3px 3px 3px rgba(black, .16); .card-head &#123; font-size: 2rem; margin-bottom: 1rem; &#125; .card-body ul &#123; margin-left: 1em; margin-right: 1em; list-style: disc; &#125; .card-body img &#123; max-width: 100%; &#125; .card-footer &#123; margin-top: 15px; text-align: right; &#125; &#125; 不過其中 .card-body ul 這個 ul 就被限制住了，只有卡片內才能這樣顯示，此時就要思考是不是只有卡片內才需要這樣的 ul 顯示？或者將它拉出來更好？ 就當下這個設計，我們其實可以略作調整，將 ul 及 img 拉出來製作，然元件的容器與內容分離。 這樣就學會了兩大 OOCSS 的觀念，而這兩個觀念下還有些細節可以注意，等到看完這幾天的介紹，就能掌握整個 CSS 模組的核心概念。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 3 - OOCSS 結構與樣式、容器與內容(實際範例)","slug":"oocss-two","date":"2016-12-02T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/03/oocss-two/","link":"","permalink":"https://wcc723.github.io/css/2016/12/03/oocss-two/","excerpt":"結構與樣式在執行的概念上就是這樣的白話，目標即是將這兩者分離，上一篇我們用建築物的結構與外觀樣式做分離，再依不同的需求去做組合。 CSS 上也是相同的道理，比如說我們可以做這樣的分類： 結構：margin、padding、display、vertical-align 樣式： 色彩樣式：color、background-color、border-color 尺寸樣式：font-size、height","text":"結構與樣式在執行的概念上就是這樣的白話，目標即是將這兩者分離，上一篇我們用建築物的結構與外觀樣式做分離，再依不同的需求去做組合。 CSS 上也是相同的道理，比如說我們可以做這樣的分類： 結構：margin、padding、display、vertical-align 樣式： 色彩樣式：color、background-color、border-color 尺寸樣式：font-size、height 案例說明我們透過一個簡單的小故事作為範例，讓大家了解 OOCSS 在實作上是如何運作。 Step1我們接到一個工作要設計一組按鈕的 CSS，由於這組按鈕是作為銷售頁面的用途，在設計上我們有以下規劃： 按鈕有三個，依據顯眼程度的順序是 購買、註冊、說明。 網站的主色是藍色，強調色彩是紅色 (這邊不特別定義色碼)。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. 就以需求來說，我們可以依據需求做出三個按鈕，名稱分別命名為 .button-resgister、.button-purchase、.button-info，顏色也分別為 藍色、紅色、白色。 就以這個範例來說，我刻意很明確地將相同的部分寫在上方，其實這也就是結構與樣式混合的範例。 .button-resgister &#123; /* 重複的部分 */ display: inline-block; padding: .375rem 1rem; font-size: 1rem; font-weight: 400; line-height: 1.5; text-align: center; white-space: nowrap; vertical-align: middle; cursor: pointer; user-select: none; border: 1px solid transparent; border-radius: .25rem; /* 樣式 */ color: #fff; background-color: #0275d8; border-color: #0275d8; &#125; 結構與樣式的混合的結果，就是有大量重複的程式碼，這個案例中我們可以先將重複的程式碼抓出來，來達到結構與樣式分離。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. Step2由於需要更多的按鈕樣式，目前提供的三個按鈕並不足夠，在規劃上需要做以下調整： 按鈕有三個，依據顯眼程度的順序是 購買(主色)、註冊(強調色)、說明。 網站的主色是藍色，強調色彩是紅色 (這邊不特別定義色碼)。 說明按鈕還要做登入的功能，註冊按鈕還要兼著做訂閱電子報。 所以命名的部分，建議不要直接使用按鈕的功能性直接命名，而是可以按鈕的樣式特性來命名，比如說： 結構：btn 色彩 主次要：primary, accent 依據這樣的調整，樣式的設計就不會被原本的功能限制，使用更為靈活。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. .btn &#123; display: inline-block; padding: .375rem 1rem; font-size: 1rem; font-weight: 400; line-height: 1.5; text-align: center; white-space: nowrap; vertical-align: middle; cursor: pointer; user-select: none; border: 1px solid transparent; border-radius: .25rem; &#125; .btn-primary &#123; color: #fff; background-color: #0275d8; border-color: #0275d8; &#125; .btn-accent &#123; color: #fff; background-color: #d9534f; border-color: #d9534f; &#125; .btn-secondary &#123; color: #373a3c; background-color: #fff; border-color: #ccc; &#125; 最後，按鈕的結構就會有很大的調整，結構與樣式分離後，面對更多的挑戰(? 時可以減少修改的幅度，如果要再調整按鈕大小，相信大家也能夠用相同的概念去調整。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 2 - OOCSS 結構與樣式、容器與內容","slug":"oocss-one","date":"2016-12-01T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/02/oocss-one/","link":"","permalink":"https://wcc723.github.io/css/2016/12/02/oocss-one/","excerpt":"以前剛進入這行，掌握了 CSS2 的大部分關鍵之後，對於製作網頁非常有成就感，因為當時寫一個站不需要太多時間(整個網站約落在 800 ~ 1200 行 CSS)，而且 CSS2 語法數量也不多，查找時間也不需要太長，自然覺得世界美好(!?) 這樣快速入門時會有一些難以發現的問題，網站是否易於維護、CSS 可複用性是否夠高、命名是否一致，當時也會思考這些問題，但在沒有統整性的觀念引導下，許多嘗試都是不斷的在碰壁。","text":"以前剛進入這行，掌握了 CSS2 的大部分關鍵之後，對於製作網頁非常有成就感，因為當時寫一個站不需要太多時間(整個網站約落在 800 ~ 1200 行 CSS)，而且 CSS2 語法數量也不多，查找時間也不需要太長，自然覺得世界美好(!?) 這樣快速入門時會有一些難以發現的問題，網站是否易於維護、CSS 可複用性是否夠高、命名是否一致，當時也會思考這些問題，但在沒有統整性的觀念引導下，許多嘗試都是不斷的在碰壁。 OOCSSOOCSS 是 CSS 的架構方法，在這基本原則下 CSS 具有以下特點： 結構與樣式的分離 內容與容器的分離 在這兩個特點下，大大的強化 CSS 的可複用性 與 CSS 的擴展能力，讓原本的 CSS 從 1000 行到 5000 行都不會難以維護，以下就用建築的樣式來介紹什麼是 結構與樣式 及 容器與內容 吧。 結構與樣式原本的樣式表，就像是拿著油漆桶幫每個物件塗上色彩，在 OOCSS 的概念裡面，我們可以用樂高的觀念來思考，我們先準備好很多的模組，在需要的地方再組合。 就以下面的範例來說，我們可以將建築物模型分為 “建築物結構”、”建築物樣式”。 圖片來源：http://www.iconninja.com/building-icon-696433 在需要使用的地方，我們再將者兩個部分接在一起，結構與樣式接合以後，就會成為一棟建築物。 這樣的用意，就是可以將樣式套用至不同的結構上，結構本身的可利用性也提高了許多。是想，如果我們要建構三種不同樣式的建築物，如果都從結構開始建置，是不是麻煩許多!?但如果只要更新樣式，結構不更新，就不需要重新打造，這樣就是結構與樣式分離的概念。 到目前為止，我們其實已經學會了 OOCSS 的其中一大觀念 “結構與樣式”，而其實 OOCSS 就是以下兩個大概念而已喔： 結構與樣式 容器與內容 容器與內容另一個觀念，我們一樣用建築物模型來說明，假設建築物是外容器、窗戶是內容，那麼作為內容的窗戶應該要能裝在各個建築上。 以下是作為容器的建築物 以下是作為內容的外容器，這外容器的重點在於不限制只能安裝在特定的建築物上。 接下來窗戶裝在建築物上了，然而這兩個建築上的窗戶應當能夠做交換 接下來，我們還能夠交換兩邊的窗戶。 在這個設計下，作為內容的物件不會被限制只能在哪個外容器下。 除了結構與樣式分離外，身為外容器的物件與內容的物件也應當需要分離，避免元件只能在原有的容器上使用；容器與內容分離的情況下，元件再重新組裝時能夠更為容易，可擴增元件的再使用率。 但這些概念如果套用在網頁該如何解釋呢？別著急～，我們在後續的章節會用實際的範例來說明。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 1 - 前言，CSS 最重要的事？","slug":"css-most-important","date":"2016-11-30T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/01/css-most-important/","link":"","permalink":"https://wcc723.github.io/css/2016/12/01/css-most-important/","excerpt":"鐵人賽系列文又開始囉，這次的主題是 CSS 你覺得 CSS 最重要的是什麼勒？ 如果換個方式思考，寫 CSS 最 痛苦 的事情是什麼呢？ 載入速度緩慢 遇到不會解的問題 接別人寫的 CSS 接別人寫的 CSS，然後還看不懂在寫什麼 兩個月後維護自己寫的 CSS ，然後還看不懂在寫什麼 稍有資歷的工程師，其實最後幾點也遇過不少次 🙈。","text":"鐵人賽系列文又開始囉，這次的主題是 CSS 你覺得 CSS 最重要的是什麼勒？ 如果換個方式思考，寫 CSS 最 痛苦 的事情是什麼呢？ 載入速度緩慢 遇到不會解的問題 接別人寫的 CSS 接別人寫的 CSS，然後還看不懂在寫什麼 兩個月後維護自己寫的 CSS ，然後還看不懂在寫什麼 稍有資歷的工程師，其實最後幾點也遇過不少次 🙈。 很多時候產品有時限性的，在撰寫程式碼的時候就不會那麼的要求，尤其是 CSS 濫用優先值、important 也是很常見的事情，接下來就會遇到： 奇怪，樣式怎麼寫不上去 頁面上的色彩與整體設計不相同 啃，字體怎麼無法調整 不同的框架相互影響 這麼低能的解法絕對不是我寫的 身為一名前端工程師，寫好 CSS 也是必須的，還記得以前在寫 CSS 的時候，為了寫出好的 CSS 經歷過很多階段的磨練，像是苦練基本功、學好 sass、自幹框架、熟悉各種架構、配合各種環境等，到現在已經衍伸出屬於自己的心法，接下來會介紹業界常用的技巧，來解決所遇到的問題：包含避免捅自己的方法。 一、CSS 架構說到看不懂自己寫什麼，通常是沒有規矩在寫 CSS，這個篇幅會放在最前方，而整個架構概念會貫通各段文章。 二、開發環境身為一名前端工程師，在自己的領土上插旗也是很重要的，無論搭配任何的後端語言，最好對於自己工作範疇有一定的掌握度，所以透過一些工具來打理良好開發環境是很重要的，也會開始了解怎麼建置 Sass 環境。 三、Sass 開發心法這邊不會介紹到 Sass 的基礎語法，而是透過先前的 CSS 架構來了解 Sass 開發中的坑，並且讓 Sass 的可用性更加翻倍！ 四、實戰架構在了解整個技術基礎概念後，還會分享我在實作上的方法，如果後面篇幅許可，再加入更多框架運用，如： Bootstrap 4 !? 在整個觀念釐清以後，除了踩到自己腳外的問題也會一一有了答案，比如說效能問題，在良好的架構下，我們可以簡單地抽離不必要的 CSS 模組，並且不會對其他的畫面產生影響。 驚險刺激的鐵人賽又開始囉，這次能不能順利達成呢!?","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Yarn - Node.js 的套件管理工具","slug":"yarn","date":"2016-10-17T16:00:00.000Z","updated":"2016-10-18T07:07:19.000Z","comments":true,"path":"nodejs/2016/10/18/yarn/","link":"","permalink":"https://wcc723.github.io/nodejs/2016/10/18/yarn/","excerpt":"NPM 每次在安裝的時候，都會安裝很久很久，就算是好幾個類似的專案，每次在執行 npm install 時都需要花費大量的時間，而且在網路不穩定的環境下還可能造成中斷。Yarn 可以讓這些問題好轉些，在實測時，安裝一次以上的套件時間將只需要原本的 20% 時間(甚至更短)，將大幅減少逛 FB 的機會。","text":"NPM 每次在安裝的時候，都會安裝很久很久，就算是好幾個類似的專案，每次在執行 npm install 時都需要花費大量的時間，而且在網路不穩定的環境下還可能造成中斷。Yarn 可以讓這些問題好轉些，在實測時，安裝一次以上的套件時間將只需要原本的 20% 時間(甚至更短)，將大幅減少逛 FB 的機會。 安裝 YarnMac 用戶需要先安裝 Homebrew，安裝方法可以參考 http://brew.sh/，這邊我也順便更新了 homebrew ，目前版本如下。 接下來再安裝的時候跳出一個錯誤 (brew install yarn) 這貌似新版的 OS Sierra 的問題，有兩個方法，一種是更新 Xcode，另一種是刪除 Xcode 原本是想採用更新 Xcode 的方式，但是 Xcode 壞了打不開(-.-)，另外就是下載的大小佔 4.4 G…，無奈的情況下，只好把 Xcode 丟進垃圾桶了。 好了，在下一次 brew install yarn，將會開使正長的安裝 Yarn (我以為 Xcode 是必備的勒…)。 下載完後檢查版本 yarn --version 。 0.15.1 使用 Yarn這邊使用兩個專案來測試，測試 安裝時間 以及所需的 磁碟空間。 專案一在當下的資料夾中，我先把原始的 node_modules (28.1 mb)移除，以下是 package.json 的部分內容。 &quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^6.5.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-autoprefixer&quot;: &quot;^3.1.1&quot;, &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, &quot;gulp-postcss&quot;: &quot;^6.2.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot; &#125; npm install 版本所佔的磁碟空間大小 輸入 yarn install 就會開始安裝，安裝時會先檢查本地端有沒有，如果沒有才會線上拉。 第一次安裝 37.03秒，第二次安裝 6.9秒。 yarn install 版本所佔的磁碟空間大小 專案二好像是一個 express 範例…，在插入一些 gulp 教學。 &quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;~4.10.6&quot;, &quot;body-parser&quot;: &quot;~1.10.1&quot;, &quot;cookie-parser&quot;: &quot;~1.3.3&quot;, &quot;morgan&quot;: &quot;~1.5.1&quot;, &quot;serve-favicon&quot;: &quot;~2.2.0&quot;, &quot;debug&quot;: &quot;~2.1.1&quot;, &quot;jade&quot;: &quot;~1.8.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;gulp-gh-pages&quot;: &quot;^0.5.4&quot;, &quot;gulp-webserver&quot;: &quot;^0.9.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot; &#125; 使用 npm install 安裝時，所佔的磁碟空間為 38mb。 用 yarn 所佔的磁碟空間為 26.7mb，且第一次安裝時間約 27 秒，第二次 約 8 秒。 加速安裝的秘密，就在於根目錄下的 .yarn-cache 資料夾，這個資料夾會將每次安裝的套件先安裝一份到這來，往後如果需要相同套件，就會從這邊拉。 NPM 與 Yarn 指令比較大多數的指令用法和原本並無差異，只要將 npm 換成 yarn 即可，特別要注意的是 npm install [package] 安裝少數套件在 yarn 是不支援的，yarn 的套件都是必須儲存 (--save)。 NPM Yarn 說明 npm install yarn install - npm install [package] X 不支援直接安裝套件 npm install --save [package] yarn add [paakage] 僅是將 --save 改成 add npm install --save-dev [package] yarn add [paakage] --dev npm install --global [package] yarn global add [package] 這段還沒測過 global 的差異 npm uninstall [package] x npm uninstall --save [package] yarn remove [package] rm -rf node_modules && npm install yarn upgrade 移除再安裝 變 直接升級套件 更多的語法：https://yarnpkg.com/en/docs/migrating-from-npm 目前 Yarn 個人還沒完全測試過，但就一開始的體驗確實不錯，入門也不太需要太多改變 (除了砍掉了 Xcode 而已!?)，算是一個值得入手的好工具。 開發團隊包含了 Facebook、Google 等，而且相容目前的 NPM 註冊表，有興趣的可以放心使用 http://www.ithome.com.tw/news/108974。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://wcc723.github.io/tags/npm/"}]},{"title":"CSS 失控的 Margin top","slug":"css-margin-collapsing","date":"2016-06-07T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/06/08/css-margin-collapsing/","link":"","permalink":"https://wcc723.github.io/css/2016/06/08/css-margin-collapsing/","excerpt":"失控的 margin-top 是指在使用 margin 時常出現的問題，內元素的 margin 被外層所吸收，導致無法正確的顯示，這我們稱為 Collapsing margins，本篇來教大家怎麼應對這個問題。","text":"失控的 margin-top 是指在使用 margin 時常出現的問題，內元素的 margin 被外層所吸收，導致無法正確的顯示，這我們稱為 Collapsing margins，本篇來教大家怎麼應對這個問題。 情境在製作 Banner 的時候，通常需要一個 Logo 在畫面的左上，於是乎我們就會準備一個 div 把美美的 logo 往裡面塞。 如圖所示，我們的 Logo 還希望離上方有些為的距離，依邏輯來說物件離邊緣要有距離，我們就會幫他補上 margin，於是乎就會出現如下的問題。 See the Pen Collapsing margins (for blog) by Wcc723 (@Wcc723) on CodePen. 仔細看看上面所發生的問題，內元素的 margin 沒有起了作用，而是被外層所吸收。 失控的 Margin top 在遇到這個問題時，如果不熟的情況下就會說：「Bug 啦！」，通常只能用各種拋開羞恥心其它的方式去解決這個問題，但只要拿抓住發生的原因，就能輕易的去克服它。 這個問題在 w3c 有提到這問題稱為「Collapsing margins」，我將這部分縮減為以下幾點： 內外層均為 “塊狀” 元素。 外層塊狀元素沒有 border、padding、overflow。 內層第一個塊狀元素(空元素不算)，不包含 float、absolute。 所以如果要避開發生這個問題，就是避免存在以上這些問題，比如說不使用塊狀元素、外層加入padding、內層加入 float 等等，以下就列出一些解決方案。 See the Pen Collapsing margins (resolve for blog) by Wcc723 (@Wcc723) on CodePen. 這也是我們在與學員之間的問答中常遇到的，這次找個機會寫個文章跟大家分享分享。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass 基礎教學 - CSS 讀書會","slug":"css-clud","date":"2016-05-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/05/26/css-clud/","link":"","permalink":"https://wcc723.github.io/css/2016/05/26/css-clud/","excerpt":"先前的讀書會難度都有點過高，所以有時候聽的人會有點母煞煞，所以這次決定先介紹基礎的部分，以後再來介紹延伸的內容。","text":"先前的讀書會難度都有點過高，所以有時候聽的人會有點母煞煞，所以這次決定先介紹基礎的部分，以後再來介紹延伸的內容。 活動網址KKtix 活動網址：http://gonsakon-7655f2.kktix.cc/events/css-book-club-003-55ae43 這次活動在高雄醫學大學，高醫本身是教育單位，有許多資源很適合辦這樣的活動，像是強力 Wifi、強力投影機、強力空調…，缺點是這個空間在地下二樓，要從學校那麼多大樓中找到這地下室還真的頗有難度。 活動簡報 專業前端 都如何管理 Sass 基礎教學 - 高雄前端社群(CSS 讀書會) from Chih-cheng Wang 簡報連結：http://www.slideshare.net/chihchengwang3/03-sass 這次的筆記也換到了 HackMD ，感謝大家一起來協作筆記。 共筆文件：https://hackmd.io/EwDgbAJghmCcIFoAsKDGySoOwIEZIFYAzBYWIgpMJWKARjoGYg== 這次的活動自認為講授的內容進步了很多，時間上我是控制在 1hr，主要原因是如果講滿了 1.5hr，會缺乏許多和到場的人互動，所以時間上就比以往在短一些。 下次的活動下次的活動預計訂在六月中旬以後，我們會拉更多的人入坑，讓 CSS 讀書會的豐富度提升。而直播也會視入坑的開發者是否願意，主要還是供到場的朋友吸收好的內容。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"workshop","slug":"workshop","permalink":"https://wcc723.github.io/tags/workshop/"}]},{"title":"讓使用者愛上你的表單，提升客戶轉換率","slug":"best-choose-input-type","date":"2016-04-21T16:00:00.000Z","updated":"2016-10-13T06:31:39.000Z","comments":true,"path":"study/2016/04/22/best-choose-input-type/","link":"","permalink":"https://wcc723.github.io/study/2016/04/22/best-choose-input-type/","excerpt":"不知道你們在使用手機填寫表單的時候，會發現這樣的狀況，填寫地址跳出中文、填寫 E-mail 表單跳出中文、填寫電話也是跳出中文，甚至是日期欄位也是跳出中文，這樣其實對於使用者來說是很不便利的。如果這個狀況發生在結帳前，很高的機率導致使用者失去耐心，甚至離開網站，如果在表單上多花點小心思，就可以讓使用者快速地填完表單，讓雙方都滿意這次的交易。","text":"不知道你們在使用手機填寫表單的時候，會發現這樣的狀況，填寫地址跳出中文、填寫 E-mail 表單跳出中文、填寫電話也是跳出中文，甚至是日期欄位也是跳出中文，這樣其實對於使用者來說是很不便利的。如果這個狀況發生在結帳前，很高的機率導致使用者失去耐心，甚至離開網站，如果在表單上多花點小心思，就可以讓使用者快速地填完表單，讓雙方都滿意這次的交易。 如這一個範例來說，當下所點擊的是電話號碼這個欄位，但跳出的是英文鍵盤，必須在切換後才能顯示數字鍵，好在這個表單的欄位並不多，只要切換一兩次就填完表單了。但如果這個狀況發生在電子商務類型的網站上後果可不僅於此，每個不順暢的流程都會造成用戶的猶豫、不耐煩，在大量的表單需要填寫的情況下，就可能使用戶離開。 為了避免用戶不愉快造成訂單的遺失，正確的表單類型是很重要的，所以在不同需求的欄位，就必須給予正確的類型，如以下範例來說，欄位中的需求是填入電話號碼，將 &lt;input&gt; 內的 type=&quot;text&quot; 修改成 type=&quot;tel&quot;，在行動版所跳出的迷你鍵盤也就會以數字的格式呈現，並且是符合電話撥打的鍵盤。 電話號碼僅是其中一項，電子郵件、密碼、日期、時間都有相對應的類型，在不同格式下所顯示的螢幕小鍵盤都不同，大家不妨透過以下範例試試看在您的手機會提供什麼樣的小鍵盤。 See the Pen http://codepen.io/Wcc723/pen/MyBbex/“&gt;Input (http://codepen.io/Wcc723/pen/MyBbex/) type by Wcc723 (@Wcc723) on CodePen. 如果你是在行動版上觀看此原始碼，可以點選 result 來顯示範例 有發現吧，有些欄位所提供的都是英文小鍵盤，但其實細節卻不大一樣，如果是 E-mail 類型的欄位就會提供 ‘@’，在 Url 類型的欄位則會提供 ‘.com’。 Google 表單類型說明文件至於什麼樣的內容要用什麼樣的輸入類型呢？ Google 提供了一份文件，讓網頁的開發者可以輕鬆的了解什麼樣的類型是最佳的選擇，Google文件：選擇最佳輸入類型 但同時我們也必須注意，並非所有的瀏覽器、手機均支援以上的類型，如 color (顏色類型)就不是所有瀏覽器均支援，在開發時需要經過測試，確認表單的類型是否能提供該網頁最好的瀏覽體驗。 背景圖片來源：https://unsplash.com/photos/VGOiY1gZZYg 歡迎分享 Facebook：https://www.facebook.com/hexschool/ 六角學院網站：http://www.hexschool.com/","categories":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/categories/study/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"轉行工程師必須克服的三大痛點","slug":"engineer-3-point","date":"2016-04-18T16:00:00.000Z","updated":"2016-10-13T06:31:39.000Z","comments":true,"path":"study/2016/04/19/engineer-3-point/","link":"","permalink":"https://wcc723.github.io/study/2016/04/19/engineer-3-point/","excerpt":"本篇是以設計師轉工程師為主要觀點 在研究所那年，我投入大量的時間學程式，由於當時的 Flash 相當火紅，所以決定從 Actionscript 3.0 開始入手，那時也遇到相當多的挫折，印象很深的是在床上看著短短的程式碼 (手打沒問題，重點是我想了解原理，才會在床上看書…)，那段寫著什麼是 “變數”，就現在看來這是很簡單的觀念，但我也是花了好幾天才能理解是什麼意思。 現在有機會從事教育推廣，從與許多設計師想轉行工程師中的對談中，認為有以下三個原因阻擾著設計師，如果可以克服，在學習上會更為順利：","text":"本篇是以設計師轉工程師為主要觀點 在研究所那年，我投入大量的時間學程式，由於當時的 Flash 相當火紅，所以決定從 Actionscript 3.0 開始入手，那時也遇到相當多的挫折，印象很深的是在床上看著短短的程式碼 (手打沒問題，重點是我想了解原理，才會在床上看書…)，那段寫著什麼是 “變數”，就現在看來這是很簡單的觀念，但我也是花了好幾天才能理解是什麼意思。 現在有機會從事教育推廣，從與許多設計師想轉行工程師中的對談中，認為有以下三個原因阻擾著設計師，如果可以克服，在學習上會更為順利： 不知道如何開始隔行如隔山，這畢竟是要進入另一個產業，尤其是程式的領域這麼廣，一開始要投入的也不知是否正確，像是我投入 Flash Actionscript 3.0 當完兵就突然沒落了 …。現在行動裝置相當火紅，如果投入 Android 或是 iOS 的開發似乎是不錯的點，但也有可能不久後的開發會改語言(如 Android 改用 Swift) !? 在不斷猶豫之中，就失去許多學習的時間。 就學習上，我是推幾種選擇方式： 選擇有興趣的 選擇當下最主流的：使用者多不易退流行，替代方案容易出現 選擇有需求的：有需求可以強迫學習 就個人經驗來說不太需要擔心學錯語言，因為這不像是線上遊戲練錯就要砍掉重練，已經學會的技能會加速其他相關技能的學習，如同當時學了 Actionscript 3.0 後再接觸 Javascript 是相當類似的，就算是當兵一年沒有接觸，透過肌肉(?)也可以快速喚醒當年的記憶。 不了解怎麼問問題設計、藝術就像是玄學，許多設計師練就了一項特殊才能：圖像化，設計師們在溝通時可以將語言轉換為圖像，甚至在與他人介紹時可以再將圖像用語言描述出來，但可惜的是程式語言無法用這個技能去描述…。 工程師需要看到程式碼、結果、錯誤訊息才能理解問題點，所以在詢問程式上的問題時有許多眉眉角角要注意，這也是設計師在詢問時經常碰壁的點，如：我想畫一個圓，但不知道為什麼都是方的 ( xxx 傳送一張截圖)。 工程師表示：… 有耐心的工程師會導引你說出他要的答案，但也有可能被工程師白眼後酸一兩句，同時也打擊了學習的慾望。這畢竟不是一個好的方式，所以在問問題時可提供以下的訊息： 原始碼：是用什麼語言寫這個方形的 (ex: html, css 的原始碼) 環境：是用什麼環境開發或預覽的 (ex: IE 預覽的唷～) 是否有錯誤訊息：盡可能提供錯誤訊息，以開發 Web 來說會經常使用到開發者工具，試著去了解錯誤訊息在哪出現吧～。 惰性這是最大的個人問題，只能說換行不是一件容易的事情，沒有人鞭策的的情況下容易落入明日復明日的狀態，就算是說很有興趣的人，回到家看到沙發還不是先躺個一兩小時再說，有些時候需要採取一些手段來強迫自己學習，這部分我用過一些方法可以參考看看： 付費課程：這當然是最有效的，錢都付了哪有沒認真上的道理…，而且付費學習效率高，短時間內就可以到達一定的水準。 每日作業：我有一年強迫自己每天寫 CSS 文章持續 100 天，包含假日我都沒有中斷過，平台也是隨意自己架的。 破釜沈舟：如果說該技能沒學完就會影響一件大事(失業、案子無法完成等等)，透過這種方式強迫學習，ActionScript 我把它當畢業論文在研究，如果沒學會就無法畢業…。 如果說你是一位設計師，正想轉職做工程師這些問題你也正好存在，這篇文章還沒有完全解決你的問題，你可以來問我們看看，我們很樂意跟你聊聊這方面的問題。 歡迎分享 Facebook：https://www.facebook.com/hexschool/ 六角學院網站：http://www.hexschool.com/","categories":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/categories/study/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"專業前端都如何管理 CSS - CSS 讀書會","slug":"css-clud","date":"2016-04-11T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/04/12/css-clud/","link":"","permalink":"https://wcc723.github.io/css/2016/04/12/css-clud/","excerpt":"CSS 讀書會原本打算兩週辦一次，但在各種原因下已經自動發展成每月一次的活動了 Orz…(下次估計也要到五月才會有了T_T)。","text":"CSS 讀書會原本打算兩週辦一次，但在各種原因下已經自動發展成每月一次的活動了 Orz…(下次估計也要到五月才會有了T_T)。 活動網址KKtix 活動網址：http://gonsakon-7655f2.kktix.cc/events/css-book-club-003 這次活動改到 作伙，是在後驛站附近的一棟透天厝裝潢成共同工作空間，一樓及頂樓有場地出租，場地另有提供迷你的投影機及布幕；我們是租用一樓的場地，雖負責人說可以容納 20 人，但我認為 15 人左右是比較舒適的。 作伙的門口，是一間透天厝，前方有個小庭院，蕃薯(貓名)常在這邊出現。 一樓的場地，如果租用的話，負責人會調整成合適的空間，比如說這次場地我們需要投影機。 上次 Javascript 讀書會的情景 (這次我忘了拍了)… 活動簡報 專業前端 都如何管理 CSS from Chih-cheng Wang 簡報連結：http://www.slideshare.net/chihchengwang3/css-60646381 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 共筆文件：https://csscollege.hackpad.com/CSS-3-CSS-fkE5HXwHeID 問卷問卷平均分數 4.46 (滿分 5 分)。 這次的主題分為前後兩段，前半段是介紹 OOCSS ，後半段是透過 OOCSS 分析其他主流框架以及 Sass 架構分享，在難度的分配上前半段較為簡單，後半段與 Sass 有很大關係，參與者並不一定皆了解 Sass ，所以這段可能會造成出神的狀況。 另外在下次活動主要三個較多人選擇(票數接近)，這部分還在猶豫要介紹什麼 ＠＿＠： CSS 技法 Sass 基本運用 Sass 與 bootstrap 意外之外這次活動參與者大部分人給予正面的回應，但和過去不同的是有一位給了過往最低分(2分)，對於主題的建議也提出希望是 正反雙方辯論。 嗯…，就這主題上我還沒想到該如何經營及主持…，或許提出這個意見的可以私下敲我聊看看怎麼進行。 結語雖然參與的人數有再上升，但隨著人數上升也是要多注意許多細節，不可能滿足所有人的需求，辦這些活動其實就要知道有人會喜歡、有人會討厭，如果因此感到挫折與無力時，就代表自己正在進步中。 這個月的 Javascript 、 CSS 讀書會都應該會暫停，因為主辦人都中了教召….。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"workshop","slug":"workshop","permalink":"https://wcc723.github.io/tags/workshop/"}]},{"title":"響應式網站設計實作坊 - 高雄前端社群","slug":"rwd-workshop","date":"2016-04-10T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/04/11/rwd-workshop/","link":"","permalink":"https://wcc723.github.io/css/2016/04/11/rwd-workshop/","excerpt":"本篇拖了很久很久才寫，主要原因是因為最近實在很忙，加上一直想跳到 Wordpress 平台上去寫作…(Server 都準備好了)，但 Wordpress的 Server 可能還會被我拿去做其他用途，所以又回來寫了，哈哈哈哈。 這是高雄前端社群久久難得一次的 Responsive 課程，也很難得出現秒級的時間內票券完售 (當然可能是免費的關係啦 :))。","text":"本篇拖了很久很久才寫，主要原因是因為最近實在很忙，加上一直想跳到 Wordpress 平台上去寫作…(Server 都準備好了)，但 Wordpress的 Server 可能還會被我拿去做其他用途，所以又回來寫了，哈哈哈哈。 這是高雄前端社群久久難得一次的 Responsive 課程，也很難得出現秒級的時間內票券完售 (當然可能是免費的關係啦 :))。 活動網址 KKtix 報名網址：http://gonsakon-7655f2.kktix.cc/events/a5791ac5-f60f9c-cc9dec-eb381d-6b57e9-3a5710-61e623-17b85b 這次也感謝很多助教的協助，許多人就經常地在高雄前端社群幫忙，包括各大小廠的活動都有他們的蹤影，這次還特別感謝從台南來的成員，讓我們的活動更加完善。 講師列表： 廖洧杰 Maple Jackson Norman 林怡萱 IKEA Till 活動簡報 響應式網頁實作坊 from Chih-cheng Wang 簡報連結：http://www.slideshare.net/chihchengwang3/ss-60067482 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 共筆文件：https://csscollege.hackpad.com/327-RWD–orIWGAfGPvb 問卷問卷分數也還不錯，平均分數 4.78 (滿分 5 分)，其中 5 分佔 84%。 而這次活動本來是想給設計師、初學者學習的，但參與的後端工程師佔不少，參與者職業組合： UI 設計師 12.5% 平面設計師 12.5% 前端工程師 43.8% 後端工程師 40.6% PM 3.1% 學生 3.1% 其他 25% (iOS 工程師也佔不少) 這次最困難的部分其實是前半段的 Grid 介紹，這也花了大半的時間在講解，嗯…這個難度設計應該是有讓不少人有感受到收穫。 0 太簡單了 秒懂 3.1% 1 稍微思考一下，但沒太多問題 53.1% 2 有遭遇一些問題，但後來都克服了 40.6% 3 遇到了問題，但不知道怎麼解決 3.1% 結語這次活動比較沒拿捏好的部分是進度，我花很多時間在前半部，但在後半段的時間就略顯不足，有很多想在特別介紹的，卻沒有控制好時間，這在往後的活動都要特別注意。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"workshop","slug":"workshop","permalink":"https://wcc723.github.io/tags/workshop/"}]},{"title":"第二次 CSS 讀書會 - Sass 環境建置","slug":"css-book-clud-2-sass-and-gulp","date":"2016-02-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/02/29/css-book-clud-2-sass-and-gulp/","link":"","permalink":"https://wcc723.github.io/css/2016/02/29/css-book-clud-2-sass-and-gulp/","excerpt":"這次是第二次的 CSS 讀書會，目標是要教大家 Sass 的環境建立，也算是比較大的挑戰，因為要在線上及現場教大家怎麼運行 Sass 的編譯環境，且主要的目標族群包含了設計師、網頁設計師，甚至是沒有碰過 command line 的開發者…。","text":"這次是第二次的 CSS 讀書會，目標是要教大家 Sass 的環境建立，也算是比較大的挑戰，因為要在線上及現場教大家怎麼運行 Sass 的編譯環境，且主要的目標族群包含了設計師、網頁設計師，甚至是沒有碰過 command line 的開發者…。 活動簡報範例：https://github.com/Wcc723/gulp-web-designers 這次活動的簡報是用 Keynote 做的，有些部分是講解上為了呈現動態效果，所以在 slideshare 無法呈現的很完整。 建立 Sass 環境，透過 Node sass from Chih-cheng Wang 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 View CSS 讀書會 2 (Sass 編譯環境) on Hackpad. 其他問題這次有許多問題是 Hackpad 上沒有提到，是在問卷內提出的問題，這邊我就一一回覆： 問題：Sass 與 Scss在一開始寫 Sass 就是使用 .sass 的格式，前前後後也有一年多的時間，雖然看到許多開發者都是使用 .scss，大多數的文件及範例也都是使用 .scss ，但當時是想說只要有愛，就可以堅持下去 !? 直到出現一個問題用 .sass 很難解決(讓我轉跳 .scss 的原因)，那就是 Sass Maps (範例：http://www.sitepoint.com/using-sass-maps/)，當時也正好在學 Susy， Susy 一定要使用 Sass Maps，用 .sass 格式寫 Sass Maps 簡直地獄…。 // scss $map: ( key: value, other-key: other-value ); Sass 格式中，Sass Maps不能換行 = =(實際上的 Maps 會更長)，當下花了很長的時間找解法，但一直找不到替代方式，就默默地轉向 .scss。 // sass $map: (key: value, other-key: other-value) 另外一個原因是在寫教學文時 .sass 對於一般使用者較為陌生，如果不熟悉的讀者看到 .sass 應該不知道在寫什麼…。 問題：為何不再用 Susy關於 Susy 這個工具我用過 Susyone、Susy 2，後來確實有些偏見 (這部分是我該反省的點Q_Q，不該用自己的主觀來勸大家別用)，這邊還是要和大家分享為何我不再使用這樣的 Grid 工具。 第一階段這幾張圖我們就看有色彩的地方，假設需求是左邊有選單(4欄寬度)，右方的區域是文章內容(8欄寬度)，總共為 12 欄寬，一開始我們可能會使用 .menu 及 .article 來規劃 CSS 。 .menu &#123; // 4 欄寬 &#125; .article &#123; // 8 欄寬 &#125; 第二階段但這兩個區域的實際內容可能不會只放文章，左邊也有可能是放廣告，所以就把側邊改成 .side，中間也改成了 .content，以符合以後的運用。 .side &#123; // 4 欄寬 &#125; .content &#123; // 8 欄寬 &#125; 第三階段後來新增了一個區域 .ad，那個區域的寬度與 .side也都相同，但稱為 .side 的區域也不便直接套在 .ad，所有就新增一個 .ad 寬度也一樣是 4 欄寬。 .side &#123; // 4 欄寬 &#125; .content &#123; // 8 欄寬 &#125; .ad &#123; // 4 欄寬 &#125; 第四階段我們會發現其實 .side、.ad 兩者 CSS 屬性差異不大，所以可以改用欄寬的方式來定義這個 class 名稱，於是乎就出現了 .col-4、.col-8，m…到了這步驟，是不是發現和 Bootstrap 2 有點像呢!?這樣的 CSS 設計模式是將網格系統模組化，增加了Class 的可複用性。 Susy 的優點在於快速建立格線系統，但如果是 col-size 的 Grid-system 就失去了快速建立格線系統的特色，模組化的優點是增加了 Class 的可複用性，但換個方向去思考，其實它也限制了創意的發想(畢竟 grid 都已經規劃好)，不同的方法與技巧也建議去嘗試看看，這樣才能了解何者適合目前的專案。 問題：為何需要用 Scss 與 CSS 如何跟後端的結合為何需要用 Scss？理由挺多的，就個人這段時間的學習來說，有以下幾個理由： 節省時間：當初學習 CSS 時，每一行都是純手工寫出來的，雖然很有成就感，但久而久之都花時間在重複的地方，透過 Sass 的技術，不僅在重複的地方花更少的時間，還可以投資更多時間在新的技法上。 管理 CSS：就純 CSS 來說，由於所有的程式碼都集中在同一個檔案上(當然也可以用@import，但就效能上有許多建議說別這麼做)，透過 Sass 可以將 CSS “模組”拆分成不同檔案，之後再編譯成同一隻檔案。 進階的 CSS：Sass 在開發上多了變數、運算，可以去思考怎樣用簡單的方式做出豐富的效果，不過這也需要投資一定的時間去研究。 如何與後端語言結合？ 其實我在專案上都是透過 Gulp 與後端結合，但這次的讀書會主要是讓新手可以入門 Sass 環境，所以沒仔細提到這段，如果是後端的開發者，可以參考範例中的 gulpfile.js，抽離掉 webserver 模組後，就可以用來編譯給後端用的 Sass (也可以依據需求調整編譯路徑等)，或者私下敲我，我們再來討論討論。 前端的工具還相當多，這樣的一次性介紹還缺乏很多，以後我再多研究研究其他前端工具再與大家分享(近期內應該還會介紹 Bower)。 建議：講者說話太快嗯…，這部分是我該多注意的，往後的課程也會更著重在單一的主題上介紹，不過大家有問題還是盡量可以在 Hackpad 或直播頻道發問，上面有許多高手會一起交流解答～。 就票數上來說，下次會介紹 CSS 架構，希望這個連假可以準備差不多 Orz 。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"第一次 CSS 讀書會","slug":"css-book-clud-1-grid-system","date":"2016-01-29T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/30/css-book-clud-1-grid-system/","link":"","permalink":"https://wcc723.github.io/css/2016/01/30/css-book-clud-1-grid-system/","excerpt":"這次在高雄舉辦了 CSS 讀書會 (Grid syetem)，主要是之前參加了 javascript 讀書會，認為CSS 也能辦相同的聚會，在第一次試辦時有許多測試水溫的方式： 想先瞭解受眾類型 估計參與人數 直播的方式是否可行 未來讀書會的方向","text":"這次在高雄舉辦了 CSS 讀書會 (Grid syetem)，主要是之前參加了 javascript 讀書會，認為CSS 也能辦相同的聚會，在第一次試辦時有許多測試水溫的方式： 想先瞭解受眾類型 估計參與人數 直播的方式是否可行 未來讀書會的方向 活動簡報這次活動的簡報是用 Keynote 做的，有些部分是講解上為了呈現動態效果，所以在 slideshare 無法呈現的很完整。 CSS 讀書會 - 1 (Grid system) from Chih-cheng Wang 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 View CSS 讀書會 1 (grid system) on Hackpad. 現場參與照片!?(用直播用到忘記拍照了 =口=) 回饋這次活動是先透過 KKtix 報名，主要是想知道如果辦這樣的讀書會有沒有人要參加，還有達到基本的宣傳，結果…，13秒內搶完10張票！！！另外 Youtube 同時在線約 45 人上下，這次到前一天不到 24 小時的時間才公佈有線上直播 Q_Q(而且我到前幾分鐘才成功連上 Youtube…)。 而 Youtube 數據到今天我還不能看 -.-…. 問卷從問卷上得知大部分的參與者都有從事前端工程，其次在設計師及學生的數量也是不少，另外在最後也希望大家填寫想了解的 CSS 主題，選擇如下： CSS 架構 (12 人選擇) 實作 (10 人) 技法 (3 人) 往後主題因為 CSS 架構以及實作的選擇數量差距較小，以後再主題的規劃上就會兩者並重，且在內容的安排上，會持續貼近設計師與前端工程師的組合，也感謝本次參與者提供意見，希望在以後能夠透過這樣的方式互相交流成長。 另外，自己意外的喜歡這個副標 『擺脫 They 的問題，完全掌控 You 的 CSS』。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"動手玩 CSS 3d","slug":"css-3d","date":"2016-01-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/24/css-3d/","link":"","permalink":"https://wcc723.github.io/css/2016/01/24/css-3d/","excerpt":"一開始接觸 CSS3 時，常常會不了解每個 CSS 屬性的意思，就需要花些時間去查詢及嘗試，就算到了現在，對於不熟悉的語法，我還是經常回我的 Blog 查詢，如先前的 動手玩 CSS，快速學會Flex，我就經常會回去查 Flex 的使用方法 Orz…，這次趁寒流來襲，不想出門的時間在家裡做簡單的 CSS 3d 範例。","text":"一開始接觸 CSS3 時，常常會不了解每個 CSS 屬性的意思，就需要花些時間去查詢及嘗試，就算到了現在，對於不熟悉的語法，我還是經常回我的 Blog 查詢，如先前的 動手玩 CSS，快速學會Flex，我就經常會回去查 Flex 的使用方法 Orz…，這次趁寒流來襲，不想出門的時間在家裡做簡單的 CSS 3d 範例。 CSS 3D當要做 CSS 3D 的效果時，可以先假想兩層的元素。外層是視角，是用第三人稱的方向在看著內層；內層就是物件的本身，可以有不同的 3D 屬性(旋轉、位移等等)。 HTML 結構如下： &lt;div class=&quot;perspective&quot;&gt; &lt;!-- 外層視角 --&gt; &lt;div class=&quot;box&quot;&gt; &lt;!-- 物件本身 --&gt; &lt;div&gt; &lt;/div&gt; 在CSS 的屬性上，外層會提供 perspective 的透視屬性，這是從第三人稱看物件的距離，值可以先使用 500px ~ 1000px (不負責研究，通常這個起手式效果不太差)；在內層的屬性則必須包含 transform-style: preserve-3d，讓物件本身已 3D 的模式呈現，並加入 transform 的變形屬性，就可以完成基本的 CSS 3D 。 CSS 結構如下： .perspective &#123; perspective: 500px; &#125; .box &#123; transform-style: preserve-3d; transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg); &#125; 接下來透過動手玩的方式，調整看看外層與內層得屬性值，了解他們彼此 perspective 與 transform 之間的效果。 可以發現，如果 perspective 值如果是非常小時，內層物件就會像衝出螢幕一樣，如同我們在看物體時，通常會保持一定的距離，並非貼的很近在觀看。 2016年的冬天…到底是怎樣的溫度會不想出門呢…，在高雄很少低於 10 度，如果低於 8 度就要拿出羽絨衣，在更低一點就只想要躲在棉被裡…。 這個體感問度是…，讓我回想到馬祖的冬天。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"跟 Javascript 相比，CSS 還是友善多了 @@","slug":"I-love-css","date":"2016-01-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/16/I-love-css/","link":"","permalink":"https://wcc723.github.io/css/2016/01/16/I-love-css/","excerpt":"本週參加了高雄 Javascript 讀書會，所選擇的書籍是 JavaScript設計模式與開發實踐，這本雖然原本是簡體書，但內容真的不錯(不過我只有看一兩章似乎沒什麼說服力 &gt;O&lt;)，也多虧這次的讀書會，讓我對於技術有更深層的看法。 JavaScript 什麼的太難了…，直接請人教比較快 了解設計模式對於大部分 JavaScript 的了解很有幫助 (如 Angular 的 Service 本身就具有 Closure 的觀念) 參加讀書會這樣的活動，對於技術的學習相當迅速，等於是直接吸別人的經驗值 工作上雖然會寫 Javascript，但這次讀書會光是 this 就可以玩死我 Orz，更別說 Closure、ES6 等等…，雖然最後還是有學到一兩招，但真的很累…。","text":"本週參加了高雄 Javascript 讀書會，所選擇的書籍是 JavaScript設計模式與開發實踐，這本雖然原本是簡體書，但內容真的不錯(不過我只有看一兩章似乎沒什麼說服力 &gt;O&lt;)，也多虧這次的讀書會，讓我對於技術有更深層的看法。 JavaScript 什麼的太難了…，直接請人教比較快 了解設計模式對於大部分 JavaScript 的了解很有幫助 (如 Angular 的 Service 本身就具有 Closure 的觀念) 參加讀書會這樣的活動，對於技術的學習相當迅速，等於是直接吸別人的經驗值 工作上雖然會寫 Javascript，但這次讀書會光是 this 就可以玩死我 Orz，更別說 Closure、ES6 等等…，雖然最後還是有學到一兩招，但真的很累…。 CSS 讀書會由於 JavaScript 對於設計師來說稍微不友善!? 所以在讀書會中有人就隨口提出了 CSS 讀書會(~其實想辦的是CSS Girls吧!!)。雖然我對於 CSS 掌握有一定的信心，但要挑什麼樣的書籍就沒什麼概念，目前有想到幾個方案： CSS Secrets :本書有相當多的奇淫巧計，堪稱CSS 界的神書，究竟有多神，可以先參考本作者先前的 簡報。 Bootstrap:方案是研究目前在市面上較為普及的 CSS Framework，藉此來了解主流框架的架構以及他們的 CSS 設計模式。 目前還在與其他同好討論是否有更適合的方案，也希望能有更多同好一同參與啊～。 100 Day UI100 Day Ui是一個相當好的活動，可以看到很多很棒的作品 . ，這個網站有些作品也被其他網友做成了網頁版本，我也就偷偷地摸了一部份漂亮的 CSS 囉～。 http://wcc723.github.io/WorkShop-gh-pages/glowButton/ 我很喜歡這樣的按鈕表現模式，雖然說之前我不喜歡大圓角，但這樣的光暈及漸層表現方式真的很棒，而且也擺脫目前許多 Style Guide 的扁平化思維。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"動手玩 CSS Blend Mode - 根本 Photoshop 的圖層效果","slug":"css-blend-mode","date":"2016-01-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/10/css-blend-mode/","link":"","permalink":"https://wcc723.github.io/css/2016/01/10/css-blend-mode/","excerpt":"現在的 CSS 變化比過去還多，原本的 CSS 主要用於排版，在 CSS3 除了排版還會包含許多效果，本篇介紹的 Blend Mode 就是混合模式的效果，讓 CSS 像 Photoshop 一樣有圖層混合。","text":"現在的 CSS 變化比過去還多，原本的 CSS 主要用於排版，在 CSS3 除了排版還會包含許多效果，本篇介紹的 Blend Mode 就是混合模式的效果，讓 CSS 像 Photoshop 一樣有圖層混合。 background-blend-mode, mix-blend-mode範例中會包含這兩種 CSS 樣式，先做簡單的介紹。 background-blend-modebackground-blend-mode 這一個 CSS 屬性是針對 背景圖片 的混合模式，所以並不會影響畫面中其他物件色彩。 mix-blend-modemix-blend-mode 這種混合模式就如同 Photoshop 中的 圖層混合模式 較為接近，會有下層圖層的色彩進行混合。 範例 範例連結網址：http://wcc723.github.io/WorkShop-gh-pages/cssBlendMode/ 範例介紹 Background Blend Mode：背景的混合模式 Background Color：*背景色彩 Text：中央文字 Text Color：*文字色彩 Text Mix Blend Mode：中央文字的圖層混合模式 Background URL：背景網址 (預設是超辣的朝天椒) * 如果你的瀏覽器不支援 HTML5 input 選色的，可以直接輸入色碼或是色名，如(#FF0000 or red) CSS 值background-blend-mode 及 mix-blend-mode 這兩種混合模式的值是相同的，這些值是不是似曾相識呢!?這些與繪圖軟體的混合模式工具是相同的唷～。 normal multiply screen overlay darken lighten color-dodge color-burn hard-light soft-light difference exclusion hue saturation color luminosity 結語透過直接的範例，減少用文字的說明，可以較快速的了解 CSS 的特性，畢竟 CSS 主要是用來處理視覺上的效果。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Compass 替代方案(3) - 加入 SVG Sprites","slug":"replace-compass-with-node-sass-3","date":"2016-01-02T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2016/01/03/replace-compass-with-node-sass-3/","link":"","permalink":"https://wcc723.github.io/sass/2016/01/03/replace-compass-with-node-sass-3/","excerpt":"Compass 的 CSS Sprites 是非常好用的工具，在以前有介紹過 compass 的 Sprites 作法，只要把圖片丟一丟就可以完成，而且也可以做 for Retina 版本，但是使用SVG 製作 Sprites 就沒有辦法。一直以來我都是以向量工具做設計，如果不能轉 SVG 這樣高品質的圖檔，對我來說也是挺困擾的。 這篇就要介紹如何使用 Gulp 來製作 SVG Sprites，並且同時產生一般 png 版本來相容於舊版的瀏覽器。 先前的 Sprites 介紹文章 Spriting with Compass Sprites for Retina","text":"Compass 的 CSS Sprites 是非常好用的工具，在以前有介紹過 compass 的 Sprites 作法，只要把圖片丟一丟就可以完成，而且也可以做 for Retina 版本，但是使用SVG 製作 Sprites 就沒有辦法。一直以來我都是以向量工具做設計，如果不能轉 SVG 這樣高品質的圖檔，對我來說也是挺困擾的。 這篇就要介紹如何使用 Gulp 來製作 SVG Sprites，並且同時產生一般 png 版本來相容於舊版的瀏覽器。 先前的 Sprites 介紹文章 Spriting with Compass Sprites for Retina CSS Sprites製作 CSS Sprites 不外乎就是要減少 HTTP Request(請求數)，藉此來達到更好的網站瀏覽效能。但 CSS Sprites 在製作上有點兒麻煩，一般來說會有以下流程。 製作許多小圖示 將小圖示合併成一張大張的圖 依據每張小圖示給予對應的 class 計算每張小圖在大圖中的絕對位置 取得每張小圖在大圖的絕對位置本身就是一件麻煩事，更麻煩的是如果大圖中要插入新圖，有可能會造成其他小圖需要更新座標 =..=。當然在以前介紹的 Compass 就能達到這些功能，而這次介紹的工具除了 Compass 原有的能力以外，還包含新的功能。 將 SVG 製作成 SVG Sprites 同時提供 .png 版本供舊版瀏覽器使用 同時提供 SVG 對應 HTML 說明文件。 可自訂產生的 CSS 樣式表 使用 SVG Sprites持續更新的範例：https://github.com/Wcc723/gulp-node-sass 這次用的套件是 gulp-svg-sprites，這個套件有個缺點就是 #NOTICE - NOT ACTIVELY MAINTAINED …。不過他滿足我所需的所有功能，所以本篇還是用這個套件。 var gulp = require(&#x27;gulp&#x27;), // svgSprite svgSprite = require(&quot;gulp-svg-sprites&quot;) var paths = &#123; &#x27;source&#x27;: &#x27;./source/&#x27;, &#x27;bower&#x27; : &#x27;./bower_components/&#x27;, &#x27;sass&#x27;: &#x27;./source/stylesheets/&#x27;, &#x27;img&#x27;: &#x27;./source/images/&#x27;, &#x27;public&#x27;: &#x27;./public/&#x27;, &#x27;tpls&#x27;: &#x27;./gulp-tpls/&#x27; &#125; // SVG Sprite gulp.task(&#x27;svg-sprite&#x27;, function() &#123; gulp.src(&#x27;./source/images/sprites/*.svg&#x27;) // 來源路徑 .pipe(plumber()) .pipe(svgSprite(&#123; svg: &#123; sprite: &quot;images/sprites/sprite.svg&quot; // 輸出 svg 路徑 &#125;, cssFile: &#x27;stylesheets/sprite.css&#x27;, //輸出 css 路徑 selector: &quot;icons-%f&quot;, // 前綴詞 templates: &#123; css: require(&quot;fs&quot;).readFileSync(paths.tpls + &#x27;svg-sprite.css&#x27;, &quot;utf-8&quot;) // css 樣板 &#125; &#125;)) .pipe(gulp.dest(paths.public)) .pipe(filter(&quot;**/*.svg&quot;)) .pipe(svg2png()) .pipe(gulp.dest(paths.public)); &#125;); watch(&#x27;./source/images/sprites/*.svg&#x27;, function() &#123; gulp.start(&#x27;svg-sprite&#x27;); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;svg-sprite&#x27;]); 這段程式碼僅是局部，在我的範例內產生的 CSS 會再由 PostCSS 合併。 接下來準備一些 SVG ，其中還加入一張包含漸層的 Skype 圖示 (如果是 icon fonts 就無法直接使用漸層色或是更豐富的色彩)。 輸入 gulp 編譯完會得到 sprite.css、sprite.png、sprite.svg以及sprite.html這些檔案，打開 sprite.html 會看到本次專案 sprites 的說明文件。 這個範例檔可以看到有哪些 Sprites 可以用運用，並且可以切換背景色以及 html code 的提示。 和 Compass 不同在於它是屬於另外產生的CSS，有時候和本身專案的 CSS 可能會有衝突，它也能透過 css template 客制屬於專案的範本。 &#123;#common&#125;.&#123;common&#125; &#123; font-size: &#123;baseSize&#125;px; &#125; .&#123;common&#125;:before &#123; content:&#x27; &#x27;; vertical-align:middle; display: inline-block; background-image: url(&quot;&#123;svgPath&#125;&quot;); background-repeat: no-repeat; background-size: &#123;relWidth&#125;em &#123;relHeight&#125;em; &#125; .no-svg .&#123;common&#125;:before &#123; background-image: url(&quot;&#123;pngPath&#125;&quot;); &#125;&#123;/common&#125; &#123;#svg&#125; &#123;#common&#125;.&#123;common&#125;&#123;/common&#125;.&#123;name&#125;:before &#123; background-position: &#123;relPositionX&#125;em &#123;relPositionY&#125;em; width: &#123;relWidth&#125;em; height: &#123;relHeight&#125;em; &#125; &#123;/svg&#125; 注意在製作 SVG 時，建議使用 Sketch 或 Affinity Designer 軟體，Adobe Illustrator 在轉 SVG 有可能會產生錯誤的格式造成無法製作 Sprites 。 Illustrator 會將漸層轉成 Base64 ，並非 SVG的漸層 本篇介紹的是 SVG Sprites，適合用在有色彩的圖案上，如果說專案只需要單色的圖示，建議可以使用 icon fonts 就可以了，icon fonts 的文章可以參考 將 Sketch icons 轉成 web icon fonts。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"Compass 替代方案(2) - 透過 PostCSS，停止加入不必要的 prefix","slug":"replace-compass-with-node-sass-2","date":"2015-12-24T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/12/25/replace-compass-with-node-sass-2/","link":"","permalink":"https://wcc723.github.io/sass/2015/12/25/replace-compass-with-node-sass-2/","excerpt":"承上篇，因為 compass 很久沒維護，所以在找替代方案。而這篇是要介紹很火紅的 post-css，主要是要解決 css3 prefix 的問題，post-css和 sass 不同的是，在 prefix 的方法不需要先定義成 @mixin ，可以在事後再決定是否加入 prefix，這讓不斷在更新改變的 prefix 流程簡化很多，並且可以有效減少 css 的檔案大小 (prefix 是很肥大的)。 Prefix 的減少速度也是相當快速，像是 box-shadow 的 Prefix 可能消失超過一年， transform 也大約一年左右不需要 Prefix，如果不想要明年慢慢的移除自己所種的 Prefix，或許可以參考看看 post-css的 autoprefixer 工具。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～","text":"承上篇，因為 compass 很久沒維護，所以在找替代方案。而這篇是要介紹很火紅的 post-css，主要是要解決 css3 prefix 的問題，post-css和 sass 不同的是，在 prefix 的方法不需要先定義成 @mixin ，可以在事後再決定是否加入 prefix，這讓不斷在更新改變的 prefix 流程簡化很多，並且可以有效減少 css 的檔案大小 (prefix 是很肥大的)。 Prefix 的減少速度也是相當快速，像是 box-shadow 的 Prefix 可能消失超過一年， transform 也大約一年左右不需要 Prefix，如果不想要明年慢慢的移除自己所種的 Prefix，或許可以參考看看 post-css的 autoprefixer 工具。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～ 什麼是 PostCSSSass、Less、Stylus 這些工具稱為預處理器，意指本身無法被直接使用，需要再編譯的語言，編譯後就能夠被瀏覽器渲染，副檔名也會從 .sass 改為 .css；而 post-css 本身就是 .css，只是透過工具去優化目前的 CSS。 目前 post-css 的社群就已經相當龐大，有許多插件也廣泛地被使用，如： autoprefixer: 可以加入 css3 prefix，甚至自訂 prefix 時代版本，或者是特定瀏覽器 lost: grid system 工具，直接在 CSS 內寫類似 susy 的 grid cssnext: css 界的 ES6，讓你可以寫下一代的 CSS (可參考：http://cssnext.io/features/) precss: 讓你可以在 css 內寫類似 sass 的語法 (例如：巢狀) 相關的插件是非常非常多的，這篇只會介紹 prefix ，如果有興趣的可以看 PostCSS Plugins。仔細看他的插件…，其實說他是另一種 sass 也不為過了…。 使用 postcss autoprefixer持續更新的範例：https://github.com/Wcc723/gulp-node-sass 會選擇引入 autoprefixer 主要是因為 compass 很久沒更新，許多 prefix 已經沒在使用，如果要自己一個一個設定也需要花很多時間。像是 Bootstrap 3 sass 版本，也是由開發團隊寫 prefix @mixin，這都面臨相同的問題 “專案的 CSS Prefix 到底是哪個時代啊!?” 。 最近為了客制 Bootstrap 3 刪 Prefix 也是刪的很累啊… var gulp = require(&#x27;gulp&#x27;), // PostCSS postcss = require(&#x27;gulp-postcss&#x27;), autoprefixer = require(&#x27;autoprefixer&#x27;); // postCSS 的套件原則上都是要一個一個載入 var paths = &#123; &#x27;source&#x27;: &#x27;./source/&#x27;, &#x27;bower&#x27; : &#x27;./bower_components/&#x27;, &#x27;sass&#x27;: &#x27;./source/stylesheets/&#x27;, &#x27;img&#x27;: &#x27;./source/images/&#x27;, &#x27;public&#x27;: &#x27;./public/&#x27;, &#x27;tpls&#x27;: &#x27;./gulp-tpls/&#x27; &#125; // postCSS gulp.task(&#x27;css&#x27;, function () &#123; // 在 processors 內定義需要用哪些套件，這邊只有使用 autoprefixer var processors = [ autoprefixer(&#123;browsers: [&#x27;last 1 version&#x27;]&#125;) ]; watch(paths.public + &#x27;stylesheets/**/**.css&#x27;, function()&#123; gulp.src(paths.public + &#x27;stylesheets/**/**.css&#x27;) .pipe(plumber()) .pipe(concat(&#x27;all.css&#x27;)) .pipe(postcss(processors)) .pipe(gulp.dest(paths.public + &#x27;./css&#x27;)); &#125;); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;css&#x27;]); 這段程式碼僅是局部，在我的範例內是由 node-sass 編譯完再由 post-css 處理。 就已最新版的瀏覽器設定來說，其實大部分 prefix 其實都已經不用加入了，如：flex、transform、backgroud等，就下面的範例來說，只有 filter 需要 prefix。 如果說，產品的使用者客群略微廣些，只要大於一個百分比的使用者都需要重視，可以修改插件的設定檔，如下 (市佔率大於 1%，且連IE 7 都不放過)。 var processors = [ autoprefixer(&#123;browsers: [&apos;&gt; 1%&apos;, &apos;IE 7&apos;]&#125;) ]; 那麼如果有支援的 prefix 他都會加入，會得到以下結果： 其實會發現，-moz-、-o-這些也不存在啊啊啊啊，Oprea 已經改用webkit，Firefox 強制更新，目前市面上的版本不需要 Prefix。 線上玩玩 PostCSS另外 Codepen 也有提供 post-css 的環境，只要在 CSS 的區域下選擇設定 &gt; CSS Preprocessor &gt; PostCSS 就可以使用 @use 加入想使用的 post-css 插件。 如下圖，透過 @use cssnext; 就可以使用 cssnext 插件。 結語Autoprefixer 是目前 post-css 看到最必須導入的工具，有效減少 prefix 的問題。其他的工具 cssnext、lost等等，目前僅會做測試或研究並不會導入。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"Compass 替代方案(1) - 更快速的 Sass","slug":"replace-compass-with-node-sass","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/12/20/replace-compass-with-node-sass/","link":"","permalink":"https://wcc723.github.io/sass/2015/12/20/replace-compass-with-node-sass/","excerpt":"Compass 是一套非常優秀的 Sass 擴充套件，從剛開始學 Sass 就一直用到現在，許多優點是一般 CSS 或 Sass 較難達到的，如： CSS Sprites：可以將圖片轉成Sprite，並提供 CSS class。 CSS3 mixin：prefix 啊～ Vertical Rhythm：CSS 文字排版的救星。 image-url, image-size：圖片路徑的取代以及取得圖片的尺寸。 但現在有些問題讓我考慮放棄使用 Compass 如： 很久沒更新，距離上次更新已將近一年 基於ruby sass，效能較差，編譯速度慢 因為久沒更新，很多 css3 @mixin 已不符合現在規範 CSS Sprites 沒有 SVG 版本 接下來會連續幾篇開始介紹透過 Node sass 取代 Compass 的相關技術研究，當然 Compass 不會馬上被取代，但也要準備好替代方案，畢竟工具只是要增加產能使用，並非一定要追最新的才行。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～","text":"Compass 是一套非常優秀的 Sass 擴充套件，從剛開始學 Sass 就一直用到現在，許多優點是一般 CSS 或 Sass 較難達到的，如： CSS Sprites：可以將圖片轉成Sprite，並提供 CSS class。 CSS3 mixin：prefix 啊～ Vertical Rhythm：CSS 文字排版的救星。 image-url, image-size：圖片路徑的取代以及取得圖片的尺寸。 但現在有些問題讓我考慮放棄使用 Compass 如： 很久沒更新，距離上次更新已將近一年 基於ruby sass，效能較差，編譯速度慢 因為久沒更新，很多 css3 @mixin 已不符合現在規範 CSS Sprites 沒有 SVG 版本 接下來會連續幾篇開始介紹透過 Node sass 取代 Compass 的相關技術研究，當然 Compass 不會馬上被取代，但也要準備好替代方案，畢竟工具只是要增加產能使用，並非一定要追最新的才行。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～ Compass 可以被取代的部分Compass 功能那麼多，說實在要取代全部還真的不容易，另一方面就算取代了全部功能，也不一定容易上手，所以打算先從經常使用的功能去改變，並且適應看看。 CSS Sprites：這部分我從 gulp 中找到 svg sprites，稍微改寫一下就足以替代。 CSS3 mixin：這是Compass的一大特色，但也是令人詬病的地方，因為久沒更新許多 prefix 早已有改變，這部分我從 post-css 找到了解決方案。 Vertical Rhythm：還未解決。 image-url, image-size：通常取用image-url是用來做icon、背景圖，這部分如果可以用svg-sprites就可以解決，但如果是為了達到一些視覺效果必須使用 image-size 那就還沒有辦法了…。 clearfix, inline-block 等現成的mixin：還未解決，靠 Sass 的架構去處理。 目前這些解決方案都還在研究中，也會分幾篇介紹這些方法的優缺點，這篇會先介紹 node-sass。 node-sass持續更新的範例：https://github.com/Wcc723/gulp-node-sass 在Bootstrap 3的時候，開發團隊選擇 Less 作為開發環境，其中一個原因是 Sass 編譯速度太慢了，後來 sass 提供了 lib-sass，讓不同的環境都可以運行sass，其中也包含了 node-sass ，因此現在 Bootstrap 4 也改為 sass 開發。 Moved from Less to Sass. Bootstrap now compiles faster than ever thanks to Libsass, and we join an increasingly large community of Sass developers.http://blog.getbootstrap.com/2015/08/19/bootstrap-4-alpha/ 如果說不使用 Compass， node-sass 將是一個不錯的選擇，我也嘗試使用 node-sass 編譯與 ruby-sass 編譯做比較，是相當有感的…(有些較具規模的compass專案會到達10秒以上的編譯時間)。 Your browser does not support the video tag. 影片中同時編譯 Bootstrap sass 版本，左邊是 node-sass，右方是 ruby-sass，都有包含sourcemaps，由於是同一個資料夾，所以是同時開始編譯。 就編譯時間來看，大概都是 2 ~ 4，不過單位不同…，node-sass是 毫秒，ruby-sass是 秒。 使用 node-sass 可以參考 gulp-sass，另外在監控可以使用 gulp-watch，讓新增刪除檔案時也會被監控到。 var gulp = require(&#x27;gulp&#x27;), plumber = require(&#x27;gulp-plumber&#x27;), sass = require(&#x27;gulp-sass&#x27;), watch = require(&#x27;gulp-watch&#x27;); // Paths var paths = &#123; &#x27;source&#x27;: &#x27;./source/&#x27;, &#x27;bower&#x27; : &#x27;./bower_components/&#x27;, &#x27;sass&#x27;: &#x27;./source/stylesheets/&#x27;, &#x27;img&#x27;: &#x27;./source/images/&#x27;, &#x27;public&#x27;: &#x27;./public/&#x27;, &#x27;tpls&#x27;: &#x27;./gulp-tpls/&#x27; &#125; // Sass gulp.task(&#x27;sass&#x27;, function() &#123; gulp.src([paths.sass + &#x27;**/**.scss&#x27;]) .pipe(plumber()) .pipe(sass(&#123;outputStyle: &#x27;nested&#x27;&#125;) .on(&#x27;error&#x27;, sass.logError)) .pipe(gulp.dest(paths.public + &#x27;./stylesheets&#x27;)) &#125;); watch([paths.sass + &#x27;**/**.scss&#x27;], function() &#123; gulp.start(&#x27;sass&#x27;, &#x27;scss-lint&#x27;); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;sass&#x27;]); 持續更新的範例：https://github.com/Wcc723/gulp-node-sass 接下來還會介紹 sass-lint、gulp-svg-sprites、gulp-postcss，對於以上有其他建議也歡迎一起在下方留言。 另外…Webm真是好物，中間的那個短片就是webm，不到1mb的影片甚至比gif還小。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"被討厭的勇氣","slug":"be-your-self","date":"2015-12-11T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"life/2015/12/12/be-your-self/","link":"","permalink":"https://wcc723.github.io/life/2015/12/12/be-your-self/","excerpt":"你過得快樂嗎？如果不快樂，代表你不夠在乎你自己。 “被討厭的勇氣”是我今年看過最值得閱讀的一本書，書中的引言有許多人提到為何沒有早一點看到這本書，在我讀完以後也會有這樣的感覺，可見內容之精彩。 本書的內容是以故事性的方式呈現，大綱是一位哲學家與具有反社會心態的年輕人對話，在不同的夜裡年輕人不斷挑戰哲學家的阿德勒學說，在這一正一反的對話內容，更能凸顯出本書的內容以及古代哲學對話與辯論的精神。 在這書中有幾個段落對我啟發很深： 心理創傷並不存在 屬於別人的課題 尋找自己的歸屬感 認真地活在當下，人生的價值就在於此","text":"你過得快樂嗎？如果不快樂，代表你不夠在乎你自己。 “被討厭的勇氣”是我今年看過最值得閱讀的一本書，書中的引言有許多人提到為何沒有早一點看到這本書，在我讀完以後也會有這樣的感覺，可見內容之精彩。 本書的內容是以故事性的方式呈現，大綱是一位哲學家與具有反社會心態的年輕人對話，在不同的夜裡年輕人不斷挑戰哲學家的阿德勒學說，在這一正一反的對話內容，更能凸顯出本書的內容以及古代哲學對話與辯論的精神。 在這書中有幾個段落對我啟發很深： 心理創傷並不存在 屬於別人的課題 尋找自己的歸屬感 認真地活在當下，人生的價值就在於此 心理創傷並不存在(在博客來上就可以閱讀到這一段…預覽) 我也是在博客來上看完後就覺得很棒，就買了這本書，書中的其中一句話：「不要由經驗來決定自我，而是由我們賦予經驗的意義來決定」。每個人都有不同的過去經驗，不好的過去還特別容易被記住，過去的經驗也足以影響現在，但經驗的好壞可由當下的想法去改變。 好比說兒童時期家境不佳，雖然餓不死但也沒吃過什麼好料，現在的當下可以有不同的想法如： 小時候家境不好，認為輸人太多，怎樣也追不上富二代。 小時候沒什麼錢，了解家境不好是什麼感覺，所以要更加努力去改變它，並且去幫助需要幫助的人。 這是一個常見的故事，雖然過去會影響現在，但真正支配者是現在的自己，並非過去的自己，不同的想法就足以改變未來。 屬於別人的課題我常常會不能理解別人的想法，就像是對於宗教狂熱、政治狂熱、政治上的惡人(!?)，或者是在生活上、工作上總是會遇到許多不易理解的人，其中也包含自己熟悉的人。在本書中有提及，所有人都是做自己認為善的事情，”善”不一定是好的事情，而是自己認為”對”的事情，每個人生活背景不同、學習過程不同，所以在善的理解上一定也不同。 如果當自己的想法與別人的善不同時，可以試著與對方溝通，但沒必要強迫對方理解，而是可以與對方分享自己的善，因為對方能不能接受是對方的課題。就如同書中的哲學家一樣，他不會要年輕人立刻接受他的想法，而是慢慢地分享想法，讓年輕人從中思考，最後他也能發展屬於自己的善。 同樣的再對別人的好，也不能去要求對方的回饋，因為對方是否回饋，是屬於對方的課題，我們只要做好自己認為有價值的事情，讓自己心中感到滿足就好。 每個人的生活環境不同，會有不同理解的善 不必想要說服他人，只要和他人分享自己的善即可 對於他人的回報是屬於他人的課題，我們只需做好自己認為有價值的事情 尋找自己的歸屬感很高興你看到了現在還沒離開，這段想先問個問題： 對於目前的家庭、情人、工作、朋友、群體是否感到自在？ 如果對於目前有感到不自在的環境，過去是否有更好的經驗？ 一直以來我想要追求更好的生活，想要賺更多的錢、領更多的薪水，也因此離開原有的環境，但現在卻覺得無聊、乏味，沒辦法表現出自我。在書中也就介紹到了，如果你無法在目前環境感受到自在，代表無法從中獲得歸屬感…。 而朋友、戀人也是相同的道理，每個人不一定能夠選擇最完美的戀人，只要能夠選擇到讓你感到自在的，就是合適的。 認真地活在當下，人身的價值就在於此大家或許都會對過去或目前的生活不夠滿意，不斷的思考未來要怎麼發展，學生時代想著如果考上大學期許以後能有好工作，上班後也不斷的在思考怎樣進入大公司或者職位的晉升。 但其實最美好的時間就在當下，我們必須去體驗現在所發生的任何美好，當然這本書也不是在鼓勵人自私，每個時間點都值得所有人去舞動，讓當下活得更有價值，書中舉例說：人生就像登山攻頂，而人生就像是在半路上。我認為更像是沒有盡頭的成長，只要做好每個當下，每天成長一點點，就是美好的人生。 後來我還買了另一本書，”什麼都能賣出好價錢：頂尖經紀人教你賣什麼都讓人買單“，在看了本書的第一章會認為與”被討厭的勇氣”有許多相似的地方，書中開頭就提到先別管行銷了──第一步該是找到你自己，這樣的開頭以及”被討厭的勇氣”讓我感受到自己的重要性，這樣的生活不僅自由，而且充滿了價值。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"客製化屬於你的 Bootstrap 4","slug":"bootstrap-and-compass","date":"2015-11-30T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/12/01/bootstrap-and-compass/","link":"","permalink":"https://wcc723.github.io/sass/2015/12/01/bootstrap-and-compass/","excerpt":"Bootstrap 是目前最流行的CSS Framework，第四版也釋出了開發版本，無論第幾版對於工程師來說 Bootstrap 就是那麼的容易上手，但扯上設計就要多多配合了，不同身份看待 Bootstrap 也有不同看法，例如： 設計師：Bootstrap 很醜誒，你看那個濁濁的顏色 (當然每個設計師觀點不同啦…)。 前端：Bootstrap 要配合設計師的稿，似乎有點麻煩…(看著對不上的Grid system)。 後端：不是都長一樣嗎？ 其實Bootstrap的設定檔就有許多細節可以調整，不需要 Overwite，載入前就可以先調整，而且並不是一定要全部元件載入，可以只使用部分的元件，靈活的使用框架，才能發揮更大的價值。","text":"Bootstrap 是目前最流行的CSS Framework，第四版也釋出了開發版本，無論第幾版對於工程師來說 Bootstrap 就是那麼的容易上手，但扯上設計就要多多配合了，不同身份看待 Bootstrap 也有不同看法，例如： 設計師：Bootstrap 很醜誒，你看那個濁濁的顏色 (當然每個設計師觀點不同啦…)。 前端：Bootstrap 要配合設計師的稿，似乎有點麻煩…(看著對不上的Grid system)。 後端：不是都長一樣嗎？ 其實Bootstrap的設定檔就有許多細節可以調整，不需要 Overwite，載入前就可以先調整，而且並不是一定要全部元件載入，可以只使用部分的元件，靈活的使用框架，才能發揮更大的價值。 如何開始這個範例會使用 Node.js, Gulp, Compass 所以請先確定有以上環境，其中最重要的是 Compass，有Compass環境，也是可以達到相同的效果。 本篇範例需要以下環境 Ruby compass 1.0 + Node.js Bower Gulp 先運行一次，從中瞭解運作認真的範例：https://github.com/Wcc723/gulp-compass-bootstrap-demo 下載這個範例，目前的結構如下： |- package.json # gulp 的套件管理 |- gulpfile.js # gulp 執行檔案 |- config.rb # compass 設定檔 (重要) |- bower.json # Bower 套件管理 (載入Bootstrap) |- source # 專案資料夾 |- index.html # 範例檔 |- scss # sass 範例檔 |- all.scss |- helper |- variables.scss # Sass 設定檔 在nodejs環境下執行以下指令 $ npm install $ bower install $ gulp 檔案結構改變如下 |- package.json # --- |- gulpfile.js # --- |- config.rb # --- |- bower.json # --- |- bower_components # Bower 下載的套件資料夾 (Bootstrap, Jquery) |- node_modules # node 模組資料夾，這個範例主要是 gulp |- source # --- |- index.html # --- |- scss # --- |- public # ** 編譯完的檔案夾 ** |- index.html # copy 過來的 |- stylesheets # 編譯後的 CSS 在這 |- js # jQuery.js 與 Bootstrap.js 的合併檔 接下來打開/public/index.html可以看到主色被改成 purple，這就是被調整變數後的 Bootstrap，通常網站的設計都會有一個主要色，只要調整_variables.scss中的 $brand-primary，就可以定義Bootstrap的主要顏色。 針對一個變數($brand-primary)調整，按鈕的顏色從藍色被修改成紫色。 打開 config.rb載入 bower bootstrap 的關鍵在於config.rb內的 additional_import_paths，這是 compass 載入外部 sass 檔案的方法，透過這個方法引用 Bootstrap 就像是本地端資料夾引用一樣。 # 匯入 Bootstrap v4 additional_import_paths = &quot;./bower_components/bootstrap/scss/&quot; 調整變數Bootstrap 的變數在 bower_components\\bootstrap\\scss\\_variables.scss，直接複製此檔案到 source\\scss\\ 內。 我的習慣架構是放在 source\\scss\\helpers\\_variables.scss。 以基本色彩來說，原始檔案內會有變數 + 值 + !default，修改只要加入新的值，並移除 !default 即可。 $brand-primary: #0275d8 !default; $brand-success: #5cb85c !default; $brand-info: #5bc0de !default; $brand-warning: #f0ad4e !default; $brand-danger: #d9534f !default; 接下來可以看看範例檔案，我調整了其中一個顏色，再載入後，Sass 就會以我的設定檔為優先去編譯它。 m…，其實我是打算顏色全部換掉，後來發現我只加了紫色。 $brand-primary: purple; $brand-success: #5cb85c; $brand-info: #5bc0de; $brand-warning: #f0ad4e; $brand-danger: #d9534f; 當會修改顏色以後，可以在看Bootstrap有提供多少的變數供修改。 注意：這份是複製檔，並非最新版 Bootstrap的設定檔 自定載入元件Bootstrap 是一個良好OOCSS範例，所有的CSS元件都模組化，基本上分為以下幾大類型。 變數 (Core variables and mixins)：這邊是基本設定，建議載入 重置 (Reset and dependencies)：主要是讓HTML標籤樣式一致，建議載入，有需求可透過變數修改 核心 CSS (Core CSS)：主要、常用的 CSS 元件 (Components)：基於核心或是Web經常使用的CSS元件，可以選擇是否載入 JavaScript 套件 (Components w/ JavaScript)：好用的 Bootstrap js 套件，如果沒有需求可以不載入 雜項 (Utility classes)：主要是單一的CSS樣式，建議載入 接下來再打開 source\\scss\\all.scss，Sass載入 Bootstrap 的方式也有兩種，一種是全部載入，另一種是載入特定元件。 如果要移除不要的元件，請選擇方法二，並將不要的元件直接刪除或是註解即可 // import 自己的變數 @import &quot;helpers/variables&quot;; // **** 方法一：載入全部的Bootstrap 4 **** // // // @import &quot;bootstrap&quot;; // **** 方法二：自選要的元件 **** // // // Core variables and mixins @import &quot;variables&quot;; @import &quot;mixins&quot;; // Reset and dependencies @import &quot;normalize&quot;; @import &quot;print&quot;; // Core CSS @import &quot;reboot&quot;; @import &quot;type&quot;; @import &quot;images&quot;; @import &quot;code&quot;; @import &quot;grid&quot;; @import &quot;tables&quot;; @import &quot;forms&quot;; @import &quot;buttons&quot;; // Components @import &quot;animation&quot;; @import &quot;dropdown&quot;; @import &quot;button-group&quot;; @import &quot;input-group&quot;; //...... 略 Bootstrap 是很重視行動版的框架，但有時在行動版上，有時少可以再更少，如果想減少載入的 CSS 不妨從元件、js套件上開始移除。 優缺點這樣做法可以節省大量的時間，並且減少CSS的錯誤(相容性、延展性等等)，但有些問題也是必須去思考： 優點： 快速建置 相對穩定 減少對不上的問題 (相信很多人有 input 和 button 對不上的問題) 工程師套用容易 缺點 環境建置學習成本較高 雖然可以自訂，但想法容易被侷限 必須花一定的時間成本學習 Bootstrap (尤其是需要自定義元件時) Bootstrap 4 觀察了一段時間，裡面許多的概念很喜歡，包括 flex、navbar、Utilities 這些的改進…，當然更重要的是從LESS轉到SASS(雖然他用的是node sass lib，但我總是用 ruby sass 去載入)。 不過也有一點真心覺得麻煩，就是他的單位許多改成用rem，em、rem、px轉來轉去，我不是數學腦啊!!!","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"過去的學習 每天一分享","slug":"ashareaday","date":"2015-11-27T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"tools/2015/11/28/ashareaday/","link":"","permalink":"https://wcc723.github.io/tools/2015/11/28/ashareaday/","excerpt":"很多人會問我設計師怎麼轉工程師，主要的方式當然是每天練啊！ (故事回到了2013…)當時會的不多，基本的CSS(還有一些些sass)、簡單的jquery，不會任何框架，所有的技術都很基本，那時給自己的目標是連續一百天發文…。","text":"很多人會問我設計師怎麼轉工程師，主要的方式當然是每天練啊！ (故事回到了2013…)當時會的不多，基本的CSS(還有一些些sass)、簡單的jquery，不會任何框架，所有的技術都很基本，那時給自己的目標是連續一百天發文…。 一個奇怪的 SPASPA(sigle page application)這種名詞也是現在才知道，當時只是想要快速建立一個站點，讓我方便練習技術，所以就花一天的時間透過Javascript寫出怪異的Blog。 當時也不會 git，更別說github，所以網站是放在自己買的空間上，而空間後來也就沒有再付費，所以就關閉了…。 A share a day這個網站我稱為 Ashareaday，用意就是為了每天分享，就算是只有一點點，也要持續的進步。網站後來的主要內容大多都被轉移到現在這部落格上，所以也就沒有再將它建立起來。 現在，有人詢問我怎麼開始學習前端時，總是會想到這一個站，所以現在轉移到 Github Page 上，如果有人詢問時，可以再繼續分享這樣的過去。 網站連結：http://wcc723.github.io/ashareaday/","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"更棒的 Jekyll 編寫工具","slug":"better-jekyll-markdown-editor","date":"2015-11-24T16:00:00.000Z","updated":"2016-10-13T06:29:40.000Z","comments":true,"path":"tools/2015/11/25/better-jekyll-markdown-editor/","link":"","permalink":"https://wcc723.github.io/tools/2015/11/25/better-jekyll-markdown-editor/","excerpt":"這個Blog也維持很長一段時間了，曾經會想要放棄維護轉到其它平台，主要原因是Jekyll上稿有些麻煩的地方，其中一項最痛的就是上圖…。在上圖之前，都必須先將圖片放到/images，接下來再手動寫相對位置，如果圖片要換，就必須再打開/images資料夾，一來一往必須花很多時間。 最近發現了Atom編輯器有套件可以自動把圖片搬移到該資料夾，並且還有許多Jekyll的輔助功能，讓我可以更專注於Blog的文章內容。 如果您跟我一樣是 Jekyll 的使用者，相信你會很喜歡這編輯工具。 圖片來自於 Atom 官網","text":"這個Blog也維持很長一段時間了，曾經會想要放棄維護轉到其它平台，主要原因是Jekyll上稿有些麻煩的地方，其中一項最痛的就是上圖…。在上圖之前，都必須先將圖片放到/images，接下來再手動寫相對位置，如果圖片要換，就必須再打開/images資料夾，一來一往必須花很多時間。 最近發現了Atom編輯器有套件可以自動把圖片搬移到該資料夾，並且還有許多Jekyll的輔助功能，讓我可以更專注於Blog的文章內容。 如果您跟我一樣是 Jekyll 的使用者，相信你會很喜歡這編輯工具。 圖片來自於 Atom 官網 如何使用在開始前，必須先安裝Atom，這是Github所開發的編輯器，大致上與 sublime text 3 相當接近，但對於套件的管理更為直覺，而且還可以容易的安裝各種 Theme(?。本篇就是要介紹他其中一個套件Markdown-Writer。 安裝 Atom 安裝 Markdown-Writer 所以先到Atom的官網下載 Atom 安裝吧。 安裝 Markdown-WriterAtom 的使用相當直覺，只要直接選擇 Perferences(cmd + ,)就可以打開設定，其中就可以找到套件安裝(Install Packages)，如下圖就可以搜尋到Markdown-Writer，再按下 install 就會開始安裝(這邊我已經裝囉)。 設定 Markdown-Writer設定最重要的…Blog路徑，這如果沒有設定，等等也玩不下去。一樣在設定內可以找到 Packages，列表上可以找到剛剛安裝的 Markdown-Writer。 Site Local Directory 這就是必要的設定，這請填入 Jekyll Blog 的本地位置。 在開始使用前，在介紹一下快捷鍵的設置。在 command(cmd + shift + p) 執行 Markdown Writer: Create Default keymaps。 再把下面的 code 找地方貼進去，這樣就可以運行 Markdown Writer 所提供的快捷鍵。 &quot;.platform-darwin atom-text-editor[data-grammar~=&apos;gfm&apos;]&quot;: &quot;shift-cmd-K&quot;: &quot;markdown-writer:insert-link&quot; &quot;shift-cmd-I&quot;: &quot;markdown-writer:insert-image&quot; &quot;cmd-i&quot;: &quot;markdown-writer:toggle-italic-text&quot; &quot;cmd-b&quot;: &quot;markdown-writer:toggle-bold-text&quot; &quot;cmd-&apos;&quot;: &quot;markdown-writer:toggle-code-text&quot; &quot;cmd-k&quot;: &quot;markdown-writer:toggle-keystroke-text&quot; &quot;cmd-h&quot;: &quot;markdown-writer:toggle-strikethrough-text&quot; &quot;ctrl-alt-1&quot;: &quot;markdown-writer:toggle-h1&quot; &quot;ctrl-alt-2&quot;: &quot;markdown-writer:toggle-h2&quot; &quot;ctrl-alt-3&quot;: &quot;markdown-writer:toggle-h3&quot; &quot;ctrl-alt-4&quot;: &quot;markdown-writer:toggle-h4&quot; &quot;ctrl-alt-5&quot;: &quot;markdown-writer:toggle-h5&quot; &quot;shift-cmd-O&quot;: &quot;markdown-writer:toggle-ol&quot; &quot;shift-cmd-U&quot;: &quot;markdown-writer:toggle-ul&quot; &quot;shift-cmd-&gt;&quot;: &quot;markdown-writer:toggle-blockquote&quot; &apos;shift-cmd-&quot;&apos;: &quot;markdown-writer:toggle-codeblock-text&quot; &quot;cmd-j cmd-p&quot;: &quot;markdown-writer:jump-to-previous-heading&quot; &quot;cmd-j cmd-n&quot;: &quot;markdown-writer:jump-to-next-heading&quot; &quot;cmd-j cmd-d&quot;: &quot;markdown-writer:jump-between-reference-definition&quot; &quot;cmd-j cmd-t&quot;: &quot;markdown-writer:jump-to-next-table-cell&quot; 使用 Markdown-Writer在建立一個 Markdown 的檔案後，就可以嘗試插入圖片 cmd + shift + i，選擇圖片後，再勾選 Copy Image to Site Image Directory，這樣就能夠把其他位置的圖片直接移動到/images資料夾內，並且會自動新增 年/月 資料夾。 (光是這個功能就足以讓我痛哭流涕…) 其他功能在使用時會感受到，例如： 程式碼標記自動插入頭尾 (`) 快捷鍵控制各種文字標記 ex: cmd + h 文字加入刪除線 還有超多功能可以在設定裡找到…(太多了，記不住) Markdown-Writer 可能出現的錯誤在第一次使用時，可能是Atom版本較舊，所以出現錯誤，這時候建議先更新Atom，並且先 Disabled 套件後解除安裝，再重新安裝 Markdown-Writer 套件。 這段時間也研究了很多部落格平台，考慮的原因也很多，最後決定繼續維護目前的 Jekyll，原因有下： 平台的 Editor 是否好用，難寫的根本撐不下去 (超重要) 平台的費用，平台是否有另外買網址的必要 (github.io 根本潮) 平台的使用者數量 (Jekyll 有 Github 罩) 不論用哪種平台，都必須思考平台未來的發展 (什麼時候會消失，文章是否能匯出) 基於這些原因，最後還是認為 Jekyll 適合我，也因此特別將Blog版型更新了一翻(雖然還有很多Bug Q_Q)…。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"將 Sketch icons 轉成 web icon fonts","slug":"sketch-convert-to-web-icon-fonts","date":"2015-11-19T16:00:00.000Z","updated":"2016-10-13T06:29:11.000Z","comments":true,"path":"tools/2015/11/20/sketch-convert-to-web-icon-fonts/","link":"","permalink":"https://wcc723.github.io/tools/2015/11/20/sketch-convert-to-web-icon-fonts/","excerpt":"在之前轉web font icons 通常是使用Icomoon，他提供不錯的介面以及大量的icons供開發者使用，但有些時候Icomoon並不符合我們的需求，例如： 公司專案，不宜上傳到第三方空間 有版本控管需求時 設計師控制慾很強時(? 而萬能的Sketch及Gulp再合體之後，就有了Sketch to icon fonts 的功能，只要轉一次，同時提供了： icon fonts 字型檔 寫好的css檔 還有HTML使用範本 對於前端以及設計師簡直接就是一大福音。","text":"在之前轉web font icons 通常是使用Icomoon，他提供不錯的介面以及大量的icons供開發者使用，但有些時候Icomoon並不符合我們的需求，例如： 公司專案，不宜上傳到第三方空間 有版本控管需求時 設計師控制慾很強時(? 而萬能的Sketch及Gulp再合體之後，就有了Sketch to icon fonts 的功能，只要轉一次，同時提供了： icon fonts 字型檔 寫好的css檔 還有HTML使用範本 對於前端以及設計師簡直接就是一大福音。 如何使用寫得很清楚的開發文件：https://github.com/cognitom/symbols-for-sketch 在開始前，請先確認有以下環境： Mac 正版的Sketch Node.js 有gulp更好 Sketch 是這次主要來輸出icons的繪圖軟體，由於只能在Mac上運行，所以Mac也是必須的，本文最後會在介紹直接使用.svg轉icon fonts的方法；Node.js是用來運行gulp的環境，如果還沒安裝可以直接到官網下載https://nodejs.org/en/；Gulp是這次的主角，負責將sketch轉成icon fonts的工具，如果熟悉javascript的開發者將會很容易上手，當然不熟也沒關係，本文會用圖文說明以下的步驟。 安裝Node.js如果你還沒安裝Node.js，就到官網找到下載點，目前的版本有4.2.2及5.1.0，不管你是哪個版本，與本次的實作影響都不大。 安裝完以後再打開 Terminal 輸入以下指令，只要有跳出版本號就算成功了(我的版本追不上時代啊～)。 $ node -v 如果還沒安裝gulp，可以順便安裝，指令如下： $ npm install gulp -g 如果不行請加 `sudo` 在前方 $ sudo npm install gulp -g 在npm 前方加入sudo代表最高權限，通常只有在安裝全域(-g, -global)才有可能使用。 下載專案接下來到https://github.com/cognitom/symbols-for-sketch把專案抓下來，如果熟悉git的開發者可以使用git指令將repo抓下來；另一種更潮的方式，就是直接選擇網站上下角的Download zip。 下載後請解壓縮它。 再次打開你的 Terminal，剩下簡單的三步驟就完成了打開Terminal後，請到剛剛下載的資料夾，如果不熟可以參考以下這個指令(我常常把檔案丟桌面，所以以下指令是針對放在桌面上的)。 $ cd /Users/*****/Desktop/symbols-for-sketch-master 安裝node gulp 相依套件這個步驟是要將gulp相依的套件從網路上抓下來，相依套件同時會放在這個資料夾(node_modules)。 $ npm install 安裝Sketch tool這有兩個方法，其中一種是使用指令，但在測試時沒有成功，所以這邊是使用方法二。 方法一：直接輸入以下指令，我沒成功… $ npm run installtool 方法二：先下載http://sketchtool.bohemiancoding.com/sketchtool-latest.zip，解壓縮後到該資料夾，輸入以下指令： $ cd ~/Downloads/sketchtools/ $ sudo ./install.sh 將Sketch轉成icon fonts最後，透過gulp指令結束這個回合吧！ $ gulp symbols 到剛剛的資料夾，資料夾內增加了dist以及編譯完成的字型檔、CSS以及範例的html。 範例的HTML可以看到成果。 將.svg 轉成icon fonts以上的Sketch轉icons如果有成功，接下來的.svg轉icons也是相當容易，只要用相同的模組改幾行程式碼就可以運行。不過要注意的是這有可能編譯失敗(原因很多，包含svg的檔案也有可能造成編譯失敗)。 這邊是使用Google Material Design 所提供的 icon，直接放在剛剛的資料夾內即可。 接下來打開gulpfile.js，找到以下幾行替換成gulp.src([&#39;./svg/*.svg&#39;]) (路徑可以自行決定)。 gulp.task(&#x27;symbols&#x27;, function()&#123; //gulp.src(&#x27;symbol-font-14px.sketch&#x27;) // 將原本轉換sketch的改成轉svg //.pipe(sketch(&#123; // export: &#x27;artboards&#x27;, // formats: &#x27;svg&#x27; //&#125;)) gulp.src([&#x27;./svg/*.svg&#x27;]) &#125;) 和先前的一樣，在 Terminal 輸入 $ gulp symbols 就可以了。 $ gulp symbols 完成～ 在以前都是使用 Icomoon 的服務再轉 web fonts，最早的時候還忘記要登入，結果整份 web fonts資料都要重建，透過這樣的工具可以自己轉、自己做版控，除了CDN的問題外，倒是挺方便的。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"},{"name":"icon fonts","slug":"icon-fonts","permalink":"https://wcc723.github.io/tags/icon-fonts/"},{"name":"sketch","slug":"sketch","permalink":"https://wcc723.github.io/tags/sketch/"}]},{"title":"SVG 客製化 checkbox","slug":"styling-checkbox","date":"2015-10-18T16:00:00.000Z","updated":"2016-10-13T06:28:27.000Z","comments":true,"path":"tools/2015/10/19/styling-checkbox/","link":"","permalink":"https://wcc723.github.io/tools/2015/10/19/styling-checkbox/","excerpt":"先前有看到酷炫的checkbox效果，一直想要做看看，最近在整理資料的時候發現還沒做(因為坑還很多)，這次就來介紹這樣的效果要怎麼完成。","text":"先前有看到酷炫的checkbox效果，一直想要做看看，最近在整理資料的時候發現還沒做(因為坑還很多)，這次就來介紹這樣的效果要怎麼完成。 在很久之前有寫一篇文章，是透過svg的stroke做動態描繪效果(CSS + SVG stroke動態描繪)，本篇也是利用類似的方法達成，另外還有參考一些文章。 參考 http://tympanus.net/Development/AnimatedCheckboxes/ http://blogs.adobe.com/dreamweaver/2015/08/css-vs-svg-styling-checkboxes-and-radio-buttons.html 先準備svg 這一個範例的重點還是在svg，最簡單的產生方式還是使用向量繪圖軟體繪製，在這個範例上是透過sketch繪製 50px * 50px的手繪風格路徑，在繪製的時候有些部分還是需要注意： 圖片大小與實際圖最好一樣大 盡量一個筆畫到底，如果兩個筆畫要做出先後效果，可以設定 transition delay 路徑的頭尾先後與繪製的先後順序有關 再轉成svg後僅需要原始碼，所以請用文字編輯器打開 .svg，接下可以參考以下的HTML結構，把 .svg的內容置入。 &lt;input type=&quot;checkbox&quot; id=&quot;checkbox&quot;&gt; &lt;label for=&quot;checkbox&quot; class=&quot;label&quot;&gt; Click me &lt;svg width=&quot;50px&quot; height=&quot;50px&quot; viewBox=&quot;0 0 50 50&quot; class=&quot;checkbox-draw&quot;&gt; &lt;!-- 剛剛轉出的svg請放這 --&gt; &lt;/svg&gt; &lt;/label&gt; CSSCSS的重點一個部分是checkbox的選取器，透過 :checked ~ 來控制後方的svg動畫是否啟用。 另一個重點就是 stroke-dashoffset: 500; 及 stroke-dasharray: 500; ，這就是效果繪製的重點，相關的細節可以參考http://wcc723.github.io/svg/2014/06/15/svg-css-stroke-animation/，只要將stroke-dashoffset的值修改為0，就會有描繪動畫的效果。 #checkbox &#123; opacity: 0; width: 50px; height: 50px; &#125; .label &#123; position: relative; display: inline-block; padding-left: 50px; cursor: pointer; font-size: 36px; &#125; .checkbox-draw &#123; width: 50px; height: 50px; position: absolute; left: -50px; top: 0; border: 2px solid white; &#125; .checkbox-draw path&#123; stroke-dashoffset: 500; stroke-dasharray: 500; transition: stroke-dashoffset .5s linear; &#125; #checkbox:checked ~ label .checkbox-draw path &#123; stroke-dashoffset: 0; &#125; 完成效果記得點一下看效果唷。 範例網址","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"Hotjar 網站熱圖","slug":"hotjar-heat-map","date":"2015-10-06T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"tools/2015/10/07/hotjar-heat-map/","link":"","permalink":"https://wcc723.github.io/tools/2015/10/07/hotjar-heat-map/","excerpt":"Hotjar 是監視網站使用者資訊的工具，提供 Heatmap、Recording、Funnels、Forms 四種監測服務，透過這四種服務可以分析使用者行為，判斷使用者操作是否符合預期。","text":"Hotjar 是監視網站使用者資訊的工具，提供 Heatmap、Recording、Funnels、Forms 四種監測服務，透過這四種服務可以分析使用者行為，判斷使用者操作是否符合預期。 服務：https://www.hotjar.com/ 註冊在註冊時分為兩個步驟，第一階段是一般註冊資訊，第二階段會要求建立要監測的站台，如果還沒有站台，其實先隨意填也沒關係，在註冊後還是可以修改。 測試 heatmap登入到Dashborad後，他會要求在網站內加入一段 &lt;script&gt; ，這段需要有在線上的網站才能夠運行，本文先以這 http://wcc723.github.io/ 做為測試，將以下 &lt;script&gt; 加入網站的主版。 另外加入後，他會有一個 驗證script 按鈕，驗證網頁是否有正確加入，如果正確就會詢問出現以下畫面，讓開發者選擇服務。 接下來開一個 Heatmap 服務，操作上也相當容易，只要填入名稱、網址即可。 接下來靜置個一段時間…，不然就是自己動手測試(Blog太久沒更新流量降低 orz…)就可以獲得一些些data。 最後就可以獲得以下的熱點圖，而目前這個blog版型是使用 Material design lite，在scroll上有些bug，因此監測scroll的準確度很低，如果要正常使用，網頁的scroll也必須注意。 Manage up to 3 Heatmaps with Hotjar Basic. Need more? Delete old Heatmaps or go unlimited. 基本版提供三個Heatmap服務 Recording這個工具用影片的方式呈現使用者的行為，啟用以後就可以進行全站錄製，但和heatmap一樣，目前本blog有scroll的bug ＝ ＝…，所以沒辦法錄得很好，只能先體驗一下。 監視工具還會提供使用者的基本資料，如國家、裝置、瀏覽器、系統還有操作時間等等，只要點 PLAY ，就可以預覽錄製的影片。 就這樣使用者的行為被開發者摸得一清二楚!? Manage up to 300 recordings with Hotjar Basic. Need more? Delete old recordings or go unlimited. 基本版提供300個影片紀錄 由於本 Blog 不適合繼續玩 Funnel、Form 所以只能留給大家自己玩了。 許多時候設計師和工程師在介面上各有意見時，不仿試試看監測工具，分析使用者的行為，或許使用者操作會超乎所有開發者的預期。而相關的工具也越來越多，只能多方嘗試，選定合適才是上策。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"動手玩 CSS，快速學會Flex","slug":"css-flex","date":"2015-08-13T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/08/14/css-flex/","link":"","permalink":"https://wcc723.github.io/css/2015/08/14/css-flex/","excerpt":"上次製作了CSS column的範例，對於學習CSS column可以快速地瞭解(但實際運用相信坑非常多)，這次用angular製作了flex的範例，讓大家透過動手玩來快速瞭解這是怎樣的坑。","text":"上次製作了CSS column的範例，對於學習CSS column可以快速地瞭解(但實際運用相信坑非常多)，這次用angular製作了flex的範例，讓大家透過動手玩來快速瞭解這是怎樣的坑。 簡單範例在學理論之前，我們先動手玩一次，再來理解各個屬性的用途。而這份範例分為上下兩部分，上部分是Flex 的外容器，下半部是Flex 元件的設定。 Flex 容器Flex的容器，這部分選項較少，這範例是反覆測試後，認為比較有明顯效果的。 範例連結 Flex 屬性align-items這物件垂直對齊的屬性 flex-start : 緊靠起始的邊界 flex-end : 靠近終點的邊界 center : 對齊中間 baseline : 對齊基線 (line-height) stretch : 延展 (本範例不適合) justify-content這是物件水平對齊的屬性 flex-start : 緊靠起始的邊界 flex-end : 靠近終點的邊界 center : 對齊中間 space-between : 平均分配空間 space-around : 平均分配空間，且包含與邊界的距離 stretch : 延展 (本範例不適合) flex-direction決定物件的排列方向 row : 水平 row-reverse : 水平反轉 column : 垂直 column-reverse : 垂直反轉 flex-wrap容器的換行模式，在本範例需縮小視窗。 nowrap : 堅決不換行 wrap : 如果超過空間就換行 wrap-reverse : 換行還要後面的往前排 (請縮小視窗) Flex 元件這部分可以自由增減元件，試著去調整每個元件的屬性，或者配合外容器，看看彼此之間的關係。 範例連結 Flex 屬性flex這個屬性在本範例並沒有列出來，他其實是包含了以下三個屬性。 &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] 所以在本範例中，就直接提供以下三個屬性的各別調整。 flex-basisflex屬性的基準值，值可以是各種單位數值，如10px、10%、10vh。 但如果沒有單位，僅有數值，那代表的是等份，如有三個元件的flex-basis分別為 1、1、2，那麼他們分別的大小則為 四分之一、四分之一、四分之二。 flex-growflex-grow、flex-shrink，建議調整視窗大小玩看看。 元件的伸展比率，預設值為1，如果說設定為0，代表元件尺寸不會大於flex-basis的值。 flex-shrink元件的收縮比率，預設值為1，如果說設定為0，代表元件尺寸不會小於flex-basis的值。 所以flex-grow、flex-shrink都設定為0，代表元件不會縮放。 align-self和外容器的align-items的屬性類似，但是只能控制元件本身的對齊。 結語以前有寫過Flex文章，有些時候偷懶都會用flex來排垂直置中的物件，而上次製作了css column，就會引發更多的思考，column可以拿來排什麼；這次的flex也是一樣的道理，直接動手玩一次，能更了解每個屬性的用途，等到機會來臨，就可以輕鬆上手。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"隨意玩玩的 nw.js","slug":"nwjs-build-web-app","date":"2015-08-12T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"web/2015/08/13/nwjs-build-web-app/","link":"","permalink":"https://wcc723.github.io/web/2015/08/13/nwjs-build-web-app/","excerpt":"之前就有聽說 web可以上桌面應用程式，也找到相關的工具，這次就是把實驗的成果記錄下來。","text":"之前就有聽說 web可以上桌面應用程式，也找到相關的工具，這次就是把實驗的成果記錄下來。 安裝nw.js環境http://nwjs.io/ 到官網下載指定版本的工具，由於我是使用mac，最後結果是可行的，但windows等其他環境我就都沒有試過。 下載後直接安裝到Mac OS應用程式內就可以了。 下載範例包https://github.com/zcbenz/nw-sample-apps 這個測試包可以快速瞭解是否有成功，實際上我也沒寫過(遮臉)。 下載後解壓縮內容大概如上，接下來在這個路徑下打開Terminal，輸入以下指令nw.js就會直接打開desktop web app。 $ /Applications/nwjs.app/Contents/MacOS/nwjs &#123;資料夾名稱&#125; 像這樣輸入以上指令，就可以打開應用程式。 這是控制應用程式導覽列的範例。 除此之外這包還有許多不錯的範例，像是Camera…，如果有興趣可以自己打開來看看。","categories":[{"name":"web","slug":"web","permalink":"https://wcc723.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wcc723.github.io/tags/web/"}]},{"title":"CSS column 教學","slug":"css-column","date":"2015-07-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/07/23/css-column/","link":"","permalink":"https://wcc723.github.io/css/2015/07/23/css-column/","excerpt":"CSS column對於文字排版有很大的幫助，就類似Adobe indesign在文字排版時，只要指定文字欄數，再將文字全部匯入即可。這樣在文字編排時則會以內容為優先，並非受限於html規則。","text":"CSS column對於文字排版有很大的幫助，就類似Adobe indesign在文字排版時，只要指定文字欄數，再將文字全部匯入即可。這樣在文字編排時則會以內容為優先，並非受限於html規則。 簡單範例可以直接透過以下範例，操作互動來了解CSS column各個屬性的操作結果，試試看以後再來了解各屬性的用途。 column-count auto 1 2 3 4 5 column-width 100px 150px 200px 250px 300px column-gap 0 5px 10px 15px 20px 30px column-rule-style none solid dashed dotted column-rule-width 0 1px 2px 5px 8px column-rule-color h3 : column-span none all column-break-inside： auto avoid column-break-before： auto always avoid left right column-break-after： auto always avoid left right 高溫狀況越來越容易發生！ 根據美國的氣象資料顯示，今年6月全球平均氣溫、上半年全球均溫、陸溫及海溫都創新高，昨天台灣因西南風沉降作用的關係也熱得發燙，新竹高溫飆上37度，創下當地今夏最高溫紀錄。氣象局預報中心主任鄭明典說，高溫狀況越來越容易發生！ 台灣溫度趨勢和全球變化一致，氣象局長期預報課李明營表示，上半年台灣均溫比氣候值高出0.68度，今年6月均溫則達29.53度，比平均氣候值高1.95度，是1947年以來最熱的6月。他說台灣今年6月均溫飆高的原因和太平洋副高壓強勁有關，但導致太平洋副高增強主因有待探究。 昨天中午新竹出現37度高溫，刷新當地今夏最高紀錄，鄭明典表示，當時西南風轉偏南風，中部以北的西半部地區以離岸風為主，海風吹不進來，加上雲量偏低，氣溫便飆高，「近年趨勢是，高溫狀況越來越容易發生！」 所幸高溫的情形在今天會有所改善，氣象局預報員張心華表示，隨著華南低壓帶逐漸往東移出，今天水氣和雲量增加，溫度會略降1至2度，但沒下雨的時候，北部有機會達35度左右。 今天中南部降雨範圍廣，北部及澎湖、金門和馬祖則有局部短暫雨，午後各地有機會出現雷陣雨，且易伴隨瞬間大雨、雷擊、強陣風和溪水暴漲；沿海地區易有9至10級強陣風，西南部及恆春半島沿海易有長浪發生，提醒民眾留意。 高溫狀況越來越容易發生！ 根據美國的氣象資料顯示，今年6月全球平均氣溫、上半年全球均溫、陸溫及海溫都創新高，昨天台灣因西南風沉降作用的關係也熱得發燙，新竹高溫飆上37度，創下當地今夏最高溫紀錄。氣象局預報中心主任鄭明典說，高溫狀況越來越容易發生！ 台灣溫度趨勢和全球變化一致，氣象局長期預報課李明營表示，上半年台灣均溫比氣候值高出0.68度，今年6月均溫則達29.53度，比平均氣候值高1.95度，是1947年以來最熱的6月。他說台灣今年6月均溫飆高的原因和太平洋副高壓強勁有關，但導致太平洋副高增強主因有待探究。 昨天中午新竹出現37度高溫，刷新當地今夏最高紀錄，鄭明典表示，當時西南風轉偏南風，中部以北的西半部地區以離岸風為主，海風吹不進來，加上雲量偏低，氣溫便飆高，「近年趨勢是，高溫狀況越來越容易發生！」 所幸高溫的情形在今天會有所改善，氣象局預報員張心華表示，隨著華南低壓帶逐漸往東移出，今天水氣和雲量增加，溫度會略降1至2度，但沒下雨的時候，北部有機會達35度左右。 今天中南部降雨範圍廣，北部及澎湖、金門和馬祖則有局部短暫雨，午後各地有機會出現雷陣雨，且易伴隨瞬間大雨、雷擊、強陣風和溪水暴漲；沿海地區易有9至10級強陣風，西南部及恆春半島沿海易有長浪發生，提醒民眾留意。 屬性說明column-count這屬性只要直接填入數值即可，用來定義欄位數量。 column-widthcolumn-count及column-width只能二擇一，前者是直接定義欄位數量，後者則是定義欄位寬度。 column-gap欄位空隙寬度。 column-rule-style欄與欄之間的border樣式。 column-rule-width欄與欄之間的border寬度。 column-rule-color欄與欄之間的border色彩。 column-span設定指定元素不受column影響。(可以使用在標題或是重要的文字上) column-break-inside文字換欄設定 auto: 自動 avoid: 文字段落結束後才換欄 column-break-before, column-break-after指定元素的前後是否強制換欄。可以放在整個段落的前後 $(document).ready(function(){ var column = 'column-count'; var columnProps = ['column-count', 'column-width', 'column-gap', 'column-rule-width', 'column-rule-style', 'column-rule-color', ]; var h3columnProps = 'column-span'; var columnBreakInside = 'column-break-inside'; var breakColumnProps = [ '', 'column-break-before', 'column-break-after' ]; $.each(columnProps, function(i, prop){ console.log($('#'+prop)); $('#'+prop).on('change', function(){ console.log('a'); var val = $(this).val(); $('.column-demo').css(prop, val); }); }); $.each(breakColumnProps, function(i, prop){ console.log($('#'+prop)); $('#'+prop).on('change', function(){ console.log('a'); var val = $(this).val(); $('.columnBreak').css(prop, val); }); }); $('#'+columnBreakInside).on('change', function(){ console.log('a'); var val = $(this).val(); $('.column-demo p').css(columnBreakInside, val); }); $('#'+h3columnProps).on('change', function(){ console.log('a'); var val = $(this).val(); $('.column-demo h3').css(h3columnProps, val); }); });","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"用CSS呈現影像比對效果","slug":"image-comparison-slider","date":"2015-07-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/07/22/image-comparison-slider/","link":"","permalink":"https://wcc723.github.io/css/2015/07/22/image-comparison-slider/","excerpt":"http://lea.verou.me/這位工程師的CSS能力非常優異，他的blog有很多意想不到的效果(而且是個正妹)，這邊來分享他的其中一個效果。","text":"http://lea.verou.me/這位工程師的CSS能力非常優異，他的blog有很多意想不到的效果(而且是個正妹)，這邊來分享他的其中一個效果。 本篇來源：http://lea.verou.me/2014/07/image-comparison-slider-with-pure-css/ 範例Lea Verou 這個範例中並沒有使用到js，並且用少量的css就能達到效果，其中的resize:是關鍵的屬性，這可以讓使用者控制範圍大小，這個屬性讓div像 textarea一樣。 &lt;div class=&quot;d0722 demo&quot;&gt; &lt;div class=&quot;image-slider&quot;&gt; &lt;div&gt; &lt;img src=&quot;/images/2015-07-22_demoimage01.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;img src=&quot;/images/2015-07-22_demoimage02.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; .image-slider&#123; // 外部容器定位 position: relative; display: inline-block; // 上層的最大範圍不會超過image line-height: 0; &amp; &gt; div &#123; // 內部上層影像容器 position: absolute; top: 0; bottom: 0; left: 0; width: 25px; max-width: 100%; overflow: hidden; resize: horizontal; //使用者可以重新調整區塊大小 &amp;:before &#123; // 右下方提示可縮放的示意三角形 content: &#x27;&#x27;; position: absolute; right: 0; bottom: 0; width: 13px; height: 13px; padding: 5px; background: linear-gradient(-45deg, white 50%, transparent 0); background-clip: content-box; cursor: ew-resize; -webkit-filter: drop-shadow(0 0 2px black); filter: drop-shadow(0 0 2px black); //使用filter 可以用圖示輪廓做陰影 &#125; &#125; img &#123; user-select: none; //圖片無法被選擇 max-width: 400px; &#125; &#125; 後記本站重新改變了風格，也是重新開始新的篇章(版型來源)，接下來繼續來寫CSS吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"壓縮css的終極必殺技","slug":"gulp-uncss","date":"2015-05-05T16:00:00.000Z","updated":"2016-10-13T03:57:25.000Z","comments":true,"path":"gulp/2015/05/06/gulp-uncss/","link":"","permalink":"https://wcc723.github.io/gulp/2015/05/06/gulp-uncss/","excerpt":"CSS 再怎麼開起開壓縮，頂多縮個幾十k，uncss可以搜尋html內所用的class、id，再將.css內的多餘class or id移除，達到最佳化的壓縮。","text":"CSS 再怎麼開起開壓縮，頂多縮個幾十k，uncss可以搜尋html內所用的class、id，再將.css內的多餘class or id移除，達到最佳化的壓縮。 注意雖然標題很聳動，但是有個問題比較麻煩，就是他無法偵測動態產生的標籤，像是js產生的，所以在移除時可能會有些錯誤…。uncss有提供解決的方案，就是使用忽略，但實際上有可能自己都忘記忽略。 使用gulp在先前的文章有介紹過gulp，本篇也是會用gulp。 首先先安裝gulp-uncss $ npm install gulp-uncss –save-dev 簡單使用npm可參考:https://www.npmjs.com/package/gulp-uncss 文件:https://github.com/giakki/uncss#within-nodejs var gulp = require(&#x27;gulp&#x27;); var uncss = require(&#x27;gulp-uncss&#x27;); gulp.task(&#x27;default&#x27;, function() &#123; return gulp.src(&#x27;site.css&#x27;) //輸入的css .pipe(uncss(&#123; html: [&#x27;index.html&#x27;, &#x27;posts/**/*.html&#x27;, &#x27;http://example.com&#x27;], //檢查的頁面(網址也可) ignore: [&#x27;.ui-datepicker&#x27;,&#x27;dropdown&#x27;] // 忽略的class or id &#125;)) .pipe(gulp.dest(&#x27;./out&#x27;)); //輸出 &#125;); 壓縮範例如下這次的壓縮並沒有針對js的問題加以修正，僅是範例而已。 壓縮前 壓縮後 透過這個方法，可以有效的壓縮css，但其實在使用上並沒有那麼容易(需要補上ignore)。","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"}]},{"title":"關於學習","slug":"about-study","date":"2015-04-29T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"study/2015/04/30/about-study/","link":"","permalink":"https://wcc723.github.io/study/2015/04/30/about-study/","excerpt":"在學習上和以前看法有很大的不同，以前讀書是為了分數，但我本來功課就不好，也對分數沒什麼追求，只要勉強及格就好，記得在復興商工(復興美工)的時候，每年祈禱不要留級就好…。 現在學習比以前更有成就感，認真學習可以效率更高、拿到更好的薪水、甚至認識更多的高手。不過就這幾年來的心得，學習並不是短時間所達到的，是長時間的累積，所以通常我會採取以下作法：","text":"在學習上和以前看法有很大的不同，以前讀書是為了分數，但我本來功課就不好，也對分數沒什麼追求，只要勉強及格就好，記得在復興商工(復興美工)的時候，每年祈禱不要留級就好…。 現在學習比以前更有成就感，認真學習可以效率更高、拿到更好的薪水、甚至認識更多的高手。不過就這幾年來的心得，學習並不是短時間所達到的，是長時間的累積，所以通常我會採取以下作法： 1. 長期習慣：在生活習慣上，每天都有固定的行程，像是上下班都是搭乘捷運，這個時間盡量別使用手機，多去看周圍的事物，也可以多思考近期內的計畫，畢竟每天看電腦的時間已經夠長了，再搭捷運、走路的時間可以讓腦袋放鬆，以及發現有趣的事物。 到了晚上，通常也不會讓自己過於勞累，工作一整天已經很疲憊了，就行程上不能過度，一般而言行程會是用餐 -&gt; 散步 -&gt; 自由安排 -&gt; 洗澡 -&gt; 睡覺。每天用餐完我都會固定散步一段時間，除了散步也可以補充一些日常生活用品，這屬於讓腦袋較為放鬆的時間，也可多與家人聊天。 接下來，每天如果還有重要工作，就會在散步完在做，然後一直到睡覺前的一段時間，我會閱讀一些書籍。睡前盡量別使用手機，會影響睡眠，閱讀可以看些大家推薦，但屬於其他領域的書籍。 2. 短期衝刺每年都有一段學習計畫，前年是CSS，去年是d3.js。長時間的堅持學習，可以讓知識越來越廣闊，而短時間的學習，可以讓專業更有深度。 進行短期衝刺的學習之前，先擬定好學習的進度、內容(或者教材)以及學習目標，固定的進度會逼迫自己前進，預先設定好的內容有助於學習順暢，而目標，可以檢視自己學習的成果。 而每年通常會安排一段時間，來做這樣的專業學習訓練，讓我額外多學習了很多技術。CSS、d3.js是個例子，但其實還有許多技術，都是短時間練到一定程度，像是git、angular等等…。 3. 發現知識這和對工作的熱情有很大關係了，很多人會說工作要看待成career而不是job，前者是長期的規劃，後者是固定領薪水上下班，如果對於自己的專業有興趣，就不易感到厭煩，可以長時間的投入。而發現知識就是在空閒的時間，還持續投入自己的專業。 以我來說，通常會用facebook追蹤各種社群，或者是定期瀏覽一些技術網站、Blog，再看到關鍵字後，在搜尋這技術對於我的專業上是否有幫助，以及學習的適切性，如果可以再安排進自己的學習時程。 而對於學習，不太需要擔心學了用不到，在研究所時，我從設計師轉學Flash Actionscript 3.0，在當完兵後Flash被賈伯斯批的一文不值，Actionscript 3.0也跟著沒落，但這段學習影響到後來javascript。同樣的還有許多技術學習，會衍伸其他觀念的理解，只要保持開放的心胸，保持學習，人生的旅途自然會越來越開闊。","categories":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/categories/study/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"Middleman + Reactjs","slug":"reactjs-environment2","date":"2015-04-26T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"js/2015/04/27/reactjs-environment2/","link":"","permalink":"https://wcc723.github.io/js/2015/04/27/reactjs-environment2/","excerpt":"上一篇是使用gulp來轉換jsx，這篇是介紹用middleman 結合 React.js。","text":"上一篇是使用gulp來轉換jsx，這篇是介紹用middleman 結合 React.js。 Middleman建立專案參考本篇請先安裝好middleman，如果沒有可參考以下連結/tools/2015/03/23/middle-intro/。 建立middleman專案，並且安裝middleman-react的gem。 $ middleman init React-middleman $ gem install middleman-react Gemfile內請加入以下這行。 gem &quot;middleman-react&quot; config.rb加入以下程式碼 # activate react # 啟用React activate :react # option if need Sprockets loading # 可以載入 react.js after_configuration do sprockets.append_path File.dirname(::React::Source.bundled_path_for(&apos;react.js&apos;)) end 如果剛剛有啟用Sprockets loading，可以打開all.js做以下調整(用途是合併react.js)，請先載入react，再載入其他script，如下範例。 //= require react //= require_tree . 最後在***.jsx內就可直接使用jsx格式(和其他javascript放在同層即可)，如果執行middleman server時出現以下錯誤： Invariant Violation: _registerComponent(...): Target container is not a DOM element 請將你的&lt;%= javascript_include_tag &quot;all&quot; %&gt; 放在 &lt;body&gt;的後方。","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"Reactjs JSX格式轉換","slug":"reactjs-environment","date":"2015-04-22T16:00:00.000Z","updated":"2016-10-13T03:57:25.000Z","comments":true,"path":"js/2015/04/23/reactjs-environment/","link":"","permalink":"https://wcc723.github.io/js/2015/04/23/reactjs-environment/","excerpt":"剛接觸React.js通常遇到一個問題，就是開發環境怎麼配置，原因在於JSX的格式需要轉換。JSX讓javascript內可以插入html tag，雖然是可以選擇使用，但官方也建議使用JSX格式來進行開發，如果對於React.js有興趣的，不妨參考一下這篇JSX格式轉換吧。","text":"剛接觸React.js通常遇到一個問題，就是開發環境怎麼配置，原因在於JSX的格式需要轉換。JSX讓javascript內可以插入html tag，雖然是可以選擇使用，但官方也建議使用JSX格式來進行開發，如果對於React.js有興趣的，不妨參考一下這篇JSX格式轉換吧。 參考文章：http://tylermcginnis.com/reactjs-tutorial-pt-2-building-react-applications-with-gulp-and-browserify/ 安裝Node.js &amp; Gulp首先要先安裝Node.js 和 Gulp，如果還沒安裝的可以參考我之前的文章。 /gulp/2014/09/22/gulp-install/ 檔案格式架構建立以下的檔案 gulpfile.js |-- app |-- index.html |-- js |-- app.js index.html code&lt;script src=&quot;app/app.js&quot;&gt;&lt;/script&gt;放在body後方，只是要避免dom的錯誤。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;React.js&lt;/title&gt; &lt;script src=&quot;http://fb.me/react-0.13.1.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;app&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;!-- build:js --&gt; &lt;script src=&quot;app/app.js&quot;&gt;&lt;/script&gt; &lt;!-- endbuild --&gt; &lt;/html&gt; app.js code僅是要測試JSX用。 var Child = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; and this is the &lt;b&gt;&#123;this.props.name&#125;&lt;/b&gt;. &lt;/div&gt; ) &#125; &#125;); var Parent = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;div&gt; This is the parent. &lt;/div&gt; &lt;Child name=&quot;child&quot;/&gt; &lt;/div&gt; ) &#125; &#125;); React.render(&lt;Parent /&gt;, document.getElementById(&#x27;app&#x27;)); 安裝gulp套件在Terminal下依序輸入以下兩行指令，而npm init是用來建立package.json，輸入後會有一些問題，一直按Enter就可以了^ ^。 $ npm init $ npm install gulp gulp-concat gulp-uglify gulp-react gulp-html-replace --save-dev gulpfile.js這範例不包含webserver，主要是轉換JSX，如果對於gulp js很熟悉的使用者，也可只參考其中的JSX轉換即可。 var gulp = require(&#x27;gulp&#x27;); var concat = require(&#x27;gulp-concat&#x27;); // 串接 var uglify = require(&#x27;gulp-uglify&#x27;); // 醜化js var react = require(&#x27;gulp-react&#x27;); var htmlreplace = require(&#x27;gulp-html-replace&#x27;); // 定義變數 var path = &#123; HTML: &#x27;app/index.html&#x27;, ALL: [&#x27;app/js/*.js&#x27;, &#x27;app/js/**/*.js&#x27;, &#x27;app/index.html&#x27;], JS: [&#x27;app/js/*.js&#x27;, &#x27;app/js/**/*.js&#x27;], MINIFIED_OUT: &#x27;build.min.js&#x27;, DEST_SRC: &#x27;dist/app&#x27;, DEST_BUILD: &#x27;dist/build&#x27;, DEST: &#x27;dist&#x27; &#125;; // 建立任務，轉換JSX gulp.task(&#x27;transform&#x27;, function()&#123; gulp.src(path.JS) .pipe(react()) .pipe(gulp.dest(path.DEST_SRC)); &#125;); // 複製index.html到dist資料夾 gulp.task(&#x27;copy&#x27;, function()&#123; gulp.src(path.HTML) .pipe(gulp.dest(path.DEST)); &#125;); // 監控以上兩個任務 gulp.task(&#x27;watch&#x27;, function()&#123; gulp.watch(path.ALL, [&#x27;transform&#x27;, &#x27;copy&#x27;]); &#125;); // 定義預設動作 gulp.task(&#x27;default&#x27;, [&#x27;watch&#x27;]); // gulu build gulp.task(&#x27;build&#x27;, function()&#123; gulp.src(path.JS) .pipe(react()) //轉換jsx .pipe(concat(path.MINIFIED_OUT)) // 串接所有js .pipe(uglify(path.MINIFIED_OUT)) // 最小化js .pipe(gulp.dest(path.DEST_BUILD)); &#125;); // 轉換js路徑 gulp.task(&#x27;replaceHTML&#x27;, function()&#123; gulp.src(path.HTML) .pipe(htmlreplace(&#123; &#x27;js&#x27;: &#x27;build/&#x27; + path.MINIFIED_OUT &#125;)) .pipe(gulp.dest(path.DEST)); &#125;); // production 輸出 gulp.task(&#x27;production&#x27;, [&#x27;replaceHTML&#x27;, &#x27;build&#x27;]); 到這部分基本上就完成了，只要透過gulp或gulp production就能預覽jsx轉換成js。","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"Reactjs 元件的生命週期","slug":"reactjs-life-cycle","date":"2015-04-20T16:00:00.000Z","updated":"2016-10-13T03:57:25.000Z","comments":true,"path":"js/2015/04/21/reactjs-life-cycle/","link":"","permalink":"https://wcc723.github.io/js/2015/04/21/reactjs-life-cycle/","excerpt":"這篇也是React.js的學習過程文章。","text":"這篇也是React.js的學習過程文章。 參考文章：http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/ 元件生命週期上一篇有提到元件生命週期，這邊照著做來瞭解以下的內容。 Component LifeCycle - 元件生命週期 componentWillMount – 元件建立 componentDidMount – 元件已經建立 componentWillReceiveProps – This life cycle is not called on the initial render, but is instead called whenever there is a change to props. Use this method as a way to react to a prop change before render() is called by updating the state with setState.(原文) componentWillUnmount – This life cycle is invoked immediately before a component is unmounted from the DOM. This is where you can do necessary clean up. For example, going back to out firebase example this is the life cycle event where you would clean up your firebase reference you set in componentWillMount.(原文) var LifeCycle = React.createClass(&#123; getInitialState: function()&#123; // 元件初始化 alert(&#x27;getInitialState 的狀態&#x27;); return &#123; name: &#x27;比克&#x27; &#125; &#125;, textClick: function()&#123; this.setState(&#123; name: &#x27;悟飯&#x27; &#125;) &#125;, componentWillMount: function()&#123; // 元件即將建立 alert(&#x27;componentWillMount 的狀態&#x27;); &#125;, componentDidMount: function()&#123; // 元件建立 alert(&#x27;componentDidMount 的狀態&#x27;); &#125;, componentWillReceiveProps: function()&#123; // 尚未測試出來 alert(&#x27;componentWillReceiveProps 的狀態&#x27;); &#125;, render: function()&#123; return( &lt;div onClick=&#123;this.textClick&#125;&gt; 必殺, &#123;this.state.name&#125; &#123;this.props.skill&#125; &lt;/div&gt; ) &#125; &#125;); React.render(&lt;LifeCycle skill=&quot;魔貫光殺砲&quot; /&gt;, document.getElementById(&#x27;app&#x27;) ); JS Bin","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"開始學習 React js","slug":"learn-reactjs","date":"2015-04-19T16:00:00.000Z","updated":"2016-10-13T03:57:46.000Z","comments":true,"path":"js/2015/04/20/learn-reactjs/","link":"","permalink":"https://wcc723.github.io/js/2015/04/20/learn-reactjs/","excerpt":"最近開始來學react，相關的文章不會寫得非常細，主要是要寫學習過程。 參考文章：http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/","text":"最近開始來學react，相關的文章不會寫得非常細，主要是要寫學習過程。 參考文章：http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/ 關於參考文章我參考的文章還挺多的，但每篇都花時間寫很細有點難，所以這篇是參考http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/去實作的過程，有興趣的可以參考該網站即可。 React 專有名詞這blog將常用名詞放在第一篇，我認為很棒，這樣有助於了解整個框架。 JSX – react將html 元件直接寫在js內，透過jsx可以在js內寫類似html 格式的程式碼，再轉換成純js。 Virtual DOM - 透過js產生出真實的DOM。 React.createClass – 這個方法用來產生html 元件。 render (method) – 繪製html元件。 React.render – 將元件繪製到html dom上。 state – 元件的內部儲存資料。 getInitialState – 設置元件的初始狀態。 setState – 改變元件的狀態。 props – 從父層的元件取得值並傳送到子元件。 propTypes – 驗證父層的值。 getDefaultProps – 設定預設的值。 Component LifeCycle - 元件生命週期 componentWillMount – Fired before the component will mount componentDidMount – Fired after the component mounted componentWillReceiveProps – Fired whenever there is a change to props componentWillUnmount – Fired before the component will unmount Events onClick onSubmit onChange 學習 React.js環境在環境上可以使用jsbin，有些小地方稍微調整一下就可以簡單上手(如下圖)。 接下來隨意用個demo，選擇run with js，就可以看看有沒有成功了。 建構第一個元件第一個元件主要介紹如何透過JSX來繪製。 var TheFirst = React.createClass(&#123; // 建立新的元件 render: function()&#123; //畫出你想要的元件架構 return( // 元件開始 &lt;div&gt; The First &lt;/div&gt; ) // 元件結束 &#125; &#125;); React.render(&lt;TheFirst /&gt;, // 輸入剛剛宣告的元件名稱 document.getElementById(&#x27;app&#x27;) // 目標DOM ); JS Bin 點擊run with js 預覽 加一點狀態在元件上var TheFirst = React.createClass(&#123; // 建立新的元件 getInitialState: function()&#123; // 定義預設狀態 return &#123; // 回傳json格式狀態 userstate: &#x27;單腳站容易歪&#x27; &#125; &#125;, render: function()&#123; // 畫出你想要的元件架構 return( // 直接用&#123;&#125;帶入值 &lt;div&gt; The First &#123;this.state.userstate&#125; &lt;/div&gt; ) // 元件結束 &#125; &#125;); React.render(&lt;TheFirst /&gt;, // 輸入剛剛宣告的元件名稱 document.getElementById(&#x27;app&#x27;) // 目標DOM ); JS Bin 事件控制var TheFirst = React.createClass(&#123; // 建立新的元件 getInitialState: function()&#123; // 定義預設狀態 return &#123; // 回傳json格式狀態 userstate: &#x27;單腳站容易歪&#x27; &#125; &#125;, handleChangeA: function(e)&#123; //自訂事件名稱 this.setState(&#123; // 設定狀態 userstate: e.target.value &#125;); &#125;, render: function()&#123; // 畫出你想要的元件架構 return( // 透過onChange觸發handleChangeA事件 &lt;div&gt; The First &#123;this.state.userstate&#125; &lt;br /&gt; change state : &lt;input type=&quot;text&quot; value=&#123;this.state.userstate&#125; onChange=&#123;this.handleChangeA&#125; /&gt; &lt;/div&gt; ) // 元件結束 &#125; &#125;); React.render(&lt;TheFirst /&gt;, // 輸入剛剛宣告的元件名稱 document.getElementById(&#x27;app&#x27;) // 目標DOM ); JS Bin 從父層抓取資料傳回值var HelloUser = React.createClass(&#123; render: function()&#123; return ( // 透過this.props 抓取父層屬性 &lt;div&gt; 必殺, &#123;this.props.skill&#125;！&lt;/div&gt; ) &#125; &#125;); React.render(&lt;HelloUser skill=&quot;魔貫光殺砲&quot;/&gt;, // 父層屬性 document.getElementById(&#x27;app&#x27;)); JS Bin 巢狀元件這邊有個陷阱，沒注意到卡超久，當載入另一個元件時，必須在用一個標籤包起載入的元件。 var SkillList = React.createClass(&#123; render: function()&#123; // 透過 this.props 讀取父層得值 var listItems = this.props.skills.map(function(item)&#123; console.log(&#123;item&#125;); return &lt;li&gt;&#123;item&#125;&lt;/li&gt;; &#125;); return ( &lt;div&gt; &lt;h2&gt;技能列表&lt;/h2&gt; &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125;); var HelloDragonBall = React.createClass(&#123; getInitialState: function()&#123; return &#123; skill: &quot;魔貫光殺砲&quot;, allskills: [&#x27;龜派氣功&#x27;, &#x27;元氣彈&#x27;, &#x27;太陽拳&#x27;] //要給內層用的陣列 &#125; &#125;, render: function()&#123; return ( // 注意，這種做法外層必須有標籤 &lt;div&gt; &lt;h1&gt;必殺, &#123;this.state.skill&#125;！&lt;/h1&gt; &lt;SkillList skills=&#123;this.state.allskills&#125; /&gt; &lt;/div&gt; ) &#125; &#125;); React.render(&lt;HelloDragonBall /&gt;, document.getElementById(&#x27;app&#x27;)); JS Bin 經典模組，新增清單var AddSkill = React.createClass(&#123; // 這元件包含了input、button，用來增加新的技能 getInitialState: function()&#123; return &#123; newSkill: &#x27;&#x27; &#125; &#125;, updateNewSkill: function(e)&#123; //每次輸入更新值 this.setState(&#123; newSkill: e.target.value &#125;) &#125;, handleAddNew: function()&#123; // 按下button時，將資料更新到父層 this.props.addNew(this.state.newSkill); this.setState(&#123; newSkill: &#x27;&#x27; &#125;) &#125;, render: function()&#123; return( &lt;div&gt; &lt;input type=&quot;text&quot; value=&#123;this.state.newSkill&#125; onChange=&#123;this.updateNewSkill&#125; /&gt; &lt;button onClick=&#123;this.handleAddNew&#125;&gt;Add new Skill&lt;/button&gt; &lt;/div&gt; ) &#125; &#125;); var SkillList = React.createClass(&#123; render: function()&#123; // 透過 this.props 讀取父層得值 var listItems = this.props.skills.map(function(item)&#123; console.log(&#123;item&#125;); return &lt;li&gt;&#123;item&#125;&lt;/li&gt;; &#125;); return ( &lt;div&gt; &lt;h2&gt;技能列表&lt;/h2&gt; &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125; &#125;); var HelloDragonBall = React.createClass(&#123; getInitialState: function()&#123; return &#123; skill: &quot;魔貫光殺砲&quot;, allskills: [&#x27;龜派氣功&#x27;, &#x27;元氣彈&#x27;, &#x27;太陽拳&#x27;] //要給內層用的陣列 &#125; &#125;, addNewSkill: function(newSkill)&#123; console.log(newSkill); // 更新allskills資料 this.state.allskills.push(newSkill); this.setState(&#123; allskills: this.state.allskills &#125;) &#125;, render: function()&#123; return ( // 模組子層addNew更新時，觸發addNewSkill &lt;div&gt; &lt;h1&gt;必殺, &#123;this.state.skill&#125;！&lt;/h1&gt; &lt;AddSkill addNew=&#123;this.addNewSkill&#125; /&gt; &lt;SkillList skills=&#123;this.state.allskills&#125; /&gt; &lt;/div&gt; ) &#125; &#125;); React.render(&lt;HelloDragonBall /&gt;, document.getElementById(&#x27;app&#x27;)); JS Bin 累了，React的tag有沒有什麼工具…，純手打好累。","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"Javascript 閉包","slug":"js-function-closures","date":"2015-04-09T16:00:00.000Z","updated":"2016-10-13T03:56:42.000Z","comments":true,"path":"javascript/2015/04/10/js-function-closures/","link":"","permalink":"https://wcc723.github.io/javascript/2015/04/10/js-function-closures/","excerpt":"一直以來我都不太敢寫純 Javascript的文章，主要原因是底子不夠深，害怕寫了之後錯誤太多，但最近想學看看React.js，如果說一直不敢寫的話，那麼就無法進步。 這篇是要介紹Javascript閉包，參考的是這篇文章，這篇寫得不錯，從頭到尾看到有感受到閉包的用法，但或許有錯誤，也在這邊重頭到尾表達一次，在詢問大家是否有需要糾正的。","text":"一直以來我都不太敢寫純 Javascript的文章，主要原因是底子不夠深，害怕寫了之後錯誤太多，但最近想學看看React.js，如果說一直不敢寫的話，那麼就無法進步。 這篇是要介紹Javascript閉包，參考的是這篇文章，這篇寫得不錯，從頭到尾看到有感受到閉包的用法，但或許有錯誤，也在這邊重頭到尾表達一次，在詢問大家是否有需要糾正的。 變數與作用域範例一首先一開始要先了解最基本的變數，變數可以分為全域及區域變數，以下範例的name = &quot;阿帕契&quot;就是全域變數，所以當alert(name);時就會直接調用全域的&quot;阿帕契&quot;；在funcA()內的var name = &quot;澇哥哥&quot;則是區域變數，所以執行funcA()則會運算內部的&quot;澇哥哥&quot;。 var name = &quot;阿帕契&quot;; function funcA()&#123; var name = &quot;澇哥哥&quot;; alert(name); &#125; funcA(); // &quot;澇哥哥&quot; alert(name); // &quot;阿帕契&quot; 範例二這個範例和剛剛很類似只是把函式funA()內的var name = &quot;澇哥哥&quot;;改成name = &quot;澇哥哥&quot;;，這樣就會有全然不同的結果。 首先第一個alert(name);會直接調用全域的name，所以結果會是&quot;阿帕契&quot;。 接下來執行funcA()，會得到函式內的name = &quot;澇哥哥&quot;;，但其實這時候全域的name已經被取代成&quot;澇哥哥&quot;。 最後的alert(name);顯示的是被取代的name也就是&quot;澇哥哥&quot;。 var name = &quot;阿帕契&quot;; function funcA()&#123; name = &quot;澇哥哥&quot;; alert(name); &#125; alert(name); // &quot;阿帕契&quot; funcA(); // &quot;澇哥哥&quot; alert(name); // &quot;澇哥哥&quot; 所以在函式內部使用var則會定義區域變數，不使用則是全域 閉包和原作文章來比，我會省略掉很多內容，主要是要介紹作用域、閉包。 在阿帕契案中，一開始只因為某藝人在Facebook上上傳了阿帕契的觀光照片，所以爆出了這個案件(var Apache = funcA();)，許多人就開始搜尋或者調查阿帕契(alert(name);)，不論是機種還是性能等等。後來阿帕契案件越滾越大，發現每天調查多會多一團(Apache();, Apache();, Apache();)。 var name = &quot;阿帕契&quot;; function funcA()&#123; var name = &quot;澇哥哥一團&quot;; alert(name); return function()&#123; name = name + &quot; 再多一團&quot;; alert(name); &#125;; &#125; var Apache = funcA(); //&quot;澇哥哥一團&quot; alert(name); //&quot;阿帕契&quot; Apache(); // &quot;澇哥哥一團 再多一團&quot; Apache(); // &quot;澇哥哥一團 再多一團 再多一團&quot; Apache(); // &quot;澇哥哥一團 再多一團 再多一團 再多一團&quot; var Apache = funcA();這整個過程中，全域的name = &quot;阿帕契&quot;;依然都沒有變動，而執行var Apache = funcA()時，區域變數的name宣告為&quot;澇哥哥一團&quot;，這整個函式也就結束，所以第一次執行也就到&quot;澇哥哥一團&quot;。 Apache();var Apache = funcA(); 以上這段執行後，&quot;澇哥哥一團&quot;也是大家都知道的事情了，其實也就沒必要一直反覆提()，只是檢調每次調查時，都會再多出一團，這段就是return function()，他調用存在Apache();函式中的name，並且在每次執行時再多一團。 所以閉包就是能訪問另一個函式的變數(var Apache = funcA();)。 Thisvar name = &quot;阿帕契&quot;; function funcA()&#123; var name = &quot;澇哥哥一團&quot;; alert(name); return function()&#123; name = name + &quot; 再多一團&quot;; alert(this.name); &#125;; &#125; var Apache = funcA(); //&quot;澇哥哥一團&quot; alert(name); //&quot;阿帕契&quot; Apache(); //&quot;阿帕契&quot; 文中最後還提到了this，它提到this是調用目前函式的對象，所以在閉包內使用this，我們實際是執行以下的函式。 window.funcA(); 所以指向的都是全域的var name = &quot;阿帕契&quot;;。 更棒的文章在寫完這篇後，我看到一篇更棒的文章http://blog.taian.su/2012-10-17-explaining-javascript-scope-and-closures-by-robert-nyman/，這篇將閉包解釋得更清楚，且還有許多的範例，有機會一定要跟著做一次喔。 如果本文有錯誤，煩請提出，我會盡快理解在修正。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"Zeplin, 跨越工程師與設計師的鴻溝","slug":"zeplin-intro","date":"2015-04-08T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"tools/2015/04/09/zeplin-intro/","link":"","permalink":"https://wcc723.github.io/tools/2015/04/09/zeplin-intro/","excerpt":"從去年開始，做網頁設計時都開始使用Sketch，一方面是對於Web來說，Sketch相當的合適，另一方面則是Sketch有相當多的擴增工具，讓在執行上可以方便不少。 這次就來介紹Sketch的擴增工具Zeplin，設計師可以透過這套工具，快速的傳達設計的內容，包含顏色、間距、字型等等，而工程師不會因為色弱，老是用錯顏色，且工程師不需要安裝Sketch就可以使用，Zeplin甚至提供Web版來快速上手。","text":"從去年開始，做網頁設計時都開始使用Sketch，一方面是對於Web來說，Sketch相當的合適，另一方面則是Sketch有相當多的擴增工具，讓在執行上可以方便不少。 這次就來介紹Sketch的擴增工具Zeplin，設計師可以透過這套工具，快速的傳達設計的內容，包含顏色、間距、字型等等，而工程師不會因為色弱，老是用錯顏色，且工程師不需要安裝Sketch就可以使用，Zeplin甚至提供Web版來快速上手。 Zeplin: https://zeplin.io/ 申請帳號如果有興趣的朋友，要先申請帳號，我在很久之前就有申請了，所以有點忘記流程，所以有興趣下載的朋友，請先提出申請吧～。 收到邀請後，也可以拿到測試版的軟體 軟體介紹注意：Sketch is Mac only. Zeplin目前我還沒有在多人環境測試 安裝完後，他會先要求登入，然後再建立檔案同時上傳到伺服器，這樣可以和其他合作夥伴同步討論。 在建立專案時，可以開Androi, iOS, Web，而這些都可以匯出不同的資料，就以Web來說，他可以將色票匯出成Sass的變數。這邊我就先選Web來建立。 開好專案後會提示在Sketch內按下cmd + E，這樣就能夠將設計稿匯入。 打開Sketch，手邊剛好有一份Bootstrap的Sketch template，就按下cmd + E。 可以看到專案的列表，就把圖片匯入剛剛開的專案上吧。 接下來回到Zeplin，可以找到剛剛Bootstrap的Sketch template，隨便點個地方，可以看到尺標都標好了，並且將顏色標出。 如果點的是內文，則可以複製內文 右方的色票旁邊有個水滴圖案，如果點了就會標示顏色的”色名” (色弱救星)，並且將他加到常用的色彩列表。 Border and fill設計師都不需要另外標顏色了~ Guildeline頁面可以看到剛剛選擇的顏色、畫面上所用到的字型以及輸出CSS。如果點Generate CSS，可以產出如下的Sass變數(色名是Zeplin取的)。 $limed-oak: #58b957; 除此之外，也可以按住cmd點選畫面上的物件，這樣就可以在物件上寫一些註解，如果多人的話也可以透過這來討論。 你相信嗎？這是Web版的頁面，就算是工程師也能透過Web版來進行討論，只要先有一個帳號就可以了。 如果撇除Mac有點貴之外，Sketch是相當值得入手的軟體，加上現在對Sketch的支援越來越多(Zeplin，或者是Google Material Design也支援Sketch範本)，有興趣的不仿來試試看。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"},{"name":"zeplin","slug":"zeplin","permalink":"https://wcc723.github.io/tags/zeplin/"}]},{"title":"Middleman 超級快上手","slug":"middle-intro","date":"2015-03-22T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"tools/2015/03/23/middle-intro/","link":"","permalink":"https://wcc723.github.io/tools/2015/03/23/middle-intro/","excerpt":"之前長時間都是使用Fire.app(到目前也有在用)，因為少許原因，所以一直有在嘗試其他工具，而之前有介紹過Gulp，他可以透過Node.js做出類似Fire.app的工具。而最近，有人和我介紹了Middleman，嘗試了一小段時間後，比想像中更容易，更貼近Fire.app，比Gulp更好設定，有興趣的就來安裝看看吧～。","text":"之前長時間都是使用Fire.app(到目前也有在用)，因為少許原因，所以一直有在嘗試其他工具，而之前有介紹過Gulp，他可以透過Node.js做出類似Fire.app的工具。而最近，有人和我介紹了Middleman，嘗試了一小段時間後，比想像中更容易，更貼近Fire.app，比Gulp更好設定，有興趣的就來安裝看看吧～。 官方網站：https://middlemanapp.com/ Middleman是基於Ruby環境的工具，因此請先確認有Ruby環境。 安裝安裝上問題不大，但是可能有ruby 版本的限制，2.0.0裝不進去，rvm切到2.1.2之後很順利安裝，或許是和gem的版本有關(反正我就裝進去了!)。 $ gem install middleman 建立專案這一套和fire.app有許多相似的地方，為了讓使用者可以快速開始，也有提供快速建立專案的方法，等等會介紹一些fire.app沒有的地方。 $ middleman init 啟動middleman的服務。 $ middleman server 這樣在進入localhost:4567之後，就可以開啟預設的畫面。 安裝其他插件接下來介紹他的一些特色，這不僅像Fire.app，也很類似Ruby on rails，所以除了一些預設的基本功能，還可以透過gemfile來擴增插件。 SlimSlim也是很多人在使用的template language，如果要產生slim的預設版型，就必須先安裝middleman-slim。 $ gem install middleman-slim 接下來init就可以產生slim的template(和原本的middleman init產生的內容是一樣，僅是改成slim的副檔名)。 $ middleman init PROJECT_NAME --template slim Sass接下來還需要其他的gem，可以直接寫入gemfile，像是sass, compass。所以打開gemfile，把以下三行加進去就可以了。 # Sass gem &quot;sass&quot; gem &quot;compass&quot; 回到terminal輸入bundle install，就可以使用sass囉(記得sass用法吧，副檔名記得要改成.sass or .scss)。 livereload這個版本的livereload已經把gem寫在裡面了，但是要自己啟動，打開config.rb，將以下的註解拿掉。 # configure :development do # activate :livereload # end 不需要重啟服務，直接就可以開始使用。 jquery如果要jquery的lib，也是將套件先寫在gemfile內，gemfile內加入以下這行，然後一樣在Terminal輸入bundle install。 gem &quot;jquery-middleman&quot; 接下來打開source/javascript/all.js裡面加入以下這行，這樣就完成了。 //= require jquery 參考：https://github.com/jasl/jquery-middleman 使用slim template languagemiddleman 不僅有template language，還支援許多類似fire.app的假字功能，這邊用一個範例來介紹： 打開index.html.slim - 5.times do p == lorem.sentence 這一段的意思是執行五次內容，包含了&lt;p&gt;以及產生lorem.sentence的假字，結果如下。 結語相對於gulp來說，middleman非常非常的容易上手，如果對於fire.app熟悉的話，並且略懂rails，大概只要20分鐘就可以開始用了。 如果說缺點，就是他並不像gulp那樣的靈活，可以與其他語言服務一起混用。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"投資自己、投資資產","slug":"we-need-more","date":"2015-03-15T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"life/2015/03/16/we-need-more/","link":"","permalink":"https://wcc723.github.io/life/2015/03/16/we-need-more/","excerpt":"之前就有打算Blog的內容不全部都是技術文，最近看了不同領域的資料，有很多不一樣的看法，其中有一本書對我的看法有很大的改變，富爸爸告訴你，為什麼A咖學生當員工，C咖學生當老闆！，這本書是屬於理財方面的書籍，之前理財完全沒有概念，想說閱讀看看，說不定有幫助，看完之後想法改變非常多…。","text":"之前就有打算Blog的內容不全部都是技術文，最近看了不同領域的資料，有很多不一樣的看法，其中有一本書對我的看法有很大的改變，富爸爸告訴你，為什麼A咖學生當員工，C咖學生當老闆！，這本書是屬於理財方面的書籍，之前理財完全沒有概念，想說閱讀看看，說不定有幫助，看完之後想法改變非常多…。 為什麼有這樣的想法工作經歷也將近屆滿三年了(也可以直接算三年啦)，前兩年薪水不算高，每年頂多存下來10萬(住外面還有學貸等等)，每年都因為薪水太少感到煩躁，後來技術上來了，薪水也提昇了不少，就開始算算要存多少錢，老了以後才能好好過(維持一定水準的生活品質)。 退休金… 雖然沒算到通貨膨脹，但這就是真真實實的問題，退休要多少錢。現在的醫療水準比以前高很多，有可能養老的時間比工作時間還要長(我阿公年紀破百)，加上醫療費等等，確實不容忽視。 改變我一直都在思考我們這一代要面臨的問題，高房價、不公平的社會福利、還沒出社會就一屁股的學貸等等，一直在思考怎麼逆轉這些問題。思考的結果是順應著這個環境，認為要養好自己身體，並且工作到七八十歲(日本 老人兼職工作到七十 「退休年齡」可以廢止了)，這是不錯的政策，我也有著這樣的信仰，但如果身體不好呢？ 現在的社會福利有非常大的問題，如果相信老了以後還有退休金可以領，那基本上領到的錢一定不夠用，別不斷說現在老人把錢吃光，就算他們不吃光，我們到時也是有相同的問題(雖然如此，也不能白白讓他們吃光啊啊)。 後來看上了富爸爸、窮爸爸系列書籍，雖然裡面的許多觀點相當的偏激，但許多概念值得參考。就以資產與負債來說，他大膽的提出自助宅並非是資產，是一種負債，像這樣違反社會風氣的論述，在裡面不斷的重複，也可以從中發現到現在的美國與鬼島台灣面臨許多相似的問題。 規畫學習前端以及技術，其中一個目標不正是提高自己的價值，賺取更多的薪水嗎？因此，除了前端的技術，還有許多可以做的事情： 學習更廣泛的技能(App、物聯、語文等) 投資資產(現金流) 創業!? 目前還沒有明確要做什麼，但並不會那樣的恐懼，不好的環境，還是有辦法成功，與其抱怨，不如去尋找希望。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"Sass map get","slug":"sass-map-get","date":"2015-02-10T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/02/11/sass-map-get/","link":"","permalink":"https://wcc723.github.io/sass/2015/02/11/sass-map-get/","excerpt":"去年有介紹sass模組的開發方式連結，sass 3.3 釋出以後有更好的方式去執行，這篇來介紹快速且好管理的模組製作方法。","text":"去年有介紹sass模組的開發方式連結，sass 3.3 釋出以後有更好的方式去執行，這篇來介紹快速且好管理的模組製作方法。 注意這篇要介紹的是sass map，所以請先確認自己的sass版本是3.3以上，如果要確認自己sass版本，可以在Terminal輸入 sass -v就可以看到目前系統內的版本。 $ sass -v 結果先來看預期的結果，按鈕是類似bootstrap，但是我簡化了很多部分的程式碼(縮短比較好閱讀)，重點是在scss內的$btn-config，透過這config可以快速調整按鈕的樣式，如果有增減，也只需要調整config即可。 See the Pen EaovPd by Wcc723 (@Wcc723) on CodePen. 開始html的部分就只有這三段代表不同的按鈕，不同的地方只有btn-xxx用來套用不同按鈕樣式。 &lt;a href=&quot;#&quot; class=&quot;btn btn-default&quot;&gt;Button default&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-primary&quot;&gt;Button primary&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;btn btn-danger&quot;&gt;Button danger&lt;/a&gt; 按鈕中還有包含基本的樣式，這不是本篇的重點，大概看過就好。 .btn &#123; display: inline-block; margin-bottom: 0; text-align: center; vertical-align: middle; padding: 6px 12px; cursor: pointer; border: 1px solid transparent; white-space: nowrap; text-decoration: none; &#125; Scss 重點開始我長期以來都是寫sass格式的，但因為sass map的關係，最近開始改寫scss…。 Sass map的格式有點類似json，只是把&#123;&#125;改成了()，以下代表了三組按鈕的樣式設定檔(default, primary, danger)，每一組還有包含他的class name、color、background、border-color，清楚的標示可以讓未來更容易閱讀程式碼。 // 定義按鈕的不同狀態設定，類似json格式 $btn-config:( default:( class: &#x27;default&#x27;, color: #333, bg: #fff, border-color: #ccc ), primary:( class: &#x27;primary&#x27;, color: #fff, bg: $brand-primary, border-color: darken($brand-primary, 0) ), danger:( class: &#x27;danger&#x27;, color: #fff, bg: $brand-danger, border-color: darken($brand-danger, 0) ) ); 透過sass的$each把$btn-config每一組設定帶出來，這方法有點類似jquery的$.each。接下來的map-get是sass map新的function，取出值以後，就像平常寫scss一樣，把變數寫在樣式內就完成了。 // 用$each 帶入設定值 @each $name, $value in $btn-config &#123; $class: map-get($value, class); // 用map-get取出各個設定值 $color: map-get($value, color); $bg: map-get($value, bg); $border-color: map-get($value, border-color); // 接下來將變數加到class內就完成了 .btn-#&#123;$class&#125;&#123; color: $color; background-color: $bg; border-color: $border-color; &amp;:hover&#123; background-color: darken($bg, 5%); border-color: darken($border-color, 5%); &#125; &#125; &#125; 延伸如果後來發現按鈕的樣式不夠，其實只要改$btn-config就可以了，如果有興趣，試著把下面這段加到範例裡的$btn-config吧～。 dark:( class: &#x27;dark&#x27;, color: #fff, bg: #333, border-color: darken(#333, 0) ) 如果在html內加入這段，有看到黑色的按鈕代表成功了。 &lt;a href=&quot;#&quot; class=&quot;btn btn-dark&quot;&gt;Button dark&lt;/a&gt; 再看一次範例。 See the Pen EaovPd by Wcc723 (@Wcc723) on CodePen.","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS 5種垂直置中方法","slug":"css-magic","date":"2015-01-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/01/16/css-magic/","link":"","permalink":"https://wcc723.github.io/css/2015/01/16/css-magic/","excerpt":"說到垂直置中一直是網頁設計師的痛，早期解決方法沒有那麼多，最常見到的就是height = line-height這種方式，可是這方式彈性很低，如果遇到多行文字就無法使用。 然而隨著CSS的演進，越來越多種垂直置中的方法，這邊就介紹幾種實用性高的垂直置中方法。","text":"說到垂直置中一直是網頁設計師的痛，早期解決方法沒有那麼多，最常見到的就是height = line-height這種方式，可是這方式彈性很低，如果遇到多行文字就無法使用。 然而隨著CSS的演進，越來越多種垂直置中的方法，這邊就介紹幾種實用性高的垂直置中方法。 條件這篇文章所介紹的垂直置中方式，都不會使用絕對值(px)，大多可以運用在各種環境，但實際上還是需要配合CSS的特性去做選用。 這次用鳴人的圖片來做介紹，這張圖片是用背景的方式載入。 //sass code .naruto background-image: image-url(&quot;narutoR.png&quot;) background-color: orange background-repeat: no-repeat width: (image-width(&quot;narutoR.png&quot;) / 2) height: (image-height(&quot;narutoR.png&quot;) / 2) +background-size(cover) 外框的部分就直接加入height: 350px的屬性。 %box height: 350px 方法一：table此table不是真table，這是IE8以上才支援的CSS語法，將div的屬性轉成table，再套用垂直置中的方式來完成。 優點：概念簡單、支援度高(IE8+) 缺點：html結構較多層、有table的特性 .table @extend %box display: table width: 100% .table-cell display: table-cell vertical-align: middle .naruto margin: 0 auto 方法二：display: inline-blockvertical-align: middle可以做垂直置中，但是限制只能使用在inline及inline-block上，而且還有諸多的限制…，但是透過一點小技巧，vertical-align: middle會是一個非常實用的置中方式(目前也常把這方法套用在專案上)。 重點在於透過偽元素製作一個垂直100%的物件，而需要置中的元素也轉換為inline-block，並且套用vertical-align: middle。 優點：相容性不錯，如果要ie7則必須自己手動插入偽元素的部分。 缺點：必須轉成inline-block .box-wrap @extend %box text-align: center &amp;:before content: &quot;&quot; display: inline-block height: 100% vertical-align: middle .naruto display: inline-block vertical-align: middle 什麼是vertical-align：http://css-tricks.com/what-is-vertical-align/ 方法三：這方法類似於margin: 0 auto的水平置中，但套用在垂直的元素上，只要將內元素設定absolute並將上下左右的距離皆設定為0，再補上margin: auto就大功告成了，但這方法只能用在內元素有明確的寬與高。 優點：相容性高 缺點：內元素必須有明確的寬高值 .box-wrap @extend %box position: relative .naruto position: absolute top: 0 left: 0 bottom: 0 right: 0 margin: auto 方法四：translateY(- 50%)以前常會用一種方式做垂直置中top: 50%; margin-top: -(元素高 / 2);，先用top往下推50%的距離，再利用margin-top拉回元素的一半高度，這方式雖然很好用，但是必須用在元素有明確高度上。 而這邊所介紹是相同的道理，但是是用transform: translateY(- 50%)將元素垂直向上50%的距離，這50%則是元素的高度，且語法都集中在元素上。 優點：如果不提到ie就沒有缺點 缺點：如果提到ie就是缺點(ie9+) .naruto position: relative top: 50% margin: 0 auto +transform(translateY(- 50%)) 方法五：flex近幾年W3C針對CSS的layout提出了新的語法 flex，經過多番的波折目前也差不多定案，所以主流的瀏覽器幾乎都支援 flex。 透過Compass(1.0+)，許多前輟詞都可以省略。 .flex-wrap +display-flex //flex +flex-wrap(wrap) //flex外框 +align-items(center) //水平置中 +justify-content(center) //垂直置中 優點：很潮 缺點：如果提到ie就是缺點(全部)、建議熟悉flex概念 前年的鐵人賽我有介紹過flex，也可以參考前年的文章，flex看似簡單，但似乎沒有那麼容易…。 display:flex CSS3 Flex的排版方式 CSS3 Flex的對齊","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS 冷知識","slug":"css-magic","date":"2015-01-12T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/01/13/css-magic/","link":"","permalink":"https://wcc723.github.io/css/2015/01/13/css-magic/","excerpt":"前幾天參加了Happy designer + RGBA的活動，這次不僅僅是兩個社群的合作，還是以CSS為主題作為介紹。這次活動不只介紹了CSS架構，還介紹了許多CSS的奇妙解法，想到很久以前也寫過類似的文章(CSS 冷知識)，個人認為這類冷僻解法相當有趣…，有機會應該定期發表CSS冷知識。","text":"前幾天參加了Happy designer + RGBA的活動，這次不僅僅是兩個社群的合作，還是以CSS為主題作為介紹。這次活動不只介紹了CSS架構，還介紹了許多CSS的奇妙解法，想到很久以前也寫過類似的文章(CSS 冷知識)，個人認為這類冷僻解法相當有趣…，有機會應該定期發表CSS冷知識。 隨著視窗縮放的背景圖CSS背景圖相當的實用，但是有個問題就是無法等比例縮放，這個奇妙解法可以解決視窗縮放的問題(關鍵字：padding-bottom)。 首先還是必須要知道圖片的比例，這次範例直接使用Fireapp的宣傳圖…(Blog內這張最適合QQ)，經過計算可以知道圖片的寬高比為100:42，那麼就寫出下面這樣的sass code，寬為100%，padding-bottom為42%。 .img-responsive-fire background-size: contain backgroubd-repeat: no-repeat padding-bottom: 42% 將Class套用至圖內並加入style=&quot;background-image: url(/path/img.jpg)&quot;，這樣背景圖就可以隨視窗縮放了 CSS background HTML img &lt;div class=&quot;img-responsive-fire&quot; style=&quot;background-image: url(/images/20130917fireapp.jpg)&quot;&gt;&lt;/div&gt; &lt;em&gt;CSS background&lt;/em&gt; &lt;br&gt; &lt;img src=&quot;/images/20130917fireapp.jpg&quot; class=&quot;img-responsive&quot; alt=&quot;&quot;&gt; &lt;em&gt;HTML img&lt;/em&gt; 只靠Class增加CSS權重http://www.w3.org/TR/CSS2/cascade.html#specificity CSS權重一直是網頁設計中常遇到的問題，就以Bootstrap來說，Bootstrap大量使用.class &gt; .class這種方式去製作Component，如果是不熟悉的開發者，在overwrite時就會加上!important以確保自己得樣式會呈現。而這個範例解法，可以避免使用!important 或 id來增加CSS的權重。 這邊先寫一個簡單的範例，一個是單純的.green，另一個是.demo &gt; .green.blue，就以優先度來說，後者大勝前者，所以當標籤套用class=&quot;blue green&quot;必定為藍色。 .green color: green .demo &gt; .green.blue color: blue 這裏有一段文字 class=\"green\" 這裏有一段文字 class=\"blue green\" 如果此時要覆蓋CSS，就是不斷的增加Class的權重如下…。 .red.red.red.red.red.red.red.red.red.red.red.red color: red 就算是.demo &gt; .green.blue也不過區區 3分 的權重，而.red*12 有高達 12分 的權重，雖然這樣做好像看起來怪怪的…，不過確實也是可行。 這裏有一段文字 class=\"blue green red\" @Supports() 判斷瀏覽器的核心@Suports 可以用來判斷瀏覽器是否支援特定CSS語法，所以再加上CSS前啜詞就能判斷目前的瀏覽器核心。就以下列範例來說-webkit-transition，就可以判斷使用者的瀏覽器是否支援-webkit-transition，然後在執行其內容CSS。 @supports (-webkit-transition: all) .supports color: red &amp;:after content: &quot;-webkit-&quot; @supports (-moz-transition: all) .supports color: blue &amp;:after content: &quot;-moz-&quot; 這範例就只支援-webkit-與-moz-相容的瀏覽器，Chrome、Safari、Opera 應該會顯示紅色，Firefox會顯示藍色。 你的瀏覽器支援 結語如果看完這篇，還有想到什麼CSS冷知識，拜託…，跟我分享…。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"2014年度回顧","slug":"2014-year-report","date":"2015-01-07T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"life/2015/01/08/2014-year-report/","link":"","permalink":"https://wcc723.github.io/life/2015/01/08/2014-year-report/","excerpt":"2014年在學習上是豐收的一年…，踩著過往的基礎，學習速度越來越快；但還有許多地方經歷不足，對於許多事情也相當任性，除了能力的上升以外，對於人生也要多學習啊～。","text":"2014年在學習上是豐收的一年…，踩著過往的基礎，學習速度越來越快；但還有許多地方經歷不足，對於許多事情也相當任性，除了能力的上升以外，對於人生也要多學習啊～。 學習成就學習上，今年算是收穫滿滿，不僅學習了許多新技術，也實際運用在工作上，產能也明顯有所改變。除此之外，還接觸了自身領域以外的技術，透過這樣的學習，越來越能夠分辨如何是好。不過也要思考，這樣的跨出自身領域的學習，也要適可而止，別讓自己迷失方向。 CSS ArchitectureCSS的架構規範等不論是OOCSS、SMACSS，重點還是需要實際的運用，去年在工作上實作了一套CSS Framework，可以運用在數個專案上，並且可以客制調整所需，如色彩、文字大小、Class name都只需要修改設定檔即可，透過這樣的實作，才會瞭解何種架構是適合用在目前的專案上。 就以Bootstrap grid system 與 Susy 來說明，前者是整套的CSS Framework，已經將網格系統可能運用到的部分模組化，讓執行可以更加快速；Susy 可以自訂網格的各種方法，並且可以讓網格區塊更加語義化，讓HTML程式碼更為整齊。就結果上，Bootstrap grid system的概念較適合大型專案，並且產出專門的文件使協作更為容易；Susy 適合小型專案，可以快速建立彈性佳的網格，所以在使用上，必須了解目前專案適合的執行方式。故大型專案，我推類似Bootstrap grid system的方式執行(自幹啦)。 SASS &amp; Compass 前年開始專精於CSS以及SASS，這兩者影響我非常多，2014年也有不斷地精進這部分，尤其是在寫法上有更多的變化。Sass的學習上，有一部分是多看其他人的做法(Bootsrap sass有很多架構面可以學習，另外台灣也有很多高手可以參考)，還有多加練習及思考，只有實作才是進步的最佳方法；另外就是Sass 3.3的推出，多了許多新功能，不會這塊主要就用Source map而已…，就沒有仔細繼續鑽研了…。 D3.js 鐵人賽D3.js列表：http://wcc723.github.io/d3js/2014/10/29/Ironman-30-days-30/ 一度認為學了D3.js可以做出酷炫而且好用的圖表，這點我是誤會很深，在鐵人賽的時候花了很多時間學習D3.js(大概學了兩個多月)，許多細節都還沒辦法相當了解，死命的硬刻出自己想要的圖表…。以下是學習後的感受： 資料從何而來：資料取得是一個大問題，且各個地方的資料格式不同，怎樣可以降低取得資料的難度也是個大問題。 圖表呈現的正確性：資料是正確的，轉換過程也沒有出錯，但是圖可能是錯誤的(表達方法錯誤)，這樣會造成錯誤的訊息傳達。 演算法、統計學：圖表的製作，會牽扯到許多演算法及統計學的觀念，以我目前的能力完全無法了解這些學科，整個只能哭哭。 GitGit從前年開始接觸，去年上保哥的課程以及保哥的30日挑戰Git，在觀念上有很大的進展，且後來在公司內推廣Git以及推坑架設Gitlab，不斷的磨練後可以應付許多基本問題。 而Git的使用上，一開始是學習command line，現在多用Gui，主要原因是每次簽入時，我會習慣的整個看過簽入的檔案內容，檢查簽入內容是否正確、是否有不需要簽入的檔案、簽入訊息是否與檔案符合，這些步驟在Gui上較容易完成，而不足的功能，配合Google search及command line也足矣。 Gulp當初也猶豫很久，已經有了Fire.app是否有需要學習Gulp，後來也是抱著嘗試的心態去學習。兩者之間的比較是Fire.app已經提供大部分前端常用的工具，如Sass、Coffeescript、livereload、Template language等等，且易於使用，而Gulp是可以自定義這些工具，但必須寫一些script去執行它。所以在工作上只需要提供Html+CSS的專案上，我大多都是使用Fire.app；但如果是已經在進行的，或者是部分需要客制工具的專案(需搭配的部分較為複雜)，我則會使用Gulp來自定所需要的工具。 Angular雖然學過保哥Angular課程，但到現在我還只能算入門，但angular有很重要的觀念就是前端MVC以及two-way binding，如果說下一個要學習的Js lib，我會選擇angular專精…。 實務達成除了學習上，也有達成一些工作以外的項目。 IT鐵人賽兩度優選(獎盃寄到台北的家…還沒辦法拍照) 前年的IThome鐵人賽主題是CSS沒有極限，當時費盡心力寫45篇，讓我的CSS功力大幅精進。而去年IT鐵人賽運氣也不錯得了優選，主題是D3.js。 前年參加完，真的很累，想說別再參加這種競賽，結果去年又再一次…，今年會嗎…？ 發起翻譯Google Matrial Design Google Matrial Design 中譯版：http://wcc723.gitbooks.io/google_design_translate/ 目前這本書再Gitbook上還在前5名，非常感謝曾經幫助我翻譯的人(還配合翻譯第二輪&gt; &lt;)，且我也從執行這專案中學習了不少經驗。 開源專案的坑：在執行的開始，我知道要順利的完成，就必須讓參與者知道目前的狀態，不能讓參與者感覺到這專案的不安定性。我在hackpad上不斷的更新專案的進度以及預期的發展，讓參與者除了知道整體專案的狀態外，還可以知道其他參與者做了什麼。 把路鋪好：每個人都是從不同領域，憑藉的熱情來參與，在執行的習慣上多少有些不同，所以盡量將規則直接鋪好。在開始前我會先翻譯個幾篇當作範例，接下來會直接提供英文版的格式，讓翻譯者專注於翻譯，減少編寫習慣的不同，第一次時間上沒辦法執行的很徹底，但在第二次翻譯的時就是照這樣的方式執行。 更新：這部分也是相當費工的，如果有人檢查有翻譯上的問題，或者是Google Material更新，也是必須配合更新，好在有高手一起協助…。 2015的期望技術學習上還沒有思考要繼續學什麼，可能是繼續專精CSS，或者是學Angular，也有可能玩玩Rails，這都還在思考中。 但有另一個比較明確的方向，就是在高雄推廣開源專案。很羨慕台北有g0v這樣的團體，許多不同專業的高手一起合作，設計師和工程師的協作，彼此拉高互相的價值，這樣活動讓許多國家稱羨。希望能有機會參與類似的活動，但g0v也不就是先由少數人發起嗎？於是坑就在我的腦中浮現，慢慢的具現化…。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"參與開源專案","slug":"open-project-for-kh","date":"2014-12-30T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"project/2014/12/31/open-project-for-kh/","link":"","permalink":"https://wcc723.github.io/project/2014/12/31/open-project-for-kh/","excerpt":"最近有參與高雄的開源社群Code for Kaohsiung，除了人到場以外，也想盡份心力，所以試著來提出一個構想，花了些許時間建立了模型，並且拿到社群介紹這個構想。這個構想源自於之前所研究的D3.js，在後期的學習，會思考怎樣可以簡易的建立資料，並且運用圖表分享。","text":"最近有參與高雄的開源社群Code for Kaohsiung，除了人到場以外，也想盡份心力，所以試著來提出一個構想，花了些許時間建立了模型，並且拿到社群介紹這個構想。這個構想源自於之前所研究的D3.js，在後期的學習，會思考怎樣可以簡易的建立資料，並且運用圖表分享。 這僅僅是原型 這個原型輸入Google試算表的Key後，會從試算表中擷取資料，將資料的key及value整理後，使用者只要選擇需要的key，就會直接轉換成圖。如果完成預期情況使用者會透過以下步驟： 在Google spreadsheet上建立資料表格 取得Google spreadsheet Key 在該網站上貼上Key，並開始測試圖表 儲存圖表狀態，並且儲存 分享圖表 當天雛形已經可以做到很基本的1、2、3，介紹後不少人有興趣，讓我更有信心完成它，於是就找了高雄前端社群的主辦人來協助完成。 前端執行在開始製作時，為了可以快速且順利的完成，選擇較擅長的幾個技術，搭配些許其他應用，以下是主要的CSS Framework &amp; javascript lib。 bootstrap (套用版型，以及部分plugin功能) Jquery &amp; Jquery UI (主要Javascript lib) D3.js , C3.js (繪製圖表) 這些套件已經有包含大多數所需要的功能，可以快速地完成所需要的功能，不過在執行中遇到了些問題，像是Two way binding…，原本想用Jquery寫就是希望可以快點產出，而在使用者操作的部分，如資料的選擇、圖表的切換，如果沒有使用Two way binding，是很難達到良好的使用者體驗。如果還有下次，會希望趕快研究angular，在這部分可以較容易達到這個需求。 後端後端是使用Node.js，也是想趁機了解node Express的架構，以及前端配合的方式，在實際開始時，發現node express挺好上手的(就以前端來說)，接下來我也在上面運行gulp、coffeescript、sass等等…。如果有機會，會再向大家介紹所使用的前端技術的。 Deploy到Heroku是很棒的經驗，雖然在之前學Rails有推過一次，但這次不是透過教學啊！Heroku的方式，讓我有真正轉職到工程師的感覺，多麽的輕鬆優雅指令解決繁雜步驟…。 前端半成品 網站的入口，進入後如果是老手直接填入Key就可以了，如果是新手，會引導到教學範例。 這個圖表我從主計處挖來的資料，是關於各個行業的平均薪資，也可以看出各個行業在不同時間的成長及消退，從中也可以知道什麼行業行情好…，很值得入坑…。 除此之外，還會有其他使用者分享的頁面、範例教學、圖表下載等等功能，這些頁面也是不斷地調整操作流程，試著讓使用者易於理解。 如果可能的話，會盡量在農曆年前釋出第一版，也希望大家能夠給我們更好的回饋，並且以行動支持Code for Kaohsiung，不斷的激發更好的創作能量。","categories":[{"name":"project","slug":"project","permalink":"https://wcc723.github.io/categories/project/"}],"tags":[{"name":"project","slug":"project","permalink":"https://wcc723.github.io/tags/project/"}]},{"title":"專輯封面顏色作為背景色(平均色)","slug":"html5-canvas-04","date":"2014-12-17T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/18/html5-canvas-04/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/18/html5-canvas-04/","excerpt":"現在有些音樂專輯選單做得很豐富，其中一種背景色會隨著專輯色改變，我剛好想到以前有做一個CSS專輯選單，如果結合Canvas似乎就能達到差不多的效果，所以就來試試看。","text":"現在有些音樂專輯選單做得很豐富，其中一種背景色會隨著專輯色改變，我剛好想到以前有做一個CSS專輯選單，如果結合Canvas似乎就能達到差不多的效果，所以就來試試看。 範例之前的CSS範例 去年在練習CSS時就有寫一篇文章，是把CD封面作成3D的，這次就再拿這個範例做實驗，結果如下： 為愛而生 我們是五月天 神的孩子都在跳舞 後青春期的詩 人生海海 神的孩子都在跳舞 1 2 3 4 5 6 背景的顏色是使用Canvas來抓顏色資料，所以他還是必須有canvas元素，這也是可以隱藏的。 實作這一個實作的重點在於RGB顏色的平均，上一篇有介紹怎麼取得RGB的顏色，這次其實只要將RGB的顏色平均後寫入背景色就算完成了。 $(document).ready(function()&#123; var _canvas = document.getElementById(&#x27;canvas&#x27;); var ctx = _canvas.getContext(&#x27;2d&#x27;); $(&#x27;#album input&#x27;).on(&#x27;change&#x27;, function()&#123; //取得選擇的專輯封面 if ($(this).is(&#x27;:checked&#x27;))&#123; imgPath = $(this).next(&#x27;li&#x27;).find(&#x27;img&#x27;) .attr(&#x27;src&#x27;); getImg(imgPath); &#125; &#125;); function getImg(imgPath)&#123; var img = new Image(); img.src = imgPath; //取得圖片的路徑，並且讀取後取得長寬資料 img.onload = function()&#123; ctx.canvas.width = img.width; ctx.canvas.height = img.height ; draw(this,0,0); //draw function &#125;; &#125; function draw(imgObj,w,h)&#123; var x = 0, y = 0; var r=[],g=[],b=[];//準備空的R,G,B陣列 ctx.drawImage(imgObj,x,y); //將圖片繪製在canvas上 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); for(var i = 0; i &lt; imgData.data.length; i += 4) &#123; //製作原始R,G,B陣列 // red r.push(imgData.data[i]); // green g.push(imgData.data[i + 1]); // blue b.push(imgData.data[i + 2]); &#125; rgb = avg(r) + &#x27;,&#x27; + avg(g) + &#x27;,&#x27; + avg(b); //平均R,G,B顏色 $(&#x27;#album&#x27;).css(&#x27;background-color&#x27;,&#x27;rgba(&#x27;+rgb+&#x27;,1)&#x27;); //將顏色寫入背景 &#125; function avg(arguments) &#123; //取得平均值，並且轉為整數 var sum = 0; for (var i = 0, j = arguments.length; i &lt; j; i++) &#123; sum += arguments[i]; &#125; return Math.floor(sum / arguments.length); &#125; &#125;); 後記不過我相信實作並不是這麼容易做出來的，還會去分析顏色所佔的面積，利用較大面積色彩作為背景色，如果是這樣平均的色彩容易髒髒的，在畫面上不一定好看。並且還要去計算所適合的文字色彩，這麼說一說，似乎還有很多可以研究…。 .padding{ padding: 20px; } $(document).ready(function(){ var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); $('#album input').on('change', function(){ //取得選擇的專輯封面 if ($(this).is(':checked')){ imgPath = $(this).next('li').find('img') .attr('src'); getImg(imgPath); } }); function getImg(imgPath){ var img = new Image(); img.src = imgPath; //取得圖片的路徑，並且讀取後取得長寬資料 img.onload = function(){ ctx.canvas.width = img.width; ctx.canvas.height = img.height ; draw(this,0,0); //draw function }; } function draw(imgObj,w,h){ var x = 0, y = 0; var r=[],g=[],b=[];//準備空的R,G,B陣列 ctx.drawImage(imgObj,x,y); //將圖片繪製在canvas上 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); for(var i = 0; i < imgData.data.length; i += 4) { //製作原始R,G,B陣列 // red r.push(imgData.data[i]); // green g.push(imgData.data[i + 1]); // blue b.push(imgData.data[i + 2]); } rgb = avg(r) + ',' + avg(g) + ',' + avg(b); //平均R,G,B顏色 $('#album').css('background-color','rgba('+rgb+',1)'); //將顏色寫入背景 } function avg(arguments) { //取得平均值，並且轉為整數 var sum = 0; for (var i = 0, j = arguments.length; i < j; i++) { sum += arguments[i]; } return Math.floor(sum / arguments.length); } });","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Canvas (3)，Canvas 小畫家","slug":"html5-canvas-03","date":"2014-12-08T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/09/html5-canvas-03/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/09/html5-canvas-03/","excerpt":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 翻翻一年之前做的，才發現原來有很多很酷的東西，還好有寫成簡易的文章，讓現在再重新看可以很快瞭解，這篇是介紹用Canvas做小畫家，並且還可以下載下來的功能，有分為好幾段，這邊全部合併成一篇。","text":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 翻翻一年之前做的，才發現原來有很多很酷的東西，還好有寫成簡易的文章，讓現在再重新看可以很快瞭解，這篇是介紹用Canvas做小畫家，並且還可以下載下來的功能，有分為好幾段，這邊全部合併成一篇。 參考：http://codepen.io/hossman/pen/AyaFl 範例在開始介紹之前，先了解這個範例，這樣會更瞭解本篇所介紹的內容，Canvas範例的功能： 繪製線段 存檔 調整RGB色彩 所以可以在這上面隨意畫個幾筆，在調整色彩，最後在下載看看，這個功能簡簡單單，但是做出來挺有成就感的。 R G B R G B Sorry, your browser doesn't support the &lt;canvas&gt; element. 請先在上面隨便畫兩筆 Save Canvas HTML在看JS之前，先稍微看一下這個html，這HTML也和上面一樣，分為三個部分。 &lt;div class=&quot;demo&quot;&gt; &lt;!-- 調整色彩 --&gt; &lt;div class=&quot;color&quot;&gt; R&lt;input id=&quot;red&quot; type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot;&gt;&lt;br&gt; G&lt;input id=&quot;green&quot; type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot;&gt;&lt;br&gt; B&lt;input id=&quot;blue&quot; type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot;&gt; &lt;/div&gt; &lt;div class=&quot;value&quot;&gt; R&lt;input id=&quot;vred&quot; type=&quot;text&quot; value=&quot;0&quot;&gt; G&lt;input id=&quot;vgreen&quot; type=&quot;text&quot; value=&quot;0&quot;&gt; B&lt;input id=&quot;vblue&quot; type=&quot;text&quot; value=&quot;0&quot;&gt; &lt;/div&gt; &lt;!-- 調整色彩end --&gt; &lt;!-- Canvas --&gt; &lt;canvas id=&quot;canvas&quot; width=&quot;400&quot; height=&quot;400&quot;&gt; Sorry, your browser doesn&#x27;t support the &amp;lt;canvas&amp;gt; element. &lt;/canvas&gt; &lt;!-- Canvas end --&gt; &lt;!-- 下載 --&gt; &lt;a id=&quot;save&quot; href=&quot;#&quot; download=&quot;aShareaDay.png&quot; class=&quot;color-btn-green&quot;&gt;Save Canvas&lt;/a&gt; &lt;!-- 下載end --&gt; &lt;/div&gt; 繪製線段這篇是前幾篇的綜合，還有參考http://codepen.io/hossman/pen/AyaFl所製作出來的。 這一段的重點在於，取得滑鼠的座標getMousePos(canvas, evt)，先取得滑鼠在畫布上的座標，在每次滑鼠移動時，都會繪製在畫布上，然後再放開滑鼠時，離開偵聽的事件。 下載Html5 的 a 有新的屬性download，可以將此標籤預設為下載的功能，並且預設檔名，另外在canvas可以利用toDataURL()把canvas轉成data:image。。 &lt;!-- html5 新增download，可以用來預設下載檔名 --&gt; &lt;a id=&quot;save&quot; href=&quot;#&quot; download=&quot;dl.png&quot; &gt;Save Canvas&lt;/a&gt; 如果把產生出來的src貼在網址列，也能產生完整的圖片。 data:image參考:http://rritw.com/a/bianchengyuyan/C__/20131018/434112.html 調整色彩接下來在抓取那三個scroll bar的rgb值，將它直接寫入到ctx.strokeStyle，strokeStyle是Canvas上的筆畫樣式，這樣就大功告成了。 $(&#x27;.color input&#x27;).change(function()&#123; r = $(&#x27;#red&#x27;).val(); g = $(&#x27;#green&#x27;).val(); b = $(&#x27;#blue&#x27;).val(); changeColor(r,g,b); //取出input中的數值 &#125;); function changeColor(r,g,b)&#123; ctx.strokeStyle = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot; //將數值寫入到 strokeStyle內即可 &#125;; 完整程式碼var _canvas = document.getElementById(&#x27;canvas&#x27;); var ctx = _canvas.getContext(&#x27;2d&#x27;); $(&#x27;.color input&#x27;).change(function()&#123; r = $(&#x27;#red&#x27;).val(); g = $(&#x27;#green&#x27;).val(); b = $(&#x27;#blue&#x27;).val(); changeColor(r,g,b); //取出input中的數值 &#125;); function changeColor(r,g,b)&#123; colors = &#123; red : r, green : g, blue : b &#125; $.each(colors, function(_color, _value) &#123; $(&#x27;#v&#x27;+_color).val(_value); &#125;); ctx.strokeStyle = &quot;rgb(&quot;+r+&quot;,&quot;+g+&quot;,&quot;+b+&quot;)&quot; ; //將顏色的值寫到ctx.strokeStyle即可 &#125;; var x = 0; var y = 0; function getMousePos(canvas, evt) &#123; var rect = canvas.getBoundingClientRect(); //getBoundingClientRect 取得物件完整座標資訊，包含寬高等 return &#123; x: evt.clientX - rect.left, y: evt.clientY - rect.top &#125;; //這個function將會傳回滑鼠在 _canvas上的座標 &#125;; function mouseMove(evt) &#123; var mousePos = getMousePos(_canvas, evt); //透過getMousePos function 去取得滑鼠座標 //mousePos 是一個物件，包含x和y的值 ctx.lineTo(mousePos.x, mousePos.y); //利用取回的值畫線 ctx.stroke(); //畫! &#125;; canvas.addEventListener(&#x27;mousedown&#x27;, function(evt) &#123; var mousePos = getMousePos(_canvas, evt); //從按下去就會執行第一次的座標取得 evt.preventDefault(); ctx.beginPath(); //建立path物件 ctx.moveTo(mousePos.x, mousePos.y); //每次的點用moveTo去區別開，如果用lineTo會連在一起 canvas.addEventListener(&#x27;mousemove&#x27;, mouseMove, false); //mousemove的偵聽也在按下去的同時開啟 &#125;); canvas.addEventListener(&#x27;mouseup&#x27;, function() &#123; canvas.removeEventListener(&#x27;mousemove&#x27;, mouseMove, false); &#125;, false); //如果滑鼠放開，將會停止mouseup的偵聽 $(&#x27;#save&#x27;).on(&#x27;click&#x27;, function()&#123; var _url = _canvas.toDataURL(); //利用toDataURL() 把canvas轉成data:image this.href = _url; //再把href載入上面的Data:image &#125;); 在畫個小新，滑鼠挺有挑戰性的…。 雖然是一些舊的文章，但現在回頭過來看，還是有許多有趣的點，甚至可以用這些概念，配合現在會的技術，發展出更有趣的玩具。 var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); $('.color input').change(function(){ r = $('#red').val(); g = $('#green').val(); b = $('#blue').val(); changeColor(r,g,b); //取出input中的數值 }); function changeColor(r,g,b){ colors = { red : r, green : g, blue : b } $.each(colors, function(_color, _value) { $('#v'+_color).val(_value); }); ctx.strokeStyle = \"rgb(\"+r+\",\"+g+\",\"+b+\")\" ; //將顏色的值寫到ctx.strokeStyle即可 }; var x = 0; var y = 0; function getMousePos(canvas, evt) { var rect = canvas.getBoundingClientRect(); //getBoundingClientRect 取得物件完整座標資訊，包含寬高等 return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; //這個function將會傳回滑鼠在 _canvas上的座標 }; function mouseMove(evt) { var mousePos = getMousePos(_canvas, evt); //透過getMousePos function 去取得滑鼠座標 //mousePos 是一個物件，包含x和y的值 ctx.lineTo(mousePos.x, mousePos.y); //利用取回的值畫線 ctx.stroke(); //畫! }; canvas.addEventListener('mousedown', function(evt) { var mousePos = getMousePos(_canvas, evt); //從按下去就會執行第一次的座標取得 evt.preventDefault(); ctx.beginPath(); //建立path物件 ctx.moveTo(mousePos.x, mousePos.y); //每次的點用moveTo去區別開，如果用lineTo會連在一起 canvas.addEventListener('mousemove', mouseMove, false); //mousemove的偵聽也在按下去的同時開啟 }); canvas.addEventListener('mouseup', function() { canvas.removeEventListener('mousemove', mouseMove, false); }, false); //如果滑鼠放開，將會停止mouseup的偵聽 $('#save').on('click', function(){ var _url = _canvas.toDataURL(); //利用toDataURL() 把canvas轉成data:image this.href = _url; //再把href載入上面的Data:image }); input[type='range']{ width: 50%; } canvas{ margin: 0 auto; border: 1px solid #E80C7A; }","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Canvas (2)，調整Canvas圖片色調","slug":"html5-canvas-02","date":"2014-12-07T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/08/html5-canvas-02/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/08/html5-canvas-02/","excerpt":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage 這篇主要是介紹Canvas中調整RGB的值，藉此改變顏色色調。","text":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage 這篇主要是介紹Canvas中調整RGB的值，藉此改變顏色色調。 Canvas 調整色調利用canvas可以重新調整影像的樣式，其中一種就是改變色彩。 參考：http://www.html5canvastutorials.com/advanced/html5-canvas-invert-image-colors-tutorial/ 反轉顏色點陣圖是由很多的點構成的，而每一個點都是由RGB三色組成，所以要反轉顏色前必須先取得每一個點的RGB值。 //影像rgb的資訊 //以下數值每三個一組，如72,84,74這樣是一組，72是紅色(R)、84是綠色(G)、74是藍色(B) [72, 84, 74, 255, 85, 95, 86, 255, 98, 106, 95, 255, 103, 106, 97, 255, 107, 109, 98, 255, 117, 114, 105, 255, 123, 119, 108, 255, 125, 118, 108, 255, 133, 127, 115, 255, 134, 130, 118, 255, 139, 137, 125, 255, 143, 145, 132, 255, 150, 154, 140, 255, 155, 163, 148, 255, 163, 171, 158, 255, 166, 177, 163, 255, 175, 181, 169, 255, 177, 183, 171, 255, 183, 186, 175, 255, 185, 188, 177, 255, 187, 190, 179, 255, 188, 191, 180, 255, 191, 193, 182, 255, 192, 194, 183, 255, 196, 196, 184, 255…] 反轉顏色就是將(255 - 值)，這樣減了以後就會黑色變白色，黃色變藍等等。 var _canvas = document.getElementById(&#x27;canvas&#x27;); var ctx = _canvas.getContext(&#x27;2d&#x27;); //建立canvas物件 var img = new Image(); img.onload = function()&#123; ctx.canvas.width = img.width ctx.canvas.height = img.height draw(this,0,0); //draw function &#125;; img.src = &#x27;/images/2013-winter/cd2.jpg&#x27;; //圖片載入的事件(與上次同) function draw(imgObj,w,h)&#123; var x = 0; var y = 0; //先定義圖片的x,p坐標位置 ctx.drawImage(imgObj,x,y); //將原始的圖片匯入 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); //取得canvas物件的資訊(需要完整的坐標及範圍) var data = imgData.data; //再將資訊轉存出來 console.log(data); //這時候用console.log(data)，就可以看到RGB的值 for(var i = 0; i &lt; data.length; i += 4) &#123; //利用回圈將顏色全部替換 // red data[i] = 255 - data[i]; // green data[i + 1] = 255 - data[i + 1]; // blue data[i + 2] = 255 - data[i + 2]; &#125; ctx.putImageData(imgData,0,0) //重新將新的影像資訊覆蓋上去 &#125; Sorry, your browser doesn't support the &lt;canvas&gt; element. Note: The getImageData() method requires that the image is hosted on a web server with the same domain as the code executing it. If this condition is not met, a SECURITY_ERR exception will be thrown.(跨網域會有問題) var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); //建立canvas物件 var img = new Image(); img.onload = function(){ ctx.canvas.width = img.width ctx.canvas.height = img.height draw(this,0,0); //draw function }; img.src = '/images/2013-winter/cd2.jpg'; //圖片載入的事件(與上次同) function draw(imgObj,w,h){ var x = 0; var y = 0; //先定義圖片的x,p坐標位置 ctx.drawImage(imgObj,x,y); //將原始的圖片匯入 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); //取得canvas物件的資訊(需要完整的坐標及範圍) var data = imgData.data; //再將資訊轉存出來 console.log(data); //這時候用console.log(data)，就可以看到RGB的值 for(var i = 0; i < data.length; i += 4) { //利用回圈將顏色全部替換 // red data[i] = 255 - data[i]; // green data[i + 1] = 255 - data[i + 1]; // blue data[i + 2] = 255 - data[i + 2]; } ctx.putImageData(imgData,0,0) //重新將新的影像資訊覆蓋上去 } 手動調整色調利用剛剛的反轉顏色，再加入一些控制元素，就可以做出類似photoshop的影像調整工具(簡易版…)，說實在還挺有趣的。 首先，先新增三個input將type設定為range，min值爲0，max值爲255，這樣就能做出RGB的控制條。 &lt;div class=&quot;color&quot;&gt; R&lt;input id=&quot;colorR&quot; type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;255&quot;&gt;&lt;br&gt; G&lt;input id=&quot;colorG&quot; type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot;&gt;&lt;br&gt; B&lt;input id=&quot;colorB&quot; type=&quot;range&quot; name=&quot;points&quot; min=&quot;0&quot; max=&quot;255&quot; value=&quot;0&quot;&gt; &lt;/div&gt; R G B Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas2 = document.getElementById(&#x27;canvas2&#x27;); var ctx2 = _canvas2.getContext(&#x27;2d&#x27;); var _colorR = $(&#x27;#colorR&#x27;).val(); var _colorG = $(&#x27;#colorG&#x27;).val(); var _colorB = $(&#x27;#colorB&#x27;).val(); var x = 0; var y = 0; var img2 = new Image(); img2.onload = function()&#123; ctx2.canvas.width = img2.width ctx2.canvas.height = img2.height draw2(this,0,0); &#125;; img2.src = &#x27;/images/2013-winter/cd2.jpg&#x27;; //以上和上次接近，只是將幾個不太會改變的變數改成全域變數 $(&#x27;.color&#x27;).on(&#x27;change&#x27;,&#x27;input&#x27;,function()&#123; //多一個on change的function，去監控這次加入的input //只要他改變，就會執行這個function _colorR = $(&#x27;#colorR&#x27;).val() _colorG = $(&#x27;#colorG&#x27;).val() _colorB = $(&#x27;#colorB&#x27;).val() //重新取得input的 RGB的值 imgObj = img2; draw2(imgObj); &#125;); function draw2(imgObj,w,h)&#123; ctx2.drawImage(imgObj,x,y); var imgData = ctx2.getImageData(x, y, imgObj.width, imgObj.height); var data = imgData.data; for(var i = 0; i &lt; data.length; i += 4) &#123; // 這邊以下將會套用新的RGB色彩 // red data[i] = _colorR - (255 - data[i]); // green data[i + 1] = _colorG - (255 - data[i + 1]); // blue data[i + 2] = _colorB - (255 -data[i + 2]); &#125; ctx2.putImageData(imgData,0,0) &#125; var _canvas2 = document.getElementById('canvas2'); var ctx2 = _canvas2.getContext('2d'); var _colorR = $('#colorR').val(); var _colorG = $('#colorG').val(); var _colorB = $('#colorB').val(); var x = 0; var y = 0; var img2 = new Image(); img2.onload = function(){ ctx2.canvas.width = img2.width ctx2.canvas.height = img2.height draw2(this,0,0); }; img2.src = '/images/2013-winter/cd2.jpg'; //以上和上次接近，只是將幾個不太會改變的變數改成全域變數 $('.color').on('change','input',function(){ //多一個on change的function，去監控這次加入的input //只要他改變，就會執行這個function _colorR = $('#colorR').val() _colorG = $('#colorG').val() _colorB = $('#colorB').val() //重新取得input的 RGB的值 imgObj = img2; draw2(imgObj); }); function draw2(imgObj,w,h){ ctx2.drawImage(imgObj,x,y); var imgData = ctx2.getImageData(x, y, imgObj.width, imgObj.height); var data = imgData.data; for(var i = 0; i < data.length; i += 4) { // 這邊以下將會套用新的RGB色彩 // red data[i] = _colorR - (255 - data[i]); // green data[i + 1] = _colorG - (255 - data[i + 1]); // blue data[i + 2] = _colorB - (255 -data[i + 2]); } ctx2.putImageData(imgData,0,0) } 以前很多的範例，久沒看真的都會在忘記，趁這段時間整理的時候再稍微複習一下，","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Canvas","slug":"html5-canvas-01","date":"2014-12-03T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/04/html5-canvas-01/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/04/html5-canvas-01/","excerpt":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage","text":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage 來源：http://cssdeck.com/labs/css3-webkit-vertical-scrollbars 初入HTML5 CanvasHTML Canvas標籤裡面的字當然是不必要的，只是瀏覽器不支援canvas的話就會顯示，而canvas標籤是繪製canvas必要的元素，和img元素不同，他必須要結尾的標籤。 &lt;canvas id=&quot;canvas&quot; width=&quot;300&quot; height=&quot;300&quot;&gt; Sorry, your browser doesn&#x27;t support the &lt;canvas&gt; element. &lt;/canvas&gt; Rendering context這是指渲染的方式，而就我所參考的範例，將會用2D呈現，當然也是能夠有3D的渲染方式(看瀏覽器支援程度)。 參考：http://www.w3school.com.cn/htmldom/met_canvas_getcontext.asp var _canvas = document.getElementById(&#x27;canvas&#x27;); var ctx = canvas.getContext(&#x27;2d&#x27;); Canvas接下來就可以利用js把canvas繪製入canvas內了。 var _canvas = document.getElementById(&#x27;canvas&#x27;); if (_canvas.getContext) &#123; //判斷是否支援 var ctx = canvas.getContext(&#x27;2d&#x27;); //宣告ctx渲染方式 draw(); //執行draw function &#125;else &#123; alert(&#x27;your browser not support canvas&#x27;) //如果不支援 &#125;; function draw()&#123; //利用ctx開始繪製 ctx.fillStyle = &quot;rgb(200,0,0)&quot;; //fillStyle:定義用於繪畫的顏色填充模式 ctx.fillRect (10, 10, 55, 50); //fillRect:繪製被填充的矩形 ctx.fillStyle = &quot;rgba(0, 0, 200, 0.5)&quot;; ctx.fillRect (30, 30, 55, 50); //同上 &#125; Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas = document.getElementById('Canvas'); console.log(_canvas, '111'); if (_canvas.getContext) { var ctx = _canvas.getContext('2d'); draw(); }else { alert('your browser not support canvas') }; function draw(){ ctx.fillStyle = \"rgb(200,0,0)\"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\"; ctx.fillRect (30, 30, 55, 50); } canvas{ border: 1px rgba(255,255,255,.5) solid; } 這樣就繪製了一個簡易的Canvas圖形，跟SVG落差非常大呢。 繪製其他圖形參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/ 畫一些方形在上一次開始canvas後，接下來要畫一些東西，並了解他一些簡單的參數設定。 fillRect(x, y, width, height) //畫一個填滿色彩的正方形 strokeRect(x, y, width, height) //畫一個正方形線段外框 clearRect(x, y, width, height) //清除一個正方形區塊，並且讓它顏色透明 var _canvas2 = document.getElementById(&#x27;canvas2&#x27;); if (_canvas2.getContext) &#123; var ctx = canvas2.getContext(&#x27;2d&#x27;); draw2(); &#125; function draw2()&#123; ctx.fillStyle = &quot;rgb(200,0,0)&quot;; //正方形的填滿色彩 ctx.fillRect (10, 10, 130, 130); //繪製一個填滿色彩的正方形 ctx.clearRect(20, 20, 110, 110); //摟空一個正方形區域 ctx.strokeStyle = &quot;rgb(0,200,0)&quot;; //正方形線段的色彩 ctx.strokeRect(40, 40, 70, 70); //畫一個正方形線段 &#125; Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas2 = document.getElementById('canvas2'); if (_canvas2.getContext) { var ctx = canvas2.getContext('2d'); draw2(); } function draw2(){ ctx.fillStyle = \"rgb(200,0,0)\"; //正方形的填滿色彩 ctx.fillRect (10, 10, 130, 130); //繪製一個填滿色彩的正方形 ctx.clearRect(20, 20, 110, 110); //摟空一個正方形區域 ctx.strokeStyle = \"rgb(0,200,0)\"; //正方形線段的色彩 ctx.strokeRect(40, 40, 70, 70); //畫一個正方形線段 } 畫一些路徑beginPath() //建立一個線段，如果需要畫線段必須要建立一個新線段 closePath() //線段的結尾，這並不是必需的 stroke() //線段上色(筆畫) fill() //線段填滿顏色 其實這邊的觀念和adobe illustrator相當類似，Illustrator 中的線段一樣分為填色和筆畫，也有分為是不是封閉取線。 Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas3 = document.getElementById('canvasB'); if (_canvas3.getContext) { var ctx = _canvas3.getContext('2d'); draw3(); } function draw3(){ ctx.beginPath(); //線段開始 ctx.moveTo(20,100); //從20,100的點 ctx.lineTo(130,100); //畫線段到130,100 ctx.lineTo(75,25); ctx.fill(); //填滿 } var _canvas3 = document.getElementById(&#x27;canvasB&#x27;); if (_canvas.getContext) &#123; var ctx = canvas3.getContext(&#x27;2d&#x27;); draw3(); &#125; function draw3()&#123; ctx.beginPath(); //線段開始 ctx.moveTo(20,100); //從20,100的點 ctx.lineTo(130,100); //畫線段到130,100 ctx.lineTo(75,25); ctx.fill(); //填滿 &#125; Move To要畫一個好看的圖案太難了(崩潰)，所以我直接參考上面的提供的網址。 Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas4 = document.getElementById('canvasC'); if (_canvas4.getContext) { var ctx = _canvas4.getContext('2d'); draw4(); } function draw4(){ ctx.strokeStyle = \"rgb(220,200,45)\"; ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // Outer circle ctx.moveTo(110,75); ctx.arc(75,75,35,0,Math.PI,false); // Mouth (clockwise) ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // Left eye ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // Right eye ctx.stroke(); } //要畫一個好看的圖案太難了，所以我直接參考上面的提供的網址。 function draw4()&#123; ctx.strokeStyle = &quot;rgb(220,200,45)&quot;; //線段顏色 ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // 最外圈的線段 ctx.moveTo(110,75); //跳到另一個線段 ctx.arc(75,75,35,0,Math.PI,false); // 嘴巴 ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // 左眼 ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // 右眼 ctx.stroke(); //筆畫上色 &#125; 這些是舊的部落格文章，最近整理出來的部分。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"Webkit 自定義Scroll Bar外觀","slug":"css-scrollbar","date":"2014-12-02T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/12/03/css-scrollbar/","link":"","permalink":"https://wcc723.github.io/css/2014/12/03/css-scrollbar/","excerpt":"Webkit 可以利用CSS修改Scoll bar的外觀，有試過其他瀏覽器是不行的，而有時候在使用局部範圍的overflow: auto，會需要較為纖細的scroll bar，如果不在意webkit以外的瀏覽器，可以試試看這個方法。","text":"Webkit 可以利用CSS修改Scoll bar的外觀，有試過其他瀏覽器是不行的，而有時候在使用局部範圍的overflow: auto，會需要較為纖細的scroll bar，如果不在意webkit以外的瀏覽器，可以試試看這個方法。 來源：http://cssdeck.com/labs/css3-webkit-vertical-scrollbars 上面這是內建webkit的scroll bar，有些時候因為需要配合版面，這樣式並不合適，而Webkit的瀏覽器可以透過以下CSS來做調整。 &amp;::-webkit-scrollbar //&quot;&amp;&quot;是必須與上一層同層級 //-webkit-scrollbar : 整體的scrollbar樣式 &amp;::-webkit-scrollbar-thumb //bar的樣式 &amp;::-webkit-scrollbar-track //軌道的樣式 ::-webkit-scrollbar-thumb:window-inactive //頁面是在被啟用的情況下(非必要) scrollbar範例注意本範例只有Webkit瀏覽器有效，Chrome or Safari style1 style2 style3 style4 style5 style6 如果要跨瀏覽器的scrollbar，就建議使用javascript或是jquery了。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Jquery 重複點擊判斷","slug":"jquery-repeat-click","date":"2014-12-01T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"jquery/2014/12/02/jquery-repeat-click/","link":"","permalink":"https://wcc723.github.io/jquery/2014/12/02/jquery-repeat-click/","excerpt":"這篇是舊文重貼，原本是在aShareaDay上的文章，可能因為太短…，所以我沒放到這新的Blog上，但最近有人在詢問(感謝貴人提醒)，範例也相當實用，就再重新放上來。","text":"這篇是舊文重貼，原本是在aShareaDay上的文章，可能因為太短…，所以我沒放到這新的Blog上，但最近有人在詢問(感謝貴人提醒)，範例也相當實用，就再重新放上來。 Jquery有個很簡單的方式可以做到重複點擊判斷，這邊就不再多作闡述，只要看了範例就可以快速瞭解。 來源：http://jsfiddle.net/visualidiot/WJEBr/ 點我 $(&#x27;.d0818click&#x27;).click(function() &#123; $(&#x27;.old&#x27;).animate(&#123;left: &#x27;+=10&#x27;&#125;); $(&#x27;.new&#x27;).is(&#x27;:animated&#x27;) || $(&#x27;.new&#x27;).animate(&#123;left: &#x27;+=10&#x27;&#125;); &#125;); 寫到這，我突然想起來為什麼沒有放到這Blog上了…，因為當時Jekyll載入外部Js功能還沒寫好，後來寫好忘記放進來…，所以最近可以補很多以前的Js文章…。 另外舊的Blog(aShareaDay)因為空間沒有再續約，所以停了，大部分文章在這Blog都可以找到，有缺的部分也會盡量補齊，感謝大家的支持。","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"視覺前端 - 按鈕的使用情境","slug":"button-style-2","date":"2014-11-25T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"design/2014/11/26/button-style-2/","link":"","permalink":"https://wcc723.github.io/design/2014/11/26/button-style-2/","excerpt":"視覺規範沒有一定的標準，究竟是美醜優先，還是使用者體驗優先，這都沒有一個準則，當然在最理想的情況下，是能同時符合兩者。所以在按鈕的使用上，我嘗試找出一些規則，來讓畫面不至於凌亂，並且讓使用者可以感受到舒適。 而按鈕本身有著不同的個性，所以在畫面的使用上，也會依據需求的不同，來使用不同個性的按鈕。就算是同一個Framework所提供的按鈕，也會有相當多樣的選擇供開發者使用，但是選擇一多，往往也會造成困擾。 “目前的情況下該用哪種按鈕？” 上面的問題，我也思考很久，所以整理了幾種可能的性給大家參考參考。","text":"視覺規範沒有一定的標準，究竟是美醜優先，還是使用者體驗優先，這都沒有一個準則，當然在最理想的情況下，是能同時符合兩者。所以在按鈕的使用上，我嘗試找出一些規則，來讓畫面不至於凌亂，並且讓使用者可以感受到舒適。 而按鈕本身有著不同的個性，所以在畫面的使用上，也會依據需求的不同，來使用不同個性的按鈕。就算是同一個Framework所提供的按鈕，也會有相當多樣的選擇供開發者使用，但是選擇一多，往往也會造成困擾。 “目前的情況下該用哪種按鈕？” 上面的問題，我也思考很久，所以整理了幾種可能的性給大家參考參考。 外框線與填滿類型外框線與填滿類型，會因為網頁設計的底色有不同定義，假設背景是淺色系，那麼深色的按鈕就會被認定為填滿；反之，深色的背景，那麼淺色就是被認定為填滿。 這個部分我選擇Bootstrap 3的按鈕來說明(選用單純的按鈕，去除其他可能性)，左邊我稱為外框線的按鈕，右邊則是填滿的按鈕。 外框線的按鈕這種按鈕是通常是白色底或是淺灰階的底色，搭配上不同色彩的文字，文字的色彩通常預設為藍色或是黑色。 填滿的按鈕而填滿的按鈕，則是按鈕底色充滿色彩，如：黑色、藍色、紅色等等，文字的色彩通常是白色，當然也有可能會出現其他淺色系的文字。 外框線的按鈕 填滿的按鈕 吸引力 較不引人注目 吸引使用者注目 個性 輕鬆、細膩 大膽、強烈 用途 大部份的按鈕 希望使用者注意按鈕 色彩 淺色 或接近於背景色 深色 或者相對於背景色 重要度 低 高 接下來，在從一些範例來說明以上的內容。 範例奇妙清單 奇妙清單是一個雲端記事本的工具，有點類似Evernote，但是沒有那麼多功能，主要是利用列表來記錄待辦事項等等。這一類型的服務工具，首要工作就是吸引使用者的使用，有足夠的使用者試用後，才能在推銷更進階付費服務。 網站背景色是淺色系，綠色的試用按鈕以及右上方的藍色按鈕，都屬於先前所提到的填滿類型按鈕(兩者其實動作是類似的)；其他的部分如登入、觀看影片的動作都是外框線的按鈕。這也清楚地說明註冊、試用的動作比其他都還要重要，所以將註冊使用填滿類型的按鈕。 Github Github是Git雲端版本儲存庫，是目前最流行版本控管儲存庫，而這類型的工具，和一般使用者所接觸的網頁會有很大的不同，這類型網站有許多功能可以去設定、調整、觀看等等。所以在畫面上會有許多的按鈕，在這樣的情況下必須決定什麼是這畫面上最重要的，以及避免畫面的凌亂。 這畫面上，大多的按鈕都是屬於外框線類型的按鈕，只有一個綠色的填滿類型按鈕(Compare, review, create a pull request)，且是用圖示表示，那綠色按鈕是Git進行版本控管的一些功能，所以就這畫面而言，版本控管是最為重要的，這個方式不僅可以將重點標示出來，也可以保持畫面的整潔，試想：如果畫面充滿了五顏六色的按鈕，那麼重點在哪？ 另外，在Github的設定選項內，其中可以找到刪除儲存庫的功能，要特別注意到，”刪除”並不是重要的選項，而是要避免使用者誤觸，所以這部分Github使用外框線的按鈕，搭配紅色的文字。 Github這網站有相當多的功能，大家不妨隨便逛看看，它們在設計時，大多頁面通常只有一個填滿類型的按鈕(少數會超過一個)。 當然，這邊所提的原則，並不是絕對，也有很多更好設計(包含很好的UX)。但是在規劃版面按鈕還沒有任何想法時，可以嘗試這樣的規則。 找出畫面上最重要功能使用填滿類型的按鈕 其他通通都是用外框線類型的按鈕","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"高雄前端社群 - d3js","slug":"d3js-in-kh-frontend","date":"2014-11-24T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"d3js/2014/11/25/d3js-in-kh-frontend/","link":"","permalink":"https://wcc723.github.io/d3js/2014/11/25/d3js-in-kh-frontend/","excerpt":"上週在高雄前端社群介紹的D3.js，忘記放到Blog上，這次介紹的內容，和之前在鐵人賽有許多不同的點，範例很多都是全新的喲。","text":"上週在高雄前端社群介紹的D3.js，忘記放到Blog上，這次介紹的內容，和之前在鐵人賽有許多不同的點，範例很多都是全新的喲。 活動資訊KKTIX：http://gonsakon-7655f2.kktix.cc/events/a5791ac5 簡報連結：D3.js for 高雄前端 這次的範例很多，主要是想要讓大家可以透過範例快速理解(不過還是被說範例太多了orz，觀者會很累)，簡報不宜介紹過多的重點…。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"視覺前端 - 按鈕的個性","slug":"button-style-1","date":"2014-11-23T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"design/2014/11/24/button-style-1/","link":"","permalink":"https://wcc723.github.io/design/2014/11/24/button-style-1/","excerpt":"在參加完鐵人賽以後，會想要再精進UI設計的部分，所以想試著寫設計得文章，接下來會連續幾篇UI設計的文章，有些是在鐵人賽前就準備好的，最近在重新整理PO出來，希望大家會感興趣。 網路上有許多開源的Framework，通常我都會參考他們的按鈕以及表單設計，因為這是最能夠表達Framework特色的元件。按鈕與表單，按鈕更能表達一個Framework的個性，如圓角、顏色填充的方式、預設的色彩變化、單位計算方式(em or px)等等，當然表單也有，但許多為了實用性，表單會將設計簡化。","text":"在參加完鐵人賽以後，會想要再精進UI設計的部分，所以想試著寫設計得文章，接下來會連續幾篇UI設計的文章，有些是在鐵人賽前就準備好的，最近在重新整理PO出來，希望大家會感興趣。 網路上有許多開源的Framework，通常我都會參考他們的按鈕以及表單設計，因為這是最能夠表達Framework特色的元件。按鈕與表單，按鈕更能表達一個Framework的個性，如圓角、顏色填充的方式、預設的色彩變化、單位計算方式(em or px)等等，當然表單也有，但許多為了實用性，表單會將設計簡化。 現在大多的HTML元件，在執行上大多會使用CSS語法，較少使用圖片，這樣可以提高元件可用性，在維護上也較為容易。而我在設計按鈕時，以時常會參考這些Framework的做法，再加以改變，這些Framework有許多CSS細節，非常有參考價值。 以下列出幾個常見的CSS Framework button。 Bootstrap 2Bootstrap 2 自從 2 開始就是Web frontend相當主流的CSS Framework，在 3 發行之後，2 的維護也中止，使用這套Framework的開發者也相對少很多，但是在網路上還是經常可以看到由Bootstrap 2所設計的網頁，Bootstrap 2依然是一款經典的CSS Framewrok。 Bootstrap 2 按鈕設計特色 明顯的漸層 鮮豔的色彩 些許的內陰影 4px的圓角 凸起的立體感 早期的按鈕，許多都是用圖片做的，因為圖片可以表現立體感、圓角等等的質感，以前的CSS沒有辦法達到這樣的效果。直到了CSS3，圓角、漸層、陰影都可以透過CSS運用在web上，此時也就流行了透過CSS達到圖片可以做的效果，如Bootstrap 2所表現的。 這當中我最愛他的primary預設藍色漸層色彩，不僅顏色抓得恰到好處，搭配著些許內陰影，充分表現出類似圖片所能呈現的質感，但又更為精緻。 Bootstrap 3Bootstrap 3 扁平化設計 Metro UI 在Window 8推出以後(Metro UI)，許多UI設計開始導入扁平化設計(Flat Design)的概念，而Web當然也不例外。扁平化就廣義來說，是相對於擬真的設計，去除了陰影、立體感，使用色塊來組成視覺的界面。 Bootstrap 3 按鈕設計特色 單色、無漸層 顏色較為沈穩 無陰影 一樣4px的圓角 無立體感 相對於Bootstrap 2的立體效果，Bootstrap導入了扁平化設計的概念，除了圓角外，其他立體效果都被移除。雖然沒有以往的立體感，但這樣的做法可以有效地減少使用者界面複雜度，更能凸顯按鈕的功能。 整個Framework在設計上相當的偏重於功能性，移除了大部分的漸層、陰影，在單一按鈕的設計上，雖沒有Bootstrap 2 那麼的豐富，但也因為如此，他更能配合各網頁原有的設計，不會過度的突出。 Jquery Mobile 1.3Jquery Mobile 1.3 Jquery Mobile Jquery Mobile 是基於Jquery所開發的行動裝置Web Framework，不僅在樣式上，還有許多的在行動裝置可用的效果，而這款Framework也有屬於自己的CSS 樣式。 Jquery Mobile 1.3 按鈕設計特色 淺漸層 顏色較為暗沈 有陰影 1em的圓角 明顯浮起的立體感 Jquery mobile像對於其他CSS framework來說，視覺感較為工程導向，和Bootstrap2 比較來說，顏色稱不上鮮豔，較為混濁。畢竟Jquery mobile是用在行動裝置上，所以在規劃上並不是只有美觀，它凸顯了按鈕的立體感並且增加按鈕的尺寸，以便於觸控。 Jquery Mobile 1.4Jquery Mobile 1.4 Jquery Mobile 1.4和以往的設計有很大的落差，最大的差別就是導入了扁平化設計，所以在預設的款式是沒有圓角、陰影、漸層等效果。 Jquery Mobile 1.4 按鈕設計特色 無漸層 預設僅有黑白兩色 預設無陰影(可選擇) 預設無圓角(可選擇) 無立體感 就像上圖一樣，預設的按鈕相當的扁平，雖然他也提供圓角、陰影作為選擇，但沒有以往的強烈。另外在尺寸上有很重要變化，就是基本的按鈕高度為44px，44px是行動裝置上手指合適的觸控範圍尺寸。 而Jquery Mobile兩個不同版本也刻意一起放出來比較，兩個在設計上已有很大的落差，1.4去除了許多裝飾(大圓角、漸層)，也將小圖示從png圖片換成了svg，這在retina顯示器的表現更為精緻。整體設計來說，我偏愛1.4的扁平化，不知大家覺得如何？ PurePure CSS Pure CSS Framework的設計理念是為了讓CSS更為簡單化，所有的元件都分為核心以及擴充兩類別，核心通常定義元件的尺寸、瀏覽器相容性，擴充則是定義元件的色彩、更多尺寸、不同狀態等。 Pure 按鈕設計特色 無漸層 (Hover有) 單色 無陰影 2px 圓角 無立體感 Pure的按鈕，就視覺上是我喜歡的類型，有著簡單的外形、細膩的變化，用相當少量的程式碼達到跨瀏覽器的效果。另外Pure的按鈕有個很特別的特色，是其他Framework少見的效果，就是在hover的色彩，按鈕無論是哪一種顏色，都僅用半透明的漸層色覆蓋在上面，這樣可以有效地減少CSS程式碼，又能表現出hover的效果，我想這是最符合Pure簡化的個性吧。 Pure整個Framework在設計概念上就是要不斷地縮短CSS code，所以和其他Framework都有些不同，但又同時保有細膩的設計，也是很值得參考的framework。 結論以上列出了幾款不同framework的按鈕，不論他的架構，透過不同的設計，自然而然就會產生不同的個性，而這些個性，也會依據觀者的不同，會有不同的解讀方式；有人會喜歡Bootstrap 2的鮮豔漸層變化，也會有著許多人喜歡Bootstrap 3的純粹色彩，當然顏色深淺、鮮豔程度也都有不同的觀感。 在製作時，參考合適的Framework風格(設計)，並挑選合適的執行方式(CSS)，在初學上可以減少錯誤，提升專案的可執行性。 這篇看到了相當多的按鈕，接下來可能會出現一個問題，目前畫面適合放什麼按鈕，所以下一篇要介紹的是按鈕在畫面上的佈局規劃，如何透過簡單的方式，清楚了解目前畫面上合適的按鈕樣式。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"前端設計師的設計與執行","slug":"frontend-designer-how-to-work","date":"2014-11-11T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"design/2014/11/12/frontend-designer-how-to-work/","link":"","permalink":"https://wcc723.github.io/design/2014/11/12/frontend-designer-how-to-work/","excerpt":"圖片來源 google material design 看到 嫁給RD的 UI Designer 的這篇文章有感，想說也寫一下我對於這個主題的想法，在工作的流程中，每個人所佔的崗位不同，都會有不同的觀點，她的這一篇所在的角色是UI，我的看法是設計師與前端之間的角色。 從學設計到現在轉職成前端，因為設計背景的關係，所以大部份在執行時都是從設計到切版都是我做，這在執行上並一定是好的流程，只是不同崗位，有不同的觀點，同時橫跨兩個崗位，就會掌握不同的面向，但畢竟是一個人，無法面面俱到，所以這邊會提出一些我的看法及解決辦法。","text":"圖片來源 google material design 看到 嫁給RD的 UI Designer 的這篇文章有感，想說也寫一下我對於這個主題的想法，在工作的流程中，每個人所佔的崗位不同，都會有不同的觀點，她的這一篇所在的角色是UI，我的看法是設計師與前端之間的角色。 從學設計到現在轉職成前端，因為設計背景的關係，所以大部份在執行時都是從設計到切版都是我做，這在執行上並一定是好的流程，只是不同崗位，有不同的觀點，同時橫跨兩個崗位，就會掌握不同的面向，但畢竟是一個人，無法面面俱到，所以這邊會提出一些我的看法及解決辦法。 規劃首先，在設計前必須了解需求，需求不外乎包含瀏覽器限制、Responsive web design、整體色調、是否包含維護、配合的後端技術or其他framework等等…，再從這些面向去思考設計如何執行。 瀏覽器限制基本上我現在所執行的網站大多是IE8+，甚至是不用管IE(在2013年後期政府專案很多都只要ie8+)，這些直接影響了所使用的CSS layout、CSS3效果、SVG等等效果，如果還有使用webfont，雖然可以執行，但是Render 會很醜…。 如果遇到需要配合低階瀏覽器，會避免掉許多效果，像是RWD、Retina display。配合低階瀏覽器，還要做這些，無疑是拿石頭砸自己的腳；且目標客群都不想用新式瀏覽器，自然也不會在乎這網站上用了什麼技術。 設計工具講到這就突然難過了起來，以前我都是使用Illustrator，在設計Web時剛開始也就認命的辛苦些(有點難用)，直到了用過Sketch、Affinity Designer，發現不僅是程式不斷的在演化，設計工具也是必須有改變，但苦於想學的東西太多，不知不覺設計工具的優先值就被往後排了。 因此在設計前先了解對於軟體的熟悉度，以及專案是否有配合其他設計師，從中判斷用哪套軟體(現在我多用Sketch 起手)。 關於Sketch、Affinity Designer，兩套我都有買，但並非相當精通，我認為Sketch較偏向Layout，而Affinity比較適合繪製細節，像是Icon、Logo等。 Sketch Affinity Designer Responsive web design這也是重點中的重點，今年以前Responsive web design只要提出來，價碼都好說好說(以後幾乎是必備)，所以在前公司提案時，盡量都會以Responsive web design為賣點，以增加拿到案子的成功率，所以既然挖了這個坑就要自己跳了…。 RWD在執行時，要先思考使用CSS framework 或是自己用sass做，在過去我主要會使用sass 搭配 susy執行，但現在由於專案越來越大，我就會自幹CSS framework。兩者不同點在於susy 比較適合小型專案，他可以語意化Class，可以快速搭建小型專案所需的layout，但在大型專案中，所有的CSS最好都是模組化，可供各頁面重複使用，以增加工作效率。 如果真有要考慮RWD，會Sass是比較好，如果不熟Sass，使用bootstrap grid system可能會穩定些。 顏色(這部分我改天整理更完整的) 在使用繪圖軟體時，調色我都使用RGB bar去拉，再把最適合的色彩存在色票內，可能會約存5種色彩(主要顏色、底色、次要色、警告色、提示色等)，有點類似bootstrap所提供色彩，但會因為專案的不同所調整。 常用的顏色會拉下來當色票，不過建議是排整齊，別跟我一樣，排整齊之後反而找不到…。 顏色上再進入sass開發後，會定義成變數，並且在套用時進行色彩運算，如果是經常使用的色彩，也可以先運算。 $primary-color: #009aff $primary-color-darken: darken($primary-color, 10%) $primary-color-lighten: lighten($primary-color, 10%) See the Pen zxOgZR by Wcc723 (@Wcc723) on CodePen. 這樣可以讓顏色更有系統的管理，不過變數的命名又是另一門學問了，這邊就不再多作闡述。 維護這直接影響這個專案的未來，有資歷的開發者都很有感觸，到底要不要挖坑給未來的自己跳…，只有經驗會告訴你。 不過以為專案就像石頭往河裡丟一樣，但常常像飛盤一樣飛回來打到自己。 配合的後端以及相關Framework、library執行前，有機會也可以先和配合的後端聊聊，雖然我寫的是Sass，但卻沒有配合過Rails or Node.js專案(泣)，可以先了解後端了解的事項有： 切好的Prototype如何交付 細部的已知功能工作分配 (javascript的分配) 專案架構是否為MVC，以及版面修正配合方式 接下來還可以詢問javascript library為何，一般來說最常使用的jquery，如果是jquery還要了解版本為何，以及可能會使用到的plugin，就以我工作上來說，大多會另外使用bootstrap js、datatable等等，這些在設計上就可以盡量使用。 除了這些之外，更重要的當然是怎樣做好Web UI，除了多看好的設計之外，更重要的是要閱讀Style guide，UI設計和程式有很大的關係，必須依據一定的準則，在執行及操作上才會有良好的體驗。 如果要推薦一份Style guide，當然就是Google material design，而且運氣不錯，有人翻譯成繁體中文版了(http://wcc723.gitbooks.io/google_design_translate/)。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"Gulp RUN ruby-compass","slug":"gulp-on-diff-os","date":"2014-11-06T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"gulp/2014/11/07/gulp-on-diff-os/","link":"","permalink":"https://wcc723.github.io/gulp/2014/11/07/gulp-on-diff-os/","excerpt":"最後一篇，來介紹gulp-compass，這一篇的內容較短，但是要特別注意系統是否可以運作ruby以及ruby compass(由於compass有更新)，所以和前一篇的差別會是多了ruby。","text":"最後一篇，來介紹gulp-compass，這一篇的內容較短，但是要特別注意系統是否可以運作ruby以及ruby compass(由於compass有更新)，所以和前一篇的差別會是多了ruby。 gulp-compass是呼叫ruby compass來運作，所以電腦內必須有ruby環境，所以建議先確認電腦內的ruby compass是否能正常運作，再來進行以下步驟。而目前compass的版本是1.01^，詳情就請參照compass官方網站。 http://compass-style.org 安裝Compass記得，在安裝compass與susy前，請確認電腦裡是否有ruby的環境，terminal內輸入ruby -v。 ruby -v 接下來輸入以下指令來安裝compass。可參考http://compass-style.org/install/ gem update —system gem install compass 輸入gem install susy，來安裝susy。可參考http://susydocs.oddbird.net/en/latest/install/ 輸入以下指令來驗證是否安裝成功 compass -v gem -v susy gulp-compass這一段和之前也相同，打開terminal輸入npm install —save-dev，安裝完後打開gulpfile.js。 這個範例已經包含常用的設定，當然也可以參考https://www.npmjs.org/package/gulp-compass。 //gulpfile.js var gulp = require(&#x27;gulp&#x27;), concat = require(&#x27;gulp-concat&#x27;), uglify = require(&#x27;gulp-uglify&#x27;), webserver = require(&#x27;gulp-webserver&#x27;), compass = require(&#x27;gulp-compass&#x27;), //新增gulp-compass coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;compass&#x27;, function() &#123; gulp.src(&#x27;app/sass/*.sass&#x27;) //來源路徑 .pipe(compass(&#123; //這段內輸入config.rb的內容 css: &#x27;app/assets/css&#x27;, //compass輸出位置 sass: &#x27;app/sass&#x27;, //sass來源路徑 sourcemap: true, //compass 1.0 sourcemap style: &#x27;compact&#x27;, //CSS壓縮格式，預設(nested) comments: false, //是否要註解，預設(true) require: [&#x27;susy&#x27;] //額外套件 susy &#125;)) // .pipe(gulp.dest(&#x27;app/assets/temp&#x27;)); //輸出位置(非必要) &#125;); gulp.task(&#x27;watch&#x27;, function () &#123; //自定一個watch的排程名稱 gulp.watch(&#x27;./app/coffeescripts/*.coffee&#x27;, [&#x27;coffee&#x27;]); //監聽路徑，以及檔案變更後所執行的任務 gulp.watch(&#x27;./app/sass/*.sass&#x27;, [&#x27;compass&#x27;]); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;coffee&#x27;,&#x27;compass&#x27;,&#x27;webserver&#x27;,&#x27;watch&#x27;]); 接下來輸入gulp，就可以開始使用compass 1.0了，當然這邊要特別注意susy，這susy的版本是2，與1差異很大，如果安裝後想使用susy1，sass內import請輸入 @import “susyone”。 //sass 檔案內容 @import &quot;compass/reset&quot; @import &quot;compass&quot; @import &quot;susy&quot; body background-color: black .container +container(80em) .span6 color: orange +span(6 of 12) 會輸出成像下面這樣，還會包含source map。 /*css reset…. 略*/ body &#123; background-color: black; &#125; .container &#123; max-width: 80em; margin-left: auto; margin-right: auto; &#125; .container:after &#123; content: &quot; &quot;; display: block; clear: both; &#125; .span6 &#123; color: orange; width: 49.15254%; float: left; margin-right: 1.69492%; &#125; /*# sourceMappingURL=style.css.map */ 如果是從前面的相關文章開始看，目前gulpfile.js檔案結果會像下面這樣。 var gulp = require(&#x27;gulp&#x27;), concat = require(&#x27;gulp-concat&#x27;), uglify = require(&#x27;gulp-uglify&#x27;), webserver = require(&#x27;gulp-webserver&#x27;), compass = require(&#x27;gulp-compass&#x27;), coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;coffee&#x27;, function() &#123; //‘coffee&#x27;是排程名稱，可自定 gulp.src(&#x27;./app/coffeescripts/*.coffee&#x27;) //來源檔案 .pipe(coffee()) //編譯 .pipe(concat(&#x27;main.js&#x27;)) //合併成一隻 .pipe(uglify()) //壓縮、醜化 .pipe(gulp.dest(&#x27;./app/assets/js&#x27;)) //輸出位置 &#125;); gulp.task(&#x27;webserver&#x27;, function() &#123; gulp.src(&#x27;app&#x27;) //起始目錄 .pipe(webserver(&#123; host: &#x27;0.0.0.0&#x27;, //host設定&#x27;0.0.0.0&#x27;，就可以用內網檢視 port: 10000, //設定一個沒在使用的port livereload: true, //auto refresh open: true //執行gulp時自動開啟browser &#125;)); &#125;); gulp.task(&#x27;compass&#x27;, function() &#123; gulp.src(&#x27;app/sass/*.sass&#x27;) //來源路徑 .pipe(compass(&#123; //這段內輸入config.rb的內容 css: &#x27;app/assets/css&#x27;, //compass輸出位置 sass: &#x27;app/sass&#x27;, //sass來源路徑 sourcemap: true, //compass 1.0 sourcemap style: &#x27;compact&#x27;, //CSS壓縮格式，預設(nested) comments: false, //是否要註解，預設(true) require: [&#x27;susy&#x27;] //額外套件 susy &#125;)) // .pipe(gulp.dest(&#x27;app/assets/temp&#x27;)); //輸出位置(非必要) &#125;); gulp.task(&#x27;watch&#x27;, function () &#123; //自定一個watch的排程名稱 gulp.watch(&#x27;./app/coffeescripts/*.coffee&#x27;, [&#x27;coffee&#x27;]); //監聽路徑，以及檔案變更後所執行的任務 gulp.watch(&#x27;./app/sass/*.sass&#x27;, [&#x27;compass&#x27;]); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;coffee&#x27;,&#x27;compass&#x27;,&#x27;webserver&#x27;,&#x27;watch&#x27;]); Gulp 系列文章 Gulp 環境安裝 Gulp Task and Gulp Pipe Gulp webserver 以及在不同系統上運作 Gulp Gulp RUN ruby-compass","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"}]},{"title":"Gulp webserver 以及在不同系統上運作 Gulp","slug":"gulp-on-diff-os","date":"2014-11-05T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"gulp/2014/11/06/gulp-on-diff-os/","link":"","permalink":"https://wcc723.github.io/gulp/2014/11/06/gulp-on-diff-os/","excerpt":"透過以上兩篇，基本上已經可以套用許多gulp的工具，而這篇要介紹的是gulp webserver，以及在不同環境使用gulp (mac OS, Windows)。","text":"透過以上兩篇，基本上已經可以套用許多gulp的工具，而這篇要介紹的是gulp webserver，以及在不同環境使用gulp (mac OS, Windows)。 Gulp web server首先，先裝gulp-webserver，這一套已經包含許多功能，甚至livereload都已經含在內部。 npm install --save-dev gulp-webserver 一樣打開Gulpfile.js，加上以下js。 var gulp = require(&#x27;gulp&#x27;), concat = require(&#x27;gulp-concat&#x27;), uglify = require(&#x27;gulp-uglify&#x27;), webserver = require(&#x27;gulp-webserver’), //定義webserver coffee = require(&#x27;gulp-coffee’); gulp.task(&#x27;webserver&#x27;, function() &#123; gulp.src(&#x27;app&#x27;) //起始目錄 .pipe(webserver(&#123; host: &#x27;0.0.0.0&#x27;, //host設定&#x27;0.0.0.0&#x27;，就可以用內網檢視 port: 10000, //設定一個沒在使用的port livereload: true, //auto refresh open: true //執行gulp時自動開啟browser &#125;)); &#125;); gulp.task(&#x27;default&#x27;, [&#x27;coffee&#x27;,&#x27;webserver&#x27;,&#x27;watch&#x27;]); //加上web server 接下來一樣回到terminal，輸入gulp，就會直接打開web，webserver這一套直接可以auto refresh，而且在跨裝置的情況下一樣可行。 特別注意：如果有開啓其他有auto refresh的軟體，可能會造成其中一方auto refresh失效(EX:Fire.app)。 這時候修改index.html或者是其他檔案修改後都會自動refresh，也不需要額外安裝套件(所以沒有限定Chrome)。 接下來直接使用wifi的內網ip加上port，也可以直接瀏覽，這個網址直接複製到使用相同wifi的裝置上也是可行的。 修改內文也一樣，裝置上的網頁也會自動refresh。 在windows上執行Gulp先前的所有範例，都是在Mac上做範例，如果此時加入使用其他環境的開發該如何配合？且Git上如何管理？ 在剛剛所介紹的範例中，所有的gulp 套件都會安裝在node_modules這個資料夾內，只要透過package.json，就可以一個指令安裝回所有的套件。所以如果有使用git，就可以直接忽略這個資料夾，同理，在給其他開發者，也不需要這個資料夾。 將整個專案移到windows內(不需要node_modules資料夾)。 只需要保留gulpfile、package.json、app資料夾即可。 輸入npm install ，就可還原node_modules資料夾，接下來一樣執行gulp就可以運行了。 這樣就可以還原整個專案，且在不同作業系統都可以正常運作。","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"}]},{"title":"D3.js 鐵人賽的結束","slug":"Ironman-30-days-30","date":"2014-10-28T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/29/Ironman-30-days-30/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/29/Ironman-30-days-30/","excerpt":"這次參加鐵人賽，我也猶豫了很久，在開始前我已經準備好了近十篇另一個主題(視覺前端與前端技術)，但是牙一咬就報名了另一個主題d3.js，用意是想學d3.js。學習的過程中挫折也是挺大的，因為我對於資料處理並不擅長，光在json的處理就費盡心思，還好在學習的過程中有許多人可以讓我詢問該怎麼做，不然真知道怎撐到最後。","text":"這次參加鐵人賽，我也猶豫了很久，在開始前我已經準備好了近十篇另一個主題(視覺前端與前端技術)，但是牙一咬就報名了另一個主題d3.js，用意是想學d3.js。學習的過程中挫折也是挺大的，因為我對於資料處理並不擅長，光在json的處理就費盡心思，還好在學習的過程中有許多人可以讓我詢問該怎麼做，不然真知道怎撐到最後。 在寫的過程中，原本想要在SVG結束之後，看著書做到底就好…，又怕被覺得太混，於是就一直到處挖可以用的資料或是技術，結果越挖越遠，造成文章順序有點跳躍式的…，為了避免這個問題，下次還是選熟悉些的技術好了，哈哈。 再怎麼說，透過這次的鐵人，也是有達到目的，就和上次一樣，一個月的密集研究，可以快速地學習一項技術，就像進入精神時光屋一樣，在30天內進步其他人一年的程度…。 在此就列出30天的成就吧： SVG SVG 簡介 SVG 超硬派了解 line, polygon, polyline, path (手工繪製) SVG 超硬派了解 path Arcs SVG Defs 以及 CSS SVG Stroke , Marker 以及 CSS D3.js 基礎 初入D3.js D3js 將資料投影到SVG上 D3.js Scale 尺度 D3.js 國慶日在家裡畫長條圖 D3.js 讀取CSV資料並繪製成長條圖 D3.js 軸線(Axis) D3.js 折線圖(Line Chart) D3.js Transition動態效果 D3.js 資料數量增減 D3.js 主題範例 D3.js 究竟搭不搭捷運與死亡率有沒有關係？(1) D3.js 究竟搭不搭捷運與死亡率有沒有關係？(2) - Google 試算表 D3.js 究竟搭不搭捷運與死亡率有沒有關係？(3) - 將資料繪製成折線圖 像jQuery 一樣的D3.js，柯P野生官網API D3.js 也可以像音樂一樣動吃動吃動(1) D3.js 也可以像音樂一樣動吃動吃動(2) D3.js layout (以環保局資料為例) D3.js 再看更多layout前，先來轉換json結構 柯P的財務報表套用 D3js Partition Layout D3.js 小玩意 D3.js 圈圈小效果 D3.js 超粘的Voronoi Diagram繪圖 其他工具 D3js 前置作業，製作簡易Server D3.js 利用Excel建立資料(CSV) PDF轉CSV，利用Tabula 以上次這次鐵人賽的文章，如果對文章內容有問題，也歡迎留言給我。下次還是不幸被推坑的話，還是做視覺前端的相關主題吧！ 另外，我在暑假期間的時候有發起翻譯Google Material的活動，目前還是Gitbook上的暢銷書，在此推薦大家閱讀。 http://wcc723.gitbooks.io/google_design_translate/ 就這麼樣，我們下次見(如果還有力氣的話)。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"PDF轉CSV，利用Tabula","slug":"Ironman-30-days-29","date":"2014-10-27T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/28/Ironman-30-days-29/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/28/Ironman-30-days-29/","excerpt":"D3.js最重要的就是資料，所以需要有許多不同的資料轉換方式。PDF是常見的檔案格式，因為製作方便，又可以跨裝置，所以PDF也是經常取得的檔案格式之一，相信大家都使用過PDF格式，它很適合閱讀，但至於轉成資料格式呢？似乎就沒有那麼容易。 這篇就來介紹Tabula將PDF轉換成CSV作為D3.js所需要的資料格式","text":"D3.js最重要的就是資料，所以需要有許多不同的資料轉換方式。PDF是常見的檔案格式，因為製作方便，又可以跨裝置，所以PDF也是經常取得的檔案格式之一，相信大家都使用過PDF格式，它很適合閱讀，但至於轉成資料格式呢？似乎就沒有那麼容易。 這篇就來介紹Tabula將PDF轉換成CSV作為D3.js所需要的資料格式 Tabula在幾個月前，Code for Kaohsiung辦了一個小活動，想讓工程師動手幫高雄，就類似g0v，不過區域不同而已。那次請到了g0v的高村長，他介紹了一個工具可以將PDF迅速轉成CSV，那就是Tabula，這次就來介紹這神奇的工具吧。 安裝Tabula : http://tabula.nerdpower.org/ 在進入Tabula官網後，就可以下載windows、Mac OS的安裝檔，如果是老手的話，也可以選擇Github手動安裝，而我是選擇直接download for Mac。 啟動安裝完後，啟動Tabula他會自動開啟瀏覽器，並且進入Tabula，如果沒有可以手動輸入127.0.0.1:8080，再不行請看看8080 port是不是被佔據了(預設為8080 port)。 使用使用上非常容易，只要以下幾個步驟就可以完成： 選擇檔案 選擇範圍 匯出 1.選擇檔案開啟網站後，下方就有很明顯的選擇檔案。 2.選擇範圍選擇範圍是利用圈選的，如果Pdf有相當多頁，可以選擇repeat this selection，就會用相同的大小、位置套用在每個頁面(如果每頁都對不上就手動了…)，至於小技巧，就是要多操作才能體會了。 選好區域後，就選擇Download csv吧。 3.匯出接下來略等一小段時間，就會跳出轉好的表格，這部分是預覽轉出的狀態，確認是接近預期的狀態後，就下載CSV，或者是複製到剪貼簿也行。 到這部分Tabula工作已經結束了。 整理檔案範例檔案：http://kptaipei.tw/?page_id=3366 這次的範例檔案是柯P的競選經費PDF檔，轉完之後還是需要到編輯器略作處理，就以這個範例來說，每個頁面的標頭也被轉出來了，那麼就必須將它刪去。 存檔以後，一份資料CSV就完成了，就可以供d3.js使用，相信對需要整理政府資料的工程師相當實用…。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"柯P的財務報表套用 D3js Partition Layout","slug":"Ironman-30-days-28","date":"2014-10-26T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/27/Ironman-30-days-28/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/27/Ironman-30-days-28/","excerpt":"看到KP API裡面有提供競選經費查詢，如果之前把資料撈回來，很難了解支出收入的關係，而且在支出與收入之中，何者比例較高。","text":"看到KP API裡面有提供競選經費查詢，如果之前把資料撈回來，很難了解支出收入的關係，而且在支出與收入之中，何者比例較高。 D3.js Partition layout參考：http://bl.ocks.org/mbostock/4348373 透過這張圖，雖然沒有數值可以了解精確的關係，但可以透過視覺快速比較彼此之間的概略比率，這也是d3.js內建的layout之一，且在這頁面上可以看到完整的程式碼，只要套用就可以了。 不過在套用前，要先轉換json的格式，昨天的文章對此有介紹，所以對d3js結構轉換可參考casper/d3js/2014/10/26/Ironman-30-days-27/。 範例詳細競選經費，還是以柯文哲官網提供為主 資料來源一樣是透過KP的API，只要資料結構轉換完，可以很輕鬆的套用各種d3.js layout範例。另外，在這個範例中整個圓並不是代表總金額，而只是支出與收入的比較圖。 Infomation 款項 : 類別 : 金額 : kpPath = &#x27;http://api.kptaipei.tw/v1/financial/all&#x27; // 將nest資料改成name, children function reSortRoot(root,value_key) &#123; for (var key in root) &#123; if (key == &quot;key&quot;) &#123; root.name = root.key; delete root.key; &#125; if (key == &quot;values&quot;) &#123; root.children = []; for (item in root.values) &#123; root.children.push(reSortRoot(root.values[item],value_key)); &#125; delete root.values; &#125; if (key == value_key) &#123; root.value = parseFloat(root[value_key]); delete root[value_key]; &#125; &#125; return root; &#125; // 將nest資料改成name, children d3.json(kpPath, function(d)&#123; //透過KP API撈資料 dataset = d.data; var nodesByType = d3.nest() //匯入資料轉成巢狀 .key(function(d) &#123; return d.type; &#125;) .key(function(d) &#123; return d.account; &#125;) .entries(dataset); //匯入KP資料 var root = &#123;&#125;; //定義一個空的物件 root.key = &quot;Data&quot;; //定義物件名稱 root.values = nodesByType; //以及物件來源 //將json的key轉成name, children root = reSortRoot(root,&quot;KpData&quot;); console.log(root) runChart(root) //資料轉完後就來開始畫圖 &#125;); function runChart(root)&#123; //畫圖 &lt;--主要插入資料位置 var width = 660, height = 500, radius = Math.min(width, height) / 2; //定義圓的大小 var x = d3.scale.linear() //建立尺度 .range([0, 2 * Math.PI]); //圓周率是也 var y = d3.scale.sqrt() //尺度，開平方根，這真的太難了 .range([0, radius]); // var color = d3.scale.category20c(); //載入d3.js 內建顏色 var svg = d3.select(&quot;.demo&quot;).append(&quot;svg&quot;) //圖形繪製的位置及大小 .attr(&quot;width&quot;, width) .attr(&quot;height&quot;, height) .append(&quot;g&quot;) .attr(&quot;transform&quot;, &quot;translate(&quot; + width / 2 + &quot;,&quot; + (height / 2 + 10) + &quot;)&quot;); var partition = d3.layout.partition() // 建立d3.js partition layout .value(function(d) &#123; return d.price; &#125;); //資料值來源為 Price(金額) var arc = d3.svg.arc() //建立弧形元件 .startAngle(function(d) &#123; return Math.max(0, Math.min(2 * Math.PI, x(d.x))); &#125;) .endAngle(function(d) &#123; return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); &#125;) .innerRadius(function(d) &#123; return Math.max(0, y(d.y)); &#125;) .outerRadius(function(d) &#123; return Math.max(0, y(d.y + d.dy)); &#125;); var path = svg.selectAll(&quot;path&quot;) //繪製path .data(partition.nodes(root)) //匯入資料 &lt;-- 主要插入資料位置 .enter().append(&quot;path&quot;) //用資料去跑 .attr(&quot;d&quot;, arc) .style(&quot;fill&quot;, function(d) &#123; return color((d.children ? d : d.parent).name); &#125;) // .on(&quot;click&quot;, click); //點擊事件 function click(d) &#123; path.transition() .duration(750) //轉場效果 .attrTween(&quot;d&quot;, arcTween(d)); //當點擊時執行縮放 &#125; d3.select(self.frameElement).style(&quot;height&quot;, height + &quot;px&quot;); // 縮放事件 function arcTween(d) &#123; var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]), yd = d3.interpolate(y.domain(), [d.y, 1]), yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]); return function(d, i) &#123; return i ? function(t) &#123; return arc(d); &#125; : function(t) &#123; x.domain(xd(t)); y.domain(yd(t)).range(yr(t)); return arc(d); &#125;; &#125;; &#125; //滑鼠滑入事件 svg.selectAll(&quot;path&quot;).on(&#x27;mouseover&#x27;, function(d)&#123; mousePos = d3.mouse(this); //取得座標 var xPos = mousePos[0] + radius; //修正座標 var yPos = mousePos[1] + radius; //修正座標 d3.select(&#x27;#tooltip&#x27;) //顯示資料 .style(&#123; &#x27;left&#x27;: xPos + &#x27;px&#x27;, &#x27;top&#x27;: yPos + &#x27;px&#x27; &#125;) .classed(&#x27;hidden&#x27;, false) //切換Class d3.select(&#x27;#tooltip .account&#x27;).html(d.account) //顯示資料 d3.select(&#x27;#tooltip .type&#x27;).html((d.children ? d : d.parent).name) d3.select(&#x27;#tooltip .price&#x27;).html(&#x27;$ &#x27; + d.value) &#125;).on(&#x27;mouseout&#x27;, function(d)&#123; //滑鼠移出 d3.select(&#x27;#tooltip&#x27;).classed(&#x27;hidden&#x27;, true) //切換Class，隱藏tooltip &#125;); &#125; 大略看一下柯文哲的支出收入，目前還沒有結束，收入部分主要是來自於個人捐贈以及網路捐贈，而支出部分主要是在人事以及宣傳上。 做完柯P財務報表，也會做看看連阿文的了…，不知道收入主要來源是不是爸爸。 path { stroke: #fff; fill-rule: evenodd; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; } kpPath = 'http://api.kptaipei.tw/v1/financial/all' // 將nest資料改成name, children function reSortRoot(root,value_key) { for (var key in root) { if (key == \"key\") { root.name = root.key; delete root.key; } if (key == \"values\") { root.children = []; for (item in root.values) { root.children.push(reSortRoot(root.values[item],value_key)); } delete root.values; } if (key == value_key) { root.value = parseFloat(root[value_key]); delete root[value_key]; } } return root; } // 將nest資料改成name, children d3.json(kpPath, function(d){ //透過KP API撈資料 dataset = d.data; var nodesByType = d3.nest() //匯入資料轉成巢狀 .key(function(d) { return d.type; }) .key(function(d) { return d.account; }) .entries(dataset); //匯入KP資料 var root = {}; //定義一個空的物件 root.key = \"Data\"; //定義物件名稱 root.values = nodesByType; //以及物件來源 //將json的key轉成name, children root = reSortRoot(root,\"KpData\"); console.log(root) runChart(root) //資料轉完後就來開始畫圖 }); function runChart(root){ //畫圖","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"d3.js 再看更多layout前，先來轉換json結構","slug":"Ironman-30-days-27","date":"2014-10-25T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/26/Ironman-30-days-27/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/26/Ironman-30-days-27/","excerpt":"上次提到d3.js有包含許多的layout，但是每種layout都有些結構上的限制，就比如說 Tree Map，這樣的layout就需要巢狀結構的json才可以製作，D3js也有提供巢狀結構的轉換，這邊就來介紹最常用的轉換方式。","text":"上次提到d3.js有包含許多的layout，但是每種layout都有些結構上的限制，就比如說 Tree Map，這樣的layout就需要巢狀結構的json才可以製作，D3js也有提供巢狀結構的轉換，這邊就來介紹最常用的轉換方式。 資料來源這次的資料又是柯P的，他的資料真的很好用…，不過今天不看圖，今天都來看console.log。 首先透過柯P的API，可以抓到以下的資料，在寫這篇文章時，總共有408筆資料，每一筆資料都是獨立的。 我打算將他分類，以Type(支出、收入)、account(帳戶)作為分類。 D3.js巢狀結構只要透過d3.js巢狀的函式，就能輕鬆達到剛剛的需求，如下： kpPath = &#x27;http://api.kptaipei.tw/v1/financial/all&#x27;; //KP資料路徑 d3.json(kpPath, function(d)&#123; dataset = d.data; console.log(dataset, &quot;原始資料&quot;); //顯示原始資料 var nodesByType = d3.nest() //轉換成巢狀架構 .key(function(d) &#123; return d.type; &#125;) //回傳type .key(function(d) &#123; return d.account; &#125;) //回傳account .entries(dataset); //輸入的資料 console.log(nodesByType, &quot;基本d3.js巢狀結構轉換&quot;) &#125;); 透過這個函式，就能完成最基本的巢狀資料的轉換，比自幹簡單很多吧…，結果會像下面這樣： 剛剛所設定的type會被轉成第一層的key，而account則會被轉成第二層的key，資料責會被轉成value。 轉換Key還有一些麻煩的事情要處理，就以剛剛介紹的Tree Map為例，他們所需要的Json格式是像下圖這樣，用的是name、children，並不是剛剛的key、value，所以還要再轉換一下。 kpPath = &#x27;http://api.kptaipei.tw/v1/financial/all&#x27; // --- 轉換巢狀結構的key --- function reSortRoot(root,value_key) &#123; for (var key in root) &#123; if (key == &quot;key&quot;) &#123; root.name = root.key; delete root.key; &#125; if (key == &quot;values&quot;) &#123; root.children = []; for (item in root.values) &#123; root.children.push(reSortRoot(root.values[item],value_key)); &#125; delete root.values; &#125; if (key == value_key) &#123; root.value = parseFloat(root[value_key]); delete root[value_key]; &#125; &#125; return root; &#125; // --- 轉換巢狀結構的key --- d3.json(kpPath, function(d)&#123; dataset = d.data; console.log(dataset, &quot;原始資料&quot;) var nodesByType = d3.nest() //轉換成巢狀架構 .key(function(d) &#123; return d.type; &#125;) .key(function(d) &#123; return d.account; &#125;) .entries(dataset); console.log(nodesByType, &quot;基本d3.js巢狀結構轉換&quot;) var root = &#123;&#125;; // 將資料命名 root.key = &quot;Data&quot;; root.values = nodesByType; // 修改資料的的key, children名稱，並且依指定規則套用。 root = reSortRoot(root,&quot;KpData&quot;); //layout用巢狀架構 console.log(root, &quot;layout用巢狀架構&quot;) &#125;); 接下來就換看到KP的資料都轉成d3.js layout所需的巢狀json，這樣有助於直接套用許多的樣式。 kpPath = 'http://api.kptaipei.tw/v1/financial/all' // --- 轉換巢狀結構的key --- function reSortRoot(root,value_key) { for (var key in root) { if (key == \"key\") { root.name = root.key; delete root.key; } if (key == \"values\") { root.children = []; for (item in root.values) { root.children.push(reSortRoot(root.values[item],value_key)); } delete root.values; } if (key == value_key) { root.value = parseFloat(root[value_key]); delete root[value_key]; } } return root; } // --- 轉換巢狀結構的key --- d3.json(kpPath, function(d){ dataset = d.data; console.log(dataset, \"原始資料\") var nodesByType = d3.nest() //轉換成巢狀架構 .key(function(d) { return d.type; }) .key(function(d) { return d.account; }) .entries(dataset); console.log(nodesByType, \"基本d3.js巢狀結構轉換\") var root = {}; // 將資料命名 root.key = \"Data\"; root.values = nodesByType; // 修改資料的的key, children名稱，並且依指定規則套用。 root = reSortRoot(root,\"KpData\"); //layout用巢狀架構 console.log(root, \"layout用巢狀架構\") });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"d3.js layout (以環保局資料為例)","slug":"Ironman-30-days-26","date":"2014-10-24T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/25/Ironman-30-days-26/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/25/Ironman-30-days-26/","excerpt":"介紹這麼多，但是還沒有介紹到d3.layout，這用途是可以快速建立圖表，這篇來介紹pie layout，用的是環保局的資料。","text":"介紹這麼多，但是還沒有介紹到d3.layout，這用途是可以快速建立圖表，這篇來介紹pie layout，用的是環保局的資料。 資料來源這次用的是環保局的Open data，環保局的資料也是不錯使用，包含許多個是，CSV、json、XML等等，在政府資料中，優點是還算標準且穩定。 而且只要會Jquery，就可以很輕鬆的把資料抓回來，範例如下： var path = &#123; url: &#x27;http://opendata.epa.gov.tw/ws/Data/WRRecovery/?$skip=0&amp;$top=1000&amp;format=json&#x27;, dataType: &#x27;jsonp&#x27;, &#125; $.ajax(path) .done(function (d) &#123; //如果成功 console.log(data) &#125;) .fail(function(jqxhr, textStatus, error)&#123; console.log(&#x27;GG,沒戲唱了&#x27;); //失敗 &#125;); 圓餅圖d3.js有出許多的layout，只要把資料給他就可以運作，程式碼參考如下，只要先建立一個layout pie物件，在設定輸入的值，套用後就可以轉成圓餅圖。 var pie = d3.layout.pie() //建立D3.layout pie物件 .sort(null) //是否排序 .value(function(d) &#123;return d.Amount; &#125;); //傳入的值 範例 Infomation 回收項目 : 回收率 : 範例中的資料(json)是用jquery去抓，在用d3去轉換成圖形。 $(function() &#123; //定義json 路徑 var path = &#123; url: &#x27;http://opendata.epa.gov.tw/ws/Data/WRRecovery/?$skip=0&amp;$top=1000&amp;format=json&#x27;, dataType: &#x27;jsonp&#x27;, &#125; var data = &quot;&quot;; var w = 450, h = 450; var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;) //插入SVG .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h); $.ajax(path) .done(function (d) &#123; //如果成功 data = d; console.log(data) runChart(&#x27;102&#x27;) &#125;) .fail(function(jqxhr, textStatus, error)&#123; console.log(&#x27;GG,沒戲唱了&#x27;); //失敗 &#125;); runChart = function(filter)&#123; var color = d3.scale.category10(); //D3 內存產生顏色的function var pie = d3.layout.pie() //建立D3.layout pie物件 .sort(null) .value(function(d) &#123;return d.Amount; &#125;); var outerRadius = h / 2 , innerRadius = h / 4; //弧形的位置 var arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius) //定義內外圈位置 var arcs = svg.selectAll(&#x27;g.arc&#x27;) .data(pie(dataFilter(data, filter))) //將資料放入pie .enter() .append(&#x27;g&#x27;) //塞好&#x27;g&#x27; .attr(&#x27;class&#x27;, &#x27;arc&#x27;) //準備好Class .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + outerRadius + &#x27;,&#x27; + outerRadius + &#x27;)&#x27;) //移動圓心的位置 arcs.append(&#x27;path&#x27;) .attr(&#x27;fill&#x27;, function(d,i)&#123; return color(i); //招喚前面的color function &#125;) .attr(&#x27;d&#x27;, arc) // 前面的 arc function //需要 pie()所產生出來得值 arcs.append(&#x27;text&#x27;) .attr(&#x27;transform&#x27;, function(d)&#123; return &#x27;translate(&#x27;+ arc.centroid(d) +&#x27;)&#x27;; //centroid()任何形狀的中心點 &#125;) .attr(&#x27;text-anchor&#x27;, &#x27;middle&#x27;) .text(function(d)&#123; return d.data.Item + d.data.Amount; //在每個形狀的中央插入文字 &#125;) .attr(&#x27;fill&#x27;, &#x27;white&#x27;); svg.selectAll(&#x27;.arc&#x27;).on(&#x27;mouseover&#x27;, function(d)&#123; //滑鼠事件 mousePos = d3.mouse(this); //取得滑鼠座標 var xPos = mousePos[0] + outerRadius; //修正滑鼠座標 var yPos = mousePos[1] + outerRadius; //修正滑鼠座標 d3.select(&#x27;#tooltip&#x27;) //將Tooltip補上資料 .style(&#123; &#x27;left&#x27;: xPos + &#x27;px&#x27;, //加上位置 &#x27;top&#x27;: yPos + &#x27;px&#x27; &#125;) .classed(&#x27;hidden&#x27;, false) d3.select(&#x27;#tooltip .name&#x27;).html(d.data.Item) //插入名稱 d3.select(&#x27;#tooltip .value&#x27;).html(d.data.Amount + &#x27;%&#x27;) &#125;).on(&#x27;mouseout&#x27;, function(d)&#123; d3.select(&#x27;#tooltip&#x27;).classed(&#x27;hidden&#x27;, true) //切換顯示及隱藏 &#125;); &#125;; dataFilter = function(data, filter)&#123; //過濾部分資料 var newData = []; $.each(data, function(i,d)&#123; if (d.Year == filter)&#123; newData.push(d); &#125; &#125;); return newData &#125;; &#125;); 結語接下會幾篇會介紹幾種不同的layout，透過不同的範例，感謝收看(MOPCON打這篇，有時候都不知道自己在打什麼…)。 path { /*stroke: DodgerBlue; stroke-width: 1; fill: none;*/ } .axis { font-size: 11px; fill: gray; } svg{ font-size: 11px; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; } $(function() { //定義json 路徑 var path = { url: 'http://opendata.epa.gov.tw/ws/Data/WRRecovery/?$skip=0&$top=1000&format=json', dataType: 'jsonp', } var data = \"\"; var w = 450, h = 450; var svg = d3.select('.demo').append('svg') //插入SVG .attr('width', w) .attr('height', h); $.ajax(path) .done(function (d) { //如果成功 data = d; console.log(data) runChart('102') }) .fail(function(jqxhr, textStatus, error){ console.log('GG,沒戲唱了'); //失敗 }); runChart = function(filter){ var color = d3.scale.category10(); //D3 內存產生顏色的function var pie = d3.layout.pie() //建立D3.layout pie物件 .sort(null) .value(function(d) {return d.Amount; }); var outerRadius = h / 2 , innerRadius = h / 4; //弧形的位置 var arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius) //定義內外圈位置 var arcs = svg.selectAll('g.arc') .data(pie(dataFilter(data, filter))) //將資料放入pie .enter() .append('g') //塞好'g' .attr('class', 'arc') //準備好Class .attr('transform', 'translate(' + outerRadius + ',' + outerRadius + ')') //移動圓心的位置 arcs.append('path') .attr('fill', function(d,i){ return color(i); //招喚前面的color function }) .attr('d', arc) // 前面的 arc function //需要 pie()所產生出來得值 arcs.append('text') .attr('transform', function(d){ return 'translate('+ arc.centroid(d) +')'; //centroid()任何形狀的中心點 }) .attr('text-anchor', 'middle') .text(function(d){ return d.data.Item + d.data.Amount; //在每個形狀的中央插入文字 }) .attr('fill', 'white'); svg.selectAll('.arc').on('mouseover', function(d){ //滑鼠事件 mousePos = d3.mouse(this); //取得滑鼠座標 var xPos = mousePos[0] + outerRadius; //修正滑鼠座標 var yPos = mousePos[1] + outerRadius; //修正滑鼠座標 d3.select('#tooltip') //將Tooltip補上資料 .style({ 'left': xPos + 'px', //加上位置 'top': yPos + 'px' }) .classed('hidden', false) d3.select('#tooltip .name').html(d.data.Item) //插入名稱 d3.select('#tooltip .value').html(d.data.Amount + '%') }).on('mouseout', function(d){ d3.select('#tooltip').classed('hidden', true) //切換顯示及隱藏 }); }; dataFilter = function(data, filter){ //過濾部分資料 var newData = []; $.each(data, function(i,d){ if (d.Year == filter){ newData.push(d); } }); return newData }; });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 也可以像音樂一樣動吃動吃動(2)","slug":"Ironman-30-days-25","date":"2014-10-23T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/24/Ironman-30-days-25/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/24/Ironman-30-days-25/","excerpt":"上一篇介紹了資料的來源以及動機，這篇就來介紹執行的層面吧。 在原本的範例中，是只有一個圓在跳動，但是音樂所能擷取的資料是一段很長的陣列，我就思考著是不是有辦法做成折線圖，並且讓他有躍動的感覺。","text":"上一篇介紹了資料的來源以及動機，這篇就來介紹執行的層面吧。 在原本的範例中，是只有一個圓在跳動，但是音樂所能擷取的資料是一段很長的陣列，我就思考著是不是有辦法做成折線圖，並且讓他有躍動的感覺。 音樂來源：http://unlimited.kptaipei.tw/ 範例參考：http://webfinal.herokuapp.com/slides.html HTML先看一下HTML的結構，在左邊呈現圖像化的效果，右邊是柯P的音樂選單，重要的是下方的class=&quot;controller&quot;，這並不是js的套件或是code，僅僅是Chrome的html5物件。 &lt;div class=&quot;demo&quot;&gt; &lt;div class=&quot;player&quot;&gt; &lt;div class=&quot;visual&quot;&gt; &lt;/div&gt; &lt;div class=&quot;playlist&quot;&gt; &lt;/div&gt; &lt;div class=&quot;controller&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 柯P資料直接透過d3.json去接柯P的資料，之前有提過KP這方面處理得相當好，用d3.js就可以直接接資料，接回來的範例如下，也可以直接打開chrome console看更完整資料。 d3.json(kpMusic, function(data)&#123; //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function &#125;); Line Chart這一段是特別需要注意的，因為音樂的所傳回的陣列長度是2048，值大概像下面這樣，範圍由-1 ~ 1，也因為長度過長，在繪製成圖形上會有效能上的問題，所以擷取其中一段即可。 所以該段js大概像這樣： //buffer 為傳來的值 newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d); //利用尺度運算資料的值，傳回y的位置 &#125;); path.attr(&#x27;d&#x27;, line(newBuffer)); //將音樂資料套用至曲線 DEMO請先選擇右方音樂，再點選播放 很抱歉，目前本範例只支援Chrome 完整Code如果有興趣想要跟著實驗，只要把這段貼回家就可以玩囉 var kpMusic = &#x27;http://api.kptaipei.tw/v1/musics/1?accessToken=kp54103aa1efbe14.85567715&#x27; //柯p資料路徑 var dataMusic = &quot;&quot;; //音樂資料 var colorBase = 0; //圓圈的顏色起始 var context; //音樂格式 var h = 100, w = 300; d3.json(kpMusic, function(data)&#123; //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function &#125;); //這部分是建立基本的layout var svg = d3.select(&quot;.visual&quot;).append(&#x27;svg&#x27;) .attr(&#123; width: 300, height: 300 &#125;); //畫面中的圓圈 circle = svg.append(&#x27;circle&#x27;) .attr(&#123; cx: 150, cy: 150 &#125;); //播放中音樂的文字 playtext = svg.append(&#x27;text&#x27;) .attr(&#123; x: 20, y: 20, width: 260, fill: &quot;white&quot; &#125;) //中央跳動的曲線 rect = svg.append(&#x27;g&#x27;)//增加一個群組g .attr(&#x27;width&#x27;, w) .attr(&#x27;height&#x27;, h) .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + (h) + &#x27;)&#x27;); path = rect.append(&#x27;path&#x27;) var audio = new Audio(); //建立音樂 function playlist()&#123; d3.select(&quot;.playlist&quot;).selectAll(&quot;a&quot;).data(dataMusic) //右方先插入歌單 .enter() .append(&quot;a&quot;) .text(function(d)&#123; return d.song_name &#125;) //傳入音樂名稱 .attr(&quot;class&quot;, &quot;song&quot;); //插入Class，作為控制用 audio.controls = true; //html5 音樂控制器 audio.preload = true; //html5 預先下載 document.querySelector(&#x27;.controller&#x27;).appendChild(audio); //指定部分插入html5 audio元件 d3.selectAll(&quot;.song&quot;).on(&quot;click&quot;, function(d)&#123; playsong(d); //點擊歌單時載入音樂 &#125;); &#125; //瀏覽器驗證 try &#123; context = new webkitAudioContext(); &#125; catch(e) &#123; try &#123; context= new AudioContext(); &#125; catch(e) &#123; &#125; &#125; function processAudio(e) &#123; //如果音樂開始執行時 //取得音軌資訊 var buffer = e.inputBuffer.getChannelData(0); var out = e.outputBuffer.getChannelData(0); var amp = 0; // Iterate through buffer to get max amplitude for (var i = 0; i &lt; buffer.length; i++) &#123; var loud = Math.abs(buffer[i]); if(loud &gt; amp) &#123; amp = loud; &#125; // write input samples to output unchanged out[i] = buffer[i]; &#125;; newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d); //利用尺度運算資料的值，傳回y的位置 &#125;); colorBase ++; //讓顏色隨著時間變化 var color = d3.hsl(colorBase % 360, .7,.7); //d3.hsl色彩運算 circle.attr(&quot;r&quot;,20+(amp*50)) //圓圈大小變換，以及顏色變換 .attr(&quot;fill&quot;, color) .attr(&quot;stroke&quot;, color); path.attr(&#x27;d&#x27;, line(newBuffer)); //將音樂資料套用至曲線 &#125; //以下為音樂相關的code var node = context.createMediaElementSource(audio); var processor = context.createScriptProcessor(2048,1,1); function playsong(d)&#123; console.log(d) audio.src = d.stream_url; playtext.text(d.song_name + &#x27; / &#x27; + d.groupname) audio.addEventListener(&#x27;canplaythrough&#x27;,function() &#123; processor.onaudioprocess = processAudio; node.connect(processor); processor.connect(context.destination); &#125;); &#125; 還有CSS要補上喔～ .player &#123; background-color: #000; width: 540px; padding: 20px; border-radius: 2px; &#125; .player circle&#123; fill: none; &#125; path &#123; stroke: DodgerBlue; fill: none; &#125; .visual&#123; float: left; &#125; .playlist&#123; float: right; width: 200px; height: 300px; overflow-y: auto; &#125; .playlist a&#123; color: white; display: block; cursor: pointer; &#125; .playlist a.selected &#123; color: DeepSkyBlue; &#125; .controller&#123; clear: both; &#125; 後記鐵人賽快要結束了，不過我到快結束才更了解D3js，有很多豐富的技巧還沒介紹的說…。 .player { background-color: #000; width: 540px; padding: 20px; border-radius: 2px; } .player circle{ fill: none; } path { stroke: DodgerBlue; fill: none; } .visual{ float: left; } .playlist{ float: right; width: 200px; height: 300px; overflow-y: auto; } .playlist a{ color: white; display: block; cursor: pointer; } .playlist a.selected { color: DeepSkyBlue; } .controller{ clear: both; } var kpMusic = 'http://api.kptaipei.tw/v1/musics/1?accessToken=kp54103aa1efbe14.85567715' //柯p資料路徑 var dataMusic = \"\"; //音樂資料 var colorBase = 0; //圓圈的顏色起始 var context; //音樂格式 var h = 100, w = 300; d3.json(kpMusic, function(data){ //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function }); //這部分是建立基本的layout var svg = d3.select(\".visual\").append('svg') .attr({ width: 300, height: 300 }); //畫面中的圓圈 circle = svg.append('circle') .attr({ cx: 150, cy: 150 }); //播放中音樂的文字 playtext = svg.append('text') .attr({ x: 20, y: 20, width: 260, fill: \"white\" }) //中央跳動的曲線 rect = svg.append('g')//增加一個群組g .attr('width', w) .attr('height', h) .attr('transform', 'translate(0,' + (h) + ')'); path = rect.append('path') var audio = new Audio(); //建立音樂 function playlist(){ d3.select(\".playlist\").selectAll(\"a\").data(dataMusic) //右方先插入歌單 .enter() .append(\"a\") .text(function(d){ return d.song_name }) //傳入音樂名稱 .attr(\"class\", \"song\"); //插入Class，作為控制用 audio.controls = true; //html5 音樂控制器 audio.preload = true; //html5 預先下載 document.querySelector('.controller').appendChild(audio); //指定部分插入html5 audio元件 d3.selectAll(\".song\").on(\"click\", function(d){ playsong(d); //點擊歌單時載入音樂 }); } //瀏覽器驗證 try { context = new webkitAudioContext(); } catch(e) { try { context= new AudioContext(); } catch(e) { } } function processAudio(e) { //如果音樂開始執行時 //取得音軌資訊 var buffer = e.inputBuffer.getChannelData(0); var out = e.outputBuffer.getChannelData(0); var amp = 0; // Iterate through buffer to get max amplitude for (var i = 0; i < buffer.length; i++) { var loud = Math.abs(buffer[i]); if(loud > amp) { amp = loud; } // write input samples to output unchanged out[i] = buffer[i]; }; newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d); //利用尺度運算資料的值，傳回y的位置 }); colorBase ++; //讓顏色隨著時間變化 var color = d3.hsl(colorBase % 360, .7,.7); //d3.hsl色彩運算 circle.attr(\"r\",20+(amp*50)) //圓圈大小變換，以及顏色變換 .attr(\"fill\", color) .attr(\"stroke\", color); path.attr('d', line(newBuffer)); //將音樂資料套用至曲線 } //以下為音樂相關的code var node = context.createMediaElementSource(audio); var processor = context.createScriptProcessor(2048,1,1); function playsong(d){ console.log(d) audio.src = d.stream_url; playtext.text(d.song_name + ' / ' + d.groupname) audio.addEventListener('canplaythrough',function() { processor.onaudioprocess = processAudio; node.connect(processor); processor.connect(context.destination); }); }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 也可以像音樂一樣動吃動吃動(1)","slug":"Ironman-30-days-24","date":"2014-10-22T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/23/Ironman-30-days-24/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/23/Ironman-30-days-24/","excerpt":"學習D3之後會常思考有什麼樣的資料可以圖形化，除了Open data外，還想到一個就是音樂，以前使用Media Player，有許許多多的音樂視覺化的效果，都是透過聲音大小變化，所以如果有聲音大小變化的資訊，似乎就可以達到這樣的效果。","text":"學習D3之後會常思考有什麼樣的資料可以圖形化，除了Open data外，還想到一個就是音樂，以前使用Media Player，有許許多多的音樂視覺化的效果，都是透過聲音大小變化，所以如果有聲音大小變化的資訊，似乎就可以達到這樣的效果。 音樂來源：http://unlimited.kptaipei.tw/ 範例參考：http://webfinal.herokuapp.com/slides.html 參考不久前在網路上看到一份D3.js的簡報，寫得真的不錯，文中介紹到一個很沒用的效果(他自己說沒用的..)，範例中會播放著音樂，而中間的圓圈會隨著音樂跳動，看著圓圈不斷地跳動，讓我發現很有趣的資訊，就是音樂啊，那不是我正在尋找的資料嗎～ 在翻閱他的範例中，可以看到他把音軌轉換成陣列的資訊，會依據音樂的品質轉換…，大概像以下這樣的陣列。 以這個範例來說，是2048長度的陣列，數值為-1 ~ 1，更新速度相當的快，只要有這個值，就可以做出上面範例的跳動圓圈。 資料技術上已經找到方向，另一個問題就是音樂的來源，由於版權問題，也不太可能隨意使用歌手的音樂。再以柯P的資料做練習時，有稍微看一下創作音樂的部分，創作音樂是使用sound cloud平台，json內在提供sound cloud平台上的資訊。運氣不錯，其中剛好有串流音樂的格式(感謝野生官網、Sound Cloud)。 這樣取得的線上音樂，就可以試著放入自己設計的播放器去執行(一開始用本機的流行樂&gt; &lt;)。 規劃一開始只有做隨機一首歌去播放，後來發現真的很有趣，而且這些音樂挺好聽的，看著自己做的曲線配合著音樂跳動，就把整個音樂清單也做出來了。 請先選擇右方音樂，再點選播放 很抱歉，目前本範例只支援Chrome 後記這範例也拿去給朋友看，部分的人也說這好像沒什麼用(泣…)，不過這就是創造的浪漫啊！ .player { background-color: #000; width: 540px; padding: 20px; border-radius: 2px; } .player circle{ fill: none; } path { stroke: DodgerBlue; fill: none; } .visual{ float: left; } .playlist{ float: right; width: 200px; height: 300px; overflow-y: auto; } .playlist a{ color: white; display: block; cursor: pointer; } .playlist a.selected { color: DeepSkyBlue; } .controller{ clear: both; } var kpMusic = 'http://api.kptaipei.tw/v1/musics/1?accessToken=kp54103aa1efbe14.85567715' //柯p資料路徑 var dataMusic = \"\"; //音樂資料 var colorBase = 0; //圓圈的顏色起始 var context; //音樂格式 var h = 100, w = 300; d3.json(kpMusic, function(data){ //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function }); //這部分是建立基本的layout var svg = d3.select(\".visual\").append('svg') .attr({ width: 300, height: 300 }); //畫面中的圓圈 circle = svg.append('circle') .attr({ cx: 150, cy: 150 }); //播放中音樂的文字 playtext = svg.append('text') .attr({ x: 20, y: 20, width: 260, fill: \"white\" }) //中央跳動的曲線 rect = svg.append('g')//增加一個群組g .attr('width', w) .attr('height', h) .attr('transform', 'translate(0,' + (h) + ')'); path = rect.append('path') var audio = new Audio(); //建立音樂 function playlist(){ d3.select(\".playlist\").selectAll(\"a\").data(dataMusic) //右方先插入歌單 .enter() .append(\"a\") .text(function(d){ return d.song_name }) //傳入音樂名稱 .attr(\"class\", \"song\"); //插入Class，作為控制用 audio.controls = true; //html5 音樂控制器 audio.preload = true; //html5 預先下載 document.querySelector('.controller').appendChild(audio); //指定部分插入html5 audio元件 d3.selectAll(\".song\").on(\"click\", function(d){ playsong(d); //點擊歌單時載入音樂 }); } //瀏覽器驗證 try { context = new webkitAudioContext(); } catch(e) { try { context= new AudioContext(); } catch(e) { } } function processAudio(e) { //如果音樂開始執行時 //取得音軌資訊 var buffer = e.inputBuffer.getChannelData(0); var out = e.outputBuffer.getChannelData(0); var amp = 0; // Iterate through buffer to get max amplitude for (var i = 0; i < buffer.length; i++) { var loud = Math.abs(buffer[i]); if(loud > amp) { amp = loud; } // write input samples to output unchanged out[i] = buffer[i]; }; newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 console.log(newBuffer.length) var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d); //利用尺度運算資料的值，傳回y的位置 }); colorBase ++; //讓顏色隨著時間變化 var color = d3.hsl(colorBase % 360, .7,.7); //d3.hsl色彩運算 circle.attr(\"r\",20+(amp*50)) //圓圈大小變換，以及顏色變換 .attr(\"fill\", color) .attr(\"stroke\", color); path.attr('d', line(newBuffer)); //將音樂資料套用至曲線 } //以下為音樂相關的code var node = context.createMediaElementSource(audio); var processor = context.createScriptProcessor(2048,1,1); function playsong(d){ console.log(d) audio.src = d.stream_url; playtext.text(d.song_name + ' / ' + d.groupname) audio.addEventListener('canplaythrough',function() { processor.onaudioprocess = processAudio; node.connect(processor); processor.connect(context.destination); }); }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"像jQuery 一樣的D3.js，柯P野生官網API","slug":"Ironman-30-days-23","date":"2014-10-21T16:00:00.000Z","updated":"2016-10-13T02:50:19.000Z","comments":true,"path":"d3js/2014/10/22/Ironman-30-days-23/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/22/Ironman-30-days-23/","excerpt":"D3.js其實最重要的還是資料，恰巧有一位候選人做了Open data，他的API格式相當優良，如果對於找不到合適資料，但需要做些練習，不如試試看柯文哲野生官網吧！ http://unlimited.kptaipei.tw/","text":"D3.js其實最重要的還是資料，恰巧有一位候選人做了Open data，他的API格式相當優良，如果對於找不到合適資料，但需要做些練習，不如試試看柯文哲野生官網吧！ http://unlimited.kptaipei.tw/ 野生官網的使用相當容易，對於會使用jquery的開發者，也可以很快瞭解，這邊也簡單介紹一下野生官網API的使用方式吧。 申請Token在使用API前，需要先申請一組Token，野生官網在這部分也做得相當乾脆，只要填入暱稱、電子郵件之後，系統就會發一組Token及介紹信給申請者。 畫面如下，填入相關資料即可： 收到Mail後，隨信會附上Token，開始動手試試看吧。 用D3.js撈撈看D3.js原則上不能進行跨站請求資料(jsonp)，但野生官網這部分已經處理掉了，所以可以直接用D3處理這一段。 先前介紹撈Google drive資料，是用jQuery處理jsonp。 參考官網提供的Api [類別內容查詢]這部分很適合做練習，就直接用官網提供的範例，用D3來試試看(結果如下)。 kpapi = \"http://api.kptaipei.tw/v1/category/41/?accessToken=kp54103aa1efbe14.85567715\"; d3.json(kpapi, function(d){ data = d.data; length = data.length; num = Math.floor(Math.random()*length); demo = d3.select('.demo'); demo.select('.demo article').html(data[num].content); }); kpapi = &quot;http://api.kptaipei.tw/v1/category/41/?accessToken=kp54103aa1efbe14.85567715&quot;; //柯p API路徑 d3.json(kpapi, function(d)&#123; //d3js json function data = d.data; length = data.length; //取得資料筆數 num = Math.floor(Math.random()*length); //隨機一則筆數 demo.select(&#x27;.demo article&#x27;).html(data[num].content); //將文章插入 &#125;); 上面這一個範例，就是用d3.js來抓柯P的API，並且隨機抓一篇文章，寫法大致上都很是不是很像jquery呢？ 剛開始的相簿在一剛開始介紹D3.js時，有展示一個柯P的相簿，作法其實類似上一個範例，不同的是用d3.data來做jQuery.each的動作，再來回顧一次這個範例吧。 var url = &quot;http://api.kptaipei.tw/v1/albums/72157646559528926&quot;; //柯p API路徑 d3.json( url ,function(d)&#123; var dataset = d.data.photos; d3.select(&#x27;.demo&#x27;).selectAll(&#x27;img&#x27;) .data(dataset) //用d3.data來插入資料 .enter() .append(&#x27;div&#x27;) .attr(&#x27;class&#x27;, &#x27;col-xs-2&#x27;) .append(&#x27;img&#x27;).attr(&#x27;class&#x27;, &#x27;img-responsive&#x27;) .attr(&#x27;src&#x27;, function(d)&#123; return d.images.large_square; &#125;); &#125;); 如果下方視窗沒有顯示範例，請點選Run with JS JS Bin 這樣來回介紹，應該會更了解D3.js吧～","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 資料數量增減","slug":"Ironman-30-days-22","date":"2014-10-20T16:00:00.000Z","updated":"2016-10-13T02:55:13.000Z","comments":true,"path":"d3js/2014/10/21/Ironman-30-days-22/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/21/Ironman-30-days-22/","excerpt":"資料很多時候需要比較、切換，所以可能會同時加入多筆資料，前一篇文章所介紹的是相同數量的資料，這次要做隨機的資料量。","text":"資料很多時候需要比較、切換，所以可能會同時加入多筆資料，前一篇文章所介紹的是相同數量的資料，這次要做隨機的資料量。 資料轉換資料數量不同時，如果增加到沒什麼，因為原本就是從無到有，都是利用Append去增加新的物件： bars.enter().append(&apos;rect&apos;); 但是如果資料比原本還要少時，就要選取多餘的元件(exit)，並且移除它(remove)。 bars.exit() //選擇多餘的部分 .remove() //清除物件 下面這個範例，預設會先用20筆資料，接下來點擊button，就會隨機的增減資料，另外動態做稍微誇張一些，覺得挺有趣的，玩了幾個動態模式，這個最彈了…。 Click Me var dataset = []; var numValues = 20; //一開始的資料數量是固定的 var randDataset = function(num)&#123; for (var i=0; i &lt; num; i++)&#123; var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(&#123; key : i, value: newNum&#125;); //產生一段陣列，包含key and value &#125; &#125;//只要給予資料&quot;數量&quot;，就會產生隨機資料 var key = function(d) &#123; return d.key; &#125; randDataset(numValues); //一開始預設的20筆資料 console.table(dataset); //打開console開結果 var originDataLength = dataset.length // 將原始的資料長度記錄 var h=200,w = 500, barMargin = 1; maxDataset = d3.max(dataset, function(d)&#123; return d.value &#125;); //從value 取得最大值 var xScale = d3.scale.ordinal() //不同於linear的尺度，可以處理非數字資料 .domain(d3.range(dataset.length)) //這範例是給予資料的長度 .rangeRoundBands([0, w], 0); //利用整體的寬度去做運算 var yScale = d3.scale.linear() //y尺度和先前是相同的，都是線性尺度 .domain([0 , maxDataset]) //輸入值範圍 .range([0, h]); //輸出值範圍 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#x27;width&#x27;,w).attr(&#x27;height&#x27;, h); //建立svg svg.selectAll(&#x27;rect&#x27;).data(dataset, key) //插入資料 .enter().append(&#x27;rect&#x27;) //直條圖用rect~ .attr(&#123; &#x27;x&#x27;: function(d, i)&#123; return xScale(i); //利用尺度算出每個rect的x軸位置 &#125;, &#x27;y&#x27;: function(d)&#123; return h - yScale(d.value); //算出y的位置(因為需要置底) &#125;, &#x27;width&#x27;: w / dataset.length - barMargin, //每個rect寬度是固定的，但需要補上間距 &#x27;height&#x27;: function(d)&#123; return yScale(d.value)&#125;, //算出高度 &#x27;fill&#x27;: function(d)&#123; return d3.hsl(320 + d.value % 360 , .5 , .5)&#125; //利用資料產生不同色彩 &#125;); var dataText = svg.selectAll(&#x27;text&#x27;).data(dataset, key).enter().append(&#x27;text&#x27;); //補上文字 dataText.text(function(d)&#123;return d.value&#125;) .attr(&#123; &#x27;x&#x27;: function(d,i)&#123; return xScale(i) + 11; //算出x位置 &#125;, &#x27;y&#x27;: function(d)&#123; return (h - yScale(d.value) + 15)&#125;, //算出文字y的位置 &#x27;fill&#x27;: &#x27;white&#x27;, //文字反白 &#x27;text-anchor&#x27;: &#x27;middle&#x27;, //文字置中 &#x27;font-size&#x27;: &#x27;11px&#x27; //字小一點比較秀氣 &#125;); var chartFn = function()&#123; //這一段是在點擊後觸發的函式 dataset = []; //資料清空 var numValues = 1 + Math.floor(Math.random() * 30); //隨機長度的資料 randDataset(numValues); //重新製作一組資料 newDataLength = dataset.length // 儲存新的資料長度 xScale.domain(d3.range(dataset.length)) //資料長度不同，所以domain改變 maxDataset = d3.max(dataset, function(d)&#123; return d.value &#125;); yScale.domain([0 , maxDataset]) //資料最大值不同，所以domain改變 var bars = svg.selectAll(&quot;rect&quot;) .data(dataset, key); //重新套用資料 var texts = svg.selectAll(&#x27;text&#x27;) .data(dataset, key); //檢查資料長度，如果比原本長就需要移除 if (newDataLength &gt; originDataLength)&#123; //如果比原本長 bars.enter().append(&#x27;rect&#x27;) .transition() .attr(&#x27;x&#x27;, w); //增加新的rect，以及進場的方式 texts.enter().append(&#x27;text&#x27;).text(function(d)&#123;return d.value&#125;) .attr(&#123; &#x27;x&#x27;: w, &#x27;y&#x27;: function(d)&#123; return (h - yScale(d.value) + 15)&#125; &#125;); //類似同上 originDataLength = newDataLength; //儲存資料長度 &#125; else if (newDataLength &lt; originDataLength)&#123; bars.exit() //選擇多餘的部分 .transition() //退場方式 //.duration(500) .attr(&#x27;width&#x27;, 0) //寬度降為0 .remove() //清除物件 texts.exit().transition().duration(500) .attr(&#x27;width&#x27;, 0) .remove() //清除文字物件 originDataLength = newDataLength; //儲存資料長度 &#125; bars.transition() .delay(500) //延遲新的效果(等前方的進退場動畫結束) // .delay(function(d, i) &#123; // return i / dataset.length * 1000; // // 每個物件套用不同的delay 時間 // &#125;) .duration(1500) // 持續時間(豪秒) .ease(&#x27;elastic&#x27;) // 動畫型態 .attr(&#123; //這段同前 &#x27;x&#x27;: function(d, i)&#123; return xScale(i) &#125;, &#x27;y&#x27;: function(d)&#123; return h - yScale(d.value) &#125;, &#x27;width&#x27;: w / dataset.length - barMargin, &#x27;height&#x27;: function(d)&#123; return yScale(d.value); &#125;, &#x27;fill&#x27;: function(d)&#123; return d3.hsl(320 + d.value % 360 , .5 , .5)&#125; &#125;) texts.transition() //文字也是同前 .delay(500) .duration(1500) // 持續時間(豪秒) .ease(&#x27;elastic&#x27;) // 動畫型態 .attr(&#123; &#x27;x&#x27;: function(d,i)&#123; //return i * (w / dataset.length) return xScale(i) + 11 &#125;, &#x27;y&#x27;: function(d)&#123; return (h - yScale(d.value) + 15)&#125;, &#x27;fill&#x27;: &#x27;white&#x27;, &#x27;text-anchor&#x27;: &#x27;middle&#x27;, &#x27;font-size&#x27;: &#x27;11px&#x27; &#125;); &#125;; // 點擊button時，更新資料 d3.select(&#x27;.update_btn&#x27;).on(&#x27;click&#x27;, function()&#123; chartFn(); &#125;); 接下來，明天又要來亂抓Open data來玩囉～ var dataset = []; var numValues = 20; //一開始的資料數量是固定的 var randDataset = function(num){ for (var i=0; i < num; i++){ var newNum = 5 + Math.floor(Math.random() * 30); dataset.push({ key : i, value: newNum}); //產生一段陣列，包含key and value } }//只要給予資料\"數量\"，就會產生隨機資料 var key = function(d) { return d.key; } randDataset(numValues); //一開始預設的20筆資料 console.table(dataset); //打開console開結果 var originDataLength = dataset.length // 將原始的資料長度記錄 var h=200,w = 500, barMargin = 1; maxDataset = d3.max(dataset, function(d){ return d.value }); //從value 取得最大值 var xScale = d3.scale.ordinal() //不同於linear的尺度，可以處理非數字資料 .domain(d3.range(dataset.length)) //這範例是給予資料的長度 .rangeRoundBands([0, w], 0); //利用整體的寬度去做運算 var yScale = d3.scale.linear() //y尺度和先前是相同的，都是線性尺度 .domain([0 , maxDataset]) //輸入值範圍 .range([0, h]); //輸出值範圍 var svg = d3.select('.demo').append('svg').attr('width',w).attr('height', h); //建立svg svg.selectAll('rect').data(dataset, key) //插入資料 .enter().append('rect') //直條圖用rect~ .attr({ 'x': function(d, i){ return xScale(i); //利用尺度算出每個rect的x軸位置 }, 'y': function(d){ return h - yScale(d.value); //算出y的位置(因為需要置底) }, 'width': w / dataset.length - barMargin, //每個rect寬度是固定的，但需要補上間距 'height': function(d){ return yScale(d.value)}, //算出高度 'fill': function(d){ return d3.hsl(320 + d.value % 360 , .5 , .5)} //利用資料產生不同色彩 }); var dataText = svg.selectAll('text').data(dataset, key).enter().append('text'); //補上文字 dataText.text(function(d){return d.value}) .attr({ 'x': function(d,i){ return xScale(i) + 11; //算出x位置 }, 'y': function(d){ return (h - yScale(d.value) + 15)}, //算出文字y的位置 'fill': 'white', //文字反白 'text-anchor': 'middle', //文字置中 'font-size': '11px' //字小一點比較秀氣 }); var chartFn = function(){ //這一段是在點擊後觸發的函式 dataset = []; //資料清空 var numValues = 1 + Math.floor(Math.random() * 30); //隨機長度的資料 randDataset(numValues); //重新製作一組資料 newDataLength = dataset.length // 儲存新的資料長度 xScale.domain(d3.range(dataset.length)) //資料長度不同，所以domain改變 maxDataset = d3.max(dataset, function(d){ return d.value }); yScale.domain([0 , maxDataset]) //資料最大值不同，所以domain改變 var bars = svg.selectAll(\"rect\") .data(dataset, key); //重新套用資料 var texts = svg.selectAll('text') .data(dataset, key); //檢查資料長度，如果比原本長就需要移除 if (newDataLength > originDataLength){ //如果比原本長 bars.enter().append('rect') .transition() .attr('x', w); //增加新的rect，以及進場的方式 texts.enter().append('text').text(function(d){return d.value}) .attr({ 'x': w, 'y': function(d){ return (h - yScale(d.value) + 15)} }); //類似同上 originDataLength = newDataLength; //儲存資料長度 } else if (newDataLength < originDataLength){ bars.exit() //選擇多餘的部分 .transition() //退場方式 //.duration(500) .attr('width', 0) //寬度降為0 .remove() //清除物件 texts.exit().transition().duration(500) .attr('width', 0) .remove() //清除文字物件 originDataLength = newDataLength; //儲存資料長度 } bars.transition() .delay(500) //延遲新的效果(等前方的進退場動畫結束) // .delay(function(d, i) { // return i / dataset.length * 1000; // // 每個物件套用不同的delay 時間 // }) .duration(1500) // 持續時間(豪秒) .ease('elastic') // 動畫型態 .attr({ //這段同前 'x': function(d, i){ return xScale(i) }, 'y': function(d){ return h - yScale(d.value) }, 'width': w / dataset.length - barMargin, 'height': function(d){ return yScale(d.value); }, 'fill': function(d){ return d3.hsl(320 + d.value % 360 , .5 , .5)} }) texts.transition() //文字也是同前 .delay(500) .duration(1500) // 持續時間(豪秒) .ease('elastic') // 動畫型態 .attr({ 'x': function(d,i){ //return i * (w / dataset.length) return xScale(i) + 11 }, 'y': function(d){ return (h - yScale(d.value) + 15)}, 'fill': 'white', 'text-anchor': 'middle', 'font-size': '11px' }); }; // 點擊button時，更新資料 d3.select('.update_btn').on('click', function(){ chartFn(); });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js Transition動態效果","slug":"Ironman-30-days-21","date":"2014-10-19T16:00:00.000Z","updated":"2016-10-13T02:51:47.000Z","comments":true,"path":"d3js/2014/10/20/Ironman-30-days-21/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/20/Ironman-30-days-21/","excerpt":"先前的資料，都是固定的，沒有任何變化，這次要介紹的是利用資料的轉變以及transition的效果。","text":"先前的資料，都是固定的，沒有任何變化，這次要介紹的是利用資料的轉變以及transition的效果。 Transition這次的範例是之前提到那本書上的唷～。 D3.js的transition和CSS的transition很像，都是放在開始的地方，然後再加入一些時間，這樣就完成了，像下面這個範例： d3.select(&apos;div&apos;) .transition() //套用動態效果 .duration(250) //動態持續時間 .attr(/* do something */) 如果和資料有關係，作法大致是相同的，再加入資料後，一樣加入.transition()： d3.select(&apos;div&apos;).data(dataset) .transition() //套用動態效果 .duration(250) //動態持續時間 .attr(/* do something */) 下面這一個範例中，只要點擊’Click Me’，就會產生出一組新的陣列並且套用入SVG，可以看到圓型以及左方、下方的軸線也會跟著轉場變化。 Click Me var w = 600,h = 400,padding = 30; var dataset = []; //產生空的陣列 var numDataPoints = 100; //最大點的數量是100 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; //隨機範圍最大值都是1000 for (var i = 0; i &lt; numDataPoints; i++)&#123; var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) //運算出新的值，並加到dataset &#125; var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;); //計算最大值 var xScale = d3.scale.linear() //線性尺度 .domain([0, Xmax]) //輸入值 .range([padding , w - padding]) //輸出值 .nice() //取最適合數值 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#123;&#x27;width&#x27;: w,&#x27;height&#x27;: h&#125;) //裁切區域 svg.append(&#x27;clipPath&#x27;) //新增svg裁切區域 .attr(&#x27;id&#x27;, &#x27;chart-area&#x27;) //定義id .append(&#x27;rect&#x27;) //再增加一個矩型 .attr(&#123; &#x27;x&#x27;: padding, &#x27;y&#x27;: padding, &#x27;width&#x27;: w - padding * 2, &#x27;height&#x27;: h - padding * 2 &#125;) svg.append(&#x27;g&#x27;) .attr(&#x27;clip-path&#x27;, &#x27;url(#chart-area)&#x27;) //套用裁切區域 .selectAll(&#x27;circle&#x27;) .data(dataset).enter() //輸入資料 .append(&#x27;circle&#x27;) //加入圓 .attr(&#123; &#x27;cx&#x27;: function(d)&#123;return xScale(d[0])&#125;, //用x尺度算出cx位置 &#x27;cy&#x27;: function(d)&#123;return yScale(d[1])&#125;, //用y尺度算出cy位置 &#x27;r&#x27;: &#x27;3px&#x27; &#125;); //Axis var xAxis = d3.svg.axis().scale(xScale) //用x尺度製作x軸線 .orient(&quot;bottom&quot;) //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(&quot;left&quot;) //標示位置 .ticks(6) //尺度數量 svg.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, &#x27;x axis&#x27;) //定義尺度樣式 .attr(&#x27;transform&#x27;, &#x27;translate(0, &#x27;+ (h - padding) +&#x27;)&#x27;) //移動到下方 .call(xAxis) //套用x軸線 svg.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, &#x27;y axis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(&#x27;+ (padding) +&#x27;)&#x27;, 0) .call(yAxis) //轉場時的code，其實有許多是和原本相同 //如果有興趣的可以先全部讀完，再重新製作一次 d3.select(&#x27;.btn&#x27;).on(&#x27;click&#x27;, function()&#123; //每次點擊的時候 dataset = []; //將陣列清空 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; for (var i = 0; i &lt; numDataPoints; i++)&#123; var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) &#125; //這段和前面一樣，YA var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;); //一樣 var xScale = d3.scale.linear() //由於尺度有重新計算，所以必須再跑一次 .domain([0, Xmax]) .range([padding , w - padding]) .nice() //取整數 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() svg.selectAll(&#x27;circle&#x27;).data(dataset) // .enter() //這不需要再加入 // .append(&#x27;circle&#x27;) //這也不需要 .transition() //套用動態效果 .duration(250) //動態持續時間 .each(&#x27;start&#x27;, function()&#123; //過場開始執行 d3.select(this) .attr(&#x27;fill&#x27;, &#x27;DeepPink&#x27;) .attr(&#x27;r&#x27;, 2) &#125;) .transition() //套用動態效果 .duration(1000) //第二段時間 .attr(&#123; &#x27;cx&#x27;: function(d)&#123;return xScale(d[0])&#125;, &#x27;cy&#x27;: function(d)&#123;return yScale(d[1])&#125;, &#x27;r&#x27;: &#x27;3px&#x27;, &#x27;fill&#x27;: &#x27;black&#x27;, &#x27;r&#x27;: 5 &#125;); // 更新Axis var xAxis = d3.svg.axis().scale(xScale) .orient(&quot;bottom&quot;) //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(&quot;left&quot;) //標示位置 .ticks(6) //尺度數量 svg.select(&#x27;.x.axis&#x27;) .transition() //動態尺度 .duration(1000) .call(xAxis); svg.select(&#x27;.y.axis&#x27;) .transition() .duration(1000) .call(yAxis); &#125;); 如果圖表會產生變化，觀者可以感受到位移，可以感受到數值的變化，在繪製圖表的時候，適當的加入不僅可以更吸引人，而且閱讀性更佳(增加前後比較的資訊)，但如果過度的效果，就會讓人眼花撩亂。 var w = 600,h = 400,padding = 30; var dataset = []; //產生空的陣列 var numDataPoints = 100; //最大點的數量是100 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; //隨機範圍最大值都是1000 for (var i = 0; i < numDataPoints; i++){ var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) //運算出新的值，並加到dataset } var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}); //計算最大值 var xScale = d3.scale.linear() //線性尺度 .domain([0, Xmax]) //輸入值 .range([padding , w - padding]) //輸出值 .nice() //取最適合數值 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //裁切區域 svg.append('clipPath') //新增svg裁切區域 .attr('id', 'chart-area') //定義id .append('rect') //再增加一個矩型 .attr({ 'x': padding, 'y': padding, 'width': w - padding * 2, 'height': h - padding * 2 }) svg.append('g') .attr('clip-path', 'url(#chart-area)') //套用裁切區域 .selectAll('circle') .data(dataset).enter() //輸入資料 .append('circle') //加入圓 .attr({ 'cx': function(d){return xScale(d[0])}, //用x尺度算出cx位置 'cy': function(d){return yScale(d[1])}, //用y尺度算出cy位置 'r': '3px' }); //Axis var xAxis = d3.svg.axis().scale(xScale) //用x尺度製作x軸線 .orient(\"bottom\") //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(\"left\") //標示位置 .ticks(6) //尺度數量 svg.append('g').attr('class', 'x axis') //定義尺度樣式 .attr('transform', 'translate(0, '+ (h - padding) +')') //移動到下方 .call(xAxis) //套用x軸線 svg.append('g').attr('class', 'y axis') .attr('transform', 'translate('+ (padding) +')', 0) .call(yAxis) //轉場時的code，其實有許多是和原本相同 //如果有興趣的可以先全部讀完，再重新製作一次 d3.select('.btn').on('click', function(){ //每次點擊的時候 dataset = []; //將陣列清空 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; for (var i = 0; i < numDataPoints; i++){ var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) } //這段和前面一樣，YA var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}); //一樣 var xScale = d3.scale.linear() //由於尺度有重新計算，所以必須再跑一次 .domain([0, Xmax]) .range([padding , w - padding]) .nice() //取整數 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() svg.selectAll('circle').data(dataset) // .enter() //這不需要再加入 // .append('circle') //這也不需要 .transition() //套用動態效果 .duration(250) //動態持續時間 .each('start', function(){ //過場開始執行 d3.select(this) .attr('fill', 'DeepPink') .attr('r', 2) }) .transition() //套用動態效果 .duration(1000) //第二段時間 .attr({ 'cx': function(d){return xScale(d[0])}, 'cy': function(d){return yScale(d[1])}, 'r': '3px', 'fill': 'black', 'r': 5 }); // 更新Axis var xAxis = d3.svg.axis().scale(xScale) .orient(\"bottom\") //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(\"left\") //標示位置 .ticks(6) //尺度數量 svg.select('.x.axis') .transition() //動態尺度 .duration(1000) .call(xAxis); svg.select('.y.axis') .transition() .duration(1000) .call(yAxis); }); .axis path, .axis line{ fill: none; stroke: black; shape-rendering: cirspEdges; } .axis text{ font-size: 11px; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 超粘的Voronoi Diagram繪圖","slug":"Ironman-30-days-20","date":"2014-10-18T16:00:00.000Z","updated":"2016-10-13T02:42:53.000Z","comments":true,"path":"d3js/2014/10/19/Ironman-30-days-20/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/19/Ironman-30-days-20/","excerpt":"Voronoi Diagram這個繪圖我在Blog的Banner上，主要原因也是因為他很有趣，除了視覺感外，它還包含了簡單的互動。","text":"Voronoi Diagram這個繪圖我在Blog的Banner上，主要原因也是因為他很有趣，除了視覺感外，它還包含了簡單的互動。 來源：http://bl.ocks.org/mbostock/4060366 這個繪圖的方式，經過我同事的指點，我才發現他是有理論基礎的(可參考：http://www.csie.ntnu.edu.tw/~u91029/VoronoiDiagram.html)，然而D3.js內建這樣的Layout不經讓我覺得對D3.js的誤會很大，原本認為D3.js是繪製資料圖表而已，但在透過上面那個理論的網站，會發現很多很多的數學原理，都和D3.js有些關聯。 Voronoi Diagram 是大自然的圖案，諸如長頸鹿的斑紋、蜻蜓的翅膀、葉片的細胞壁。應用相當廣泛。 互動在這一個範例中，一開始會先繪製一個Voronoi Diagram圖案，接下來滑鼠滑過之後，會替換掉其中一個，並且會隨著滑鼠的移動不斷的改變其週邊的外形。 var svgSize = &#123; w : 960, h : 500 &#125; var hslValue = 3; var vertices = d3.range(100).map(function(d) &#123; return [Math.random() * svgSize.w, Math.random() * svgSize.h]; //產生100個坐標，位置是隨機的 &#125;); console.log(vertices) var voronoi = d3.geom.voronoi() //套用voronoi，這段只有裁切區域 .clipExtent([[0,0], [svgSize.w , svgSize.h]]) //裁切voronoi區域 var svg = d3.select(&#x27;.chart&#x27;).append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, svgSize.w) .attr(&#x27;height&#x27;, svgSize.h) .on(&#x27;mousemove&#x27;, function() &#123; vertices[0] = d3.mouse(this);//殘忍地將第一個替換掉 redraw(); //將滑鼠的坐標帶入redraw &#125;) var path = svg.append(&#x27;g&#x27;).selectAll(&#x27;path&#x27;); //等等要用path來畫間隔線 svg.selectAll(&#x27;circle&#x27;) .data(vertices) //將剛剛產生的x,y插入 .enter().append(&#x27;circle&#x27;) //補上原點的位置 .attr(&#x27;transform&#x27;, function(d)&#123; return &#x27;translate(&#x27; + d + &#x27;)&#x27;; &#125;) //位置坐標如資料 .attr(&#x27;r&#x27;, 1.5) //大小是1.5px redraw() function redraw()&#123; path = path.data(voronoi(vertices) , polygon) // voronoi(vertices) 會傳回path 所需要的路徑坐標 // 然後用polygon function執行 path.exit().remove(); //如果多餘就移除 path.enter().append(&#x27;path&#x27;) .attr(&#x27;d&#x27;, polygon) //調用下方的polygon函示 .style(&#x27;fill&#x27;, function(d, i)&#123; return d3.hsl((120 + i * hslValue % 360),.6,.6)&#125;) path.order(); //這段似乎有沒有都沒差... &#125; function polygon(d) &#123; console.log(d) return &quot;M&quot; + d.join(&quot;L&quot;) + &quot;Z&quot;; &#125; path &#123; stroke: white; &#125; 另外我的Blog上的Banner，也是這個方式去做出來的，只是改變了兩個效果： RWD(自適應) 色彩 原始碼在https://github.com/Wcc723/wcc723.github.io/blob/master/assets/themes/casper2013/js/d3_banner.js，有興趣的可以參考看看～(無註解) var svgSize = { w : 600, h : 500 } var hslValue = 3; var vertices = d3.range(60).map(function(d) { return [Math.random() * svgSize.w, Math.random() * svgSize.h]; //產生100個坐標，位置是隨機的 }); console.log(vertices) var voronoi = d3.geom.voronoi() //套用voronoi，這段只有裁切區域 .clipExtent([[0,0], [svgSize.w , svgSize.h]]) //裁切voronoi區域 var svg = d3.select('.demo').append('svg') .attr('width', svgSize.w) .attr('height', svgSize.h) .on('mousemove', function() { vertices[0] = d3.mouse(this);//殘忍地將第一個替換掉 redraw(); //將滑鼠的坐標帶入redraw }) var path = svg.append('g').selectAll('path'); //等等要用path來畫間隔線 svg.selectAll('circle') .data(vertices) //將剛剛產生的x,y插入 .enter().append('circle') //補上原點的位置 .attr('transform', function(d){ return 'translate(' + d + ')'; }) //位置坐標如資料 .attr('r', 1.5) //大小是1.5px redraw() function redraw(){ path = path.data(voronoi(vertices) , polygon) // voronoi(vertices) 會傳回path 所需要的路徑坐標 // 然後用polygon function執行 path.exit().remove(); //如果多餘就移除 path.enter().append('path') .attr('d', polygon) //調用下方的polygon函示 .style('fill', function(d, i){ return d3.hsl((120 + i * hslValue % 360),.6,.6)}) path.order(); //這段似乎有沒有都沒差... } function polygon(d) { console.log(d) return \"M\" + d.join(\"L\") + \"Z\"; } path { stroke: white; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 圈圈小效果","slug":"Ironman-30-days-19","date":"2014-10-17T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/18/Ironman-30-days-19/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/18/Ironman-30-days-19/","excerpt":"D3js除了繪製圖表外，還有許多開發者拿來作為視覺或者互動效果，假日的文章，就來介紹一些網路上所找到的效果。","text":"D3js除了繪製圖表外，還有許多開發者拿來作為視覺或者互動效果，假日的文章，就來介紹一些網路上所找到的效果。 抱怨…，今天中華電信網路出問題，附近的商家…捷運站網路也都掛了，害我跑很遠才有網路可用…&gt; &lt;。 在學D3的過程中，除了看書就是不斷的找範例，有些範例並不是實用型，只是些效果，但是可以從中看到別人怎麼活用D3.js。 互動範例來源：http://bl.ocks.org/mbostock/1062544 這一個範例中我認為最重要是他所寫的滑鼠、觸控監聽事件，範例如下： svg.append(&#x27;rect&#x27;).attr(&#x27;width&#x27;, width) .attr(&#x27;height&#x27;, height) .on(&#x27;ontouchstart&#x27; in document ? &#x27;touchmove&#x27; : &#x27;mousemove&#x27;, particle); 在下面黑色區域滑動滑鼠，或者是用觸控都可以有圓圈圈的效果。 var width = 600, height = 500; var i = 0; //場上圓圈的數量，預設是0 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;) //插入SVG .attr(&#x27;width&#x27;, width) .attr(&#x27;height&#x27;, height); svg.append(&#x27;rect&#x27;).attr(&#x27;width&#x27;, width) .attr(&#x27;height&#x27;, height) .on(&#x27;ontouchstart&#x27; in document ? &#x27;touchmove&#x27; : &#x27;mousemove&#x27;, particle); //偵測是滑鼠還是觸控事件 function particle()&#123; var m = d3.mouse(this) //m是陣列，只有x,y 坐標 svg.insert(&#x27;circle&#x27;, &#x27;rect&#x27;) //在rect內新增circle .attr(&#x27;cx&#x27;, m[0])//滑鼠x坐標 .attr(&#x27;cy&#x27;, m[1])//滑鼠y坐標 .attr(&#x27;r&#x27;, 1e-6) //(0.000001 ,科學計算法) .style(&#x27;stroke&#x27;, d3.hsl((i = (i+1) % 360), 1, .5)) //(i = (i+1) % 360) 取餘數 .style(&#x27;stroke-opacity&#x27;, 1) //一開始是不透明 .transition() //轉場效果 .duration(2000) //動畫轉場時間2秒 .ease(Math.sqrt) //取得平方根，不懂在這邊有什麼意義 .attr(&#x27;r&#x27;, 100) //不斷放大 .style(&#x27;stroke-opacity&#x27;, 1e-6) //轉變成半透明 .remove(); //時間到後移除物件 d3.event.preventDefault(); //移除預設事件 &#125; svg.selectAll(&#x27;.class&#x27;).on(&#x27;mouseover&#x27;, function(d)&#123; //do something &#125;).on(&#x27;mouseout&#x27;, function(d)&#123; //do something &#125;); 明天要介紹我部落格上方的Banner喔～ var width = 600, height = 500; var i = 0; //場上圓圈的數量，預設是0 var svg = d3.select('.demo').append('svg') //插入SVG .attr('width', width) .attr('height', height); svg.append('rect').attr('width', width) .attr('height', height) .on('ontouchstart' in document ? 'touchmove' : 'mousemove', particle); //偵測是滑鼠還是觸控事件 function particle(){ var m = d3.mouse(this) //m是陣列，只有x,y 坐標 svg.insert('circle', 'rect') //在rect內新增circle .attr('cx', m[0])//滑鼠x坐標 .attr('cy', m[1])//滑鼠y坐標 .attr('r', 1e-6) //(0.000001 ,科學計算法) .style('stroke', d3.hsl((i = (i+1) % 360), 1, .5)) //(i = (i+1) % 360) 取餘數 .style('stroke-opacity', 1) //一開始是不透明 .transition() //轉場效果 .duration(2000) //動畫轉場時間2秒 .ease(Math.sqrt) //取得平方根，不懂在這邊有什麼意義 .attr('r', 100) //不斷放大 .style('stroke-opacity', 1e-6) //轉變成半透明 .remove(); //時間到後移除物件 d3.event.preventDefault(); //移除預設事件 } svg { background: black; } rect { fill: none; pointer-events: all; } circle { fill: none; stroke-width: 2px; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 究竟搭不搭捷運與死亡率有沒有關係？(3) - 將資料繪製成折線圖","slug":"Ironman-30-days-18","date":"2014-10-16T16:00:00.000Z","updated":"2016-10-13T02:57:04.000Z","comments":true,"path":"d3js/2014/10/17/Ironman-30-days-18/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/17/Ironman-30-days-18/","excerpt":"有了資料跟一些D3.js基礎後，就可以嘗試把資料轉換成圖，雖然萬事已經具備，但要繪製成圖，還是需要費些心力。","text":"有了資料跟一些D3.js基礎後，就可以嘗試把資料轉換成圖，雖然萬事已經具備，但要繪製成圖，還是需要費些心力。 在資料上，先前有提到高雄縣市合併有影響死亡率，所以這次還有再補上高雄縣市合併的資料。 互動這次還之前的不同，還有加上簡單的互動，而D3js的互動和jQuery寫法觀念相當接近，只是操作DOM時把$換成了d3，如果熟悉jquery的開發者很快就能上手。 範例大概如下： svg.selectAll(&#x27;.class&#x27;).on(&#x27;mouseover&#x27;, function(d)&#123; //do something &#125;).on(&#x27;mouseout&#x27;, function(d)&#123; //do something &#125;); 剩下的部分，就直接看code應該會比較理解～ $(function() &#123; var shPath = &#x27;https://spreadsheets.google.com/feeds/list/&#x27;, shKey = &#x27;1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM&#x27;, shCallback = &#x27;/public/values?alt=json-in-script&amp;callback=?&#x27;, shList = [ &#123; &#x27;listKey&#x27;: &#x27;od6&#x27;, &#125;,&#123; &#x27;listKey&#x27;: &#x27;ol1cvs7&#x27;, &#125; ,&#123; &#x27;listKey&#x27;: &#x27;objevh6&#x27;, &#125; //這部分是高雄縣市的合併資料 ] var url = shPath + shKey + &#x27;/&#x27; + shList + shCallback; //合併路徑 var dataRemote = []; //建立空的陣列 //讀入每一個資料表 $.each(shList, function(i, list)&#123; $.getJSON( shPath + shKey + &#x27;/&#x27; + list.listKey + shCallback) .done(function (data) &#123; //如果成功 list.dataName = [] var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t //資料頁的標題 dataRemote.push(&#123; //存回陣列 &#x27;title&#x27;: title, &#x27;data&#x27;: entry &#125;); //送回dataset jsonDone(); //執行驗證 &#125;) .fail(function(jqxhr, textStatus, error)&#123; console.log(&#x27;GG,沒戲唱了&#x27;); //失敗 &#125;); &#125;) //驗證資料跑完沒 jsonDone = function()&#123; if (shList.length != dataRemote.length)&#123; console.log(&#x27;快好了&#x27;); //驗證未完成 &#125; else if (shList.length == dataRemote.length)&#123; console.log(&#x27;好了&#x27;, dataRemote); //驗證成功 dataset = dataRemote runChart(); //繪製圖表 &#125; &#125;; //真的開始畫圖了 runChart = function()&#123; var margin = &#123;top: 60, right: 40, bottom: 50, left: 60&#125;; var w = 560 ; // 寬 var h = 300 ; // 高 console.log(dataset[0].data.length) datatime = []; //將時間存成陣列，作為Xscale用處 $.each(dataset[0].data,function(i,d)&#123; datatime.push(d.gsx$time.$t) &#125;); var xScale = d3.scale.linear().domain([0,dataset[0].data.length]).range([0,w]) var yScale = d3.scale.linear().domain([.2, .85]).range([h, 0]); //Y的Scale就不另外寫，先直接設定值 // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d.gsx$percent.$t); //利用尺度運算資料的值，傳回y的位置 &#125;); //增加一個SVG元素 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w + margin.left + margin.right) //將左右補滿 .attr(&#x27;height&#x27;, h + margin.top + margin.bottom) //上下補滿 .append(&#x27;g&#x27;) //增加一個群組g .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + margin.left + &#x27;,&#x27; + margin.top + &#x27;)&#x27;); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 var xAxis = d3.svg.axis().scale(xScale).ticks(5).orient(&#x27;bottom&#x27;).tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;x axis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + h + &#x27;)&#x27;) .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient(&#x27;left&#x27;); // SVG加入y軸線 svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;y axis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0,0)&#x27;) .call(yAxisLeft); $.each(dataset,function(i,d)&#123; svg.append(&#x27;path&#x27;).attr(&#x27;d&#x27;, line(d.data)) .style(&#123; &#x27;stroke&#x27;: d3.hsl((120 + 90*i), .6, .6),//d3.hsl是d3提供的顏色function &#x27;stroke-width&#x27;:1, &#125;);//將每個資料繪製成折線，並且套用不同的色彩 svg.append(&#x27;g&#x27;).selectAll(&#x27;circle&#x27;).data(d.data).enter() //增加原點 .append(&#x27;circle&#x27;) .attr(&#123; &#x27;cx&#x27;: function(d, i)&#123;return xScale(i + 1) &#125;, &#x27;cy&#x27;: function(d)&#123;return yScale(d.gsx$percent.$t)&#125;, //x,y算法都類似line function &#x27;r&#x27;:&#x27;2px&#x27;, &#x27;class&#x27;: &#x27;dot&#x27; //這圓點主要是要給hover使用的 &#125;) .style(&#123; &#x27;fill&#x27;: d3.hsl((120 + 90*i), .6, .6)//套用相同色彩 &#125;) svg.append(&#x27;g&#x27;).append(&#x27;text&#x27;) //補上左上示意文字 .text(d.title) .style(&#123; &#x27;fill&#x27;: d3.hsl((120 + 90*i), .6, .6), &#x27;transform&#x27;: &#x27;translate(8px,&#x27;+ ((i * 15) + 12) //拉開間距 +&#x27;px)&#x27;, &#x27;font-size&#x27;:&#x27;12px&#x27; &#125;) &#125;); showTips = function(id)&#123; //這部分是要作為Hover用的資料 date = dataset[0].data[id].gsx$time.$t //時間取其中一份的即可 var html = &#x27;&#x27; $.each(dataset, function(i, dataset)&#123; //將資料定義，並回傳 title = dataset.title; percent = dataset.data[id].gsx$percent.$t; html = html + &#x27;&lt;div&gt;&lt;span&gt;&#x27;+title+&#x27;&lt;/span&gt;/&lt;span&gt; &#x27;+percent+&#x27;%&lt;/span&gt;&lt;/div&gt;&#x27; &#125;); html = &#x27;&lt;div&gt;&#x27;+date+&#x27;&lt;/div&gt;&#x27; + html; return html; //回傳整理好的html &#125;; svg.selectAll(&#x27;.dot&#x27;).on(&#x27;mouseover&#x27;, function(d)&#123; //d3 function，類似jquery，直接可以控制class var xPos = parseFloat(d3.select(this).attr(&#x27;cx&#x27;)) + margin.left //截取點的位置 var yPos = parseFloat(d3.select(this).attr(&#x27;cy&#x27;)) + margin.top //這一個目標(d)，裡面也包含了資料，所以d.gsx$id可以抓到這個點所包含的資料 var id = d.gsx$id.$t - 1 //抓取資料id d3.select(&#x27;#tooltip&#x27;) //將div抓來用 .style(&#123; &#x27;left&#x27;: xPos + &#x27;px&#x27;, &#x27;top&#x27;: yPos + &#x27;px&#x27; &#125;) .classed(&#x27;hidden&#x27;, false) //移除隱藏的class .html(showTips(id)) //將剛剛的showTips function帶入 &#125;).on(&#x27;mouseout&#x27;, function(d)&#123; //如果移出的話 d3.select(&#x27;#tooltip&#x27;).classed(&#x27;hidden&#x27;, true); //補回剛剛的Class &#125;); &#125; &#125;); 有注意到嗎？在互動的事件上是使用一般的div，所以SVG與HTML是可以混合使用的，不過也記得要補上html部分的程式碼。 path &#123; stroke: DodgerBlue; stroke-width: 1; fill: none; &#125; .axis &#123; font-size: 11px; fill: gray; &#125; .x.axis line &#123; stroke: lightgrey; &#125; .x.axis .minor &#123; stroke-opacity: .5; &#125; .x.axis path &#123; stroke: #fafafa; &#125; .y.axis line, .y.axis path &#123; fill: none; stroke: lightgrey; &#125; .x.axis text&#123; display: none; &#125; .demo&#123; position: relative; &#125; #tooltip&#123; position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; &#125; #tooltip.hidden&#123; opacity: 0; &#125; $(function() { var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&callback=?', shList = [ { 'listKey': 'od6', },{ 'listKey': 'ol1cvs7', } ,{ 'listKey': 'objevh6', } //這部分是高雄縣市的合併資料 ] var url = shPath + shKey + '/' + shList + shCallback; //合併路徑 var dataRemote = []; //建立空的陣列 //讀入每一個資料表 $.each(shList, function(i, list){ $.getJSON( shPath + shKey + '/' + list.listKey + shCallback) .done(function (data) { //如果成功 list.dataName = [] var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t //資料頁的標題 dataRemote.push({ //存回陣列 'title': title, 'data': entry }); //送回dataset jsonDone(); //執行驗證 }) .fail(function(jqxhr, textStatus, error){ console.log('GG,沒戲唱了'); //失敗 }); }) //驗證資料跑完沒 jsonDone = function(){ if (shList.length != dataRemote.length){ console.log('快好了'); //驗證未完成 } else if (shList.length == dataRemote.length){ console.log('好了', dataRemote); //驗證成功 dataset = dataRemote runChart(); //繪製圖表 } }; //真的開始畫圖了 runChart = function(){ var margin = {top: 60, right: 40, bottom: 50, left: 60}; var w = 560 ; // 寬 var h = 300 ; // 高 console.log(dataset[0].data.length) datatime = []; //將時間存成陣列，作為Xscale用處 $.each(dataset[0].data,function(i,d){ datatime.push(d.gsx$time.$t) }); var xScale = d3.scale.linear().domain([0,dataset[0].data.length]).range([0,w]) var yScale = d3.scale.linear().domain([.2, .85]).range([h, 0]); //Y的Scale就不另外寫，先直接設定值 // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d.gsx$percent.$t); //利用尺度運算資料的值，傳回y的位置 }); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 var xAxis = d3.svg.axis().scale(xScale).ticks(5).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); $.each(dataset,function(i,d){ svg.append('path').attr('d', line(d.data)) .style({ 'stroke': d3.hsl((120 + 90*i), .6, .6),//d3.hsl是d3提供的顏色function 'stroke-width':1, });//將每個資料繪製成折線，並且套用不同的色彩 svg.append('g').selectAll('circle').data(d.data).enter() //增加原點 .append('circle') .attr({ 'cx': function(d, i){return xScale(i + 1) }, 'cy': function(d){return yScale(d.gsx$percent.$t)}, //x,y算法都類似line function 'r':'2px', 'class': 'dot' //這圓點主要是要給hover使用的 }) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6)//套用相同色彩 }) svg.append('g').append('text') //補上左上示意文字 .text(d.title) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6), 'transform': 'translate(8px,'+ ((i * 15) + 12) //拉開間距 +'px)', 'font-size':'12px' }) }); showTips = function(id){ //這部分是要作為Hover用的資料 date = dataset[0].data[id].gsx$time.$t //時間取其中一份的即可 var html = '' $.each(dataset, function(i, dataset){ //將資料定義，並回傳 title = dataset.title; percent = dataset.data[id].gsx$percent.$t; html = html + ''+title+'/ '+percent+'%' }); html = ''+date+'' + html; return html; //回傳整理好的html }; svg.selectAll('.dot').on('mouseover', function(d){ //d3 function，類似jquery，直接可以控制class var xPos = parseFloat(d3.select(this).attr('cx')) + margin.left //截取點的位置 var yPos = parseFloat(d3.select(this).attr('cy')) + margin.top //這一個目標(d)，裡面也包含了資料，所以d.gsx$id可以抓到這個點所包含的資料 var id = d.gsx$id.$t - 1 //抓取資料id d3.select('#tooltip') //將div抓來用 .style({ 'left': xPos + 'px', 'top': yPos + 'px' }) .classed('hidden', false) //移除隱藏的class .html(showTips(id)) //將剛剛的showTips function帶入 }).on('mouseout', function(d){ //如果移出的話 d3.select('#tooltip').classed('hidden', true); //補回剛剛的Class }); } }); path { stroke: DodgerBlue; stroke-width: 1; fill: none; } .axis { font-size: 11px; fill: gray; } .x.axis line { stroke: lightgrey; } .x.axis .minor { stroke-opacity: .5; } .x.axis path { stroke: #fafafa; } .y.axis line, .y.axis path { fill: none; stroke: lightgrey; } .x.axis text{ display: none; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 究竟搭不搭捷運與死亡率有沒有關係？(2) - Google 試算表","slug":"Ironman-30-days-17","date":"2014-10-15T16:00:00.000Z","updated":"2016-10-13T02:57:22.000Z","comments":true,"path":"d3js/2014/10/16/Ironman-30-days-17/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/16/Ironman-30-days-17/","excerpt":"上一篇提到資料是放在Google 試算表上，然後再透過web 前端去接資料，當初會想這麼做的原因有以下幾點： 資料路徑穩定，不易掛點 技術上只要成功一次，以後都沒問題 資料建立簡單，大部份的人都可以參與 可以多人協作 對我來說，資料怎麼接一直是很大的問題，也在想如果沒有後端技術，要處理資料是不是比較複雜，還好有Google Drive，不僅解決了資料處理以及介接的問題，還有許多的優點可以去活用。","text":"上一篇提到資料是放在Google 試算表上，然後再透過web 前端去接資料，當初會想這麼做的原因有以下幾點： 資料路徑穩定，不易掛點 技術上只要成功一次，以後都沒問題 資料建立簡單，大部份的人都可以參與 可以多人協作 對我來說，資料怎麼接一直是很大的問題，也在想如果沒有後端技術，要處理資料是不是比較複雜，還好有Google Drive，不僅解決了資料處理以及介接的問題，還有許多的優點可以去活用。 相信試算表大部分功能大家都很熟悉了，這邊就只提幾個可以注意的小地方，供大家參考參考。 試算表路徑： https://docs.google.com/spreadsheets/d/1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM/edit#gid=0 資料格式資料怎麼找，就各憑本事了，能力好會用知道怎麼爬，能力普通可以像我一樣用Google搜尋就好，但是找來的資料格式許多都不是想要的，所以還是需要稍作整理，那麼就可以趁轉到Google Drive上時順便改成自己想要的格式。 就以時間來說，也可以趁這時候轉成西元年，並且套用成時間格式。 表格標頭試算表的標頭，建議使用英文名稱，再轉成json後他會以key的方式呈現，就以百分比來說，他會像下面的方式呈現： gsx$percent.$t 發佈到網路這一段我找很多資料，看起來很複雜，其實很簡單，只是我關鍵字下錯了…。 匯出成json讓其它工具使用，經我略微的測試與該試算表的權限沒什麼關係，只要選擇 檔案 &gt; 發佈到網路(位置會隨著版本不同而更換) ，接下來把該開啟的都打開就可以了。 如圖，我是把整份文件打開。 試算表的Key~最後要接資料，每份試算表都有一組key，它是固定的，只要開一份新的試算表都會產生，在剛剛發佈到網路那動作網址列其中一段就是key。 https://spreadsheets.google.com/feeds/list/&#123;Key&#125;/&#123;list&#125;/public/values?alt=json-in-script&amp;callback=? 另外還有一個是分頁的key，如果只有一個分頁，預設的key基本上是od6，但如果有超過兩個以上的分頁，試算表也會指定不同的key給分頁，查詢的方式如下連結。 https://spreadsheets.google.com/feeds/worksheets/&#123;Key&#125;/public/basic 接下來在這個網頁可以找到很多網址，分頁的key就隱藏在其中…，基本上都在public前後啦…。 如果有更好地搜尋方式也歡迎大家提供 &gt; &lt;。 Demo接下來就來用一小段Code來測試是否可以使用，如果下面的範例成功，會抓取一些些資料顯示在下面，如果失敗的話會顯示”GG,沒戲唱了”。 $(function()&#123; var shPath = &#x27;https://spreadsheets.google.com/feeds/list/&#x27;, shKey = &#x27;1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM&#x27;, shCallback = &#x27;/public/values?alt=json-in-script&amp;callback=?&#x27;, shList = &#x27;ol1cvs7&#x27; var dataset = [] $.getJSON( shPath + shKey + &#x27;/&#x27; + shList + shCallback) .done(function (data) &#123; //如果成功 var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t dataset.push(&#123; &#x27;title&#x27;: title, &#x27;data&#x27;: entry &#125;); //送回dataset console.log(dataset) $(&#x27;.demo .log&#x27;).text(&#x27;success:&#x27; + dataset[0].title + &#x27;,&#x27; + dataset[0].data[5].gsx$time.$t) &#125;) .fail(function(jqxhr, textStatus, error)&#123; $(&#x27;.demo .log&#x27;).text(&#x27;GG,沒戲唱了&#x27;); //失敗 &#125;); &#125;); $(function(){ var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&callback=?', shList = 'ol1cvs7' var dataset = [] $.getJSON( shPath + shKey + '/' + shList + shCallback) .done(function (data) { //如果成功 var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t dataset.push({ 'title': title, 'data': entry }); //送回dataset console.log(dataset) $('.demo .log').text('success:' + dataset[0].title + ',' + dataset[0].data[5].gsx$time.$t) }) .fail(function(jqxhr, textStatus, error){ $('.demo .log').text('GG,沒戲唱了'); //失敗 }); });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 究竟搭不搭捷運與死亡率有沒有關係？(1)","slug":"Ironman-30-days-16","date":"2014-10-14T16:00:00.000Z","updated":"2016-10-13T03:25:22.000Z","comments":true,"path":"d3js/2014/10/15/Ironman-30-days-16/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/15/Ironman-30-days-16/","excerpt":"D3js最終還是需要與資料串接，在玩了一段時間基本的功能後，就會想找點東西試試看，於是就到處搜尋可以用的資料(希望與時事結合)，雖然取得資料方法相當多，但是能夠派上用場而且又要會使用，就沒有那麼容易。 因為我的jsonp，或者json能力並不是挺好，所以在找資料前，有先研究怎麼與Google Drive做介接，所以這幾篇還會介紹怎麼從Google試算表取得資料。","text":"D3js最終還是需要與資料串接，在玩了一段時間基本的功能後，就會想找點東西試試看，於是就到處搜尋可以用的資料(希望與時事結合)，雖然取得資料方法相當多，但是能夠派上用場而且又要會使用，就沒有那麼容易。 因為我的jsonp，或者json能力並不是挺好，所以在找資料前，有先研究怎麼與Google Drive做介接，所以這幾篇還會介紹怎麼從Google試算表取得資料。 本篇統計僅供參考 資料來源資料來源http://statis.moi.gov.tw/micst/stmain.jsp?sys=100 無意間剛好逛到這個網站，發現裡面有許多的人口資料，裡面包含了死亡人數統計，也恰巧有”粗死亡率”，想說最近有討論到搭不搭捷運與死亡率的關係，所以就來試試看這份資料可不可行。 首先來了解一下基本資訊 臺北捷運營運：1996年3月28日 高雄捷運營運：2008年3月9日 高雄縣市合併(來源資料)：2011年1月 這份資料是抓取兩個都市的粗死亡率(所以不呈現人口數)，另外在高雄市2010年以前是合併前的資料，2011年以後是合併資料，來源當然是能撈多少就多少。 Demo雖然有很多工具可以呈現這樣的資料，但是就以目前的主題我選擇d3js + Jquery。 資料在確定要哪些後，就把原始的資料轉貼到Google Drive，除了可以將資料統一格式外，也可以降低我對於跨網域的煩惱…。 資料上我以都市為單位拆成三個資料表，每個圖表都包含了id、時間、死亡人數、粗死亡率。 接下來就開始串啦～，結果大概像下面這樣，Hover到點上，會顯示該時間點的資料。 高雄市與台北市粗死亡率 以上資料來源：http://statis.moi.gov.tw/micst/stmain.jsp?sys=100 高雄縣市合併時間(來源資料)：2011年1月 結語至於搭不搭捷運與死亡率有沒有關係，恩…可能研究不夠透徹，所以看不太出來，不過城鄉差距與死亡率關係倒是挺明顯的(可參考http://statis.moi.gov.tw/micst/stmain.jsp?sys=100)，所以縣市合併以後，高雄市的死亡率確實有略微增高。 另外為什麼每年二、三月似乎死亡率高些…(抖)，尤其在2009年二月高很多，稍微有查詢一下，可能是經濟不景氣的關係(Wiki 2009台灣年表)。 透過這些圖表，可以容易看到表格資料不易發現的地方，這或許也是圖像化迷人的點吧。 $(function() { var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&callback=?', shList = [ { 'listKey': 'od6', 'dataName': 'dataTaipei' },{ 'listKey': 'ol1cvs7', 'dataName': 'dataKaohsiung' } // ,{ // 'listKey': 'objevh6', // 'dataName': 'dataKaohsiungOld' // } ] var url = shPath + shKey + '/' + shList + shCallback; var dataRemote = []; //讀入每一個資料表 $.each(shList, function(i, list){ $.getJSON( shPath + shKey + '/' + list.listKey + shCallback) .done(function (data) { //如果成功 list.dataName = [] var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t dataRemote.push({ 'title': title, 'data': entry }); //送回dataset jsonDone(); }) .fail(function(jqxhr, textStatus, error){ console.log('GG,沒戲唱了'); //失敗 }); }) //驗證資料跑完沒 jsonDone = function(){ if (shList.length != dataRemote.length){ console.log('快好了'); //驗證未完成 } else if (shList.length == dataRemote.length){ console.log('好了', dataRemote); //驗證成功 runData(); //整理資料 } }; //整理資料 runData = function(){ //整理資料 dataset = dataRemote runChart(); }; //真的開始畫圖了 runChart = function(){ var margin = {top: 60, right: 40, bottom: 50, left: 60}; var w = 560 ; // 寬 var h = 300 ; // 高 console.log(dataset[0].data.length) // var Ymax = d3.max(dataset[0].data, function(d,i){ return d.data.gsx$percent.$t}), // Ymin = d3.min(dataset[0].data, function(d,i){ return d.data.gsx$percent.$t}); datatime = []; $.each(dataset[0].data,function(i,d){ datatime.push(d.gsx$time.$t) }); console.log(datatime) var xScale = d3.scale.linear().domain([0,dataset[0].data.length]).range([0,w]) var yScale = d3.scale.linear().domain([.2, .85]).range([h, 0]); // console.log(Ymax,Ymin) // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d.gsx$percent.$t); //利用尺度運算資料的值，傳回y的位置 }); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 // tickSubdivide不清楚是什麼用處 var xAxis = d3.svg.axis().scale(xScale).ticks(5).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); parseArray = function(data, l){ array = []; $.each(data,function(i,d){ array.push(d.l) }) } // svg.append('path').attr('d', line(dataset[0].data)); // svg.append('path').attr('d', line(dataset[1].data)); $.each(dataset,function(i,d){ svg.append('path').attr('d', line(d.data)) .style({ 'stroke': d3.hsl((120 + 90*i), .6, .6), 'stroke-width':1, })// svg.append('g').selectAll('circle').data(d.data).enter() .append('circle') .attr({ 'cx': function(d, i){return xScale(i + 1) }, 'cy': function(d){return yScale(d.gsx$percent.$t)}, 'r':'2px', 'stroke':'transparent', 'stroke-width':'3px', 'class': 'dot' }) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6) }) svg.append('g').append('text') .text(d.title) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6), 'transform': 'translate(8px,'+ ((i * 15) + 12) +'px)', 'font-size':'12px' }) }); showTips = function(id){ date = dataset[0].data[id].gsx$time.$t var html = '' $.each(dataset, function(i, dataset){ title = dataset.title; percent = dataset.data[id].gsx$percent.$t; html = html + ''+title+'/ '+percent+'%' }) console.log(date) html = ''+date+'' + html; return html } svg.selectAll('.dot').on('mouseover', function(d){ var xPos = parseFloat(d3.select(this).attr('cx')) + margin.left var yPos = parseFloat(d3.select(this).attr('cy')) + margin.top var id = d.gsx$id.$t - 1 d3.select('#tooltip') .style({ 'left': xPos + 'px', 'top': yPos + 'px' }) .classed('hidden', false) .html(showTips(id)) }).on('mouseout', function(d){ d3.select('#tooltip').classed('hidden', true) }) } }); path { stroke: DodgerBlue; stroke-width: 1; fill: none; } .axis { font-size: 11px; fill: gray; } .x.axis line { stroke: lightgrey; } .x.axis .minor { stroke-opacity: .5; } .x.axis path { stroke: #fafafa; } .y.axis line, .y.axis path { fill: none; stroke: lightgrey; } .x.axis text{ display: none; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 折線圖(Line Chart)","slug":"Ironman-30-days-15","date":"2014-10-13T16:00:00.000Z","updated":"2016-10-13T02:58:10.000Z","comments":true,"path":"d3js/2014/10/14/Ironman-30-days-15/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/14/Ironman-30-days-15/","excerpt":"在開始有題到網頁互動式資料視覺化：使用D3這本書，整本大致上都看完了，但是裡面居然沒有折線圖！雖然這本書主要教的是觀念，不過折線圖還是很重要，所以還是另外找了折線圖的範例來仔細學習一下。","text":"在開始有題到網頁互動式資料視覺化：使用D3這本書，整本大致上都看完了，但是裡面居然沒有折線圖！雖然這本書主要教的是觀念，不過折線圖還是很重要，所以還是另外找了折線圖的範例來仔細學習一下。 Demo先前有介紹過SVG:Path，大概像下面這樣： &lt;path d=&quot;M12,294.11764705882354L24,300L36,270.5882352941176L48,294.11764705882354L60,282.3529411764706L72,276.47058823529414L84.1,264.70588235294116L96,276.47058823529414L108,247.05882352941177L120,241.1764705882353L132,229.41176470588235L144,241.1764705882353L156,223.52941176470588L168.3,217.6470588235294L180,200L192,223.52941176470588L204.3,200L216,211.76470588235293L228,211.76470588235293L240,223.52941176470588L252,217.6470588235294L264,200L276,188.23529411764707L288,164.7058823529412L300,176.47058823529414L312,200L324,217.6470588235294L336.6,188.23529411764707L348,158.8235294117647L360,152.94117647058823L372,135.2941176470588L384,117.64705882352942L396,100L408.6,111.76470588235296L420.6,88.23529411764707L432,76.47058823529412L444,47.05882352941177L456,41.176470588235304L468,52.94117647058826L480,47.05882352941177L492.6,17.64705882352939L504,29.411764705882376L516,29.411764705882376L528,23.529411764705912L540,35.29411764705884L552,23.529411764705912L564,17.64705882352939L576,0L588,17.64705882352939L600,41.176470588235304&quot;&gt;&lt;/path&gt; 雖然之前有介紹過自幹的方式…，可是用來上資料真的會有點痛，不過還好d3有一個function d3.svg.line()可以用來繪製svg “path”，只要給予x、y，剩下d3都會處理。 本篇的範例參考自http://bl.ocks.org/benjchristensen/2579599 範例我可是花了點時間調的比他漂亮呢！(挺 var margin = &#123;top: 60, right: 40, bottom: 50, left: 60&#125;; var w = 580 ; // 寬 var h = 300 ; // 高 var dataset = []; //建立空的資料陣列 var Num = 20 for (var i=0; i &lt; 50; i++)&#123; var newNum = Num + (5 - Math.floor(Math.random() * 10)); dataset.push(newNum); Num = newNum; &#125; //隨機產生一組隨機的數字陣列，數字的值，每次加減不超過5 //X是資料的數量，Y則是資料的值 console.log(dataset) var Ymax = d3.max(dataset), Ymin = d3.min(dataset); var xScale = d3.scale.linear().domain([0, dataset.length]).range([0, w]); var yScale = d3.scale.linear().domain([Ymin, Ymax]).range([h, 0]); // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d); //利用尺度運算資料的值，傳回y的位置 &#125;); //增加一個SVG元素 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;) .attr(&#x27;width&#x27;, w + margin.left + margin.right) //將左右補滿 .attr(&#x27;height&#x27;, h + margin.top + margin.bottom) //上下補滿 .append(&#x27;g&#x27;) //增加一個群組g .attr(&#x27;transform&#x27;, &#x27;translate(&#x27; + margin.left + &#x27;,&#x27; + margin.top + &#x27;)&#x27;); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 // tickSubdivide不清楚是什麼用處 var xAxis = d3.svg.axis().scale(xScale).orient(&#x27;bottom&#x27;).tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;x axis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0,&#x27; + h + &#x27;)&#x27;) .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient(&#x27;left&#x27;); // SVG加入y軸線 svg.append(&#x27;g&#x27;) .attr(&#x27;class&#x27;, &#x27;y axis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(0,0)&#x27;) .call(yAxisLeft); svg.append(&#x27;path&#x27;).attr(&#x27;d&#x27;, line(dataset)); //將資料套用d3.svg.line() CSS path &#123; stroke: DodgerBlue; stroke-width: 1; fill: none; &#125; .axis &#123; font-size: 11px; fill: gray; &#125; .x.axis line &#123; stroke: lightgrey; &#125; .x.axis .minor &#123; stroke-opacity: .5; &#125; .x.axis path &#123; stroke: #fafafa; &#125; .y.axis line, .y.axis path &#123; fill: none; stroke: lightgrey; &#125; 不知道大家對於到目前的範例難度感覺如何，對我而言還挺難的，尤其資料、json的處理我相當的不擅長，不過既然稱為D3.js，還是要來玩一些資料，明天開始來找資料玩玩吧～ var margin = {top: 60, right: 40, bottom: 50, left: 60}; var w = 580 ; // 寬 var h = 300 ; // 高 var dataset = []; //建立空的資料陣列 var Num = 20 for (var i=0; i < 50; i++){ var newNum = Num + (5 - Math.floor(Math.random() * 10)); dataset.push(newNum); Num = newNum; } //隨機產生一組隨機的數字陣列，數字的值，每次加減不超過5 //X是資料的數量，Y則是資料的值 console.log(dataset) var Ymax = d3.max(dataset), Ymin = d3.min(dataset); var xScale = d3.scale.linear().domain([0, dataset.length]).range([0, w]); var yScale = d3.scale.linear().domain([Ymin, Ymax]).range([h, 0]); // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d); //利用尺度運算資料的值，傳回y的位置 }); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 // tickSubdivide不清楚是什麼用處 var xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); svg.append('path').attr('d', line(dataset)); //將資料套用d3.svg.line() path { stroke: DodgerBlue; stroke-width: 1; fill: none; } .axis { font-size: 11px; fill: gray; } .x.axis line { stroke: lightgrey; } .x.axis .minor { stroke-opacity: .5; } .x.axis path { stroke: #fafafa; } .y.axis line, .y.axis path { fill: none; stroke: lightgrey; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 軸線(Axis)","slug":"Ironman-30-days-14","date":"2014-10-12T16:00:00.000Z","updated":"2016-10-13T03:07:37.000Z","comments":true,"path":"d3js/2014/10/13/Ironman-30-days-14/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/13/Ironman-30-days-14/","excerpt":"到上一次為止，其實就可以畫出簡單的資料圖表，現在開始就要讓資料圖表更為豐富且好閱讀。 今天要介紹的軸線(Axis)，讓圖表上多一個可以閱讀的尺標，D3.js正好有提供這樣的函式，可以輕鬆的產出軸線。","text":"到上一次為止，其實就可以畫出簡單的資料圖表，現在開始就要讓資料圖表更為豐富且好閱讀。 今天要介紹的軸線(Axis)，讓圖表上多一個可以閱讀的尺標，D3.js正好有提供這樣的函式，可以輕鬆的產出軸線。 如果要憑空畫出這樣的軸線(Axis)，說實在還有點複雜，D3提供的函式d3.svg.axis()，只要這短短一行就能產生軸線，並且加上尺度.scale()就完成一半了，剩下就只要調整位置、刻度範圍、單位等等就完成了。 所以這範例，主要也是看程式碼，加油吧！ Demo var w = 600,h = 400,padding = 30; //random data var dataset = []; var numDataPoints = 100; //總共100個點 var xRange = Math.random() * 500; var yRange = Math.random() * 1000; for (var i = 0; i &lt; numDataPoints; i++)&#123; var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) &#125;//和更早之前一樣，我們用假的資料來做範例 console.table(dataset) var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;) //取得X,Y的最大及最小值 var xScale = d3.scale.linear() //製作線性尺度 .domain([0, Xmax]) //輸入的範圍 .range([padding , w - padding]) //輸出的範圍 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#123;&#x27;width&#x27;: w,&#x27;height&#x27;: h&#125;) //增加SVG容器 svg.selectAll(&#x27;circle&#x27;).data(dataset).enter() //插入資料 .append(&#x27;circle&#x27;) //增加圓形物件 .attr(&#123; &#x27;cx&#x27;: function(d)&#123;return xScale(d[0])&#125;, //利用尺度算出圓心x位置 &#x27;cy&#x27;: function(d)&#123;return yScale(d[1])&#125;, //同上算出y &#x27;r&#x27;: &#x27;2px&#x27;, //圓心大小 &#x27;fill&#x27;: &#x27;black&#x27; //填色 &#125;); svg.selectAll(&#x27;text&#x27;).data(dataset).enter() //插入資料 .append(&#x27;text&#x27;) //增加文字區塊 .text(function(d)&#123; return d[0]+ &#x27;,&#x27; + d[1]&#125;) //補上坐標文字 .attr(&#123; &#x27;x&#x27;: function(d)&#123;return xScale(d[0])&#125;, &#x27;y&#x27;: function(d)&#123;return yScale(d[1])&#125;, &#x27;fill&#x27;: &#x27;red&#x27;, //填滿紅色 &#x27;font-size&#x27;: &#x27;10px&#x27; //文字大小 &#125;); //Axis var xAxis = d3.svg.axis().scale(xScale) //增加軸線物件，並套用尺度(x) .orient(&quot;bottom&quot;) //標示位置 .ticks(6) //刻度數量 var yAxis = d3.svg.axis().scale(yScale) //增加軸線物件，並套用尺度(y) .orient(&quot;left&quot;) //標示位置 .ticks(10) //刻度數量 //刻度化標籤，這範例不使用 // var formatAsAxis = d3.format(&#x27;.1%&#x27;); // xAxis.tickFormat(formatAsAxis); //刻度化標籤 svg.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, &#x27;axis&#x27;) //增加一個群組並加上class=&quot;axis&quot; .attr(&#x27;transform&#x27;, &#x27;translate(0, &#x27;+ (h - padding) +&#x27;)&#x27;) //移動到下方 .call(xAxis); //將軸線匯入 svg.append(&#x27;g&#x27;).attr(&#x27;class&#x27;, &#x27;axis&#x27;) .attr(&#x27;transform&#x27;, &#x27;translate(&#x27;+ (padding) +&#x27;)&#x27;, 0) //移動到左方 .call(yAxis); 剛剛最後還有加Class，別忘了…，記得補上喔。 .axis path, .axis line&#123; fill: none; stroke: SlateGray; shape-rendering: cirspEdges; &#125; .axis text&#123; font-size: 11px; fill: #999; &#125; var w = 600,h = 400,padding = 30; //random data var dataset = []; var numDataPoints = 100; //總共100個點 var xRange = Math.random() * 500; var yRange = Math.random() * 1000; for (var i = 0; i < numDataPoints; i++){ var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) }//和更早之前一樣，我們用假的資料來做範例 console.table(dataset) var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}) //取得X,Y的最大及最小值 var xScale = d3.scale.linear() //製作線性尺度 .domain([0, Xmax]) //輸入的範圍 .range([padding , w - padding]) //輸出的範圍 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //增加SVG容器 svg.selectAll('circle').data(dataset).enter() //插入資料 .append('circle') //增加圓形物件 .attr({ 'cx': function(d){return xScale(d[0])}, //利用尺度算出圓心x位置 'cy': function(d){return yScale(d[1])}, //同上算出y 'r': '2px', //圓心大小 'fill': 'black' //填色 }); svg.selectAll('text').data(dataset).enter() //插入資料 .append('text') //增加文字區塊 .text(function(d){ return d[0]+ ',' + d[1]}) //補上坐標文字 .attr({ 'x': function(d){return xScale(d[0])}, 'y': function(d){return yScale(d[1])}, 'fill': 'red', //填滿紅色 'font-size': '10px' //文字大小 }); //Axis var xAxis = d3.svg.axis().scale(xScale) //增加軸線物件，並套用尺度(x) .orient(\"bottom\") //標示位置 .ticks(6) //刻度數量 var yAxis = d3.svg.axis().scale(yScale) //增加軸線物件，並套用尺度(y) .orient(\"left\") //標示位置 .ticks(10) //刻度數量 //刻度化標籤，這範例不使用 // var formatAsAxis = d3.format('.1%'); // xAxis.tickFormat(formatAsAxis); //刻度化標籤 svg.append('g').attr('class', 'axis') //增加一個群組並加上class=\"axis\" .attr('transform', 'translate(0, '+ (h - padding) +')') //移動到下方 .call(xAxis); //將軸線匯入 svg.append('g').attr('class', 'axis') .attr('transform', 'translate('+ (padding) +')', 0) //移動到左方 .call(yAxis); .axis path, .axis line{ fill: none; stroke: SlateGray; shape-rendering: cirspEdges; } .axis text{ font-size: 11px; fill: #999; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 讀取CSV資料並繪製成長條圖","slug":"Ironman-30-days-13","date":"2014-10-11T16:00:00.000Z","updated":"2016-10-13T03:07:53.000Z","comments":true,"path":"d3js/2014/10/12/Ironman-30-days-13/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/12/Ironman-30-days-13/","excerpt":"有了Excel的資料，也可以用d3.js去轉換成json，再結合前幾篇所做的長條圖，不就可以輕易的完成資訊圖表了!?是的，這次就來完成這個圖表吧。","text":"有了Excel的資料，也可以用d3.js去轉換成json，再結合前幾篇所做的長條圖，不就可以輕易的完成資訊圖表了!?是的，這次就來完成這個圖表吧。 今天的流程，算是這幾次的整合，如果有看前幾篇的話，這篇不會很難，但是卻很實用。 DemoCSV範例。 這個範例將會用到昨天所介紹的d3.csv()這個函示去取得本地端的CSV檔案，並且轉換成Json，接下來就把它套用在先前所作好的範例上…，這次的程式碼雖然很長，但都是前幾天剪剪貼貼就可以完成的，而所有的註解，我都一起寫在原始碼上，也方便各位對照(覺得SlateGray這個顏色很好看)。 那麼有了資料，我們再跟先前所練習的範例做結合吧。 dataPath = &#x27;/demoFile/d3data/&#x27;; dataFile = &#x27;d3demoData141011.csv&#x27;; dataUrl = dataPath + dataFile; //定義SVG的大小 d3.csv(dataUrl, function(data)&#123; console.debug(JSON.stringify(data)); dataset = data; var w = 600,h = 250,padding = 30, barMargin = 2; //定義寬高,padding等等值 var Ymax = d3.max(dataset, function(d)&#123;return d.value&#125;), Ymin = d3.min(dataset, function(d)&#123;return d.value&#125;); //取得Y軸的最大值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var colorScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([0, 700]) //這次顏色都要用尺度來算 var barWidth = (w - padding*2) / dataset.length - barMargin; var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#123;&#x27;width&#x27;: w,&#x27;height&#x27;: h&#125;) //接下來開始產生SVG svg.selectAll(&#x27;rect&#x27;).data(dataset).enter() //和先前一樣，選取&#x27;circle&#x27;並把資料加入 .append(&#x27;rect&#x27;) // 增加圓到SVG內 .attr(&#123; //加入屬性到圓 &#x27;x&#x27;: function(d, i)&#123;return xScale(i)&#125;, //利用尺度算出X的位置 &#x27;y&#x27;: function(d)&#123;return h - yScale(d.value)&#125;, //同理算出Y &#x27;width&#x27;: barWidth, &#x27;height&#x27;:function(d)&#123;return yScale(d.value)&#125;, //同理算出Y // &#x27;r&#x27;: function(d)&#123;return Math.sqrt(h - d[1])&#125;, //圓的大小是高 - Y值的平方 &#x27;fill&#x27;: function(d)&#123; var color = 0.2 + colorScale(d.value) * 0.001; return d3.hsl(200 ,color, color); //利用尺度來算出顏色 &#125;, &#x27;title&#x27;: function(d)&#123; return &#x27;Name : &#x27; + d.name; &#125; //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) &#125;); svg.selectAll(&#x27;text&#x27;).data(dataset).enter() //補上資料數值 .append(&#x27;text&#x27;) .text(function(d)&#123; return d.value&#125;) //將值寫到SVG上 .attr(&#123; &#x27;x&#x27;: function(d, i)&#123;return xScale(i) + barWidth/2&#125;, //和上面相同，算出X、Y的位置 &#x27;y&#x27;: function(d)&#123;return h - yScale(d.value) + 15&#125;, &#x27;fill&#x27;: &#x27;white&#x27;, //文字填滿為紅色 &#x27;text-anchor&#x27;: &#x27;middle&#x27;, &#x27;font-size&#x27;: &#x27;10px&#x27; //Fill、font-size也可以用CSS寫喔～ &#125;); svg.append(&#x27;g&#x27;).selectAll(&#x27;text&#x27;).data(dataset).enter() //這邊再多做一個人名顯示的區域 .append(&#x27;text&#x27;) .text(function(d)&#123; return d.name&#125;) //寫入人名 .attr(&#123; &#x27;x&#x27;: function(d, i)&#123;return xScale(i) + barWidth/2&#125;, //和上面相同，算出X、Y的位置 &#x27;y&#x27;: function(d)&#123;return h - yScale(d.value) - 10&#125;, &#x27;fill&#x27;: &#x27;SlateGray&#x27;, //文字填滿為超漂亮灰色 &#x27;text-anchor&#x27;: &#x27;middle&#x27;, &#x27;font-size&#x27;: &#x27;10px&#x27; //Fill、font-size也可以用CSS寫喔～ &#125;); &#125;); dataPath = '/demoFile/d3data/'; dataFile = 'd3demoData141011.csv'; dataUrl = dataPath + dataFile; //定義SVG的大小 d3.csv(dataUrl, function(data){ console.debug(JSON.stringify(data)); dataset = data; var w = 600,h = 250,padding = 30, barMargin = 2; //定義寬高,padding等等值 var Ymax = d3.max(dataset, function(d){return d.value}), Ymin = d3.min(dataset, function(d){return d.value}); //取得Y軸的最大值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var colorScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([0, 700]) //這次顏色都要用尺度來算 var barWidth = (w - padding*2) / dataset.length - barMargin; var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //接下來開始產生SVG svg.selectAll('rect').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('rect') // 增加圓到SVG內 .attr({ //加入屬性到圓 'x': function(d, i){return xScale(i)}, //利用尺度算出X的位置 'y': function(d){return h - yScale(d.value)}, //同理算出Y 'width': barWidth, 'height':function(d){return yScale(d.value)}, //同理算出Y // 'r': function(d){return Math.sqrt(h - d[1])}, //圓的大小是高 - Y值的平方 'fill': function(d){ var color = 0.2 + colorScale(d.value) * 0.001; return d3.hsl(200 ,color, color); //利用尺度來算出顏色 }, 'title': function(d){ return 'Name : ' + d.name; } //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d.value}) //將值寫到SVG上 .attr({ 'x': function(d, i){return xScale(i) + barWidth/2}, //和上面相同，算出X、Y的位置 'y': function(d){return h - yScale(d.value) + 15}, 'fill': 'white', //文字填滿為紅色 'text-anchor': 'middle', 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ }); svg.append('g').selectAll('text').data(dataset).enter() //這邊再多做一個人名顯示的區域 .append('text') .text(function(d){ return d.name}) //寫入人名 .attr({ 'x': function(d, i){return xScale(i) + barWidth/2}, //和上面相同，算出X、Y的位置 'y': function(d){return h - yScale(d.value) - 10}, 'fill': 'SlateGray', //文字填滿為超漂亮灰色 'text-anchor': 'middle', 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ }); });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 利用Excel建立資料(CSV)","slug":"Ironman-30-days-12","date":"2014-10-10T16:00:00.000Z","updated":"2016-10-13T03:08:17.000Z","comments":true,"path":"d3js/2014/10/11/Ironman-30-days-12/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/11/Ironman-30-days-12/","excerpt":"做了那麼多，資料都是隨機產生的，雖然每次打開都不一樣，但是還是假的資料，這次來試試看讀取Excel的資料吧。","text":"做了那麼多，資料都是隨機產生的，雖然每次打開都不一樣，但是還是假的資料，這次來試試看讀取Excel的資料吧。 CSVExcel可以轉出一種稱為csv(Comma-Separated Values)格式的檔案，檔案的資料內容都是用逗點隔開的，大概像下面這樣： name,value Tyler,234 Boy,124 Joe,357 第一行的name,value可以當作是標題或者是變數名稱，第二行開始的Tyler,234....都是值，d3.js可以將csv轉換成Json檔案格式，可以直接用來作為繪圖所需要的資料。 Excel今天又是假日，所以code就短一點，來介紹Excel怎麼做CSV，打開Excel以後，建立如下的資料。 接下來選擇另存新檔，附檔名選擇.CSV。 如果用文字編輯器打開，預期會出現下面的結果，而這就是D3所需要的csv格式。 如果不想自己做，也可以下載我做好的範例。 D3.js接下了Excel的工作就完成了，來試試看用D3js讀取看看吧，其實方式也相當簡單，只要用d3.csv()就可以讀取並且轉換成json資料格式，只要給d3.js路徑即可。 dataPath = &#x27;/demoFile/d3data/&#x27;; //檔案路徑 dataFile = &#x27;d3demoData141011.csv&#x27;; //檔名 dataUrl = dataPath + dataFile; //路徑加檔名 //定義SVG的大小 d3.csv(dataUrl, function(data)&#123; console.table(data); //用table的方式在console呈現json d3.select(&#x27;.demo&#x27;).text(JSON.stringify(data)) //把json寫到.demo上 &#125;); 如果對於json還認為不好閱讀的人，可以使用console.table()來呈現json，這樣會好閱讀很多。 而這個範例所轉換出來的json格式就像下面這樣。 那麼有了資料，我們明天再跟先前所練習的範例做結合吧。 dataPath = '/demoFile/d3data/'; //檔案路徑 dataFile = 'd3demoData141011.csv'; //檔名 dataUrl = dataPath + dataFile; //路徑加檔名 //定義SVG的大小 d3.csv(dataUrl, function(data){ console.table(data); //用table的方式在console呈現json d3.select('.demo').text(JSON.stringify(data)) //把json寫到.demo上 });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 國慶日在家裡畫長條圖","slug":"Ironman-30-days-11","date":"2014-10-09T16:00:00.000Z","updated":"2016-10-13T03:08:32.000Z","comments":true,"path":"d3js/2014/10/10/Ironman-30-days-11/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/10/Ironman-30-days-11/","excerpt":"上一篇的重點相當重要，可以運用在各種圖表上，而其實在之前介紹的用div繪製直條圖，在SVG上當然也是行得通，而且相當容易，今天是國慶日，當然就要來點簡易好吸收的主題。","text":"上一篇的重點相當重要，可以運用在各種圖表上，而其實在之前介紹的用div繪製直條圖，在SVG上當然也是行得通，而且相當容易，今天是國慶日，當然就要來點簡易好吸收的主題。 有了上一篇的觀念，這個直條圖就能更容易地呈現，無論資料量的多寡，或者是資料值的大小，都能完整地呈現在SVG上。 Demo在SVG上繪製直條圖，要注意的事情並不多，只有兩點需要略微注意： 直條Bar是從底部往上，但是一般SVG是由上往下 Bar的寬度、間距要怎麼定義 問題一：最簡單的方式，就是將Bar向下位置一個距離(距離為高 - 資料值)，接下來再往下延伸資料值的Bar，這個範例直接看圖可能比較好理解。 問題二：定義了Bar的寬度，如果資料的數量較多，可能多的部分會跑出SVG畫布，比較好的方式是定義間距的寬度就好，Bar的寬度由資料的總量來決定。 接下來不囉唆，快快看完今天的範例，來去過國慶日了。 var w = 600,h = 250,padding = 30, barMargin = 2; //定義SVG的大小，但是只要定義直條的間距就好，寬度用算的就好 var dataset = []; for (var i=0; i &lt; 20; i++)&#123; var Num1 = 5 + Math.floor(Math.random() * 255); dataset.push(Num1); &#125;; console.log(dataset); //和先前一樣，產生一組隨機的資料 var Ymax = d3.max(dataset, function(d)&#123;return d&#125;), Ymin = d3.min(dataset, function(d)&#123;return d&#125;) //這個函示可以取得資料的最大值、最小值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值改為資料的數量 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var barWidth = (w - padding*2) / dataset.length - barMargin; //算出每一個bar的寬度 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#123;&#x27;width&#x27;: w,&#x27;height&#x27;: h&#125;) //接下來開始產生SVG svg.selectAll(&#x27;rect&#x27;).data(dataset).enter() //和先前一樣，選取&#x27;circle&#x27;並把資料加入 .append(&#x27;rect&#x27;) // 增加圓到SVG內 .attr(&#123; //加入屬性到圓 &#x27;x&#x27;: function(d, i)&#123;return xScale(i)&#125;, //利用尺度算出X的位置 &#x27;y&#x27;: function(d)&#123;return h - yScale(d)&#125;, //同理算出Y，但是要放在底部，所以要y-yScale(d) &#x27;width&#x27;: barWidth, //bar的寬度 &#x27;height&#x27;:function(d)&#123;return yScale(d)&#125;, //高度算法與Y相同 &#x27;fill&#x27;: function(d)&#123; var color = 0.2 + d * 0.002; return d3.hsl(200 ,color, color); &#125; //顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) &#125;); svg.selectAll(&#x27;text&#x27;).data(dataset).enter() //補上資料數值 .append(&#x27;text&#x27;) .text(function(d)&#123; return d&#125;) //將值寫到SVG上 .attr(&#123; &#x27;x&#x27;: function(d, i)&#123;return xScale(i) + barWidth/2&#125;, //和上面相同，算出X、Y的位置 &#x27;y&#x27;: function(d)&#123;return h - yScale(d) + 15&#125;, //數值放在bar 內 &#x27;fill&#x27;: &#x27;white&#x27;, //文字填滿為白色 &#x27;text-anchor&#x27;: &#x27;middle&#x27;, //文字置中 &#x27;font-size&#x27;: &#x27;10px&#x27; //Fill、font-size也可以用CSS寫喔～ &#125;); var w = 600,h = 250,padding = 30, barMargin = 2; //定義SVG的大小，但是只要定義直條的間距就好，寬度用算的就好 var dataset = []; for (var i=0; i < 20; i++){ var Num1 = 5 + Math.floor(Math.random() * 255); dataset.push(Num1); }; console.log(dataset); //和先前一樣，產生一組隨機的資料 var Ymax = d3.max(dataset, function(d){return d}), Ymin = d3.min(dataset, function(d){return d}) //這個函示可以取得資料的最大值、最小值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值改為資料的數量 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var barWidth = (w - padding*2) / dataset.length - barMargin; //算出每一個bar的寬度 var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //接下來開始產生SVG svg.selectAll('rect').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('rect') // 增加圓到SVG內 .attr({ //加入屬性到圓 'x': function(d, i){return xScale(i)}, //利用尺度算出X的位置 'y': function(d){return h - yScale(d)}, //同理算出Y，但是要放在底部，所以要y-yScale(d) 'width': barWidth, //bar的寬度 'height':function(d){return yScale(d)}, //高度算法與Y相同 'fill': function(d){ var color = 0.2 + d * 0.002; return d3.hsl(200 ,color, color); } //顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d}) //將值寫到SVG上 .attr({ 'x': function(d, i){return xScale(i) + barWidth/2}, //和上面相同，算出X、Y的位置 'y': function(d){return h - yScale(d) + 15}, //數值放在bar 內 'fill': 'white', //文字填滿為白色 'text-anchor': 'middle', //文字置中 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js Scale 尺度","slug":"Ironman-30-days-10","date":"2014-10-08T16:00:00.000Z","updated":"2016-10-13T03:08:57.000Z","comments":true,"path":"d3js/2014/10/09/Ironman-30-days-10/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/09/Ironman-30-days-10/","excerpt":"上一篇其實就已經介紹了D3.js相當重要的data()以及enter()，今天要介紹的也是很重要，就是(Scale)尺度。","text":"上一篇其實就已經介紹了D3.js相當重要的data()以及enter()，今天要介紹的也是很重要，就是(Scale)尺度。 尺度尺度是一個D3的函式可以設定輸入以及輸出的範圍，就以下方的圖來說，如果來源的資料範圍是10~990，目標輸出的範圍必須限制在0~100，透過尺度函式後，所有的資料就會依據這尺度進行轉換，就像是輸入的資料值如果是500，那麼在目標輸出值就會是50。 所以在使用時必須定義輸入及輸出的資料範圍，就以這個範例來說，他的函式會如下，domain([10, 990])表示輸入範圍，range([0, 100])表示輸出範圍。 var d3Scale = d3.scale.linear() //產生一個線性尺度 .domain([10, 999]) //傳入的值 .range([0 , 100]) //輸出的範圍 console.log(&quot;輸出的值 = &quot; + d3Scale(500)) 在本頁可以打開瀏覽器的開發工具 &gt; console，就可以看到輸出的值是”50”。 Demo接下來我們利用這個概念來做一個範例，這個範例的值是隨機產生的，值得範圍很不一定，因此還必須取得資料的最大值及最小值，這部分d3也有提供函式可以處理，d3.max()、d3.min()這兩個函式可以取得最大值及最小值。 var w = 600,h = 250,padding = 20; //定義SVG的大小 var dataset = []; for (var i=0; i &lt; 20; i++)&#123; var Num1 = 5 + Math.floor(Math.random() * 900); var Num2 = 5 + Math.floor(Math.random() * 220); dataset.push([Num1, Num2]); &#125;; console.log(dataset); //和先前一樣，產生一組隨機的資料 var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;) //這個函示可以取得資料的最大值、最小值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([Xmin, Xmax]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([ h - padding ,padding]) //類似X軸的尺度 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#123;&#x27;width&#x27;: w,&#x27;height&#x27;: h&#125;) //接下來開始產生SVG svg.selectAll(&#x27;circle&#x27;).data(dataset).enter() //和先前一樣，選取&#x27;circle&#x27;並把資料加入 .append(&#x27;circle&#x27;) // 增加圓到SVG內 .attr(&#123; //加入屬性到圓 &#x27;cx&#x27;: function(d)&#123;return xScale(d[0])&#125;, //利用尺度算出X的位置 &#x27;cy&#x27;: function(d)&#123;return yScale(d[1])&#125;, //同理算出Y &#x27;r&#x27;: function(d)&#123;return Math.sqrt(h - d[1])&#125;, //圓的大小是高 - Y值的平方 &#x27;fill&#x27;: function(d)&#123;return d3.hsl(d[0] % 360, .6, .6 );&#125; //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) &#125;); svg.selectAll(&#x27;text&#x27;).data(dataset).enter() //補上資料數值 .append(&#x27;text&#x27;) .text(function(d)&#123; return d[0]+ &#x27;,&#x27; + d[1]&#125;) //將值寫到SVG上 .attr(&#123; &#x27;x&#x27;: function(d)&#123;return xScale(d[0])&#125;, //和上面相同，算出X、Y的位置 &#x27;y&#x27;: function(d)&#123;return yScale(d[1])&#125;, &#x27;fill&#x27;: &#x27;red&#x27;, //文字填滿為紅色 &#x27;font-size&#x27;: &#x27;10px&#x27; //Fill、font-size也可以用CSS寫喔～ &#125;); 有了這些函式，就可以讓圖形資料乖乖的在範圍內呈現了。 var d3Scale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([10, 990]) //傳入的值是原始資料的最小及最大值 .range([0 , 100]) //輸出的範圍是左邊的padd距離，到右邊的padding console.log(\"輸出的值 = \" + d3Scale(500)) var w = 600,h = 250,padding = 20; //定義SVG的大小 var dataset = []; for (var i=0; i < 20; i++){ var Num1 = 5 + Math.floor(Math.random() * 900); var Num2 = 5 + Math.floor(Math.random() * 220); dataset.push([Num1, Num2]); }; console.log(dataset); //和先前一樣，產生一組隨機的資料 var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}) //這個函示可以取得資料的最大值、最小值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([Xmin, Xmax]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([ h - padding ,padding]) //類似X軸的尺度 var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //接下來開始產生SVG svg.selectAll('circle').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('circle') // 增加圓到SVG內 .attr({ //加入屬性到圓 'cx': function(d){return xScale(d[0])}, //利用尺度算出X的位置 'cy': function(d){return yScale(d[1])}, //同理算出Y 'r': function(d){return Math.sqrt(h - d[1])}, //圓的大小是高 - Y值的平方 'fill': function(d){return d3.hsl(d[0] % 360, .6, .6 );} //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d[0]+ ',' + d[1]}) //將值寫到SVG上 .attr({ 'x': function(d){return xScale(d[0])}, //和上面相同，算出X、Y的位置 'y': function(d){return yScale(d[1])}, 'fill': 'red', //文字填滿為紅色 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3js 將資料投影到SVG上","slug":"Ironman-30-days-09","date":"2014-10-07T16:00:00.000Z","updated":"2016-10-13T03:09:18.000Z","comments":true,"path":"d3js/2014/10/08/Ironman-30-days-09/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/08/Ironman-30-days-09/","excerpt":"先前介紹SVG那麼多的篇幅，結果上一篇居然用Div了事，這樣怎麼說得過去…，所以這篇要用SVG把”資料”畫出來。","text":"先前介紹SVG那麼多的篇幅，結果上一篇居然用Div了事，這樣怎麼說得過去…，所以這篇要用SVG把”資料”畫出來。 為何又是SVG在上一篇的介紹，相信對D3js有很基本的了解，就是資料進來，然後加入html物件，接下來調整外觀…，大致上是如此。在”資料驅動物件”這基礎上，目標物件事要容易被控制且有彈性，SVG俱有這樣的特色，SVG可以在範圍內隨意定義位置、色彩甚至是外形，且屬性單純(吧…)。 Demo這篇就來份不怎麼安分的資料，他是陣列內還包陣列的資料，大概像下面這樣： var dataset = [[5, 20], [480, 90], [250, 50]] 不只是這樣，我們還要隨機的，增加的豐富性，當然這邊就直接看範例以及程式碼吧。 var w = 600; var h = 250; var dataset = []; for (var i=0; i &lt; 20; i++)&#123; var Num1 = 5 + Math.floor(Math.random() * 480); //產生第一個數值 var Num2 = 5 + Math.floor(Math.random() * 230); //產生第二個數值 dataset.push([Num1, Num2]); //兩個合併成一個陣列 &#125;; console.log(dataset); //檢查看看有沒有怪怪的 var svg = d3.select(&#x27;.demo&#x27;).append(&#x27;svg&#x27;).attr(&#123;&#x27;width&#x27;: w,&#x27;height&#x27;: h&#125;) //產生一個SVG svg.selectAll(&#x27;circle&#x27;).data(dataset).enter() //記得喔 data(dataset).enter() 把資料放入 .append(&#x27;circle&#x27;) .attr(&#123; &#x27;cx&#x27;: function(d)&#123;return d[0] + 10&#125;, //定義圓心的x，在第一個值 &#x27;cy&#x27;: function(d)&#123;return d[1] + 10&#125;, //定義圓心的y，在第二個值 &#x27;r&#x27;: function(d)&#123;return Math.sqrt(h - d[1])&#125;, //圓心的半徑，第二個值開平方 &#x27;fill&#x27;: function(d)&#123;return d3.hsl(d[0] % 360, .6, .6 );&#125; //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) &#125;); svg.selectAll(&#x27;text&#x27;).data(dataset).enter() //補上資料數值 .append(&#x27;text&#x27;) .text(function(d)&#123; return d[0]+ &#x27;,&#x27; + d[1]&#125;) //將值寫到SVG上 .attr(&#123; &#x27;x&#x27;: function(d)&#123;return d[0] + 10&#125;, //和上面相同，算出X、Y的位置 &#x27;y&#x27;: function(d)&#123;return d[1] + 10&#125;, &#x27;fill&#x27;: &#x27;red&#x27;, //文字填滿為紅色 &#x27;font-size&#x27;: &#x27;10px&#x27; //Fill、font-size也可以用CSS寫喔～ &#125;); var w = 600; var h = 250; var dataset = []; for (var i=0; i < 20; i++){ var Num1 = 5 + Math.floor(Math.random() * 480); //產生第一個數值 var Num2 = 5 + Math.floor(Math.random() * 230); //產生第二個數值 dataset.push([Num1, Num2]); //兩個合併成一個陣列 }; console.log(dataset); //檢查看看有沒有怪怪的 var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //產生一個SVG svg.selectAll('circle').data(dataset).enter() //記得喔 data(dataset).enter() 把資料放入 .append('circle') .attr({ 'cx': function(d){return d[0] + 10}, //定義圓心的x，在第一個值 'cy': function(d){return d[1] + 10}, //定義圓心的y，在第二個值 'r': function(d){return Math.sqrt(h - d[1])}, //圓心的半徑，第二個值開平方 'fill': function(d){return d3.hsl(d[0] % 360, .6, .6 );} //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d[0]+ ',' + d[1]}) //將值寫到SVG上 .attr({ 'x': function(d){return d[0] + 10}, //和上面相同，算出X、Y的位置 'y': function(d){return d[1] + 10}, 'fill': 'red', //文字填滿為紅色 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ }); 這一篇難度也沒有很高，主要只是要介紹怎麼使用D3.js畫在SVG上，但是下一篇，將會有很重要的觀念需要了解。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"初入D3.js","slug":"Ironman-30-days-08","date":"2014-10-06T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/07/Ironman-30-days-08/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/07/Ironman-30-days-08/","excerpt":"先前的練習差不多了，接下來要開始實作，不過要先聲明本文是學習過程的記錄，所以很多範例是參考網頁互動式資料視覺化: 使用D3，當然到了後面也會有很多不同的運用，並不會重頭到尾都是這本書的內容，就像上一篇一樣，還可以玩玩柯P的API。","text":"先前的練習差不多了，接下來要開始實作，不過要先聲明本文是學習過程的記錄，所以很多範例是參考網頁互動式資料視覺化: 使用D3，當然到了後面也會有很多不同的運用，並不會重頭到尾都是這本書的內容，就像上一篇一樣，還可以玩玩柯P的API。 D3 的強項就許多資料所介紹D3js是一套js library，D3是利用資料(Data)來”驅動”文件的物件(DOM)，所以就這點就和Jquery有很大的差別，Jquery容易上手，就在於它對DOM的操作相對容易；而D3js在操作DOM上有點類似Jquery，但它的重點在於使用資料來控制文件。 資料資料的格式相當多種，在學習D3js之前(到現在也是)，我對於資料的處理相當的不在行，就連基本陣列都有問題，更不用提到json，所以就…慢慢開始吧。 最基本的資料就是陣列，D3js只要有陣列就可以開始驅動文件，一般來說最基本的陣列像下面這樣： [30,26,27,31,13,10,20,20,24,25,25,21,17,21,6,7,13,23,27,31] 這個陣列是用隨機的方式去產生的，可以用以下的Js程式碼來產生： var dataset = []; //定義空的陣列 for (var i=0; i &lt; 20; i++)&#123; //如果數量少於20 var newNum = 5 + Math.floor(Math.random() * 30); //產生一個 0...30的整數，並且加上5 dataset.push(newNum); //將整數送到剛剛的空陣列 &#125; 如果對於上面這段程式碼覺得沒有問題，那麼就可以繼續的往下學習了。 使用 D3js首先，當然要先把d3.js加到HTML上。 &lt;script src=&quot;/js/d3.min.js&quot;&gt;&lt;/script&gt; 接下來要寫點Script ，範例如下： var dataset = []; //建立空的資料陣列 for (var i=0; i &lt; 20; i++)&#123; var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(newNum); &#125; //隨機產生一組長度20，值為5~35的數字。 d3.select(&#x27;.demo&#x27;).selectAll(&#x27;div&#x27;) //選取 class內的div .data(dataset) // 將資料加入至 div .enter() // return data .append(&#x27;div&#x27;) // 這邊加入的div已經有包含data .attr(&#x27;class&#x27;,&#x27;bar&#x27;) //套用class .style(&#x27;height&#x27;, function(d)&#123; //將data的值取出作為高 return (d*3) + &#x27;px&#x27; &#125;) 這一段程式碼中要特別注意的是.data(dataset).enter()這一段，這段是將剛剛所產生的陣列用迴圈的方式執行，所以在這之後的append(&#39;div&#39;)就會依據資料的量去執行，如果量有20筆，那麼就會執行append(&#39;div&#39;)20次。 DEMO 隨機的資料。 最後再補點樣式。 .bar &#123; display: inline-block; width: 20px; height: 75px; margin-right: 3px; background-color: RoyalBlue; &#125; D3js我就是這樣開始的，當然為了學這個，也是翻遍了許多資料，希望剩下文章能夠帶給大家學習上的參考。 var dataset = []; for (var i=0; i < 20; i++){ var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(newNum); } d3.select('.pre').text(dataset); d3.select('.demo').selectAll('div') .data(dataset) // D3 data computing .enter() .append('div') .attr('class','bar') .style('height', function(d){ return (d*3) + 'px' }); console.log(d3.select('.demo').selectAll('div')) .bar { display: inline-block; width: 20px; height: 75px; margin-right: 3px; background-color: RoyalBlue; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3js 前置作業，製作簡易Server","slug":"Ironman-30-days-07","date":"2014-10-05T16:00:00.000Z","updated":"2016-10-13T02:19:39.000Z","comments":true,"path":"d3js/2014/10/06/Ironman-30-days-07/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/06/Ironman-30-days-07/","excerpt":"部分情況下，直接點兩下index.html就可以打開網頁，而且js都可以正常運行，但某些瀏覽器會限制js載入本地端的檔案，主要是安全性考量，這也可能影響到d3js嘗試載入任何外部檔案(CSV、Json等等)，為了避免往後的範例有這樣的問題，所以必須要有個簡易的伺服器。","text":"部分情況下，直接點兩下index.html就可以打開網頁，而且js都可以正常運行，但某些瀏覽器會限制js載入本地端的檔案，主要是安全性考量，這也可能影響到d3js嘗試載入任何外部檔案(CSV、Json等等)，為了避免往後的範例有這樣的問題，所以必須要有個簡易的伺服器。 製作伺服器的方式相當多，像是windows也可以用IIS來建立，而我自己是直接購買Fire.app(http://fireapp.kkbox.com/)，開啟專案後直接就會產生簡易的Server，除了Fire.app外，本篇提供兩個簡單的方式來製作簡易的Webserver。 Fire.app Python Simple ServerMac 和 Linux 內建就有Python，打開Terminal(終端機)後，先輸入Python –version，如果版本是2.x，只要在對應的資料夾路徑下輸入以下指令，就可以使用簡易的webserver(我沒什麼用Python，所以我的版本是2.x)。 python -m SimpleHTTPServer 8888 &amp; 如果是更高的3.x版本，我手上的資料是輸入以下指令： python -m http.server 8888 &amp; 開啟python webserver後，在瀏覽器輸入localhost:8888就可以打開這網頁。 Node Gulp WebserverNode.js 有許多不錯的工具相當好用，而Gulp是其中一個，這是一個任務管理工具，可以編譯Sass、CoffeeScript等等(不久前我在Blog有介紹過，可以參考http://wcc723.github.io/gulp/2014/09/22/gulp-install/)。 這次不會用相當多的功能，主題是要介紹D3.js，所以我已經有準備好Gulp Webserver所需要的簡易script，大家只要安裝好Node.js後，按照以下步驟即可(比Python略微複雜，但Windows也可使用，熟練的話也可以多運用Gulp)。 Gulp 環境安裝首先，先到官網下載，並安裝Node.js。 接下來在Mac Terminal或是Windows 命令提示字元下輸入以下指令： node -v npm -v 預期會出現以下結果 接下來安裝Gulp，輸入以下指令(我Mac懶得重裝&gt; &lt;)： npm install -g gulp 到這邊環境就算安裝完成了。 執行Gulp到https://github.com/Wcc723/D3js_WebServer_Demo下載我精心準備的簡易Webserver，裡面包含一個簡單的D3 範例以及Gulp Script。 下載後解壓縮，Terminal或是命令提示字元進入該資料夾，並輸入npm install，就會把Gulp所需要的模組安裝到這個資料夾。 輸入Gulp，就會開啟Webserver同時將瀏覽器開啟，這個Demo我是抓柯P Api所提供的相簿，接下來大家也可以在自己的電腦上練習D3.js了。 小Demo JS Bin","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG Stroke , Marker 以及 CSS","slug":"Ironman-30-days-06","date":"2014-10-04T16:00:00.000Z","updated":"2016-10-13T03:09:38.000Z","comments":true,"path":"d3js/2014/10/05/Ironman-30-days-06/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/05/Ironman-30-days-06/","excerpt":"今天是假日，就來個簡單的收尾，來介紹這幾天的混合用法，當然，我不會想在假日看到&lt;Path&gt;…。 會先介紹之前Blog所提到的stroke animation，在介紹marker，marker是製作一個圖形，套用在line、path、polygon等等的線段上，可以定義在起始點、終點、以及轉折點上。","text":"今天是假日，就來個簡單的收尾，來介紹這幾天的混合用法，當然，我不會想在假日看到&lt;Path&gt;…。 會先介紹之前Blog所提到的stroke animation，在介紹marker，marker是製作一個圖形，套用在line、path、polygon等等的線段上，可以定義在起始點、終點、以及轉折點上。 Stroke Dash參考來源http://cssdeck.com/labs/ironman-svg-line-animation 作者是把這效果用在描繪鋼鐵人上，做得很酷，而本篇是介紹它的原理。 stroke-dasharray + stroke-dashoffsetstroke-dasharray是把stroke做成了是虛線的效果，線段會被拆成線段、空白、線段、空白，效果就像下面這樣。 line &#123; stroke-dasharray: 60; &#125; 如上顯示，線段被拆成60px的line在空60px的space。 stroke-dashoffset而stroke-dashoffset屬性是將上面的虛線推移，兩者會有以下幾點特性： 推移後，dasharray還是會保持循環。 dashoffset的值不會大於dasharray。 如果dashoffset 等於 dasharray，線段起始點會是空白。 所以這部分就再加上40的stroke-dashoffset來看看結果。 line.l2&#123; stroke-dashoffset: 40; &#125; 如果兩者數值相等，線段的起始點就會呈現空白，這邊先設較小的值(200)。 line.l3&#123; stroke-dasharray: 200; stroke-dashoffset: 200; &#125; 如果數值相當的大，就能夠將整個線段隱藏。 結合CSS aniamtionaniamtion 相關的瀏覽器前輟詞問題，可參考/css/2013/10/17/css-animation-keyframe/ 這邊就show重要的CSS code，利用上面的原理將線段隱藏，然後透過animation將線段拉回來，這樣就會有動態描繪的感覺。 //sass .stroke stroke-dashoffset: 2000 stroke-dasharray: 2000 //動畫效果 10秒 線性動畫 無限循環 .ani animation: circle-draw 10s linear infinite //keyframes的值 //將dashoffset拉回至0 @keyframes circle-draw 80% stroke-dashoffset: 0 &lt;svg class=&quot;stroke ani&quot; height=&quot;400&quot; width=&quot;100%&quot; &gt; &lt;g&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;10&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;20&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;30&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;40&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;50&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;60&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;70&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;80&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;90&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;100&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;110&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;120&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;130&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;140&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;150&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;160&quot;/&gt; &lt;/g&gt; &lt;/svg&gt; 以上的SVG code，當然這也可以用Illustrator來繪製，只要把svg code換掉就可以了。 注意，儘量不要在網頁上做無限循環的重復播放，很耗效能。 .stroke{ stroke-dashoffset: 2000; stroke-dasharray: 2000; } .ani { -webkit-animation: circle-draw 10s linear infinite; } @-webkit-keyframes circle-draw{ 80% { stroke-dashoffset: 0; } } 回到Marker根據上一篇的介紹，Marker做法和漸層相當的類似，除了需要定義id外，一樣需要寬與高，不過marker還多了refx 和 refy，這是用來給路徑套用時所參照的相對位置；所以下面的範例refx=&quot;5&quot; refy=&quot;5&quot;，也是要給circle使用的位置。 在定義完後，Polyline的style內加上marker-mid: url(#midCircle);就完成對marker的套用，當然這篇的另一個範例所使用的CSS(Class)也可以繼續套用在這範例上。 &lt;svg width=&quot;100%&quot; height=&quot;200&quot;&gt; &lt;defs&gt; &lt;marker id=&quot;midCircle&quot; markerWidth=&quot;8&quot; markerHeight=&quot;8&quot; refx=&quot;5&quot; refy=&quot;5&quot;&gt; &lt;circle id=&quot;dot&quot; cx=&quot;5&quot; cy=&quot;5&quot; r=&quot;3&quot; fill=&quot;red&quot; /&gt; &lt;/marker&gt; &lt;marker id=&quot;endCircle&quot; markerWidth=&quot;8&quot; markerHeight=&quot;8&quot; refx=&quot;5&quot; refy=&quot;5&quot;&gt; &lt;circle id=&quot;dot&quot; cx=&quot;5&quot; cy=&quot;5&quot; r=&quot;3&quot; fill=&quot;white&quot; stroke=&quot;red&quot; /&gt; &lt;/marker&gt; &lt;/defs&gt; &lt;polyline class=&quot;stroke ani&quot; points=&quot;20,140 60,120 80,100 100,95 120,120 140,80 160,85 180,125 200,80 220,95 240,140 260,145 280,120 300,95 320,88 340,80 360,102&quot; style=&quot;fill:none; stroke:red; stroke-width:1; marker-mid: url(#midCircle); marker-end: url(#endCircle); &quot; /&gt; &lt;/svg&gt; 這樣就做出簡易的折線圖，SVG的觀念和一般的Html有些的不同，這次的鐵人賽主要介紹的不是SVG，只是略微帶過，有興趣的可以參考 http://tutorials.jenkov.com/svg/index.html 所寫的SVG教學。 台灣也有高手是介紹SVG的也可以多向他學習http://www.oxxostudio.tw/index.html?tag-web，不止基礎的教學，還包含許多豐富的技法，令人歎為觀止(跪)。 接下來開始，就會進入D3js的世界，有許多沒辦法做很好的地方，就試試看用硬派的方式去處理吧。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG Defs 以及 CSS","slug":"Ironman-30-days-05","date":"2014-10-03T16:00:00.000Z","updated":"2016-10-13T02:18:11.000Z","comments":true,"path":"d3js/2014/10/04/Ironman-30-days-05/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/04/Ironman-30-days-05/","excerpt":"SVG內還有一個相當有趣的標簽&lt;def&gt;，用途是先定義一些圖形、漸層、形狀等等，甚至可以把它們群組起來，等待使用，如果用Illustrator 來介紹的話，就像是圖樣工具。","text":"SVG內還有一個相當有趣的標簽&lt;def&gt;，用途是先定義一些圖形、漸層、形狀等等，甚至可以把它們群組起來，等待使用，如果用Illustrator 來介紹的話，就像是圖樣工具。 教程參考：http://tutorials.jenkov.com/svg/ .rect{ fill: url(#gradient); } @-webkit-keyframes rotate { from { -webkit-transform: rotate(0deg); } to { -webkit-transform: rotate(360deg); } } .pos{ -webkit-transform: translate(82px, 82px); } .circle1{ background-position: center center; background-repeat: no-repeat; fill: none; stroke-width: 1; -webkit-transition: all .5s; stroke: url(#gradient); -webkit-animation: rotate 1s infinite linear; } svg:hover .circle1{ stroke-width: 3; } 漸層我們先用&lt;def&gt;定義一個漸層的範圍，這難度比path簡單太多了…，在經過苦痛般的path鍛鍊，下面這段範例看完相信大家已經懂一半了。 簡易步驟： 定義linearGradient，包含id、x,y位置、spreadMethod(展開的模式，這邊只會做簡單的範例)。 設定每一段的色彩位置、顏色、透明度。 套用 範例如下正方形，先定義好linearGradient標簽，並給予需要的屬性，最後在rect矩形內加入fill=&quot;url(#gradient)&quot;就可以套用了。 &lt;svg width=&quot;100%&quot; height=&quot;180&quot;&gt; &lt;defs&gt; &lt;linearGradient id=&quot;gradient&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;0%&quot; y2=&quot;100%&quot; spreadMethod=&quot;pad&quot;&gt; &lt;stop offset=&quot;0%&quot; stop-color=&quot;DodgerBlue&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;50%&quot; stop-color=&quot;DeepSkyBlue&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;100%&quot; stop-color=&quot;white&quot; stop-opacity=&quot;0&quot;/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;rect x=&quot;5&quot; y=&quot;5&quot; width=&quot;150&quot; height=&quot;150&quot; fill=&quot;url(#gradient)&quot; /&gt; &lt;/svg&gt; 結合CSS先前都沒有介紹到SVG與CSS的關係，其實大部份的SVG屬性都可以用CSS去控制，所以這部分在用CSS去強化漸層的運用。 This demo only for webkit 以下有完整的程式碼，但特別注意，CSS的transform使用在SVG上，transform-origin的位置會受x、y改變，所以在用一個&lt;g&gt;群組包起來。另外我這有寫Hover的效果，也可以試試看(只是改Stroke的寬度而已)。 &lt;svg width=&quot;100%&quot; height=&quot;180&quot;&gt; &lt;defs&gt; &lt;linearGradient id=&quot;gradient&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;0%&quot; y2=&quot;100%&quot; spreadMethod=&quot;pad&quot;&gt; &lt;stop offset=&quot;0%&quot; stop-color=&quot;DodgerBlue&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;50%&quot; stop-color=&quot;DeepSkyBlue&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;100%&quot; stop-color=&quot;white&quot; stop-opacity=&quot;0&quot;/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;g class=&quot;pos&quot;&gt; &lt;circle class=&quot;circle1&quot; cx=&quot;0&quot; cy=&quot;0&quot; r=&quot;79&quot; /&gt; &lt;/g&gt; &lt;/svg&gt; @-webkit-keyframes rotate &#123; from &#123; -webkit-transform: rotate(0deg); &#125; to &#123; -webkit-transform: rotate(360deg); &#125; &#125; .pos&#123; -webkit-transform: translate(82px, 82px); &#125; .circle1&#123; background-position: center center; background-repeat: no-repeat; fill: none; stroke-width: 3; -webkit-transition: all .5s; stroke: url(#gradient); -webkit-animation: rotate 1s infinite linear; &#125;","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG 超硬派了解 path Arcs","slug":"Ironman-30-days-04","date":"2014-10-02T16:00:00.000Z","updated":"2016-10-13T02:23:04.000Z","comments":true,"path":"d3js/2014/10/03/Ironman-30-days-04/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/03/Ironman-30-days-04/","excerpt":"這次來到Path的最後一個屬性A，A是所謂的弧形，和先前不同的是，弧形一個屬性可以比上一章全部的難度…。這次看看能不能用硬派的方式來學習Arcs弧形…。 本篇建議使用超過720px裝置觀看","text":"這次來到Path的最後一個屬性A，A是所謂的弧形，和先前不同的是，弧形一個屬性可以比上一章全部的難度…。這次看看能不能用硬派的方式來學習Arcs弧形…。 本篇建議使用超過720px裝置觀看 教程參考：http://tutorials.jenkov.com/svg/ Arcs svg text{ font-size: 10px; } 弧形就本質上來說，是屬於圓形或是橢圓的一部份，因此Mozilla MDN也介紹他擁有以下的屬性，我認為直接觀看這些屬性還是很難理解，所以決定都用硬派的方式標上坐標！。 a使用方法： A rx ry x-axis-rotation large-arc-flag sweep-flag x y Example 1參考http://www.oxxostudio.tw/articles/201406/svg-05-path-2.html。 110, 315 起點 162, 225 終點 w 200(rx) h 200(ry) A rx ry x-axis-rotation large-arc-flag sweep-flag x y //剛剛的值 A 1 2 0 0 1 310 215 rx、ry如果小於起點到終點的長度，那麼會是依比率的，所以是1:2的橢圓形；sweep-flag為1，是順時鐘方向(逆時鐘會往下跑)；310 215是終點的位置。 &lt;svg width=&quot;100%&quot; height=&quot;250&quot;&gt; &lt;path d=&quot;M10 215 L 110 215 A 1 2 0 0 1 310 215 L 540 215&quot; stroke=&quot;#333&quot; fill=&quot;Crimson&quot; stroke-width=&quot;3&quot; fill-opacity=&quot;0.5&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;110&quot; cy=&quot;215&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;110&quot; y=&quot;225&quot; fill=&quot;red&quot;&gt;110, 315 起點&lt;/text&gt; &lt;circle cx=&quot;310&quot; cy=&quot;215&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;310&quot; y=&quot;225&quot; fill=&quot;red&quot;&gt;162, 225 終點&lt;/text&gt; &lt;line x1=&quot;110&quot; y1=&quot;215&quot; x2=&quot;310&quot; y2=&quot;215&quot; style=&quot;stroke: green;&quot;/&gt; &lt;text x=&quot;150&quot; y=&quot;210&quot; fill=&quot;green&quot;&gt;w 200(rx)&lt;/text&gt; &lt;line x1=&quot;210&quot; y1=&quot;215&quot; x2=&quot;210&quot; y2=&quot;15&quot; style=&quot;stroke: green;&quot;/&gt; &lt;text x=&quot;210&quot; y=&quot;110&quot; fill=&quot;green&quot;&gt;h 200(ry)&lt;/text&gt; &lt;/svg&gt; Example 2接下來我們在旋轉的角度上補了30，弧形的角度就會旋轉(綠色的線，僅有旋轉，並沒有修正成圓心的位置)。 110, 315 起點 162, 225 終點 &lt;svg width=&quot;100%&quot; height=&quot;250&quot;&gt; &lt;path d=&quot;M10 215 L 110 215 A 1 2 30 0 1 310 215 L 540 215&quot; stroke=&quot;#333&quot; fill=&quot;Crimson&quot; stroke-width=&quot;3&quot; fill-opacity=&quot;0.5&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;110&quot; cy=&quot;215&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;110&quot; y=&quot;225&quot; fill=&quot;red&quot;&gt;110, 315 起點&lt;/text&gt; &lt;circle cx=&quot;310&quot; cy=&quot;215&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;310&quot; y=&quot;225&quot; fill=&quot;red&quot;&gt;162, 225 終點&lt;/text&gt; &lt;line x1=&quot;110&quot; y1=&quot;215&quot; x2=&quot;310&quot; y2=&quot;215&quot; style=&quot;stroke: green;&quot; transform=&quot;rotate(30, 210, 215)&quot;/&gt; &lt;line x1=&quot;210&quot; y1=&quot;215&quot; x2=&quot;210&quot; y2=&quot;15&quot; style=&quot;stroke: green;&quot; transform=&quot;rotate(30, 210, 215)&quot;/&gt; &lt;/svg&gt; Example sweep-flag &amp; large-arc-flag範例取自於https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths。 M 80 80 125 125 終點 http://www.oxxostudio.tw/articles/201406/svg-05-path-2.html 有很棒的解釋，這部分我要用個人的方式解釋囉～ 這張圖，據說可以解釋 “sweep-flag &amp; large-arc-flag”，那麼就來試著說說看吧。 //這個範例僅有改變 large-arc-flag sweep-flag 兩個值，其餘皆相同 A rx ry x-axis-rotation large-arc-flag sweep-flag x y 思考一下這以下可能代表什麼 sweep-flag:1 = 順時鐘 sweep-flag:0 = 逆時鐘 large-arc-flag:1 = 取較長的弧線 large-arc-flag:0 = 取較短的弧線 rx ry必須大於半徑才能產生長弧線及短弧線 左上：逆時鐘，取較短的弧線 右上：逆時鐘，取較長弧線 左下：順時鐘，取較短的弧線 右下：順時鐘，取較長弧線 試試看所以在稍早的範例，只要增加A的rx、ry也可以這樣做喔～。將rx、ry調整後，large-arc-flag也可以使用，值為1就會採用較長的弧線(實線的部分)，值為0就會採用短的弧線(虛線的部分)。 110, 315 起點 162, 225 終點 A 120 120 &lt;svg width=&quot;100%&quot; height=&quot;250&quot;&gt; &lt;path d=&quot;M10 215 L 110 215 A 120 120 0 1 1 310 215 L 540 215&quot; stroke=&quot;#333&quot; fill=&quot;none&quot; stroke-width=&quot;3&quot; fill-opacity=&quot;0.5&quot;/&gt; &lt;path d=&quot;M10 215 L 110 215 A 120 120 0 0 1 310 215 L 540 215&quot; stroke=&quot;#333&quot; stroke-dasharray=&quot;5, 5&quot; fill=&quot;none&quot; stroke-width=&quot;3&quot; fill-opacity=&quot;0.5&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;110&quot; cy=&quot;215&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;110&quot; y=&quot;225&quot; fill=&quot;red&quot;&gt;110, 315 起點&lt;/text&gt; &lt;circle cx=&quot;310&quot; cy=&quot;215&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;310&quot; y=&quot;225&quot; fill=&quot;red&quot;&gt;162, 225 終點&lt;/text&gt; &lt;line x1=&quot;210&quot; y1=&quot;215&quot; x2=&quot;210&quot; y2=&quot;95&quot; style=&quot;stroke: green;&quot; transform=&quot;translate(0 -67)&quot;/&gt; &lt;line x1=&quot;210&quot; y1=&quot;215&quot; x2=&quot;330&quot; y2=&quot;215&quot; style=&quot;stroke: green;&quot; transform=&quot;translate(0 -67)&quot;/&gt; &lt;text x=&quot;214&quot; y=&quot;144&quot; fill=&quot;green&quot;&gt;A 120 120&lt;/text&gt; &lt;/svg&gt; 真的超級難懂，不過自己試著做一次，就會好懂很多。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG 超硬派了解 line, polygon, polyline, path (手工繪製)","slug":"Ironman-30-days-03","date":"2014-10-01T16:00:00.000Z","updated":"2016-10-13T02:20:18.000Z","comments":true,"path":"d3js/2014/10/02/Ironman-30-days-03/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/02/Ironman-30-days-03/","excerpt":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 今天要介紹的是線段系列，可以想像成Illustrator的鋼筆工具(也不知道為什麼要翻譯鋼筆工具，據說是設計師不會懂貝茲曲線…)，分為line、polygon、polyline、path，而其中我認為最難的是path…，希望今天能夠突破他。我將用非天才型的硬派學習法！ 本篇建議使用超過720px裝置觀看","text":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 今天要介紹的是線段系列，可以想像成Illustrator的鋼筆工具(也不知道為什麼要翻譯鋼筆工具，據說是設計師不會懂貝茲曲線…)，分為line、polygon、polyline、path，而其中我認為最難的是path…，希望今天能夠突破他。我將用非天才型的硬派學習法！ 本篇建議使用超過720px裝置觀看 教程參考：http://tutorials.jenkov.com/svg/ Line這是最簡單的，只要標注上起點以及終點就完成了，起點是x1、y1，終點則是x2、y2。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;300&quot; y2=&quot;0&quot; style=&quot;stroke: Tomato;stroke-width: 3px&quot;/&gt; &lt;line x1=&quot;0&quot; y1=&quot;10&quot; x2=&quot;300&quot; y2=&quot;60&quot; x3=&quot;0&quot; y3=&quot;80&quot; style=&quot;stroke: Tomato; stroke-width: 3px&quot;/&gt; &lt;/svg&gt; 我也試試看能不能三點，寫了x3、y3都是沒用的(白目)。 PolylinePolyline我查到的中文翻譯是折線，它主要是繪製多點線段。來源… 點的位置’40,0’，40代表x，0代表y，兩個點中間會接一個空格。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;polyline points=&quot;40,0 60,60 0,60&quot; style=&quot; stroke:red; stroke-width:2&quot;/&gt; &lt;polyline points=&quot;140,0 160,60 100,60&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;polyline points=&quot;240,0 260,60 200,60 240,0&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;/svg&gt; Polyline開始類似Illustrator的鋼筆工具(但還不能繪製弧線)，在線段之間還能填入色彩，但特別要注意的是他並不是自動封閉線段。 PolygonPolygon中文翻譯為多邊形，用來繪製不少於3個邊的圖形，使用方式和Polyline完全相同。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;polygon points=&quot;40,0 60,60 0,60&quot; style=&quot; stroke:red; stroke-width:2&quot;/&gt; &lt;polygon points=&quot;140,0 160,60 100,60&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;polygon points=&quot;240,0 260,60 200,60 240,0&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;/svg&gt; 刻意使用和polyline相同的程式碼，兩者只有標簽不同，從這樣比較能夠比對出兩個不同的地方，重點就是Polygon會自動連接最後點到第一個點。 地獄般的PathSVG &lt;path&gt;是相當有難度的一個章節，每次打開到這個章節，都會想要關掉網頁。它的難度就我目前看來，就是用鍵盤畫貝茲曲線吧…。 參考資料這一張有一定的難度，所以在範例上我參考以下網站。 http://tutorials.jenkov.com/svg/path-element.html http://www.w3schools.com/svg/svg_path.asp https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths 在w3c school的教程裡有提到path常用的屬性，這在path是相當重要的所以先列出來。 其實我一直在逃避學習Path，因為他真的很複雜，所以我採用最熱血的學習方式！要用手工的方式把坐標，標在SVG上！ M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Bézier curve T = smooth quadratic Bézier curveto A = elliptical Arc Z = closepath 接下來就用以上的資料，嘗試畫一個圖形。 svg text{ fill: red; font-size: 10px; } Example M、LM、L使用方法： M x y L x y 150, 3 300, 150 3, 150 &lt;svg width=&quot;100%&quot; height=&quot;200&quot;&gt; &lt;path d=&quot;M150 3 L300 150 L3 150 Z&quot; style=&quot; stroke: #333; stroke-width:3; fill: MediumOrchid&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;150&quot; cy=&quot;3&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;150&quot; y=&quot;20&quot; fill=&quot;red&quot;&gt;150, 3&lt;/text&gt; &lt;circle cx=&quot;300&quot; cy=&quot;150&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;300&quot; y=&quot;140&quot; fill=&quot;red&quot;&gt;300, 150&lt;/text&gt; &lt;circle cx=&quot;3&quot; cy=&quot;150&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;3&quot; y=&quot;140&quot; fill=&quot;red&quot;&gt;3, 150&lt;/text&gt; &lt;/svg&gt; 這個三角形的範例，M150 3 這樣是一個群組，所以第一個點是移動到M150 3開始，接下來劃線到L300 150這個點，再來是劃線到L3 150，最後直接用Z來封閉曲線。 因此，path的第一點通常是M: move to Example H、VH、V使用方法： M x V y 10, 10 10, 90 90, 90 90, 10 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;path d=&quot;M10 10 H 90 V 90 H 10 L 10 10&quot; fill=&quot;black&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;10&quot; y=&quot;20&quot; fill=&quot;red&quot;&gt;10, 10&lt;/text&gt; &lt;circle cx=&quot;10&quot; cy=&quot;90&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;10&quot; y=&quot;80&quot; fill=&quot;red&quot;&gt;10, 90&lt;/text&gt; &lt;circle cx=&quot;90&quot; cy=&quot;90&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;90&quot; y=&quot;80&quot; fill=&quot;red&quot;&gt;90, 90&lt;/text&gt; &lt;circle cx=&quot;90&quot; cy=&quot;10&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;90&quot; y=&quot;20&quot; fill=&quot;red&quot;&gt;90, 10&lt;/text&gt; &lt;/svg&gt; 這一個範例，是利用H、V來取代垂直以及水平移動。這一段的內容是移動到10 10，再來垂直到x90的位置，再來是水平到y90，然後再到垂直向上到x10，最後用L拉線回到10 10的位置。 最後的L也可以直接用Z來close path Example C 貝茲曲線C使用方法： C x1 y1, x2 y2, x y 這是Mozilla所提供的示意圖，看了這個圖，認為還是自己畫一個可能比較了解，所以動手來試試看吧～。 圖片來源：https://developer.mozilla.org/@api/deki/files/159/=Cubic_Bezier_Curves.png M10 10 C140 140 160 140 300 20 用這樣的圖是不是更了解呢，首先定義第一個起始點位置M10 10，接下來加入C貝茲曲線，這邊開始就幻想著自己正在畫Illustrator，首先加入C140 140，這是第一根手把的位置，之後補一個,，在依序把後面的點完成。這之間可以對照上面的範例。 &lt;svg width=&quot;100%&quot; height=&quot;200px&quot;&gt; &lt;path d=&quot;M10 10 C140 140,160 140,300 10&quot; stroke=&quot;black&quot; fill=&quot;none&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;10&quot; cy=&quot;10&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;10&quot; y=&quot;20&quot; fill=&quot;red&quot;&gt;M10 10&lt;/text&gt; &lt;circle cx=&quot;140&quot; cy=&quot;140&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;120&quot; y=&quot;150&quot; fill=&quot;red&quot;&gt;C140 140&lt;/text&gt; &lt;circle cx=&quot;160&quot; cy=&quot;140&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;160&quot; y=&quot;130&quot; fill=&quot;red&quot;&gt;160 140&lt;/text&gt; &lt;circle cx=&quot;300&quot; cy=&quot;10&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;300&quot; y=&quot;20&quot; fill=&quot;red&quot;&gt;300 20&lt;/text&gt; &lt;line x1=&quot;10&quot; y1=&quot;10&quot; x2=&quot;140&quot; y2=&quot;140&quot; style=&quot;stroke: Tomato;&quot;/&gt; &lt;line x1=&quot;160&quot; y1=&quot;140&quot; x2=&quot;300&quot; y2=&quot;10&quot; style=&quot;stroke: Tomato;&quot;/&gt; &lt;/svg&gt; Example Ss使用方法： S x2 y2, x y 我用超硬派學習法，徹底了解了它的特徵…。 M10 80 C140 160 160 120 300 80 S520 40 600 100 透過超硬派學習法，一個一個刻出每個點的位置，感受到腦細胞的大量死亡，上圖的紅點是C所在的位置，C總共會有三個坐標，包含兩個手把以及最後一個點，而S是緊接在最後一個點的後方，延伸出一個綠色的手把(這一個不需要給坐標)，再補上一個藍色手把以及做後一個藍色點。 &lt;svg width=&quot;100%&quot; height=&quot;200px&quot;&gt; &lt;path d=&quot;M10 80 C140 140,160 140 , 300 80 S 520 20,600 80&quot; stroke=&quot;black&quot; fill=&quot;none&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;10&quot; cy=&quot;80&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;10&quot; y=&quot;90&quot; fill=&quot;red&quot;&gt;M10 80&lt;/text&gt; &lt;circle cx=&quot;140&quot; cy=&quot;140&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;140&quot; y=&quot;160&quot; fill=&quot;red&quot;&gt;C140 160&lt;/text&gt; &lt;circle cx=&quot;160&quot; cy=&quot;140&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;140&quot; y=&quot;120&quot; fill=&quot;red&quot;&gt;160 120&lt;/text&gt; &lt;circle cx=&quot;300&quot; cy=&quot;80&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;300&quot; y=&quot;100&quot; fill=&quot;red&quot;&gt;300 80&lt;/text&gt; &lt;circle cx=&quot;520&quot; cy=&quot;20&quot; r=&quot;3&quot; fill=&quot;blue&quot;/&gt; &lt;text x=&quot;520&quot; y=&quot;40&quot; fill=&quot;blue&quot;&gt;S520 40&lt;/text&gt; &lt;circle cx=&quot;600&quot; cy=&quot;80&quot; r=&quot;3&quot; fill=&quot;blue&quot;/&gt; &lt;text x=&quot;600&quot; y=&quot;100&quot; fill=&quot;blue&quot;&gt;600 100&lt;/text&gt; &lt;line x1=&quot;10&quot; y1=&quot;80&quot; x2=&quot;140&quot; y2=&quot;140&quot; style=&quot;stroke: Tomato;&quot;/&gt; &lt;line x1=&quot;160&quot; y1=&quot;140&quot; x2=&quot;300&quot; y2=&quot;80&quot; style=&quot;stroke: Tomato;&quot;/&gt; &lt;line x1=&quot;520&quot; y1=&quot;20&quot; x2=&quot;600&quot; y2=&quot;80&quot; style=&quot;stroke: blue;&quot;/&gt; &lt;circle cx=&quot;440&quot; cy=&quot;20&quot; r=&quot;3&quot; fill=&quot;green&quot;/&gt; &lt;line x1=&quot;300&quot; y1=&quot;80&quot; x2=&quot;440&quot; y2=&quot;20&quot; style=&quot;stroke: green;&quot;/&gt; &lt;/svg&gt; Example Q TQ、T使用方法： Q x1 y1, x y T x y 剛剛提到，C有三個點，兩個是手把，一個是終點，Q則是兩個點，一個共用手把，加上終點。T則是在Q後方，在複製一個相同的點，有點類似S的翻版。 M10 80 Q150 150 300 80 T590 80 &lt;svg width=&quot;100%&quot; height=&quot;200px&quot;&gt; &lt;path d=&quot;M10 80 Q150 150, 300 80 T590 80&quot; stroke=&quot;black&quot; fill=&quot;none&quot;/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=&quot;10&quot; cy=&quot;80&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;10&quot; y=&quot;90&quot; fill=&quot;red&quot;&gt;M10 80&lt;/text&gt; &lt;circle cx=&quot;150&quot; cy=&quot;150&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;150&quot; y=&quot;170&quot; fill=&quot;red&quot;&gt;Q150 150&lt;/text&gt; &lt;circle cx=&quot;300&quot; cy=&quot;80&quot; r=&quot;3&quot; fill=&quot;red&quot;/&gt; &lt;text x=&quot;300&quot; y=&quot;100&quot; fill=&quot;red&quot;&gt;300 80&lt;/text&gt; &lt;line x1=&quot;10&quot; y1=&quot;80&quot; x2=&quot;150&quot; y2=&quot;150&quot; style=&quot;stroke: Tomato;&quot;/&gt; &lt;line x1=&quot;300&quot; y1=&quot;80&quot; x2=&quot;150&quot; y2=&quot;150&quot; style=&quot;stroke: Tomato;&quot;/&gt; &lt;circle cx=&quot;590&quot; cy=&quot;80&quot; r=&quot;3&quot; fill=&quot;blue&quot;/&gt; &lt;text x=&quot;590&quot; y=&quot;100&quot; fill=&quot;red&quot;&gt;T590 80&lt;/text&gt; &lt;polyline points=&quot;300,80 445,10 590,80&quot; style=&quot;fill:none; stroke:green; fill: none&quot;/&gt; &lt;/svg&gt; 小結透過本篇的超硬派教學，對於幾種線段應該會更了解吧，至少我很了解了(泣…)。SVG的文章不會太多，D3js至少會有20篇以上，大家可以放心～。 另外在D3.js的教學裡面，超複雜的Path有很簡單的處理方式…，所以只要先大致了解就可以了。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG 簡介","slug":"Ironman-30-days-02","date":"2014-09-30T16:00:00.000Z","updated":"2016-10-13T02:15:17.000Z","comments":true,"path":"d3js/2014/10/01/Ironman-30-days-02/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/01/Ironman-30-days-02/","excerpt":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 SVG(Scalable Vector Graphics)，中文直譯就是”可縮放向量圖形 “，它是以XML格式儲存，而在瀏覽器上是從IE9後才開始支援SVG。也因為是XML格式，所以D3對它特別容易進行操作。","text":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 SVG(Scalable Vector Graphics)，中文直譯就是”可縮放向量圖形 “，它是以XML格式儲存，而在瀏覽器上是從IE9後才開始支援SVG。也因為是XML格式，所以D3對它特別容易進行操作。 教程參考：http://tutorials.jenkov.com/svg/ SVG 範例(直接繪製)在svg標簽內就可以直接開始繪製向量圖型，而其中xmlns=&quot;http://www.w3.org/2000/svg”在微軟MSDN的解釋為定義SVG區段的命名空間，移除也沒什麼差別。 在定義SVG時，也建議同時給予寬與高，如果沒有，預設是100%。 &lt;!-- SVG tag --&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;100%&quot; height=&quot;120&quot;&gt; &lt;!-- 矩行 tag --&gt; &lt;rect x=&quot;2&quot; y=&quot;2&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #333; stroke-width: 3; fill: MediumTurquoise;&quot;/&gt; &lt;/svg&gt; SVG 基本型SVG是屬於向量的圖形，所以他有許多的繪圖概念與Illustrator相似，如矩行、圓形、多邊形等等…。 矩形在定義一個形狀時，通常會定義以下屬性，形狀、位置、尺寸以及樣式。矩行是相當基本的圖形，所以就依序定義以下屬性。 &quot;shapes tag&quot; &quot;x&quot; &quot;y&quot; &quot;width&quot; &quot;height&quot; &quot;style&quot; &lt;svg width=&quot;100%&quot; height=&quot;105&quot;&gt; &lt;rect x=&quot;2&quot; y=&quot;2&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #333; stroke-width: 3; fill: FireBrick;&quot;/&gt; &lt;rect x=&quot;120&quot; y=&quot;2&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;stroke: #333; stroke-width: 3; fill: LightSkyBlue;&quot;/&gt; &lt;/svg&gt; 而矩形除了一般的方形、長方形以外，也可以增加圓角的屬性rx、ry，但這就沒有像css的border-radius那麼的自由了，只能四個角設定相同的值；rx、ry也僅僅是設定其圓角垂直以及水平的半徑而已。 &lt;svg width=&quot;100%&quot; height=&quot;105&quot;&gt; &lt;rect x=&quot;2&quot; y=&quot;2&quot; width=&quot;100&quot; height=&quot;100&quot; rx=&quot;10&quot; style=&quot;stroke: #333; stroke-width: 3; fill: FireBrick;&quot;&gt;&lt;/rect&gt; &lt;rect x=&quot;120&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; rx=&quot;40&quot; ry=&quot;10&quot; style=&quot;stroke: #333; stroke-width: 3; fill: LightSkyBlue;&quot;&gt;&lt;/rect&gt; &lt;/svg&gt; 圓形圓形中有一點要特別注意，圓形的cx,cy所代表的是圓心(r)的位置，所以在定義圓形的位置，如果不想跑到圖框外，務必cx、cy要大於r的值。 &lt;svg width=&quot;100%&quot; height=&quot;105&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;51&quot; r=&quot;50&quot; style=&quot;stroke: #333; stroke-width: 3; fill: SeaShell;&quot;/&gt; &lt;/svg&gt; 橢圓形橢圓形概念和圓形也相當類似，只是將半徑r的值改成垂直及水平半徑rx、ry。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;51&quot; rx=&quot;80&quot; ry=&quot;30&quot; style=&quot;stroke: #333; stroke-width: 3; fill: MediumVioletRed;&quot;/&gt; &lt;/svg&gt; CSS樣式控制SVG就像HTML的物件一樣很好控制，但不同的是他有屬於它自己的屬性，就好比我們要將顏色填滿在一般html物件會使用background-color，而在SVG內會使用fill，這部分也會運用到D3。 &lt;style&gt; .rect&#123; fill: HotPink; stroke: LightSlateGray; stroke-width: 3px; transition: fill .3s; &#125; .rect:hover&#123; fill: SlateGray; &#125; &lt;/style&gt; 先產生一個SVG物件，但不要設定Style，只增加class。 &lt;svg width=&quot;100%&quot; height=&quot;105&quot;&gt; &lt;rect x=&quot;2&quot; y=&quot;2&quot; width=&quot;100&quot; height=&quot;100&quot;/&gt; &lt;rect class=&quot;rect&quot; x=&quot;120&quot; y=&quot;2&quot; width=&quot;200&quot; height=&quot;100&quot;/&gt; &lt;/svg&gt; 接下來寫一段CSS，針對剛剛增加的class，控制它的填滿以及筆畫寬度(跟Illustrator很像吧)，還可以補上:hover。 .rect&#123; fill: HotPink; stroke: LightSlateGray; stroke-width: 3px; transition: fill .3s; &#125; .rect:hover&#123; fill: SlateGray; &#125; 結果我們會看到以下這樣的結果，左邊沒有設定會是黑色(沒設定是黑色、不會是透明！)，右邊就是剛剛所設定的樣式。 小結如果對於SVG有興趣的設計師，也可以試試看把Illustrator的檔案轉出成SVG，在一個個拆解，就會發現SVG跟Illustrator根本就是太像了。用canvas的概念來思考，當然也可以將Photoshop轉成png，只是最終發現他還是一張圖…(認真)。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"2014 鐵人賽慢慢開始跑","slug":"Ironman-30-days-01","date":"2014-09-29T16:00:00.000Z","updated":"2016-10-13T00:42:07.000Z","comments":true,"path":"d3js/2014/09/30/Ironman-30-days-01/","link":"","permalink":"https://wcc723.github.io/d3js/2014/09/30/Ironman-30-days-01/","excerpt":"去年參加了鐵人賽，主題是CSS，這過程中讓我獲得很多，重點並不是在於得獎，而是在每天追求的過程中，必須在有限的時間內不斷地追求知識，也不斷的挖掘有什麼是可以分享的。","text":"去年參加了鐵人賽，主題是CSS，這過程中讓我獲得很多，重點並不是在於得獎，而是在每天追求的過程中，必須在有限的時間內不斷地追求知識，也不斷的挖掘有什麼是可以分享的。 先簡單自我介紹一下背景 我是一位設計師，目前是專職前端的工程師 去年鐵人賽摸到了優選 技術的Blog : http://wcc723.github.io 在今年的工作中，我感受到SVG (Scalable Vector Graphics)的未來性原因如下： XML標準 (相對於Canvas更容易使用CSS、JS控制) 向量圖形 (目前的裝置解析度不一，而向量圖沒有解析度問題) 格式靈活，可以用繪圖軟體或是純文字繪製 SVG library剛剛有提到，SVG有許多執行的方式，我是視覺設計出身，就會想直接用繪圖軟體畫，然後再轉存成svg格式檔案，但是這樣並沒有辦法動，所以就需要透過CSS 或是 JS。 相關的JS lib 以及 plugin 相當的多，下面介紹兩款主流的lib。 Snap.js http://snapsvg.io 透過Snap，可以更容易繪製動態的SVG圖形，假設設計師已經提供了向量原始檔，在結合Snap，就能夠像以前的Flash做出豐富的HTML5互動網站(它說像用jQuery控制DOM一樣容易…)。 對Snap繪製互動圖形有興趣，也可以參考它的基本教學 http://snapsvg.io/start/ D3.js http://d3js.org 當然，這次我報名的是D3.js，所以當然這就是這次的主角。D3在中文上的翻譯是”資料驅動文件”，圖形化的過程中，資料是非常重要的，選擇D3一部份原因也是工作需求。 參考資料D3的學習資料相當多，在這三十天中，我會先簡單介紹SVG，接下來再透過Oreilly所出版的網頁互動式資料視覺化的教學來習作，另外還會搜尋許多的範例及資料來學習。 主要參考書籍 網頁互動式資料視覺化：使用D3http://www.books.com.tw/products/0010621239 參考範例 https://github.com/mbostock/d3/wiki/Gallery 所以這三十篇不會是教學，而是個人學習記錄分享，而到了最後會有其他延伸運用。當然有遇到任何問題，也是會跟大家討論。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"Gulp Task and Gulp Pipe","slug":"gulp-task","date":"2014-09-23T16:00:00.000Z","updated":"2016-10-13T00:43:57.000Z","comments":true,"path":"gulp/2014/09/24/gulp-task/","link":"","permalink":"https://wcc723.github.io/gulp/2014/09/24/gulp-task/","excerpt":"Gulp主要有四個指令，用這些指令就可以完成大部份工作。 gulp.task(name, fn) 定義一個任務名稱，接下來指定任務的工作內容 gulp.run(task) 運行指定的任務 gulp.src(glob) 檔案來源 gulp.dest(folder) 檔案的存檔路徑 而在上回的範例裡，已經呈現了主要的三個。 //gulpfile.js var gulp = require(&#x27;gulp&#x27;), coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;coffee&#x27;, function() &#123; //&#x27;coffee&#x27;是排程名稱，可自定 gulp.src(&#x27;./app/coffeescripts/*.coffee&#x27;) //來源檔案 .pipe(coffee()) //編譯 .pipe(gulp.dest(&#x27;./app/assets/js&#x27;)) //輸出位置 &#125;); 而這篇會介紹如何用gulp將一個任務串接，並且監視它。","text":"Gulp主要有四個指令，用這些指令就可以完成大部份工作。 gulp.task(name, fn) 定義一個任務名稱，接下來指定任務的工作內容 gulp.run(task) 運行指定的任務 gulp.src(glob) 檔案來源 gulp.dest(folder) 檔案的存檔路徑 而在上回的範例裡，已經呈現了主要的三個。 //gulpfile.js var gulp = require(&#x27;gulp&#x27;), coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;coffee&#x27;, function() &#123; //&#x27;coffee&#x27;是排程名稱，可自定 gulp.src(&#x27;./app/coffeescripts/*.coffee&#x27;) //來源檔案 .pipe(coffee()) //編譯 .pipe(gulp.dest(&#x27;./app/assets/js&#x27;)) //輸出位置 &#125;); 而這篇會介紹如何用gulp將一個任務串接，並且監視它。 以下是今年coscup Appleboy所分享的簡報(他的投影片真得很精彩)，先前就有聽過Gulp、Grunt等等技術，但是實際要運用也是需要參考許多文章，而其中許多都是 Appleboy的資料。 另外這邊有介紹Gulp與Grunt兩者在任務流程上的不同，Gulp在處理上，是不斷的編譯、編譯、編譯，最後直接寫入檔案，這篇就來介紹，Gulp是如何串接這些任務。 來源：http://www.slideshare.net/appleboy/automating-your-workflow-with-gulp Js ugly在上次的範例中，我們有準備兩個coffee原始檔，這次就要將這兩個原始檔合併壓縮。 回到terminal中輸入以下指令。 npm install gulp-uglify gulp-concat --save-dev gulp-uglify是用來壓縮js以及去除變數，gulp-concat則是用來合併多隻檔案。所有的流程都會用’.pipe’來進行串接，結果就會像下面的程式碼，編譯coffee、合併成一隻js、壓縮、輸出。 //gulp var gulp = require(&#x27;gulp&#x27;), concat = require(&#x27;gulp-concat&#x27;), uglify = require(&#x27;gulp-uglify&#x27;), coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;coffee&#x27;, function() &#123; //‘coffee&#x27;是排程名稱，可自定 gulp.src(&#x27;./app/coffeescripts/*.coffee&#x27;) //來源檔案 .pipe(coffee()) //編譯 .pipe(concat(&#x27;main.js&#x27;)) //合併成一隻 .pipe(uglify()) //壓縮、醜化 .pipe(gulp.dest(&#x27;./app/assets/js&#x27;)) //輸出位置 &#125;); gulp.task(&#x27;default&#x27;, [&#x27;coffee&#x27;]);//預設動作 執行gulp 接下來回到terminal執行gulp，應該會發現/app/assets/js內的js被合併成一隻main.js，到這邊也算達到預期的效果，但是每次不斷執行相同動作也是挺麻煩der~。所以我們要另外寫個任務，不斷地監測檔案是否修改，只要有修改檔案，就自動編譯。 Gulp watch透過gulp.watch，可以監聽指定的資料夾，而被監聽的資料夾只要有檔案變更，就會直行指定的任務。 //gulp gulp.task(&#x27;watch&#x27;, function () &#123; //自定一個watch的排程名稱 gulp.watch(&#x27;./app/coffeescripts/*.coffee&#x27;, [&#x27;coffee&#x27;]); //監聽路徑，以及檔案變更後所執行的任務 &#125;); gulp.task(&#x27;default&#x27;, [&#x27;coffee&#x27;,&#x27;watch&#x27;]); 參考以上的原始碼，只要在terminal輸入gulp，就會自動監聽。 只要每次修改，就會如上一樣，不斷地執行coffee這個任務，如果要中斷目前的監聽，就在Terminal內按下Ctrl + C。 到目前為止的gulpfile.js var gulp = require(&#x27;gulp&#x27;), concat = require(&#x27;gulp-concat&#x27;), uglify = require(&#x27;gulp-uglify&#x27;), coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;coffee&#x27;, function() &#123; //‘coffee&#x27;是排程名稱，可自定 gulp.src(&#x27;./app/coffeescripts/*.coffee&#x27;) //來源檔案 .pipe(coffee()) //編譯 .pipe(concat(&#x27;main.js&#x27;)) //合併成一隻 .pipe(uglify()) //壓縮、醜化 .pipe(gulp.dest(&#x27;./app/assets/js&#x27;)) //輸出位置 &#125;); gulp.task(&#x27;watch&#x27;, function () &#123; //自定一個watch的排程名稱 gulp.watch(&#x27;./app/coffeescripts/*.coffee&#x27;, [&#x27;coffee&#x27;]); //監聽路徑，以及檔案變更後所執行的任務 &#125;); gulp.task(&#x27;default&#x27;, [&#x27;coffee&#x27;,&#x27;watch&#x27;]); 以目前的範例結果大概會像這樣。 | app / | - coffeescripts / | - a.coffee | - b.coffee | - js/ | - jquery-1.11.0.min.js | - sass/ | - all.sass | - assets/ | js / | - main.js | - index.html | node_modules / | - 各式node module…. | - gulpfile.js | - package.json","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"Gulp 環境安裝","slug":"gulp-install","date":"2014-09-21T16:00:00.000Z","updated":"2016-10-13T00:45:44.000Z","comments":true,"path":"gulp/2014/09/22/gulp-install/","link":"","permalink":"https://wcc723.github.io/gulp/2014/09/22/gulp-install/","excerpt":"鐵人賽我有準備一些文章，如網頁視覺設計(技巧、grid system)、前端設計工具的文章，比較偏向視覺設計以及前端工程的混和，但是鐵人賽我決定要換主題，所以文章就直接放出來(都寫了別浪費…)。 這一篇是Gulp的安裝，後來還有一系列的Gulp文章。 Gulp 可以做什麼Gulp 是一個前端任務管理工具，它可以做到如Fire.app、Prepros、Grunt等等所能做的事情，如果這樣還不是很了解，那就列表給大家看看。 編譯 SASS、Coffeescript 壓縮 .CSS, .JS, 甚至圖檔 web server with Livereload 享受自己動手做Task工具的快感 others.. 雖然很多工具，都能做到類似的功能，但是如果需求不足的時候，就要開另一個工具來幫忙，如另外許多專案已經在執行中，或者是老專案，有些工具過於強大，就會顯得沒那麼合適，那麼就可以用gulp客製化屬於該專案使用的工具。","text":"鐵人賽我有準備一些文章，如網頁視覺設計(技巧、grid system)、前端設計工具的文章，比較偏向視覺設計以及前端工程的混和，但是鐵人賽我決定要換主題，所以文章就直接放出來(都寫了別浪費…)。 這一篇是Gulp的安裝，後來還有一系列的Gulp文章。 Gulp 可以做什麼Gulp 是一個前端任務管理工具，它可以做到如Fire.app、Prepros、Grunt等等所能做的事情，如果這樣還不是很了解，那就列表給大家看看。 編譯 SASS、Coffeescript 壓縮 .CSS, .JS, 甚至圖檔 web server with Livereload 享受自己動手做Task工具的快感 others.. 雖然很多工具，都能做到類似的功能，但是如果需求不足的時候，就要開另一個工具來幫忙，如另外許多專案已經在執行中，或者是老專案，有些工具過於強大，就會顯得沒那麼合適，那麼就可以用gulp客製化屬於該專案使用的工具。 Gulp 需求在開始使用Gulp前，需要先安裝Node.js，Node.js 是一個讓 Javascript 運行在服務端的開發平台。它使用了 Google 的 V8 虛擬機(Google Chrome 瀏覽器使用的 Javascript 執行環境)。 另外還有npm，是由Node.js 官方提供的第三方管理工具，並且是一種在 Node.js 應用程式中建立、分享、重複使用模組，而npm在目前的版本，都會隨著Node.js的安裝同時安裝好npm。 簡而言之，我們使用Node.js的服務，透過npm管理工具。 安裝node js(這部分與先前安裝gitbook雷同) Node.js在這一個部分windows與mac其實只是安裝檔不同， 這邊就只Show出windows版本的安裝(Mac版大致相同，而後面的介紹會兩者混用) 下載安裝後如果是windows，請打開”命令提示字元”，輸入： node -v npm -v 預期會出現以下的版本(或者更高) 如果是Mac，請打開終端機，和windows相同，輸入以下指令： node -v npm -v 預期會出現以下的版本(或者更高) 接下來，大部份的操作，也都是兩者相同，就不再一一贅述。 首先，安裝全域的Gulp。 npm install -g gulp 到目前為止，整體的環境就算完成了，接下來就是建立專案，而這部分我會先開啟一個簡單的範例，有興趣的使用者也可以下載範例來直接使用。 範例檔案這邊我們先假設專案需要編譯coffeescript、compass with susy，最後還需要webserver 並且具有livereload的功能，所以專案的架構大概如下： | app / | - coffeescripts / | - a.coffee | - b.coffee | - js/ | - jquery-1.11.0.min.js | - sass/ | - all.sass | - index.html 這個專案內容都在app/的資料夾內，coffeescripts 有兩個coffee檔，sass檔內只有一個all.sass，另外還有個jquery，也會隨後一起壓縮。 如何開始使用Gulp接下來的範例，會先在mac上執行，最後再放回windows，兩者大致相同。而一開始的範例，會先編譯coffeescript。 npm是nodejs的模組管理工具，這邊會建立一個package.json。 npm init 接下來我們就來安裝gulp以及coffeescript。 npm install --save-dev gulp gulp-coffee —save-dev的用途是將套件安裝，並且把安裝的資訊也一起寫入剛剛產生的package.json，如果打開package.json，會看到剛剛所安裝的套件名稱及版本。 &quot;devDependencies&quot;: &#123; &quot;gulp-coffee&quot;: &quot;^2.1.1&quot;, &quot;gulp&quot;: &quot;^3.8.7&quot; &#125; 這時候看資料夾內，也會看到node的套件安裝到資料夾內了。 這邊開始是重點https://www.npmjs.org/package/gulp-coffee 官方網站有寫出gulp-coffee怎麼使用，我們可以將它修改成適合這個專案的，首先建立gulpfile.js，檔案內容如下。 //gulpfile.js var gulp = require(&#x27;gulp&#x27;), coffee = require(&#x27;gulp-coffee&#x27;); gulp.task(&#x27;coffee&#x27;, function() &#123; //&#x27;coffee&#x27;是排程名稱，可自定 gulp.src(&#x27;./app/coffeescripts/*.coffee&#x27;) //來源檔案 .pipe(coffee()) //編譯 .pipe(gulp.dest(&#x27;./app/assets/js&#x27;)) //輸出位置 &#125;); 接下來在terminal輸入gulp coffee，就可以編譯coffee了。 接下來就會在assets/js看到編譯好的兩個檔案。 以目前的範例結果大概會像這樣。 | app / | - coffeescripts / | - a.coffee | - b.coffee | - js/ | - jquery-1.11.0.min.js | - sass/ | - all.sass | - assets/ | js / | - a.js | - b.js | - index.html | node_modules / | - 各式node module…. | - gulpfile.js | - package.json 目前就可以做的簡易的coffee編譯，接下來會使用更多的工具。 工商服務 MOPCON傳說中「真．濁水溪以南最強大科技研討會」Mobile Open Platform Conference 聽說 9/22 準時開始報名, 這次單是議程講師的公司堆起來就金光閃閃啊~~~ http://mopcon.kktix.cc/events/2014-registration 官方網站 http://mopcon.org/2014/","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"Gem Github pages","slug":"github-page","date":"2014-09-04T16:00:00.000Z","updated":"2016-10-13T00:45:48.000Z","comments":true,"path":"jekyll/2014/09/05/github-page/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/09/05/github-page/","excerpt":"最近聽說github pages有更新，那我也稍微看一下(真的只是稍微)，之前都是用純Jekyll寫Blog，現在發現有github pages的gem(其實已經存在很久了)，似乎可以方便很多。 這篇主要就是記錄安裝過程以及簡易使用。 https://github.com/github/pages-gem","text":"最近聽說github pages有更新，那我也稍微看一下(真的只是稍微)，之前都是用純Jekyll寫Blog，現在發現有github pages的gem(其實已經存在很久了)，似乎可以方便很多。 這篇主要就是記錄安裝過程以及簡易使用。 https://github.com/github/pages-gem 安裝github-pages裝之前請先確認有ruby環境，先前的Jekyll教學有完整的Ruby環境安裝，所以這邊就不再提了。 打開Terminal輸入以下指令(Windows沒有測試過)。 gem install github-pages 安裝完後輸入github-pages versions，可以看到目前所有相關gem的版本。 Bundle接下來要把gem寫到專案裡，打開專案後新增一個檔案Gemfile，裡面輸入以下： gem &apos;github-pages&apos; 接下來在Terminal輸入bundle install，這樣專案與Github pages的gem就會綁在一起`。 執行jekyll恩…，這真的不是很困難，所以已經到結尾了…，打開Terminal輸入以下指令就完成了。 bundle exec jekyll serve --watch 至於這樣有什麼功能呢？我也還正在閱讀中…。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"安裝Gitbook","slug":"gitbook-install","date":"2014-09-03T16:00:00.000Z","updated":"2016-10-13T00:45:52.000Z","comments":true,"path":"design/2014/09/04/gitbook-install/","link":"","permalink":"https://wcc723.github.io/design/2014/09/04/gitbook-install/","excerpt":"利用Gitbook製作電子書是相當容易的，作者只要熟悉markdown語法以及簡易的安裝，就可以快速編寫屬於自己的書籍，它有著以下幾點特色。 利用git 版本控制 用git就可以發佈新版本 利用markdown語法編寫 包含手機版 這邊就簡單介紹如何安裝gitbook server在自己本機上，以利於快速與他人合作。 注意：本文不會提到git操作，在使用gitbook前，請先熟悉git。","text":"利用Gitbook製作電子書是相當容易的，作者只要熟悉markdown語法以及簡易的安裝，就可以快速編寫屬於自己的書籍，它有著以下幾點特色。 利用git 版本控制 用git就可以發佈新版本 利用markdown語法編寫 包含手機版 這邊就簡單介紹如何安裝gitbook server在自己本機上，以利於快速與他人合作。 注意：本文不會提到git操作，在使用gitbook前，請先熟悉git。 https://www.gitbook.io/book/wcc723/google_design_translate 安裝在安裝Gitbook必須先裝Node.js，Node.js 是一個讓 Javascript 運行在服務端的開發平台。它使用了 Google 的 V8 虛擬機(Google Chrome 瀏覽器使用的 Javascript 執行環境)。 另外還有npm，是由Node.js 官方提供的第三方管理工具，並且是一種在 Node.js 應用程式中建立、分享、重複使用模組，而npm在目前的版本，都會隨著Node.js的安裝同時安裝好npm。 簡而言之，我們使用Node.js的服務，透過npm管理工具，如果還是不知道，就是照著操作就是了。 安裝node.jsNode.js在這一個部分windows與mac其實只是安裝檔不同，只要按照官方程序裝完就可以了。 這邊就只Show出windows版本的安裝(Mac版大致相同，而後面的介紹會兩者混用) 如果是windows，請打開”命令提示字元”，輸入： node -v npm -v 預期會出現以下的版本(或者更高) 如果是Mac，請打開終端機，和windows相同，輸入以下指令： node -v npm -v 預期會出現以下的版本(或者更高) 安裝gitbook由於我這邊mac已經裝完，我用windows做範例，當然結果是一樣的。 打開command輸入以下指令。 npm install -g gitbook 安裝完後輸入 gitbook version，預期會出現以下畫面。 gitbook serve範例專案：https://github.com/Wcc723/google_design_translate 接下來到一個專案的資料夾，輸入gitbook serve，它就會打開一個port，並且運行gitbook server。 網址輸入localhost:4000就可以看到這一個網站。 可能會遇到的問題我也不知道為什麼…，Mac版會出現這個錯誤，反正有解決方式。 回到Terminal，輸入ulimit -n 4096，在執行一次gitbook serve。 ulimit -n 4096 安捏，就可以正常執行了。 剩下的部分，可以參考目前範例的架構。而最近發這篇文，是因為聽說9月9日快到了。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"翻譯Material Design心得","slug":"google-material-design","date":"2014-07-22T16:00:00.000Z","updated":"2016-10-13T00:42:07.000Z","comments":true,"path":"design/2014/07/23/google-material-design/","link":"","permalink":"https://wcc723.github.io/design/2014/07/23/google-material-design/","excerpt":"距離上次的文章也將近一個月…，這段時間主要是在翻譯Google Design，所以有一段時間沒有發新的文章。然而翻譯Google Material Design的原因，也是想要讓中文化後的更多人閱讀，進而引起大家的討論。 整體翻譯的時間從6月27日到7月23日將近一個月的時間，特別感謝從一開始就協助翻譯的Tillonter Hsu、Helen兩位，到最後都還在翻譯；也很感謝Peter、Frances的加入，讓整體進度突飛猛進，還有社群其他的好友Charlene、Mkdodos、陳聖博、Xuan沒有大家的幫忙，這是沒有辦法再這麼快的速度完成的，當然研究所的朋友Xunyi，感謝一起入坑幫忙。 https://www.gitbook.io/book/wcc723/google_design_translate","text":"距離上次的文章也將近一個月…，這段時間主要是在翻譯Google Design，所以有一段時間沒有發新的文章。然而翻譯Google Material Design的原因，也是想要讓中文化後的更多人閱讀，進而引起大家的討論。 整體翻譯的時間從6月27日到7月23日將近一個月的時間，特別感謝從一開始就協助翻譯的Tillonter Hsu、Helen兩位，到最後都還在翻譯；也很感謝Peter、Frances的加入，讓整體進度突飛猛進，還有社群其他的好友Charlene、Mkdodos、陳聖博、Xuan沒有大家的幫忙，這是沒有辦法再這麼快的速度完成的，當然研究所的朋友Xunyi，感謝一起入坑幫忙。 https://www.gitbook.io/book/wcc723/google_design_translate 進度第一次Commit的時間是6月27日，當時我同事和一位前端的好友一同翻譯(3人)，原本打算在一周後，翻譯篇數約達到10篇後再開始公開找人，但發現進度有點趕不上，且大陸那邊也發佈了(簡體中文版)[http://www.ui.cn/Material/]，所以在避免拖延太久的情況下，就在Facebook 高雄前端社群上公開找人一起翻譯。 翻譯人員如下： Charlene Frances Helen Mkdodos Tillonter Hsu Peter Xuan Xunyi 陳聖博 雖然用的技術有git、gitbook、markdown等等，但翻譯者只要有熱情，技術的問題就應當撇除，所以大家的進度都是記錄在Hackpad(簡單易用)，其餘部分會依據參與者可以配合的方式進行。 在大家一起協助翻譯後，我翻譯的篇數就變少很多，主要就是協助整理、統一格式、聯絡各個翻譯者。在進度上，是儘量不催促翻譯者的進度(畢竟每個人都有自己的生活)，而是透過Hackpad去不斷更新內容，讓參與翻譯的人都了解這計劃是不斷的在進行，這樣翻譯者自然會有更深的認同感，一直保持進度翻譯下去。 總共篇數約4X篇，在翻譯30篇左右時，我上傳至Gitbook準備公開。在7/16時，我在幾個社群網站先公開，因為怕等到整個完成後，這篇翻譯文章的價值會降低(大陸的翻譯數量變多、討論Material Design的人變少等等)，讓大家的辛苦，沒有感受到應有的掌聲…。 而在這7月23日，最後一篇超長文章也傳來了(恰巧我的生日耶)，Material Design的翻譯也算到達一個進度，接下來就是校稿，校稿則會開放更多人一起協作，當然…，校稿前也就必須要先準備一些規範orz…。 公開的第一天，以及隔天的指標。 遭遇的問題這些問題不記錄起來，下次還是會遇到…。 格式在一開始雖然有先做一份格式，也有寫一些基礎的格式規範，但參與者不一定會了解我們的明白，畢竟買電器都不會先看說明書了…，所以許多格式都要在後續做整理，這個部分花相當多的時間。 認為比較好的模式，是找擅長markdown以及gitbook規範的人員，一同協助將原文版本的格式轉換成markdown，接下來參與者，只要下載已經做好的markdown檔案，在翻譯成中文，就完成了。 缺點是在開始時，必須花較多的時間討論格式，會讓開始的時間延後，且就算討論過，每個參與者所定義的還是會有所誤差，必須重新檢視到可接受範圍內。 特殊名詞許多名詞，是否要翻譯也是問題像是Material Design，這個詞到最後都沒有被翻譯，都是用原文呈現，而其他部分都是尊重翻譯者所翻譯的內容；且有許多詞是要用類似大陸的直譯式，還是像中文會轉換成較為口語的方式，在翻譯時都有許多的疑問。 這部分有位朋友建議我，在最主要的名詞(標題)，旁邊加上括號標上原文，如：質感設計(Material Design)；但是後來想到如果這名詞在不同的頁面章節也有重複出現呢…？ 目前是規劃透過校稿來處理這個問題，但如果有下次，會考慮專有名詞先加上原文吧。 Git Branch這次在Github都是在master上執行，一方面也是我沒有特別去規定要如何上git，目前會思考branch是依據翻譯人員還是章節來做規劃(如果有人有相關意見，也歡迎來討論)。 在翻譯這計劃告一段落後，就會回到原本的計劃，學習D3.js、Susy 2；至於會不會有其它翻譯或開放專案，我也不確定，說不定iOS 8也會在借助大家的幫忙？","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"D3 Js 介紹","slug":"d3-js-intro","date":"2014-06-23T16:00:00.000Z","updated":"2016-10-12T06:47:42.000Z","comments":true,"path":"d3/2014/06/24/d3-js-intro/","link":"","permalink":"https://wcc723.github.io/d3/2014/06/24/d3-js-intro/","excerpt":"之前有提到最近要學的技能是Rails以及D3.js，這也是我今年的計劃，剛好也趁最近Diablo III手氣不好，一直打不到華戒，就抽空來都學學吧。 最近的文章，都不算是什麼教學文，算是學習記錄。","text":"之前有提到最近要學的技能是Rails以及D3.js，這也是我今年的計劃，剛好也趁最近Diablo III手氣不好，一直打不到華戒，就抽空來都學學吧。 最近的文章，都不算是什麼教學文，算是學習記錄。 參考書籍不久前歐萊禮的書在博客來有特價，我就買了這本D3，雖然前面廢話有點多，但在難度設定上是屬於較為簡單的，如果說會寫jquery以及js基礎概念，相信很容易上手。 參考書籍：網頁互動式資料視覺化：使用D3 D3 簡介D3 是全名是 Data-Driven Documents，是利用資料驅動文件的js lib。它可以將資料載入後，利用資料的內容驅動HTMl上的物件，甚至是針對使用者的操作將物件轉換成其它狀態。 簡單來說，就是將資料圖表化，甚至是透過使用者的操作，呈現出不同的樣式。 為什麼選擇D3之前的文章有提到，我有在學習SVG，SVG是屬於向量的技術，而D3適合操作SVG來做圖形呈現，正好符合無限期支持向量技術的理念!?另外就是在工作上，資料驅動圖形是一個趨勢，和文字表格比起來，大家更愛看的是圖形呈現，且最好是能夠互動，基於這樣的理由…，D3是我所了解到最適合的工具。 範例我一直以為他只能操控SVG物件，但事實上第一個Demo就導正我的觀念了…，SVG儘是適合表現視覺化，但是D3是可以控制Html大多數的DOM。 簡單介紹一下本篇所使用的D3 Api。 d3.select // DOM 選取器，類似jquery的$(&apos;&apos;) d3.selectAll // 選取複數元素 selection.data // 將資料與被選擇的元素串接 selection.enter // 將資料傳送至未被串街的元素 本篇的Html(我習慣用日期分…有時候是前幾天寫的)。 本篇的CSS .bar &#123; display: inline-block; width: 20px; height: 75px; margin-right: 3px; background-color: teal; &#125; 以下是本篇的Js var dataset = []; //建立空的資料陣列 for (var i=0; i &lt; 20; i++)&#123; var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(newNum); &#125; //隨機產生一組長度20，值為5~35的數字。 d3.select(&#x27;.d0622&#x27;).selectAll(&#x27;div&#x27;) //選取 class內的div .data(dataset) // 將資料加入至 div .enter() // return data .append(&#x27;div&#x27;) // 這邊加入的div已經有包含data .attr(&#x27;class&#x27;,&#x27;bar&#x27;) //套用class .style(&#x27;height&#x27;, function(d)&#123; //將data的值取出作為高 return (d*3) + &#x27;px&#x27; &#125;) Demo 本篇雖然沒有介紹到SVG，但如果對D3有興趣，建議先對SVG有初步的了解，在學習上會更有幫助。 小感把Js寫成文字好難…。 12/3 更新由於有很多人是透過Google搜尋到本頁面，但本篇也沒有介紹非常詳細。而後來有參加鐵人賽，有製作相當多的Demo，如果對於D3.js有興趣，不妨參考看看我在鐵人賽的一些文章吧。 鐵人賽文章列表 高雄前端社群D3.js 如果有任何問題，可以直接下方留言，或者不夠好的地方，也請多多賜教，感謝。","categories":[{"name":"d3","slug":"d3","permalink":"https://wcc723.github.io/categories/d3/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"d3","slug":"d3","permalink":"https://wcc723.github.io/tags/d3/"}]},{"title":"Rails 環境建設","slug":"rails-101-install","date":"2014-06-21T16:00:00.000Z","updated":"2016-10-12T06:07:29.000Z","comments":true,"path":"rails/2014/06/22/rails-101-install/","link":"","permalink":"https://wcc723.github.io/rails/2014/06/22/rails-101-install/","excerpt":"最近要學的技術有兩個，一個是D3.js，另一個是Rails，目前是參考Xdite所提供的Rails 101，安裝過程中有發生些小問題，所以特別記錄起來，以免之後要在裝的時候忘記…。 Rails不是要打算精通後端，而是希望了解，以便往後再配合後端時能更有效率的處理問題。","text":"最近要學的技術有兩個，一個是D3.js，另一個是Rails，目前是參考Xdite所提供的Rails 101，安裝過程中有發生些小問題，所以特別記錄起來，以免之後要在裝的時候忘記…。 Rails不是要打算精通後端，而是希望了解，以便往後再配合後端時能更有效率的處理問題。 安裝環境 參考的書籍：Rails 101 https://leanpub.com/rails-101 硬體：Macbook pro retina 2013 系統版本：OSX 10.9.3 安裝Homebrew在PDF書上第一個要安裝的，會想要記錄也是以下這原因…。 以上的圖是書上的範例，直接複製會得到以下的結果…，沒有空白鍵啊!!!重點是我找不到原因還卡很久… ruby-e&quot;$(curl-fsSLhttps://raw.github.com/Homebrew/homebrew/go/install)&quot; 所以沒意外的話應該是以下指令 ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 想說我有裝git了，跳過brew install git，直接升級。 brew update brew tap homebrew/dupes brew install apple-gcc42怎好像沒截到圖…。 安裝 XQuartz安裝XQuartz。 安裝完後登出在登入。 安裝 ImageMagick / MySQL別懷疑，這邊我完全不懂，只知道MySQL是資料庫。 brew install imagemagick 透過brew安裝時，圖示都變成啤酒了… Installing mysql unset TMDIR 這個用了沒感覺(跳過…) mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew--prefixmysql)&quot; -\\ sudo mysqladmin -u root password &apos;123456&apos; mkdir -p ~/Library/LaunchAgents 這個用了沒感覺(跳過…) find /usr/local/Cellar/mysql/ -name &quot;homebrew.mxcl.mysql.plist&quot; -exec cp &#123;&#125; ~/Library/LaunchAgents/ \\; launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 安裝 RVM透過rvm就可以執行特定版本的ruby及gems，rails的版本演進相當快，所以必須透過RVM來切換不同的rails版本。 bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer) . ~/.profile $source ~/.profile 安裝 Ruby 2.0brew install libyaml rvm pkg install openssl rvm install 2.0.0 --with-openssl-dir=$HOME/.rvm/usr --verify-downloads 1 很順利，忘記截圖… rvm use 2.0.0，這段我出了點問題，於是上網找了其他解法，依序輸入以下幾行。 source ~/.rvm/scripts/rvm type rvm | head -n 1 rvm use 2.0.0 安裝必要 Ruby gemsgem install rails --version 4.0.0 gem install mysql2 gem install capistrano gem install capistrano-ext 設定 HTTP Server (使用 Pow)簡單來說，就是看localhost:3000不爽，要換掉的意思!? curl get.pow.cx | sh gem install powder Pow用法，方法一 cd ~/.pow/ ln -s ~/projects/wiki 方法二 powder link Rails安裝環境相當複雜，如果沒有記錄，到時候也是會卡在相同的地方…。 安裝環境 全劇終…","categories":[{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/categories/rails/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"https://wcc723.github.io/tags/ruby/"},{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/tags/rails/"}]},{"title":"CSS + SVG stroke 動態描繪","slug":"svg-css-stroke-animation","date":"2014-06-14T16:00:00.000Z","updated":"2016-10-12T06:42:59.000Z","comments":true,"path":"svg/2014/06/15/svg-css-stroke-animation/","link":"","permalink":"https://wcc723.github.io/svg/2014/06/15/svg-css-stroke-animation/","excerpt":"SVG有很多有趣的效果，尤其是stroke，它有許多不同的屬性參數，套用上css animation就有意想不到的效果，雖然不能達到豐富的互動，但至少可以在視覺上令人為之一亮。 這篇要利用stroke的dash特性，做出圖形描繪的動態效果。","text":"SVG有很多有趣的效果，尤其是stroke，它有許多不同的屬性參數，套用上css animation就有意想不到的效果，雖然不能達到豐富的互動，但至少可以在視覺上令人為之一亮。 這篇要利用stroke的dash特性，做出圖形描繪的動態效果。 參考來源http://cssdeck.com/labs/ironman-svg-line-animation 作者是把這效果用在描繪鋼鐵人上，做得很酷，而本篇是介紹它的原理。 stroke-dasharray + stroke-dashoffsetstroke-dasharray是把stroke做成了是虛線的效果，線段會被拆成線段、空白、線段、空白，效果就像下面這樣。 /*這邊是CSS*/ line &#123; stroke-dasharray: 60; &#125; 如上顯示，線段被拆成60px的line在空60px的space。 stroke-dashoffset而stroke-dashoffset屬性是將上面的虛線推移，兩者會有以下幾點特性： 推移後，dasharray還是會保持循環。 dashoffset的值不會大於dasharray。 如果dashoffset 等於 dasharray，線段起始點會是空白。 所以這部分就再加上40的stroke-dashoffset來看看結果。 /*這邊是CSS*/ line.l2&#123; stroke-dashoffset: 40; &#125; 如果兩者數值相等，線段的起始點就會呈現空白，這邊先設較小的值(200)。 line.l3&#123; stroke-dasharray: 200; stroke-dashoffset: 200; &#125; 如果數值相當的大，就能夠將整個線段隱藏。 結合CSS aniamtionaniamtion 相關的瀏覽器前輟詞問題，可參考/css/2013/10/17/css-animation-keyframe/ 這邊就show重要的CSS code，利用上面的原理將線段隱藏，然後透過animation將線段拉回來，這樣就會有動態描繪的感覺。 //先將stroke隱藏 .stroke&#123; stroke-dashoffset: 2000 stroke-dasharray: 2000 &#125; //動畫效果 10秒 線性動畫 無限循環 .ani &#123; animation: circle-draw 10s linear infinite &#125; //keyframes的值 //將dashoffset拉回至0 @keyframes circle-draw&#123; 80% &#123; stroke-dashoffset: 0; &#125; &#125; &lt;svg class=&quot;stroke ani&quot; height=&quot;400&quot; width=&quot;100%&quot; &gt; &lt;g&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;10&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;20&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;30&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;40&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;50&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;60&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;70&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;80&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;90&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;100&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;110&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;120&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;130&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;140&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;150&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;160&quot;/&gt; &lt;/g&gt; &lt;/svg&gt; 以上的SVG code，當然這也可以用Illustrator來繪製，只要把svg code換掉就可以了。 注意，儘量不要在網頁上做無限循環的重復播放，很耗效能。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"SVG 漸層沒想到是這樣的做法","slug":"svg-linear-gradient","date":"2014-06-04T16:00:00.000Z","updated":"2016-10-12T06:42:23.000Z","comments":true,"path":"svg/2014/06/05/svg-linear-gradient/","link":"","permalink":"https://wcc723.github.io/svg/2014/06/05/svg-linear-gradient/","excerpt":"最近在研究SVG，在做專案的時候就會想用一些相關的技術，當時想在stroke上使用漸層色，所以就研究了SVG的漸層做法。 SVG的漸層做法，和我想像有些落差，原本以為會是類似CSS的寫法，但結果卻…。","text":"最近在研究SVG，在做專案的時候就會想用一些相關的技術，當時想在stroke上使用漸層色，所以就研究了SVG的漸層做法。 SVG的漸層做法，和我想像有些落差，原本以為會是類似CSS的寫法，但結果卻…。 SVG 漸層SVG漸層，找到的做法是在HTML先定義漸層；而CSS的漸層是直接寫在樣式表內，這樣的做法對於主要使用CSS有很大的不便(哭)。或許有用CSS的做法，但我不是很清楚。 定義漸層在任何一&lt;svg&gt;標簽內，新增一個&lt;defs&gt;，&lt;defs&gt;標簽內在新增一個&lt;linearGradient&gt;標簽，這樣就可以開始定義漸層，而結構如下： &lt;defs&gt; &lt;linearGradient id=&quot;myGradient&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;0%&quot; y2=&quot;100%&quot; spreadMethod=&quot;pad&quot;&gt; &lt;stop offset=&quot;0%&quot; stop-color=&quot;#E80C7A&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;50%&quot; stop-color=&quot;#E83D9D&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;100%&quot; stop-color=&quot;#fff&quot; stop-opacity=&quot;1&quot;/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; 另外重要的是linearGradient需要一個id，因為他是id，所以一個page內一個linearGradient只能定義一次(不同的SVG可以共用相同的linearGradient)。 使用接下來隨意繪製一個圖形，圖形的許多屬性都能套用剛剛定義的漸層，如在以下圓型的fill屬性值為url(#myGradient)，就可以將剛剛的漸層帶入。 &lt;svg width=&quot;164&quot; height=&quot;164&quot;&gt; &lt;circle cx=&quot;82&quot; cy=&quot;82&quot; r=&quot;79&quot; style=&quot;fill: url(#myGradient)&quot;/&gt; &lt;/svg&gt; CSS只要定義好後，CSS也能夠使用漸層色，一樣用url(id)，像是以下範例就用stroke: url(#myGradient)(再次提醒，漸層定義一次就能重複使用)。 // sass code // 這範例還偷插了stroke-width以及animation。 svg stroke-width: 1px stroke: url(#myGradient) fill: none +transition(stroke-width .5s) &amp;:hover stroke-width: 4px +animation(infinite-rotate 1s infinite linear) html的部份就不需要寫什麼了，就由CSS去定義。 //html &lt;svg width=&quot;164&quot; height=&quot;164&quot;&gt; &lt;circle cx=&quot;82&quot; cy=&quot;82&quot; r=&quot;79&quot; /&gt; &lt;/svg&gt; 最後這也是我在實驗的效果，結合SVGstroke的粗細變化，以及stroke的漸層。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"Sass 3.3 Source Maps","slug":"sass-source-maps","date":"2014-06-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/06/02/sass-source-maps/","link":"","permalink":"https://wcc723.github.io/sass/2014/06/02/sass-source-maps/","excerpt":"Sass 3.3 除了上次提到的$Map外，還有另一個很有特色的功能就是Source Maps，這功能主要是配合開發者工具，直接就可以看Sass原始碼在哪一個檔甚至是哪一段，而這篇會配合Chrome 開發者工具來介紹Source Maps。","text":"Sass 3.3 除了上次提到的$Map外，還有另一個很有特色的功能就是Source Maps，這功能主要是配合開發者工具，直接就可以看Sass原始碼在哪一個檔甚至是哪一段，而這篇會配合Chrome 開發者工具來介紹Source Maps。 注意請確認使用的Sass 版本為3.3以及Compass 1.0以上，如果不是，請參考上次這篇文章。 Chrome 設定有點忘了Chrome版本要多少才能使用sass maps，而我目前的版本是35.0.1916.114是可以直接執行的，如果發現沒有以下設定，就煩請升級到我這版本以上。 首先，打開開發者工具，右方有一個設定按鈕，按下它。 在General 內可以找到Source &gt; Enable CSS source maps，把它選起來後關掉開發者工具。 Compass 設定這邊的範例是直接用上次那篇的(上次文章)。 基本上我用Sass都會引用Compass，所以這邊直接介紹Compass的做法。打開專案資料夾，找到config.rb(沒有就自己加吧)，加入sourcemap = true。 接下來在terminal輸入compass watch，會出現兩個檔，一個是之前的screen.css，另一個是screen.css.map，.map就是等等要給Chrome看的，所以別太在意他的內容。 接下來回到Chrome使用開發者工具，隨意檢視一個物件，會發現screen.css改成用screen.sass了！ **screen.sass:14**也直接寫出在screen.sass這個檔案的第14行可以找到這段code，對於css開發者來說，就可以省去很多時間找css code了。 如果使用的是其他工具再過不知道多久的時間，Fire.app應該會更新到sass 3.3，這些工具在使用時，都可以當做一個簡易的server，適合配合livereload等工具。但是這對於source map來說會有些問題，因為Chrome source map 會對應不到最原始的檔案位置，所以必須加入原始的sass檔位置。 打開開發者工具，一樣到設定的位置，從workspace內找到Folders這選項，把原始的Sass檔案夾加入。 在開發者工具內的Sources內可以找到已經加入的資料夾。 對他點擊右鍵，選擇Map to Network Resource。 選擇對應的檔案。 接下來，按照原本的Chrome開發者工具使用方法，就可直接修改screen.sass這個檔案，配合著compass、livereload等等，畫面就會自動重整。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"}]},{"title":"CSS + html 冷知識","slug":"css-cold-knows","date":"2014-05-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/05/23/css-cold-knows/","link":"","permalink":"https://wcc723.github.io/css/2014/05/23/css-cold-knows/","excerpt":"CSS及HTML已經學了有段時間，但還有許多不清楚的點都會在(偶然)的情況下發現，而有些只是有趣，但有些發現，或許是以前忽略的，但在卻是那麼的實用…。","text":"CSS及HTML已經學了有段時間，但還有許多不清楚的點都會在(偶然)的情況下發現，而有些只是有趣，但有些發現，或許是以前忽略的，但在卻是那麼的實用…。 label 不一定要配for再用sublime text 時，如果輸入label + tab，就會出現&lt;label for=&quot;&quot;&gt;&lt;/label&gt;，我也一直認為&lt;label&gt;裡面就是要有for，但label沒有for也可以call到指定的input。 This is a check box &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; This is a check box&lt;/label&gt; 上方的checkbox，只要點擊文字，就可以讓checkbox轉換為checked。 如上面的範例，label如果裡面有input，那麼點擊到input範圍，都可以focus到內部的input。 This is a check box 注意，兩個input就只會一個有效…。 UTF-8 字符 也能作為class name簡單來說，uff-8的小圖形也能作為class name。 核能 ☢ !? ☯ 神秘力量 HTML code &lt;div class=&quot;demo d0524&quot;&gt; &lt;div class=&quot;anti-☢&quot;&gt;核能 ☢ !?&lt;/div&gt; &lt;div class=&quot;☯-power&quot;&gt; ☯ 神秘力量&lt;/div&gt; &lt;/div&gt; Sass code //sass .anti-☢ color: orange .☯-power color: white text-shadow: 0 0 3px black 利用:before 來做垂直置中利用inline-block的特性來做到垂直置中，優點是支援before就可以，缺點是要置中的元素，也必須設定為inline-block。 這段字想要垂直至中 Sass code .vertical height: 200px border: orange 1px solid &amp;:before content: &quot;&quot; display: inline-block vertical-align: middle width: 1px height: 100% div display: inline-block","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"純CSS Drop Menu","slug":"pure-css-drop-menu","date":"2014-05-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/05/20/pure-css-drop-menu/","link":"","permalink":"https://wcc723.github.io/css/2014/05/20/pure-css-drop-menu/","excerpt":"CSS 有很多技巧，都很值得去開發，最近發現了一個很簡單的技術，就是純CSS下拉式選單，這讓我避免使用Jquery去做slider的效果，重點是…超簡單！","text":"CSS 有很多技巧，都很值得去開發，最近發現了一個很簡單的技術，就是純CSS下拉式選單，這讓我避免使用Jquery去做slider的效果，重點是…超簡單！ 重點提示這是利用max-hegiht + transition所達到的效果，好處是不用配合jquery的slider function，壞處就是…，drop-menu一定會包含overflow的屬性，如果設計不能有這屬性的話，就會被限制住。 HtmlHTML架構如下，而這篇是真的純CSS，所以會插入一個input去做切換的效果，實際製作的時候，可以直接用js來切換class，也能達到相同的效果。 &lt;div class=&quot;drop-menu&quot;&gt; &lt;label for=&quot;drop-menu&quot;&gt; 下拉式選單 &lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;drop-menu&quot;&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; sass除了排版的樣式外，其餘的重點我都直接標示在sass code裡，而最重要的是用max-height來達到這樣的效果(height不可以喲)。 .drop-menu max-width: 300px label display: block border: 1px solid #ccc padding: 6px cursor: pointer input display: none .menu-list background-color: #FFF +box-shadow(0 0 8px rgba(black, .6)) overflow: hidden //重點 max-height: 0 //重點 +transition(max-height .3s) //重點 a display: block padding: 4px border-bottom: 1px dashed #ccc input:checked + .menu-list max-height: 300px //重點 Demo 下拉式選單 list-1 list-2 list-3 list-4 很容易吧～","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"玩玩看Rails","slug":"rails-go","date":"2014-05-08T16:00:00.000Z","updated":"2016-10-12T06:07:29.000Z","comments":true,"path":"rails/2014/05/09/rails-go/","link":"","permalink":"https://wcc723.github.io/rails/2014/05/09/rails-go/","excerpt":"對Rails有些興趣，而線上剛好有Step by step教學，不如就試試看(本篇只是個操作記錄，並不是教學)。","text":"對Rails有些興趣，而線上剛好有Step by step教學，不如就試試看(本篇只是個操作記錄，並不是教學)。 資料來源http://railsbridge-docs-zh-tw.herokuapp.com/docs/ Rails 安裝由於這台Mac已經有裝ruby、Git所以有些步驟就跳過，直接輸入sudo gem install rails就會開始安裝。 接下來會等一段時間，等待結束後，就輸入一些指令來驗證是否安裝成功。 which git which ruby which rails ruby -v rails -v 大概會有以下的結果。 設定Git這我設定好了，所以跳過～。 http://railsbridge-docs-zh-tw.herokuapp.com/installfest/configure_git?back=osx_railsinstaller 生成一個SSH Key終端機輸入以下指令 ls ~/.ssh/id_rsa 如果出現No such file or directory，就是沒有SSH Key，沒有就是要生一個，在終端機輸入以下指令。 ssh-keygen -C &#123;your email&#125; -t rsa 接下來會出現要安裝的資料夾，然後詢問是否要密碼，密碼會要求輸入兩次，空白的也可以。 然後會出現以下內容 Generating public/private rsa key pair. Enter file in which to save the key (/Users/student/.ssh/id_rsa): Created directory &apos;/Users/student/.ssh&apos;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/student/.ssh/id_rsa. Your public key has been saved in /Users/student/.ssh/id_rsa.pub. The key fingerprint is: 88:54:ab:77:fe:5c:c3:7s:14:37:28:8c:1d:ef:2a:8d student@example.com SSH Key會放在~/.ssh/id_rsa.pub。 id_rsa.pub 是你的 public key（公鑰），你可以隨便拷給別人。id_rsa 是你的 private key（私鑰），請當做機密妥善保管，不可流出。 驗證SSH終端機輸入 ssh-add ~/.ssh/id_rsa 應該會出現 Identity added: /Users/apple/.ssh/id_rsa (/Users/apple/.ssh/id_rsa) 註冊Heroku 這註冊流程很容易，直接跳到安裝，註冊後他會要求安裝Toolbelt，而基本上也是下一步到底就能裝完的，安裝後終端機輸入： heroku version 有可能出現以下文字，那就是成功了 heroku-toolbelt/3.2.0 (x86_64-darwin10.8.0) ruby/1.9.3 接下來把SSH 加到Heroku先輸入以下指令： heroku keys:add 接下來會先要使用者輸入Heroku帳密，然後再選擇要用哪組SSH key。 開始Rails前面跑了很久，終於開始Rails了。找好一個資料夾後，輸入以下指令： rails new test_app 再整個專案建立完成後，輸入cd test_app，然後再輸入一下指令開始rails吧： rails server 建立DB在終端機依序輸入以下指令： rails generate scaffold drink name:string temperature:integer rake db:migrate rails server 接下來打開http://localhost:3000/drinks，會出現和之前不同的畫面，而這已經是簡單的應用程式了。 Deploy Rails 應用程式Step 1 使用Git等等沒意外的話，應該是用Git上傳，所以要先建立Git儲存庫。依序輸入以下指令： git init git add -A git commit -m &quot;initial commit&quot; 這樣git就已經簽入了。 Step 2.1 程式部署（Deploy）到 Heroku這邊教學裡有提到要建立Heroku應用程式，就先照做吧，依指令輸入： heroku create 接下來輸入git remote show來驗證是否成功，沒意外應該會出現heroku。 Step 2.2 Rails 應用程式來部署到 Heroku這部分要修改一個檔案，到text_app資料夾內學找一個Gmefile的檔案，用純文字編輯器修改。 原 gem &apos;sqlite3&apos; 修改為 group :development, :test do gem &apos;sqlite3&apos; end group :production do gem &apos;pg&apos; gem &apos;rails_12factor&apos; end 而在教學網站有提到資料庫的問題，這邊就轉貼參考吧。 http://railsbridge-docs-zh-tw.herokuapp.com/裝機趴-installfest/deploy_rails_應用程式?back=開新rails應用程式 為什麼要用 SQLite (sqlite3) 和 PostgreSQL (pg) ？SQLite 和 PostgreSQL 是兩種不同的資料庫。我們把 SQLite 用在開發環境（Development）及測試環境（Test），因為它比較好安裝。我們把 PostgreSQL 用在生產環境（Production）因為 Heroku 幫我們剛裝好了，而且功能比 SQLite 多。現在我們已經根據開發、測試、生產環境拆分了資料庫，這是 Rails 的預設。 這邊我都是按照流程操作了…，再繼續輸入指令(指令輸入久了總有一天應該會的…) bundle install --without production step 2.3 設定 root route再用編輯起打開config/routes.rb找到下面這行： # root &apos;welcome#index&apos; 然後替換成這個 root &apos;drinks#index&apos; 設定完後把這動作簽入 git add . git commit -m &quot;Updates for heroku deployment&quot; Push 到Herofu就跟平常push到github一樣，不過會問個問題而已 git push heroku master 接下來在終端機打這些字，heroku就會run起來了 heroku run rake db:migrate 接下來可以到官網或者是heroku open就可以開啟該網站。也可以透過heroku info看詳細資訊。 你應用程式的網址會是 application-name.herokuapp.com ──以上面的例子來說，它就會是 floating-winter-18.herokuapp.com。請確定你有看到應用程式的歡迎頁，然後留著瀏覽器視窗不要關掉。 登入Heroku網頁一樣可以看到應用程式的網址","categories":[{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/categories/rails/"}],"tags":[{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/tags/rails/"}]},{"title":"SVG 線段","slug":"SVG-line","date":"2014-05-04T16:00:00.000Z","updated":"2016-10-12T06:40:01.000Z","comments":true,"path":"svg/2014/05/05/SVG-line/","link":"","permalink":"https://wcc723.github.io/svg/2014/05/05/SVG-line/","excerpt":"這次要練習的是SVG的line、polyline、polygon，這三個都有點類似，但是Polyline和Polygon兩者之間卻有線與塊之間的差異。","text":"這次要練習的是SVG的line、polyline、polygon，這三個都有點類似，但是Polyline和Polygon兩者之間卻有線與塊之間的差異。 Lineline簡單來說就是兩個點之間的線段，所以起點是x1、y1，終點則是x2、y2。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;300&quot; y2=&quot;0&quot; style=&quot;stroke: pink; &quot;/&gt; &lt;line x1=&quot;0&quot; y1=&quot;10&quot; x2=&quot;300&quot; y2=&quot;10&quot; x3=&quot;200&quot; y3=&quot;30&quot; style=&quot;stroke: pink; &quot;/&gt; &lt;/svg&gt; 但是line只能當做兩點間的線段，就算寫了x3、y3都是沒用的喔(如上)。 PolylinePolyline我查到的中文翻譯是折線，它主要是繪製多點線段。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;polyline points=&quot;40,0 60,60 0,60&quot; style=&quot; stroke:red; stroke-width:2&quot;/&gt; &lt;polyline points=&quot;140,0 160,60 100,60&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;polyline points=&quot;240,0 260,60 200,60 240,0&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;/svg&gt; Polyline有點類似Illustrator的鋼筆工具(但還不能繪製弧線)，在線段之間還能填入色彩，但特別要注意的是他並不是自動封閉線段。 PolygonPolygon中文翻譯為多邊形，用來繪製不少於3個邊的圖形。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;polygon points=&quot;40,0 60,60 0,60&quot; style=&quot; stroke:red; stroke-width:2&quot;/&gt; &lt;polygon points=&quot;140,0 160,60 100,60&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;polygon points=&quot;240,0 260,60 200,60 240,0&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;/svg&gt; 這邊我刻意用和polyline相同的code，兩者只有標簽不同，從這樣比較能夠比對出兩個不同的地方，重點就是Polygon會自動連接最後點到第一個點。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"Sass 3.3","slug":"sass-3.3","date":"2014-05-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/05/02/sass-3.3/","link":"","permalink":"https://wcc723.github.io/sass/2014/05/02/sass-3.3/","excerpt":"Sass3.3出一段時間了，而Fire.app目前還是3.2的版本，據說是因為在等Compass 1.0正式版，而如果用Ruby的Compass確實也只能用3.2 版的sass。 不過新東西就是想用看看，上網查了一下並不複雜，所以這次就來試試看Sass 3.3 + Compass 1.0.alpha吧。","text":"Sass3.3出一段時間了，而Fire.app目前還是3.2的版本，據說是因為在等Compass 1.0正式版，而如果用Ruby的Compass確實也只能用3.2 版的sass。 不過新東西就是想用看看，上網查了一下並不複雜，所以這次就來試試看Sass 3.3 + Compass 1.0.alpha吧。 Ruby 更新Sass由於我都是使用Fire.app，所以ruby的Sass還在3.2…，而現在3.3也已經release了，所以直接update就可以了。 sudo gem update sass 安裝Compass alphaCompass 1.0還尚未release，所以如果像我這樣裝的話，會是屬於0.12版的，而它對應的Sass則是3.2版。 Compass alpha 安裝如果專案進行不受影響的情況下，可以試試看安裝Compass 1.0(或者平常沒在用Ruby在編譯的可以試試看)。 gem install compass --pre 這樣他就會安裝還在測試中的Compass 1.0，接下來就像平常用的那樣，就可以開始Watch 專案資料夾。 compass watch 測試Sass 3.3 的新功能就是$map，對我而言它可以減少模組話所需要的code，而且使用更直覺，以下就簡單介紹$map的用法，順便測試Sass 3.3能不能與Compass一起Run。 1.定義$map$all-colors: (first: #b06,next: #334,third: #666777,) //首先定義$all-colors //裡面有三組變數，包含一個名稱以及一個顏色 2.套用至樣式//利用@each將$class及$color 套用至$all-colors變數裡 @each $class, $color in $all-colors //接下來$all-colors的三組名稱及變數，都會套用到以下的樣式 .btn-#&#123;$class&#125; background-color: $color +background(linear-gradient($color, darken($color,10%))) //套套看Compass的CSS3 3.輸出如果沒有出錯的話剛剛的Compass watch，就能夠將Sass轉換成CSS了，轉換的結果會下方的CSS。 .btn-first &#123; background-color: #bb0066; background: -moz-linear-gradient(#bb0066, #88004a); background: -webkit-linear-gradient(#bb0066, #88004a); background: linear-gradient(#bb0066, #88004a); &#125; .btn-next &#123; background-color: #333344; background: -moz-linear-gradient(#333344, #1d1d27); background: -webkit-linear-gradient(#333344, #1d1d27); background: linear-gradient(#333344, #1d1d27); &#125; .btn-third &#123; background-color: #666777; background: -moz-linear-gradient(#666777, #4e4f5c); background: -webkit-linear-gradient(#666777, #4e4f5c); background: linear-gradient(#666777, #4e4f5c); &#125; 有圖有真相(有沒有好用的Macbook pro截圖軟體…，可以自動壓縮的)","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"}]},{"title":"SVG 矩形、圓形、橢圓","slug":"SVG-base-shapes","date":"2014-04-30T16:00:00.000Z","updated":"2016-10-12T06:13:13.000Z","comments":true,"path":"svg/2014/05/01/SVG-base-shapes/","link":"","permalink":"https://wcc723.github.io/svg/2014/05/01/SVG-base-shapes/","excerpt":"SVG是屬於向量的圖形，所以他有許多的繪圖概念與Illustrator，所以這次就來了解他的一些常用的基本圖形。","text":"SVG是屬於向量的圖形，所以他有許多的繪圖概念與Illustrator，所以這次就來了解他的一些常用的基本圖形。 矩形在定義一個矩形形狀時，通常會定義以下屬性，形狀、位置、尺寸以及樣式。 &quot;shapes&quot; &quot;x&quot; &quot;y&quot; &quot;width&quot; &quot;height&quot; &quot;style&quot; &lt;svg width=&quot;100%&quot; height=&quot;200&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: gray; fill: 336699;&quot;/&gt; &lt;rect x=&quot;120&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;stroke: gray; fill: 339966;&quot;/&gt; &lt;/svg&gt; 而矩形除了一般的方形、長方形以外，也可以增加圓角的屬性rx、ry，但這就沒有像css的border-radius那麼的自由了，只能四個角設定相同的值；rx、ry也僅僅是設定其圓角垂直以及水平的半徑而已。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; rx=&quot;10&quot; style=&quot;stroke: gray; fill: 336699;&quot;/&gt; &lt;rect x=&quot;120&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; rx=&quot;40&quot; ry=&quot;10&quot; style=&quot;stroke: gray; fill: 339966;&quot;/&gt; &lt;/svg&gt; 圓形圓形相當的容易，所以本篇才會將這些圖形合併在同一篇 圓形中有一點要特別注意，圓形的cx,cy所代表的是 圓心(r) 的位置，所以在定義圓形的位置，如果不想跑到圖框外，務必cx、cy要大於r的值。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;50&quot; style=&quot;stroke: gray; fill: 339966;&quot;/&gt; &lt;/svg&gt; 橢圓形橢圓形概念和圓形也相當類似，只是將半徑r的值改成垂直及水平半徑rx、ry。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;50&quot; rx=&quot;80&quot; ry=&quot;30&quot; style=&quot;stroke: gray; fill: 990000;&quot;/&gt; &lt;/svg&gt; 小結咦…到目前為止是不是太容易點…。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"SVG Group","slug":"SVG-G","date":"2014-04-29T16:00:00.000Z","updated":"2016-10-12T06:38:43.000Z","comments":true,"path":"svg/2014/04/30/SVG-G/","link":"","permalink":"https://wcc723.github.io/svg/2014/04/30/SVG-G/","excerpt":"上一篇有簡單介紹一下SVG的元素，雖然沒有介紹很詳細，但是很多部分都和Canvas很相近，所以就不詳細介紹了。 而這篇要介紹svg &lt;g&gt;這個標簽，它的用途是群組化元素，而被群組後的元素就可以一起被控制，甚至是一起設定樣式。","text":"上一篇有簡單介紹一下SVG的元素，雖然沒有介紹很詳細，但是很多部分都和Canvas很相近，所以就不詳細介紹了。 而這篇要介紹svg &lt;g&gt;這個標簽，它的用途是群組化元素，而被群組後的元素就可以一起被控制，甚至是一起設定樣式。 群組svg SVG 上面的文字與方塊已經算是一個群組了，接下來可以在&lt;g&gt;這個元素，使用變形(transform)來一起改變外觀，像是以下這樣。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g transform=&quot;rotate(-10)&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; 像以上這樣，&lt;g&gt;群組就會被旋轉(-10 deg)。 G 的繼承在G裡面的元素，都會被外層&lt;g&gt;所設定的樣式影響，像以下內部的元素沒有設定外框，但卻可以繼承其父層的&lt;g&gt;樣式。 也就像CSS一樣，如果子元素有設定，則子元素優先。 &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g style=&quot;stroke: pink; stroke-width: 5px&quot;&gt; &lt;circle cx=&quot;40&quot; cy=&quot;35&quot; r=&quot;30&quot; style=&quot;fill: white;&quot;/&gt; &lt;circle cx=&quot;120&quot; cy=&quot;35&quot; r=&quot;30&quot; style=&quot;fill: white;&quot;/&gt; &lt;rect x=&quot;160&quot; y=&quot;5&quot; width=&quot;40&quot; height=&quot;40&quot; style=&quot;fill: white;&quot;/&gt; &lt;rect x=&quot;220&quot; y=&quot;5&quot; width=&quot;40&quot; height=&quot;40&quot; style=&quot;fill: red;&quot;/&gt; &lt;/g&gt; &lt;/svg&gt; G 沒有X,Yㄜ，反正就是沒有，這樣似乎有點困擾。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g x=&quot;40&quot; y=&quot;20&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; 向上面這樣，就算有設定&lt;g&gt;的x,y值，但就是完全沒有反應，如果要控制&lt;g&gt;的位置，就要用transform了。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g transform=&quot;translate(40,20)&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; 利用transform=”translate(40 20)”，就可以位移了，這用法和CSS3 transform相當接近，雖然類似x,y但本質上還是有所不同。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g&gt; &lt;svg x=&quot;40&quot; y=&quot;20&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/svg&gt; &lt;/g&gt; &lt;/svg&gt; 不過我沒想到的是，svg還可以這樣用，在&lt;g&gt;裡面再放一個&lt;svg&gt;，這樣就可以設定他的x,y，這招太絕了，這樣就可以避免使用translate，使用x,y來設定位置。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"SVG 簡介","slug":"SVG-intro","date":"2014-04-20T16:00:00.000Z","updated":"2016-10-12T06:37:58.000Z","comments":true,"path":"svg/2014/04/21/SVG-intro/","link":"","permalink":"https://wcc723.github.io/svg/2014/04/21/SVG-intro/","excerpt":"好久沒寫文章了，這段時間工作還是經常的會翻這Blog的資料，裡面很多很多的技術雖然很基礎，但是就是很實用。 所以呢！現在要挑戰”基礎”SVG！","text":"好久沒寫文章了，這段時間工作還是經常的會翻這Blog的資料，裡面很多很多的技術雖然很基礎，但是就是很實用。 所以呢！現在要挑戰”基礎”SVG！ 無限期支持向量技術我早期多以Illustrator進行平面設計，所以在轉網頁設計這行業也是多以Illustrator，雖說許多同行的都建議用Photoshop，但我不這麼認為，且更堅定的要繼續以向量設計為主(但不會只有用Illustrator…)。 SVG簡介SVG(Scalable Vector Graphics)，中文直譯就是”可縮放向量圖形“，它是以XML格式儲存。而在瀏覽器上是從IE9後才開始支援SVG。 SVG優點 向量物件(Vector)，不同於點陣，向量並不會有解析度的問題，可自由的縮放。 嵌入式外部影像，包括PNG、JPEG、SVG等。 可有文字物件(可以被搜尋)。 開發人員可利用DOM抓取SVG物件。 SVG 範例(直接繪製) &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;100%&quot; height=&quot;120&quot;&gt; &lt;rect width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;/svg&gt; 在svg標簽內就可以直接開始繪製向量圖型，而其中xmlns=&quot;http://www.w3.org/2000/svg&quot;在微軟MSDN的解釋為定義SVG區段的命名空間，目前我測試移除也沒什麼差別。 SVG 外部圖形圖片來源 http://seeklogo.com/tag.html?q=Google 外部PNG &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;100%&quot; height=&quot;180&quot;&gt; &lt;image width=&quot;447&quot; height=&quot;179&quot; xlink:href=&quot;/images/google-logo.png&quot;/&gt; &lt;/svg&gt; 外部SVG &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;100%&quot; height=&quot;180&quot;&gt; &lt;image width=&quot;447&quot; height=&quot;179&quot; xlink:href=&quot;/images/google-logo.svg&quot;/&gt; &lt;/svg&gt; 雖然SVG是向量的圖形，如果和Canvas做比較還有許多不同的特點，像是Html dom、外部點陣圖、不需要js也能繪製。 而這兩個技術的差別，網路上也有許多文章有提到，但我希望在日後再比較兩者的差異。 對SVG還不到相當了解可以寫非常長的文章，但我不認為要寫夠分量才值得算一篇文章，學習過程中過度的要求，會影響到學習技術的熱誠以及效率，所以很快就會有下一篇了(應該)。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"Sprites for Retina","slug":"css-icon-sprites","date":"2014-03-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/03/24/css-icon-sprites/","link":"","permalink":"https://wcc723.github.io/css/2014/03/24/css-icon-sprites/","excerpt":"上禮拜教召，讓這篇已經準備好的文章又拖了一個禮拜…，然後現在打開卻有點忘記怎麼做…。 Compass sprites for retina來源：https://speakerdeck.com/hlb/maintainable-css-with-sass-and-compass Hlb的簡報有介紹，本篇也是參考此簡報做的。","text":"上禮拜教召，讓這篇已經準備好的文章又拖了一個禮拜…，然後現在打開卻有點忘記怎麼做…。 Compass sprites for retina來源：https://speakerdeck.com/hlb/maintainable-css-with-sass-and-compass Hlb的簡報有介紹，本篇也是參考此簡報做的。 本篇重點延續上一篇，利用compass製作sprites for retina，讓png icons在行動裝置以及有更高解析度的螢幕有更好的表現。 準備工作和上篇一樣，圖片是從http://icomoon.io/下載作為範例用，但這次是要有兩種size(其實上次就有做好了)。 而兩個資料夾對應的圖片檔名也要相同，但記得尺寸寬及高是各兩倍。 Sass首先先到https://gist.github.com/estahn/3837343下載_compass-retina-sprites.scss這隻檔案，這一個mixin中有一段device-pixel-ratio，這可以判斷目前裝置的像數比(相關文章http://rettamkrad.blogspot.tw/2013/04/retina-device-and-web-develop.html)。 如果不是很清楚，建議可以先看那篇文章，接下來就開始sass實做了。 @import compass-retina-sprites.scss //匯入普通版的icons $icons-spacing: 1px $icons-sprite-dimensions: true @import &quot;icons/*.png&quot; @include all-icons-sprites //匯入2x size的icons $icons2x-spacing: 1px $icons2x-sprite-dimensions: true @import &quot;icons2x/*.png&quot; @include all-icons2x-sprites //製作成retina款式 @include all-retina-sprites($icons-sprites, $icons2x-sprites) 接下來會產生兩種size的png sprites。 普通size 2x size 使用其實用法和上一篇一模一樣，透過css media會判斷裝置是要用哪種icons sprites，以下有兩個demo，有retina裝置的使用者不妨看看兩者之間的差異吧~(一般螢幕兩者看到的會一樣)。 &lt;div class=&quot;icons-mobile&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons-phone&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons-nice&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons-setting&quot;&gt; &lt;/div&gt; 一般 Sprites Retina Sprites 比較圖這邊另外附上比較圖。 現在許多網站的icons sprites也有做for retina，像是facebook新版的網站，當然還有非常多，不妨四處觀察看看吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Spriting with Compass","slug":"css-icon-sprites","date":"2014-03-12T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/03/13/css-icon-sprites/","link":"","permalink":"https://wcc723.github.io/css/2014/03/13/css-icon-sprites/","excerpt":"因為最近剛轉換工作，所以一段時間沒寫文章，沒寫文章的時間雖然不至於會退步，但會感覺到進步遲緩…。 這次來介紹利用Compass製作sprites，sprites 就像是的Google icons，他把許多的icons集合在同一張的png，這樣可以減少用戶對於伺服器的請求數。而這次會有兩篇sprites文章，本篇是介紹基本的sprites，下次介紹retina版sprites。 Compass sprites來源：http://compass-style.org/help/tutorials/spriting/","text":"因為最近剛轉換工作，所以一段時間沒寫文章，沒寫文章的時間雖然不至於會退步，但會感覺到進步遲緩…。 這次來介紹利用Compass製作sprites，sprites 就像是的Google icons，他把許多的icons集合在同一張的png，這樣可以減少用戶對於伺服器的請求數。而這次會有兩篇sprites文章，本篇是介紹基本的sprites，下次介紹retina版sprites。 Compass sprites來源：http://compass-style.org/help/tutorials/spriting/ 本篇重點利用compass製作css sprites，而在下一篇會介紹如何製作retina版本css srpites。 準備工作首先先準備些icons到自己的images資料夾內，而本篇的圖片是從http://icomoon.io/下載作為範例用，如下圖所示。 我在icons資料夾內放入了幾張不同size的圖檔，另外切記，製作sprites請存png。 Sass接下來開始Sass吧。 @import &quot;icons/*.png&quot; //匯入圖檔 @include all-icons-sprites //將圖檔轉成 sprites 接下來會在資料夾內看到以下的圖檔，這樣就成功一半了。 在CSS檔內會看到這樣的結果，icons是資料夾名稱，mobile是檔名，兩個串在一起就是一個class，但這範例缺少一個重要的屬性…，就是寬跟高。 .icons-mobile &#123; background-position: 0 -134px; &#125; Compass sprites 設定值http://compass-style.org/help/tutorials/spriting/customization-options/ Compass sprites有提供許多的設定值，相關的參數如以上網址，我們以$&lt;map&gt;-spacing為例，這是可以讓產生的sprites每張縮圖產生間距，只要把&lt;map&gt;替換成資料夾名稱即可。 如以下sass，就可以讓每張縮圖額外有1px的間距，這樣的sprites icons也比較不會互相干擾。 //$&lt;map&gt;-spacing $icons-spacing: 1px 而另一個設定是讓每一個class都會寫入當初匯入的png寬與高，$&lt;map&gt;-sprite-dimensions預設值為false，只要改為true就會將每個icon加上寬與高。 只要將這些設定值，寫在匯入的png前方，在匯入後就會依據這些設定做成sprites。 $icons-spacing: 1px $icons-sprite-dimensions: true @import &quot;icons/*.png&quot; @include all-icons-sprites 這樣匯入的每張圖，都會被補上寬與高。 .icons-mobile &#123; background-position: 0 -137px; height: 49px; width: 30px; &#125; 完成在tag內直接填上對應的class名稱，就可以使用了。 &lt;div class=&quot;icons1-mobile&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons1-phone&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons1-nice&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons1-setting&quot;&gt; &lt;/div&gt; 這樣就可以省去一大半用css算sprites位置的時間囉～。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Jquery 重複click判斷","slug":"jquery-repeat-click","date":"2014-02-28T16:00:00.000Z","updated":"2016-10-11T09:48:48.000Z","comments":true,"path":"jquery/2014/03/01/jquery-repeat-click/","link":"","permalink":"https://wcc723.github.io/jquery/2014/03/01/jquery-repeat-click/","excerpt":"今天要分享的是Jquery 重複click判斷。 來源參考http://jsfiddle.net/visualidiot/WJEBr/","text":"今天要分享的是Jquery 重複click判斷。 來源參考http://jsfiddle.net/visualidiot/WJEBr/ $('.d0818click').click(function(evt) { evt.preventDefault(); $('.old').animate({left: '+=10'}); $('.new').is(':animated') || $('.new').animate({left: '+=10'}); }); 點我 $('.d0818').click(function() { $('.old').animate({left: '+=10'}); $('.new').is(':animated') || $('.new').animate({left: '+=10'}); });","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"大陸面試題 如何反轉元素內容","slug":"reverse-element","date":"2014-02-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/02/26/reverse-element/","link":"","permalink":"https://wcc723.github.io/css/2014/02/26/reverse-element/","excerpt":"最近大陸網路上有篇問題文，問題：看到一道面試題：ul有10000 個li子元素，如何將這10000 個li顛倒順序。而其中有一個神回復，真的是活用CSS3的特色，所以在這邊分享給大家看看(本篇以150個為例)。 來源：http://v2ex.com/t/100982","text":"最近大陸網路上有篇問題文，問題：看到一道面試題：ul有10000 個li子元素，如何將這10000 個li顛倒順序。而其中有一個神回復，真的是活用CSS3的特色，所以在這邊分享給大家看看(本篇以150個為例)。 來源：http://v2ex.com/t/100982 神回復在本篇的五樓已經有對此文做了神回復。 ul {transform: rotate(180deg)} li {transform: rotate(180deg)} 搞定 簡單來說，就是反轉一次外圈，在反轉一次個別的元素，來達到這個效果。 ul +transform(rotate(180deg)) li +transform(rotate(180deg)) 我的提案其實他的已經是神回復了，要超越它實在是太難了，所以我提出另一個方式，就是使用display: flex，利用flex-direction來反向排列其內容。 ul display: flex flex-direction: column-reverse 兩個結果如下，最左方的是原始題目，中間是神回復，最右方是利用display: flex。 codepen :http://codepen.io/Wcc723/pen/GFgtm 以上是針對此題目的兩個CSS解法，還有人想到其他解決方案嗎？","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS設定中英文不同的字體","slug":"font-code-range","date":"2014-02-20T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/02/21/font-code-range/","link":"","permalink":"https://wcc723.github.io/sass/2014/02/21/font-code-range/","excerpt":"Just font中的字型學文章都相當有意思，而有一篇是關於中英文字搭配的問題；這篇雖然是以windows word為例，但裡面的概念在網頁上也是很有幫助，而其中一段”以 Windows 內建的三種字型為例，表現最好的是微軟正黑體，英文部分採用了微軟的 Segoe UI，粗細與中文較一致“，在目前web中當然也可以有這樣的設定，只要用CSS3的unicode-range，就能夠在中文字中套用”微軟正黑體”，英文套用”Segoe UI”。","text":"Just font中的字型學文章都相當有意思，而有一篇是關於中英文字搭配的問題；這篇雖然是以windows word為例，但裡面的概念在網頁上也是很有幫助，而其中一段”以 Windows 內建的三種字型為例，表現最好的是微軟正黑體，英文部分採用了微軟的 Segoe UI，粗細與中文較一致“，在目前web中當然也可以有這樣的設定，只要用CSS3的unicode-range，就能夠在中文字中套用”微軟正黑體”，英文套用”Segoe UI”。 本篇參考 利用 CSS 分別設定中文字、英數、注音、假名的字體：使用 CSS3 @font-face 大眾字型學(3)：Word 預設中英搭配有什麼問題？ Uni-code 字符百科 本篇重點了解unicode-range的使用方法。 效果展示unicode-range部分效果在Mac OS上測試有問題，不管是Chrome、Safari、Firefox都有點問題…。 這一句話只有\"我\"會被換成黑體 以上面這一段文字為例，在windows內，”我”這一個文字會被替換成微軟正黑體，而其他文字沒有變化。 https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-range 如果參考Mozilla 的MDN可以了解到， unicode-range: U+26 /* 單一字符 */ unicode-range: U+0025-00FF /* 範圍字符 */ unicode-range: U+4?? /* 萬用字符 */ unicode-range: U+0025-00FF, U+4?? /* 利用&apos;,&apos;，多選取字符 */ http://unicode-table.com/cn/ 再參考uni code的表，可以查詢各文字的unicode。 用這樣的方式就能夠選取特定的文字，或是語系等等。 @font-face font-family: custom-Iam src: local(&quot;Heiti TC&quot;), local(&quot;微軟正黑體&quot;), local(&quot;Microsoft JhengHei&quot;) unicode-range: U+6211 .custom-Iam font-family: custom-Iam 針對指定語系設定在一般來說，通常換字體沒有針對語系，就像下方這一個範例，我將字體換成了’Mac OS 黑體-繁’、’Windows 微軟正黑體’，但在中英文排版中，用同一種字體不一定合適(請看just font)。 This is 一個中文English交雜的sentence 中文的語系的unicode-range為U+4E00-9FFF，英語系為U+00-024F，將這個值加入到@font-face內，就能為特定語系換字體。如下範例中文還是’Mac OS 黑體-繁’、’Windows 微軟正黑體’，但英文的部份已經替換成’Helvetica’、’Segoe UI’，範例如下。 This is 一個中文English交雜的sentence 在css內只要將兩者的font-family皆設定相同名稱，但指向不同的unicode-range，就可以達到這樣的效果。 @font-face font-family: custom-sans-serif src: local(&quot;Heiti TC&quot;), local(&quot;微軟正黑體&quot;), local(&quot;Microsoft JhengHei&quot;) unicode-range: U+4E00-9FFF @font-face font-family: custom-sans-serif src: local(Helvetica), local(Segoe UI) unicode-range: U+00-024F .custom-sans-serif font-family: custom-sans-serif 其他範例不只在黑體能夠這樣做，明體當然也可以。 This is 一個中文English交雜的sentence @font-face font-family: custom-serif src: local(&quot;LiSong Pro&quot;), local(&quot;新細明體&quot;), local(&quot;PMingLiU&quot;) unicode-range: U+4E00-9FFF @font-face font-family: custom-serif src: local(Times), local(Times New Roman) unicode-range: U+00-024F .custom-serif font-family: custom-serif 延伸發現在字符百科中，不僅可以查詢的文字的unicode 編號，其實還可以查到許多符號性的文字，這些文字其實可以直接當作web font使用，還免載入外部的字型檔，就像下方的幾個不同雪花一樣。 ❄❅❆","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass 模組開發","slug":"sass-component","date":"2014-02-13T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/02/14/sass-component/","link":"","permalink":"https://wcc723.github.io/sass/2014/02/14/sass-component/","excerpt":"最近社群上有人分享了一個連結，是關於sass模組製作的教學，大致看了一下，發現和我的方式頗為接近，所以就在這介紹我的Sass模組開發方式。 http://www.sitepoint.com/sass-component-10-minutes/","text":"最近社群上有人分享了一個連結，是關於sass模組製作的教學，大致看了一下，發現和我的方式頗為接近，所以就在這介紹我的Sass模組開發方式。 http://www.sitepoint.com/sass-component-10-minutes/ 本篇重點以按鈕模組為例，示範Sass模組開發。 效果展示 btn-default demo-btn demo-btn Validation demo-btn Error demo-btn Warning demo-btn Information &lt;a href=&quot;#&quot; class=&quot;demo-btn&quot;&gt;demo-btn&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Validation&quot;&gt;demo-btn Validation&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Error&quot;&gt;demo-btn Error&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Warning&quot;&gt;demo-btn Warning&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Information&quot;&gt;demo-btn Information&lt;/a&gt; 以上是分為兩組的範例，上面那一組是模組預設值，而下方這組是透過變數以及@each來快速產生，透過這個方式，可以有效的管理CSS程式碼，以及增加開發速度。 模組開發流程首先，分為兩個部分，一個是共通的屬性，另一部份是可變動的屬性；共通部分就是基本的格式，也是模組最基礎的屬性，可變動的可以如顏色、大小、對齊方式等等，而本篇則是用顏色。 建立@extend 及@mixin@extend就是模組的共通屬性，如果不清楚的，可以和下方的@mixin一起參考。 %buttonDemo color: #fff text-decoration: none padding: .3em 1em display: inline-block text-align: center vertical-align: middle cursor: pointer text-shadow: -1px -1px 0 rgba(00,00,00,0.3) +border-radius(3px) +box-sizing(border-box) +box-shadow(inset 0 .1em 0 rgba(255, 255, 255, .2), 0 1px 2px rgba(0, 0, 0, 0.05)) +transition(box-shadow .2s) &amp;:hover +box-shadow(inset 0 .1em .3em rgba(0, 0, 0, .3),0 1px 2px rgba(0, 0, 0, 0.05)) color: #fff &amp;:focus,&amp;:active,&amp;.current +box-shadow(inset 0 .1em .6em rgba(0, 0, 0, .4),0 1px 2px rgba(0, 0, 0, 0.05)) @mixin就是一個基本的模組，將顏色屬性先挑選出來，再透過Sass的運算可以產生許多樣式，而@extend可以避免CSS檔產生過多不必要的程式碼。 $defaultColor: #107FC9 //預設色彩 @mixin buttonDemo($className: btn-default,$color: $defaultColor) $darkenColor: saturate(darken($color, 10%),15%) $lightenColor: saturate($color, 2%) .#&#123;$className&#125; @extend %buttonDemo border: 1px solid $darkenColor background-color: $lightenColor margin: 1px &amp;:hover,&amp;.current background-color: $darkenColor btn-default 到這部分就有一個基本的按鈕樣式。 利用@each 大量製作+buttonDemo(.demo-btn.Validation, #5cb85c) +buttonDemo(.demo-btn.Error, #d9534f) +buttonDemo(.demo-btn.Warning, #f0ad4e) +buttonDemo(.demo-btn.Information, #5bc0de) 到了這部分，其實我們可以利用上面的方式來產生多樣模組，但其實.Validation以及後方的色彩#5cb85c都是可以重複使用的，如果我們利用$each，除了在這一個模組會更好管理外，還可以用來製作其他模組。 首先，先定義基本的class名稱及色彩。參考 $button-types: (Validation, #5cb85c) (Error, #d9534f) (Warning, #f0ad4e) (Information, #5bc0de) 製作一個新的@mixin，利用$each將每一個class名稱及色彩套用至buttonDemo這一個@mixin內。 @mixin DemoButtons($prefix: demo-btn) +buttonDemo($prefix, $defaultColor) //載入預設的樣式 @each $button-type in $button-types $thisClass: nth($button-type, 1) $thisColor: nth($button-type, 2) $thisallClass: $prefix+&quot;.&quot;+$thisClass +buttonDemo($thisallClass, $thisColor) +DemoButtons() demo-btn demo-btn Validation demo-btn Error demo-btn Warning demo-btn Information 用這方式就可以完成sass模組，且包含了許多樣式。而這模組的架構，是我目前在測試的，有興趣的可以參考就好，畢竟CSS寫法相當多樣，只有適合沒有完美的寫法，下方另外提供codepen範例。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"做網頁如果缺Icons怎麼辦","slug":"web-font-icons","date":"2014-02-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/02/10/web-font-icons/","link":"","permalink":"https://wcc723.github.io/css/2014/02/10/web-font-icons/","excerpt":"最近很多人跟我討論到的網站上icon的問題，如果要畫icon要花多久時間、使用的方法等等。而以我來說，較傾向使用免費icons或者是付費的向量icon，不建議自己畫這些icon，因為要畫一個icon所花的時間成本，都可以買一套200枚的icons了= =。 而今天要推薦的是ico moon，這在之前就有推薦過，而這次的教學，要針對於要直接使用他的icons在網頁上。 http://icomoon.io/","text":"最近很多人跟我討論到的網站上icon的問題，如果要畫icon要花多久時間、使用的方法等等。而以我來說，較傾向使用免費icons或者是付費的向量icon，不建議自己畫這些icon，因為要畫一個icon所花的時間成本，都可以買一套200枚的icons了= =。 而今天要推薦的是ico moon，這在之前就有推薦過，而這次的教學，要針對於要直接使用他的icons在網頁上。 http://icomoon.io/ 本篇重點使用Ico Moon web-font icons在網頁上，並且了解其特性。 效果展示 &lt;span class=&quot;icon-phone&quot; style=&quot;font-size: 3em&quot;&gt;&lt;/span&gt; 上面理當來說，可以看到一隻電話，使用上和bootstrap的icon相當類似，但不同的是它用偽元素插入文字，透過web-font轉換成圖形，所以基本上是需要支援偽元素的瀏覽器才能使用，在不支援的瀏覽器(ex: ie7)，ico moon也有提供解決的方式，所以大可盡量使用。 由於是web-font，屬於字體的一種，所以可以把它當作文字的屬性，自由的調整它的顏色(color)及大小(font-size)。 使用Ico Moonhttp://icomoon.io/ 首先，請打開以上連結，Ico Moon有提供web-font icon的製作，以及大量的icon，另外也可以付費取得更進階的服務。 在進入網頁後，點選右上方的Launch App，開啟製作web-font的應用程式介面。 在應用程式內可以看到大量的icons，當然是可以把他們全部通通選起來，但要記得，選越多檔案越大…，其中我喜歡Entypo這組，我就把這群組的選起來。 選完後點下面的font。 如果不想下載下來，可以點quick used，而本篇會介紹下載到本機使用。 設定在以上的步驟完後，其實就可以點選下載，其實還有提供許多設定值，如：ie7 support…。 在上一張圖的右上方，有Preferences的選項，裡面就有許多設定…。 這裡面有許多設定，參考如下： Encode &amp; Embed Font in CSS 字體內嵌入CSS檔(不需要外部字型檔) Support IE 7 (and older) 支援萬惡IE7 Include Metadata in Fonts 不清楚.. Use Class Selector 不使用屬性選取器，改用自訂選取器(如果不清楚，就用內建的吧) Font Metrics 字體規格 再都設定完後，請選擇下方的Download到本機，並且解壓縮後打開demo.html。 裡面會看到這一個範例檔，可以查詢到每一個icon所使用的Class以及範例。 使用在自己的網頁上解壓縮後，有許多的檔案，其中請把以下三個資料夾或檔案複製到自己的專案上(如果沒有support ie7就不會有ie7資料夾)。 style.css /ie7/ /fonts/ 在專案內的html檔只要插入以下程式碼，即可開始使用(如果沒有support ie7，就僅需要以下第一行)。 &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;!--[if lt IE 8]&gt;&lt;!--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;ie7/ie7.css&quot;&gt; &lt;!--&lt;![endif]--&gt; 範例 ie7IE 7的部分，由於新的大魔王IE 11出現，測試一直有問題，所以我用Aurora 瀏覽器模擬IE7進行測試，結果是可以的，如果有純正IE 7的使用者，不妨試試看…(不是在本站測試，本站並沒有載入ie7 fix)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"icons","slug":"icons","permalink":"https://wcc723.github.io/tags/icons/"}]},{"title":"Amazon book 書籍封面展示效果 (CSS 3D)","slug":"amazon-books","date":"2014-01-26T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/01/27/amazon-books/","link":"","permalink":"https://wcc723.github.io/css/2014/01/27/amazon-books/","excerpt":"自從學了CSS 3D後，就一直想嘗試使用在網頁上，但除了形象網頁外，使用CSS 3D的網站似乎不是很多，畢竟這不是必要的效果。而最近在Amazon Books的購物商城上，發現他們有用CSS 3D在展示書籍的正反面。 Amazon books","text":"自從學了CSS 3D後，就一直想嘗試使用在網頁上，但除了形象網頁外，使用CSS 3D的網站似乎不是很多，畢竟這不是必要的效果。而最近在Amazon Books的購物商城上，發現他們有用CSS 3D在展示書籍的正反面。 Amazon books 本篇重點試試看Amazon Books中的書籍展示效果，到底包含了些什麼CSS 語法。 效果展示這效果我是做在codepen 上，裡面的封面圖片是直接連結台灣博客來書店，所以如果掉圖就是…被下架了。 codepen連結 在滑鼠滑過書上方時，書本會呈現微開，這會讓使用者感覺書本可以點擊(在Amazon Books中，點擊書本就可以看書的簡介)；而在hover過下方的flip to back時，書會翻轉30度，如果點擊則會翻轉180度，這樣就可以看到書的背面。 語法結構題外話，最近我正在學slim，所以codepen上的html是用slim寫的，這邊就先介紹一下html的結構吧。 html結構&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;imgWrap&quot;&gt; &lt;img src=&quot;#...&quot; alt=&quot;&quot; class=&quot;first-child&quot;&gt; &lt;img src=&quot;#...&quot; alt=&quot;&quot; class=&quot;second-child&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;fliptoBack&quot;&gt;|flip to back&lt;/a&gt; .wrap 用途是來定位整體的位置 .imgWrap 書本的外圍架構，並且做翻轉書本的效果 img .first-child 書的正面 img .second-child 書的背面 Js在看CSS前，我想先說明js的部分，有些地方沒有辦法用css達成的，會用js去完成，避免等等css的誤解，先介紹一下我的script寫了什麼。 先取得第一張封面的寬高定義為w,h w = $(&apos;.first-child&apos;).width(); h = $(&apos;.first-child&apos;).height(); //將外框及第二張圖設定成相同的寬高 $(&apos;.imgWrap, .wrap, .second-child&apos;).width(w); $(&apos;.imgWrap, .wrap, .second-child&apos;).height(h); 滑過下方文字時，將書本套用&apos;.flip&apos;的class $(&apos;.fliptoBack&apos;).hover(function() &#123; $(&apos;.imgWrap&apos;).toggleClass(&apos;flip&apos;); &#125;); 點擊下方文字時，將書本套用&apos;.flip180&apos;的class $(&apos;.fliptoBack&apos;).click(function() &#123; $(&apos;.imgWrap&apos;).toggleClass(&apos;flip180&apos;); &#125;); CSS依慣例，我是用sass寫…，另外就是有點長。 $bookwidth: 60px //先定義書本的&quot;厚度&quot; .wrap +perspective(1200px) //3D的景深 position: relative margin: 40px auto 20px auto .fliptoBack //下方文字的位置 display: block text-align: center .imgWrap +transform-style(preserve-3d) //先定義成transform3d的模式 +transition(transform .5s ease) //針對transform進行動畫 position: absolute &amp;:before //這一塊是要假裝成書的內頁 content: &quot;&quot; position: absolute width: 100% height: 100% +border-right-radius(5px) background: black &amp;:after //這邊是書背 content: &quot;&quot; position: absolute left: 0 top: 0 height: 100% width: $bookwidth background: black +transform3d(rotateY(90deg)) +transform-origin(0) &amp;.flip //在滑鼠掠過下方文字時，套用的&apos;.flip&apos; +transform3d(rotateY(30deg)) //翻轉30度 &amp;.flip180 //點擊時套用的&apos;.flip180&apos;，用來翻轉180度 +transform3d(rotateY(180deg) translateZ($bookwidth)) //另外再翻轉180度後，必須調整書本的Z軸，讓他在視覺上位置不變 img //兩張圖片的設定 position: absolute top: 0 left: 0 border: #ccc 1px solid +transition(transform .3s ease) +backface-visibility(hidden) //不顯示背面 +border-right-radius(3px) +box-sizing(border-box) &amp;.first-child //定義第一張圖片，並且滑鼠滑過時旋轉30度 +transform3d(rotateY(0deg)) +transform-origin(0) z-index: 2 &amp;:hover +transform3d(rotateY(-30deg)) &amp;.second-child //讓封底一開始時就反轉到另一面 +transform3d(rotateY(-180deg) translateZ($bookwidth)) CSS 3D很有趣，只是看起來code有點長，但是玩一段時間會很有成就感。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"從CSS到Sass 學習分享","slug":"css-to-sass","date":"2014-01-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/01/22/css-to-sass/","link":"","permalink":"https://wcc723.github.io/css/2014/01/22/css-to-sass/","excerpt":"本身是視覺設計系所畢業，在學期間雖然有做過網站，但其實Html及CSS可以算沒有寫過，連html需要結尾都不知道。兩年前，進路職場還是相當依賴Dreavweaver，所以更別說Sublime text這麼潮的工具，我是根本連聽都沒聽過。 但到了現在，對於CSS及Sass已經可以和人侃侃而談，閒暇之餘還去參加鐵人賽分享一下CSS3的研究心得；而這當中，我覺得最重要的就是”開始”的行為，不論是從基礎的CSS，或者是利用Sass開發，只要跨出了第一步，剩下就容易許多了。","text":"本身是視覺設計系所畢業，在學期間雖然有做過網站，但其實Html及CSS可以算沒有寫過，連html需要結尾都不知道。兩年前，進路職場還是相當依賴Dreavweaver，所以更別說Sublime text這麼潮的工具，我是根本連聽都沒聽過。 但到了現在，對於CSS及Sass已經可以和人侃侃而談，閒暇之餘還去參加鐵人賽分享一下CSS3的研究心得；而這當中，我覺得最重要的就是”開始”的行為，不論是從基礎的CSS，或者是利用Sass開發，只要跨出了第一步，剩下就容易許多了。 如果已經跨出了第一步，剩下很容易就達成了。 基礎的學習 http://www.w3school.com.cn/css/ 當決定要學CSS時，就開始到處搜尋基礎的課程，相關的資源非常的多，只是怎樣的課程是好的課程，我當時的選擇是夠詳細且自己能夠理解的，上方這個就達到我的需求，這邊也推薦給大家。 這一個教程在CSS2的介紹算是非常全面且實用性很高，如果是有興趣的開發者或設計師，建議把此教程從頭看完。而其中我最推薦其中一個章節”CSS選取器”，這裡所介紹的基本選取器，許多CSS老手都不一定了解，詳讀之後必定會覺得功力大增。而本教程所不足的部分，建議可以參考以下連結，兩者都是W3C所提供的，內容其實大同小異，只是下方連結有更進階的CSS3教學。 http://www.w3schools.com/ 基礎非常的重要，馬步站的穩，怎樣也推不倒。 透過開發工具研究他人作品 基礎了解後，活用也是一個重點，但總不能憑空就能活用，所以可以透過平常的搜尋，發現不錯的網頁設計排版，就可以透過開發者工具去一層層的了解。 開發者工具推薦使用Chrome或是Firefox，尤其是前者目前有廣大的使用者支持，學習的重點可以放在： HTML的構造 CSS的語法 偽元素的運用 (pseudo-elements) 各種selector的運用 是否有結合javascript 至於開發者工具的使用技巧，就不在本篇的介紹囉～，最簡單的方法就是Chrome瀏覽器&gt;右鍵&gt;檢查元素 就可以開始玩了。 模仿是學習的開始。 廣泛的了解 除了自學外，要不斷地去了解新的動態，透過自己的搜尋探索，那簡直就是在黑暗中找物品，透過社群以及追蹤可以省去許多時間，只要一有新的動態，每個社群就會開始輪流發送，基本上不用擔心失去任何的訊息。這邊就推薦幾個活動力不錯的社群(台灣)： 高雄前端社群(這規定要放第一個) 為薄滴賽 = Web Design RGBA 網頁設計師社群 KSDG(高雄軟體社群超友情推薦) HTML5與CSS3在台灣(超專業社群) 一般的初學者，也可以透過以上順序當作入門的選擇(越上的越有親切感!?)，在進入社群後不只可以收到新的技術訊息、其他高手的協助，當有問題時在社群發問，也可以很迅速的獲得答案。 但要注意，社群雖然可以獲得許多的資源，但資源的篩選就是在個人。例如從社群可以知道Less、stylus、sass等CSS的進階語言，知道後就透過這些關鍵字去搜尋這些語言的相關資源，評估何種語言是最適合自己，再擇一去學習及精通。 俗話說：在家靠父母，出外靠朋友。 進階的學習 還是回到一開始所說的，跨出第一步是最重要的。Sass要從哪一個專案開始用？CoffeeScript要什麼開始學？想那麼多，不如下一個專案就開始吧，只要開始後，慢慢的學習，持之以恆的做下去，那麼這一個技能就是你的了。 就以Sass來說，其實我是在只會階層式語法就直接開始用了，反正編譯出來真的有問題(基本上也不會有什麼問題)，當CSS改也沒關係，最重要的事，我開始用sass了。只要有那個心，隨時都可以開始，但如果不斷的想下次再試試看，那就是永遠的下次。 一步一步慢慢走，持之以恆下去，目標就在眼前。 挑戰自己除了在專案上挑戰自己外，也可以再有空閒的時間嘗試新的技巧。2013年的鐵人賽對我影響很大，那時候正在挑戰每天發一篇文章，因為鐵人賽的關係，必須提升文章的品質，並且更深入的研究CSS3，在鐵人賽結束的時候，從本來不會CSS transform到可以運用許多transform 3D的技法。 到了現在，每天發文就是一個習慣，一段時間不發文就會有罪惡感-O-，而這到底是興趣還是被迫…？算興趣吧，但某方面來說已經變強迫症(笑)。 以上提到的，最重要還是一個”開始”，如果不知道怎麼開始，可以問問上方社群的人，不然就點畫面最下方有我的facebook，就來問我吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"在Jekyll中調整屬於自己的Template","slug":"jekyll-define-page","date":"2014-01-14T16:00:00.000Z","updated":"2016-10-12T06:28:55.000Z","comments":true,"path":"jekyll/2014/01/15/jekyll-define-page/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/15/jekyll-define-page/","excerpt":"會用jekyll有一部分是想要自己設計版型，我所擅長的是視覺設計、HTML、CSS，我就用這幾個技能設計自己的版型，當然這並不是那麼的一兩篇就可以介紹完。所以這篇會說明一個範例，介紹Jekyll中的版型運作邏輯，有興趣的使用者可以依據這概念設計屬於自己的blog。","text":"會用jekyll有一部分是想要自己設計版型，我所擅長的是視覺設計、HTML、CSS，我就用這幾個技能設計自己的版型，當然這並不是那麼的一兩篇就可以介紹完。所以這篇會說明一個範例，介紹Jekyll中的版型運作邏輯，有興趣的使用者可以依據這概念設計屬於自己的blog。 本篇重點調整jekyll bootstrap的版型，加入文章摘要於首頁，藉此了解jekyll bootstrap的運作方式。 參考：http://truongtx.me/tags.html#jekyll-ref 注意由於jekyll內不能連續輸入兩個大括號 或是 大括號+百分比，所以等等的大括號中間都會插入空白隔開，Copy時記得刪除….。 &#123; &#123; content &#125; &#125; ^ ^ //記得消除.. &#123; % include JB/setup %&#125; ^ //記得消除.. Jekyll bootstrap架構首先我們再來看一下網站架構，這邊列出可能會修改到的檔案。 |-- index.html #網站首頁 |-- _config.yml #網站設定檔 | |---/_includes #網站結構資料夾 | |--/JB #Jekyll-bootstrap 模組 | |--/themes #Jekyll-bootstrap 預設版型 | |---/_layouts #版型 | |---/_posts #文章資料夾 | |---/assets #CSS,JS 資料夾 前幾篇有介紹_config.yml，今天要介紹怎麼修改index.html的版型。 在傳統Jekyll架構中網站首頁的index.html可以透過設定檔去抓取_layouts內的版型，index.html設定參考如下： --- layout: default --- 而在Jekyll bootstrap內的_layouts會再去載入屬於它專有的版型，路徑就放在_includes/themes/twitter/內，而在layout內的default.html原始碼如下： --- theme : name : twitter --- &#123; % include JB/setup %&#125; &#123; % include themes/twitter/default.html %&#125; //前4行的是設定CSS的路徑 //後2行是在載入include/themes/twitter/內的default.html 而最後的include/themes/twitter/default.html的結構就像是一般的html，而以上的內容會被放在default.html的&#123; &#123; content &#125; &#125;內。 default.html的原始碼 而以上三個請參考這張圖，最左方的是跟目錄的index.html，透過一層一層的去取的Jekyll bootstrap版型。 開始上面的介紹有點抽象，接下來就來實際操作一次可能會更了解，請按照步驟慢慢地做下去。 步驟一首先打開include/themes/twitter/資料夾，並且創一個index.html檔案。 裡面程式碼請輸入以下(就這麼三行，剩下的他會去抓同層的default.html)： &lt;div class=&quot;content&quot;&gt; &#123; &#123; content &#125; &#125; &lt;/div&gt; 步驟二打開_layouts的資料夾，並且複製post.html於原位置，並且修改檔名為index.html。 打開index.html修改以下程式碼。 include themes/twitter/post.html 修改成 include themes/twitter/index.html 步驟三打開跟目錄的index.html，貼下以下程式碼。 程式碼：https://github.com/wcc723demo/wcc723demo.github.io/blob/master/index.html 接下來利用先前介紹的Ruby jekyll server來預覽看看網頁，應該會得到這樣的結果，他把目前頁面的前100字擷取了出來。 上面那一段的程式碼的內容如下(煩請自動補腦大括號)： for post in site.posts limit:10 //本站的10筆文章 post.title //等等會用來放置中文標題 if post.content contains &quot;&lt;!-- more --&gt;&quot; //如果內容包含&quot;&lt;!-- more --&gt;&quot; 就擷取到&quot;&lt;!-- more --&gt;&quot; //如果沒有就擷取100字 endfor,endif 語法結尾 步驟四 修改文章最後把/_posts/core-samples內的範例文章2011-12-29-jekyll-introduction.md打開，在文字中插入以下分隔語法。 &lt;!-- more --&gt; 最後在首頁就能看到文章的摘要，而如果增加文章，也會依這功能擷取摘要。 範例網站：http://wcc723demo.github.io/ 注意由於jekyll內不能連續輸入兩個大括號 或是 大括號+百分比，所以本文中的大括號中間都會插入空白隔開，Copy時記得刪除….。 &#123; &#123; content &#125; &#125; ^ ^ //記得消除.. &#123; % include JB/setup %&#125; ^ //記得消除..","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"在Jekyll設定自己的留言板","slug":"jekyll-disqus","date":"2014-01-13T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/14/jekyll-disqus/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/14/jekyll-disqus/","excerpt":"寫blog的作者，都會希望每篇文章都能有些回覆，所以一個留言機制是必要的，但是jekyll本身是屬於靜態網頁，並沒有資料庫，所以必須透過其他服務來做。在jekyll bootstrap內已經有包含disqus的留言板，而且設定容易，使用者也相當多，非常建議用disqus服務。","text":"寫blog的作者，都會希望每篇文章都能有些回覆，所以一個留言機制是必要的，但是jekyll本身是屬於靜態網頁，並沒有資料庫，所以必須透過其他服務來做。在jekyll bootstrap內已經有包含disqus的留言板，而且設定容易，使用者也相當多，非常建議用disqus服務。 本篇重點在jekyll bootstrap內建立屬於自己的留言板，主要會使用disqus，設定容易，使用方便。 Disqus許多網站，甚至是這次所建立的jekyll bootstrap，都應該有看過以下這個留言板，這是disqus的服務，不管是開發者或是使用者都相容易。他是用iframe嵌入在網站內，資料會存在disqus.com的server，所以開發者可以不用理會資料庫要怎麼建；而使用者可以用disqus或是facebook帳號登入就可以開始使用了。 http://disqus.com/ 開啟以上連結並先登入(我是用facebook)，上方有兩個選項For Websites 及 Using Disqus，Using Disqus是給一般使用者管理留言用，這次會用For Websites來增加到Jekyll網站。 點完就選擇Add Disqus to Your Site來增加到網站上吧。 這邊設定其實很容易，只要輸入一個site name就可以了，其他可以不設定，sitename這個值等等也需要回填到jekyll bootstrap上。 設定 _config.yml打開jekyll內的_config.yml，可以找到以下的內容。 comments : provider : disqus # 啟動的留言板服務，這邊就用預設即可 disqus : short_name : jekyllbootstrap # 將內容替換成剛剛在disqus上申請的site name livefyre : site_id : 123 intensedebate : account : 123abc facebook : appid : 123 num_posts: 5 width: 580 colorscheme: light 這部分就如上方所解說的一樣，把short_name修改成剛剛申請的site name。 comments : provider : disqus disqus : short_name : wcc723demo # 將內容替換成剛剛在disqus上申請的site name 之後只要和之前一樣上傳到github，就會發現留言板已經換成屬於自己的。 git add --all git commit -m &quot;disqus&quot; git push 完成 接下來回到網頁上，可以試著留言，而他的留言是依據網址，如果需要管理這些內容可以到disqus的後台(連Local都建了…)。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"在Winodws上運作jekyll","slug":"windows-jekyll-server","date":"2014-01-12T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/13/windows-jekyll-server/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/13/windows-jekyll-server/","excerpt":"Jekyll是在Ruby環境下運行，而Windows對於Ruby的支援性較差，所以在安裝時較為麻煩(Mac OS使用者可以直接參考官方網站)，並且會有些問題，有興趣的Windows user就來參考我這篇吧~(我至少從頭裝了5次!)。","text":"Jekyll是在Ruby環境下運行，而Windows對於Ruby的支援性較差，所以在安裝時較為麻煩(Mac OS使用者可以直接參考官方網站)，並且會有些問題，有興趣的Windows user就來參考我這篇吧~(我至少從頭裝了5次!)。 本篇重點介紹如何在Windows環境下安裝jekyll，並解決可能會遇到的問題，而Mac OSX使用者可以參考官方網站，如果在兩個環境都安裝一遍的情況下，會發現Mac OSX真的簡單太多了…。 Mac使用者可以從這裡開始閱讀 本篇適用於windows 7(64bit)、windows 8(64bit)，其他環境未測試。 Windows下安裝Ruby首先請打開以下連結，會看到不同版本的ruby installers，選定的Ruby版本等等會對應DevKit，如果沒有電腦內還沒有安裝Ruby的使用者，可以以參考本篇安裝2.0以上的 Ruby。 http://rubyinstaller.org/downloads/ 下載完後就開始安裝吧，語系也沒什麼好調的，只有英文跟日文= =。 接受License 路徑上可以用預設即可，如果在網路上搜尋問題，大部分的人也都是用預設路徑來回答。 安裝完成。 安裝完成後，在程式集內或是windows8的動態磚可以找到 Command Prompt with Ruby，而等等還要安裝DevKit。 安裝DevkitGem是Ruby的應用程序，而在windows中，許多的gem都需要透過DevKit才能夠使用，Jekyll也是，所以這邊要先安裝DevKit。 上一步驟的http://rubyinstaller.org/downloads/，從這邊下載DevKit，記得版本要對應上一步驟的Ruby版本，接下來如下解壓縮。 打開Command Prompt with Ruby 輸入以下指令 cd Devkit ruby dk.rb init 再輸入ruby dk.rb install，就可以完成Devkit安裝了。 ruby dk.rb install Mac OS使用者從這邊開始與Windows較為接近，可以從這邊開始閱讀。 安裝Jekyll剛剛的Command Prompt with Ruby，會一直使用，而Ruby的指令就直接輸入在這裏面，Mac OS的使用者就打開Terminal (終端機)吧。 首先升級gem。 gem update --system 接下來安裝jekyll。 gem install jekyll 接下來驗證jekyll是否有安裝完成，以及檢查版本 jekyll -v 啟用Jekyll辛苦建立的blog在這邊就可以看到了，在jekyll的資料夾下輸入jekyll server，就可以看到嚕。 jekyll server 這時候網址列只要輸入http://localhost:4000/，就可以看到剛剛建立的站台，注意：這個站台是在輸入jekyll server後產生的，如果檔案有修改，必須先停止jekyll server，再重新啟動才會看到新的修改 如果要停止只要按照說明按下Ctrl + C即可。 Windows 特有錯誤在我安裝過那麼多次，都一定會遇到的錯誤，就是Windows版 jekyll中文會有編碼的問題，只要輸入jekyll server就會出現以下錯誤。 這時候就要到Ruby裡的jekyll資料夾修改一些設定檔 在windows的Ruby安裝路徑找到convertible.rb這個檔案打開 C:\\Ruby200-x64\\lib\\ruby\\gems\\2.0.0\\gems\\jekyll-1.4.2\\lib\\jekyll\\convertible.rb 將convertible.rb裡的值如下修改，就可以修正這個問題 原 self.content = File.read_with_options(File.join(base, name), merged_file_read_opts(opts)) 改為 self.content = File.read(File.join(base, name),:encoding=&gt;&quot;utf-8&quot;) 接下來再輸入一次jekyll server試試看吧，這問題就會解決了。 Mac OS的優勢windows在每次修改完檔案後，都必須停止jekyll server，再重新啟動，網站才會更新；而Mac OS只要輸入jekyll server --watch，他就會自動偵測站台是否有儲存，只要有儲存動作就會更新網站。 jekyll server --watch 所以我喜歡在Mac OS寫文章…。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"利用Jekyll Bootstrap 快速建立Blog","slug":"jekyll-bootstrap","date":"2014-01-11T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/12/jekyll-bootstrap/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/12/jekyll-bootstrap/","excerpt":"Bootstrap是一套好用的framework，而jekyll就利用bootstrap的便利建立一套jekyll framework，稱作為Jekyll Bootstrap。除了版型外，還另外增加許多實用的模組，如Disqus、google analytic等等，本篇就來介紹如何在github上建立jekyll bootstrap。","text":"Bootstrap是一套好用的framework，而jekyll就利用bootstrap的便利建立一套jekyll framework，稱作為Jekyll Bootstrap。除了版型外，還另外增加許多實用的模組，如Disqus、google analytic等等，本篇就來介紹如何在github上建立jekyll bootstrap。 本篇重點接續前篇github的使用，請務必先參考前一篇的內容。而本篇會進一步的使用jekyll bootstrap，且建立在前篇所的github page，最後在介紹jekyll的發文方式及可能會遇到的問題。 安裝Jekyll bootstrap透過Jekyll bootstrap號稱可以從0開始到建立一個Blog只要3分鐘，但根據我的經驗…第一次建立應該要超過10分鐘，除非這流程已經練習好幾次了。 Jekyll bootrap 透過以上連結就可以到Jekyll bootrap的官方網站，詳細的介紹會放在文章的後半段，前半段會直接介紹如何安裝。再到Jekyll bootrap網站後，直接點選Code on Github。 到了github上，就把整個code下載到本機，而這邊我是直接Download zip。 下圖的左方是本機端(上次的github page資料夾)，右方則是下載的jekyll bootstrap，就把他們整個複製到本機端吧！ 接下來打開git shell，如果是mac os可以打開terminal，依序輸入以下git指令，將jekyll bootstrap上傳到github page伺服器。 git add --all git commit -m &quot;jekyll bootstrap&quot; git push 完成最後只要輸入username.github.io就可以看到以下的網站，這樣就代表成功了。 參考http://wcc723demo.github.io/ Jekyll設定在設定前，先了解Jekyll bootstrap的資料夾結構。 *僅列出部分* |-- index.html #網站首頁 |-- _config.yml #網站設定檔 | |---/_includes #網站結構資料夾 | |--/JB #Jekyll-bootstrap 模組 | |--/themes #Jekyll-bootstrap 預設版型 | |---/_layouts #版型 | |---/_posts #文章資料夾 所以在發文前，就先設定一下網站的名稱吧，打開_config.yml，可以找到title的設定，就把它改成自己的網站名稱，然後利用git push上傳吧。 在一段時間後，就可以看到網站的標題已經替換了。 發文發文我們這邊用它內建的文章做介紹，首先我們在以下路徑可以找到這篇文章，這篇使用教學。注意，jekyll的檔名上是有一定的規則年-月-日-標題.附檔名，副檔名則接受.md或是.html兩者都可以正常運作。 \\_posts\\core-samples\\2011-12-29-jekyll-introduction.md \\年-月-日-標題.md \\年-月-日-標題.html 接下來打開這篇文章，每篇文章的開始都需要一個yaml文件頭，用來設定一些數據，就如同資料庫的欄位一樣(注意：首行不能有空格)。他是利用’—‘來標記開始和結束。 --- layout: post #文章的版型 category: lessons #文章的資料夾 tagline: Supporting tagline #文章的標語 tags: #文章的tag - intro - beginner - jekyll - tutorial published: true #是否發佈 --- 所以在以上，應該有發現到沒有標題，因為標題要設定在檔名上，所以這邊不會有標題。這邊我就在文章的內部，用markdown加入一行字之後再用git push上傳。 接下來在github page上，看到內文有了改變。 參考連結 這時候可能會遇到的錯誤如果github page在此時如果編譯錯誤，他會發一封mail到用戶的信箱，如下圖，這是沒有驗證過的信箱…，要驗證後的信箱他才會正常的編譯。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"GitHub Page","slug":"jekyll-githubpage","date":"2014-01-05T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/06/jekyll-githubpage/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/06/jekyll-githubpage/","excerpt":"這一篇先介紹Github Page，這一個空間是每一個GitHub使用者都可以了解的地方，如果需要做一些DEMO給其他人看，可以試試看這方式，速度快，而且免費!","text":"這一篇先介紹Github Page，這一個空間是每一個GitHub使用者都可以了解的地方，如果需要做一些DEMO給其他人看，可以試試看這方式，速度快，而且免費! 本篇重點學會使用Github page，再參考本篇文章前，建議先有git基礎，而本篇是用git shell做demo，如果是mac OS使用者可以用terminal(還更簡單喔…)。 如果需要git shell，只要安裝github for windows就有附贈git shell了 申請 Github 帳號首先當然要先申請一個帳號，再申請的流程也不囉嗦，只要填入使用者名稱、E-mail、以及密碼即可。 新的儲存庫 (New repository)畫面的右方，應該可以找到如下的小框框，這邊會列出你所有的儲存庫，只要點其右上的New repository，就可以創立新的儲存庫。 這邊要特別注意了，因為是要for github page用，repository name要輸入username.github.io，剩下不需要特別設定，只要按下creat repository就創立了。 如果看到這個畫面，就代表已經創立成功，而他上方所顯示的https://github.com/username/...這一段等等會用到，可以先複製起來。 Push 一個文件檔首先先把儲存庫上的空儲存庫clone下來(我習慣這樣用)。 git clone https://github.com/username/.....剛剛那排 接下來建立一個index.html檔，內容如下。 &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hi~大家好 &lt;/body&gt; &lt;/html&gt; 如果新的檔案建立好就依下方輸入git指令： git add --all git commit -m &quot;first commit&quot; 最後在push上去(如果有要輸入帳密，就輸入吧)。 git push -u origin master 在剛剛的網頁重新整理後，可以看到那一個index.html已經傳上去了。 等待這時候網址請輸入username.github.io，可能會看到如下的畫面。 http://wcc723demo.github.io/ 但請不要灰心，就不斷地一直按F5，10分鐘內應該就可以看到如下面的畫面。 後記到這部分github page就算是成功了，而接下來就會開始接觸到jekyll，如果用過github的使用者應該是相當容易上手的。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"Emmet Live Style 加減用啦~","slug":"emmet-livestyle","date":"2014-01-03T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"tools/2014/01/04/emmet-livestyle/","link":"","permalink":"https://wcc723.github.io/tools/2014/01/04/emmet-livestyle/","excerpt":"livereload for Windows因為是測試版，經常性的有問題，有時候還會不能使用，這時候可以試試Emmet LiveStyle，他主要會針對CSS的部分直接reload。來看看官方的影片吧。","text":"livereload for Windows因為是測試版，經常性的有問題，有時候還會不能使用，這時候可以試試Emmet LiveStyle，他主要會針對CSS的部分直接reload。來看看官方的影片吧。 安裝http://livestyle.emmet.io/install/ 安裝流程都是參考官方文件。而這是Sublime Text的擴充功能，所以一定要用Sublime Text，流程如下： 安裝Package Control 安裝LiveStyle 擴充功能 安裝Chrome的 LiveStyle 擴充功能 使用LiveStyle 安裝Package Control這部分只要開啟Sublime Text，按下ctrl+`並且貼上以下的code即可。 import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 原諒我這段，這邊我懶得重裝了…，所以沒有圖。 安裝LiveStyle 擴充功能在Sublime Text上方的Preferences下找到Package Control。 選擇：Install Package 接下來輸入LiveStyle，就能安裝LiveStyle擴充功能 安裝Chrome的 LiveStyle 擴充功能打開這個網址Chrome Emmet LiveStyle，再加入倒Chomre就可以了。 使用 LiveStyleChrome的擴充元件，放在開發者工具裡，只要按下F12，就能看到開發者工具，找到LiveStyle並Enable LiveStyle for current page。 接下來開啟正在做的檔案(直接開就可以了) 修改CSS，不需要存檔，就會發現畫面上的CSS效果跟著改變囉。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"},{"name":"emmet","slug":"emmet","permalink":"https://wcc723.github.io/tags/emmet/"},{"name":"sublime text","slug":"sublime-text","permalink":"https://wcc723.github.io/tags/sublime-text/"}]},{"title":"Jekyll 介紹","slug":"what-is-jekyll","date":"2014-01-03T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/04/what-is-jekyll/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/04/what-is-jekyll/","excerpt":"本篇開始會重頭介紹Jekyll，如果對jekyll有興趣的開發者，請先必備以下的技能。 熟悉 Git (至少要會git push) 熟悉 Html (修改 template 及 寫文章用)","text":"本篇開始會重頭介紹Jekyll，如果對jekyll有興趣的開發者，請先必備以下的技能。 熟悉 Git (至少要會git push) 熟悉 Html (修改 template 及 寫文章用) 為什麼會考慮Jykell在用之前，先說一下過去用過什麼類似的CMS好了。 首先，我購買了一個php空間，什麼都不會的情況下，就用Wordpress建立了第一個blog，就個剛開始來說，他是挺方便的，只要上傳到空間就建完了。但我在這之中遇到了幾個問題： 版型不好改(主要是要配合許多內建的元件及php語法，要花很多時間理解)。 慢(1000元的美國空間配合強大的CMS…)。 如果要在文章內放入自己的demo不方便。 文章寫不方便(除了不是markdown外，光loading就很慢) 接下來，我自己用ajax寫了第二個blog(?)，也是現在這blog的前生a share a day，做這個的原因，一部分是針對wordpress不方便做改進，另一部份是為了挑戰100天發文。但是自己寫的要和強大的CMS挑戰，就如同XX比雞腿一樣…。接下來就遇到了一些問題： 文章一多很難管理(純html) Google 等搜尋引擎搜不到內容(試著處理，但還是有問題) 在這期間logdown出了，真的是非常非常適合寫程式的人使用，簡單的介面、流暢的操作，但是這不是我要的blog，原因如下： 我的CSS demo很多，這點還是不方便 free template缺乏個性 後來就是現在的Jekyll blog，它有一些優點，是我喜歡的： 自己做版型很容易，輕鬆做出自己的個性 做demo容易 快 管理容易 markdown 混用 html Jykell Necessary Skills在學習前，還是有學習門檻，往後的內容會牽涉到許多git及html，只要熟悉這兩個技能，建立就不會太困難。 熟悉 Git (push 到 github page 用) 熟悉 Html (修改 template 及 寫文章用) 雖然寫文章是用markdown，但都會寫markdown的應該就精通html了吧-.-。 What is JekyllJekyll是基於Ruby Gem的解析引擎，能夠將樣板、liquid 語言、markdown轉換為”靜態網頁”的產生器。http://jekyllrb.com/ 特色 No more databases 不需要資料庫 Liquid Template 動態模板 Free hosting with GitHub Pages 只要學會git push 就可以丟到github page上 Markdown 好編寫 Jekyll 的相關技術Git, Github, Github PagesGit版本控制工具，Github是使用git版本控制項目的的虛擬主機服務(這邊不再詳述)http://pages.github.com/Github Pages是Github提供的服務，可以建立自己的靜態頁面，而他有提供額外的Jekyll解析服務，在每次的git push後會將markdown轉換為靜態的html，且不需要任何databases，是很適合建立blog的服務。 特色 快速 html靜態頁就是快速。 穩定 大廠牌”github” 就是穩定。 免費 free! 容量無限 只要會git commit、git push。 MarkdownMarkdown的目標是實現「易讀易寫」，他在編寫完後就像是一般的文字檔，而不會像是程式語言，並沒有許多的標籤及指令。其語法都是用標點符號組成，主要目的是用來作為網路內容的寫作語言。相關範例建議參考 http://markdown.tw/ Liquid TemplateJekyll所使用的樣板語言，如果熟悉html或是其他樣板語言將會比較容易上手。 Jekyll 運作流程這分為兩種，一種是預計要使用的在github page上的，另一種是要在本地端預覽用的。而在github page呈現前，建議能夠在本地端正常運作，在push到github page上市能夠正常顯示的。 本地端Local 建立好本地端的Liquid Template以及文章，透過Jekyll server，就能產生出靜態的頁面。 Github Page在push Liquid Template後，之後每次都只需要push文章就可以，而每次push到github上的文章及Template，都會透過Jekyll server轉換為靜態的網站。 ###後記 Jekyll loacl端建議使用Mac OSX，由於工作的關係，我會頻繁地在兩種系統交換使用，Windows是在安裝上的注意事項就可以寫一整篇了…，OSX就去看官網吧，三到四行貼完就結束了。 不過我一開始是在Windows上建立的，接下來的文章還是會介紹我所遇到的問題。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"font-family要怎麼玩","slug":"font-family","date":"2013-12-31T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/01/01/font-family/","link":"","permalink":"https://wcc723.github.io/css/2014/01/01/font-family/","excerpt":"在平面設計中，字型的運用是一門高深的學問，而網頁設計中雖然大多使用內建的字體，但如果沒有的仔細的去調整，就像是word直接用內建的字型一樣，會產生不協調感。 參考 Just Font","text":"在平面設計中，字型的運用是一門高深的學問，而網頁設計中雖然大多使用內建的字體，但如果沒有的仔細的去調整，就像是word直接用內建的字型一樣，會產生不協調感。 參考 Just Font 本篇重點了解font-family的設定值，以及參考其他知名網站的設定方式。 font-familyfont-family分為兩個部分，一個是指定字體”family-name”，另一種是泛用字”generic-family”。 Formal syntax: [ &lt;family-name&gt; | &lt;generic-family&gt; ]# 泛用字 generic-family首先介紹泛用字，泛用字簡單來說，就是系統的明體、黑體、捲曲字等預設值，並不是指定特定的字體，而也可稱為”字體集”、”統稱字體”、”泛用字集”、”通用字體集”等，泛用字的類型如下： 注意：並非所有瀏覽器及系統的預設泛用字是相同的 泛用字集 中文 English serif 明體 貳零壹肆 新年快樂 2014 Happy New Year. sans-serif 黑體 貳零壹肆 新年快樂 2014 Happy New Year. cursive 捲曲字體 貳零壹肆 新年快樂 2014 Happy New Year. fantasy 花俏字體 貳零壹肆 新年快樂 2014 Happy New Year. monospace 等寬字體 貳零壹肆 新年快樂 2014 Happy New Year. 一般來說定義font-family時，會將泛用字放在最後方，參考如下。 &quot;Lucida Grande&quot;,Helvetica,Arial,Verdana,sans-serif //最後方的是sans-serif(黑體) 指定字體 family-name這部分就相當容易理解，只要直接輸入字型名稱即可，但特別要注意的是如果字體名稱中有空白，就必須用&#39;&#39; 或 &quot;&quot; 將他括起來。 但有少部分的字體，設定時需要注意它的英文及中文名稱，個瀏覽器的解讀不同，如IE就能夠接受”Microsoft JhengHei”，而Chrome則不行。 字體 中文 English \"Microsoft JhengHei\" 貳零壹肆 新年快樂 2014 Happy New Year. 微軟正黑體 貳零壹肆 新年快樂 2014 Happy New Year. 另外在優先順序上，放在前方的字體會先被套用，如果不能才會套用次要的字體，也可以利用這方式來套用不同的字體在中英文上。 如下方的範例，先”Segoe UI”，其次是”微軟正黑體”，最後再放泛用字。 font-family: &quot;Segoe UI&quot;,&quot;微軟正黑體&quot;,sans-serif 字體 中文 English \"Segoe UI\" 貳零壹肆 新年快樂 2014 Happy New Year. \"Segoe UI\",\"微軟正黑體\" 貳零壹肆 新年快樂 2014 Happy New Year. 參考font-family在每個網頁的設定都不相同，在Mac OS以及Windows上所擁有的字型也都不相同，在設定上也必須考量到其他系統使用者的觀感，這邊就提供幾間不同公司的font-family設定值。 Apple (TW)http://www.apple.com/tw/ font-family: &quot;Lucida Grande&quot;,Helvetica,Arial,Verdana,sans-serif Apple 貳零壹肆 新年快樂 2014 Happy New Year. 微軟台灣http://www.microsoft.com/taiwan/ font-family: &quot;微軟正黑體&quot;, &quot;Microsoft JhengHei&quot;, &quot;Segoe UI Semibold&quot;, &quot;Segoe UI&quot;, &quot;Lucida Grande&quot;, Verdana, Arial, Helvetica, sans-serif Microsoft 貳零壹肆 新年快樂 2014 Happy New Year. Yahoo (US)http://www.yahoo.com/ font-family: &apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif Yahoo 貳零壹肆 新年快樂 2014 Happy New Year. Googlegoogle的設定值最泛用….。 https://www.google.com font-family: arial,sans-serif Google 貳零壹肆 新年快樂 2014 Happy New Year.","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"前端軟體-Prepos介紹","slug":"prepos-intro","date":"2013-12-26T16:00:00.000Z","updated":"2016-10-12T06:04:14.000Z","comments":true,"path":"tools/2013/12/27/prepos-intro/","link":"","permalink":"https://wcc723.github.io/tools/2013/12/27/prepos-intro/","excerpt":"情境當在進行前端設計的時候，如果想要分享Html給夥伴看看，有哪些方式呢？ 叫他過來看 截圖之後，傳line給他看 上傳到空間，丟網址給他看 今天介紹一個更快的方式，利用prepos免上傳，直接傳網址給他看。","text":"情境當在進行前端設計的時候，如果想要分享Html給夥伴看看，有哪些方式呢？ 叫他過來看 截圖之後，傳line給他看 上傳到空間，丟網址給他看 今天介紹一個更快的方式，利用prepos免上傳，直接傳網址給他看。 本篇重點Prepos的功能相當多，除了產生可以跨裝置的網址外，還可以編譯相當多語言，如LESS, Sass, SCSS, Stylus, Jade, Slim, Coffeescript, LiveScript, Haml and Markdown等等，另外還可以做圖檔優化。 這次就介紹Prepos這套軟體，從安裝到執行，一次搞定。注意：跨裝置限定區網 本篇範例使用prepos 4.0.1 安裝link: http://alphapixels.com/prepros/ 本篇是利用OSX做介紹，但是本套軟體在windows上也可以使用，操作基本上是接近的，所以不管是哪一個系統的使用者都可以快速上手。 在進入網站後，左方可以選擇下載的版本，大家就選擇要使用的版本下載吧(這次只會介紹他的免費版)。 下載後，只要就點兩下解壓縮 因為是網路上下載的，所以在prepos.app上按住cmd + 滑鼠左鍵 選擇打開 接下來會出現提示視窗，直接按打開就可以了。 另外他還有提供Install Chrome Extension的連結，可以安裝其Chrome擴充程式，但如果有安裝livereload，就可以不安裝它提供的擴充程式。 使用這套操作界面很直覺，如果有使用過fire.app等等軟體，相信很快就能上手。 這次就拿aShare的原始版型檔做範例吧，只要把資料夾整個拖曳到prepos裡就可以了。 丟進去後，他就會列出這個專案裡所有可以編譯檔案。 每一個檔案，還能單獨設定其編譯設定。另外在下方有一個地球的圖案(Live preview)，點擊後就會開啟瀏覽器，直接預覽網頁。 這邊就介紹我最喜歡的功能 跨裝置測試(Multi Device Testing)，點擊Prepos右上方功能列，類似手持裝置的符號。 接下來就可以獲得跨裝置的資訊，只要在其他裝置輸入以上網址，或者是利用qrcode就可以預覽這個專案。 輸入以上網址，就可以看到Prepos全部的專案 選擇專案就可以開始預覽，如果沒有錯誤，就把這個網址傳給夥伴吧～。注意：跨裝置限定區網 跨裝置測試這套軟體他的livereload和其他相似軟體不同之處，就是在跨裝置也可以livereload(免費版只能對於有編譯的檔案livereload)，以下就來直接做範例給大家看吧。 這個是手機版上所看到aShare版型 接下來把Sass中的色彩變數改成紅色 於是乎，手機上的色彩就會自動轉成編譯後的色彩 結語Prepos在概念上是很棒的一套軟體，在3.0.X版本的時候我就有接觸過，但是當時他經常性的編譯錯誤(有時候多按個save又編譯成功= =)，所以我在使用時，都是開fire.app，然後關閉prepos的auto compile，僅使用它的跨裝置功能。而最近他出4.0.1版，有空可以多拿來玩看看還有沒有類似的問題。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"簡易CSS transform 視差效果","slug":"css-transform","date":"2013-12-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/12/24/css-transform/","link":"","permalink":"https://wcc723.github.io/css/2013/12/24/css-transform/","excerpt":"在先前範例中可以得知，CSS transform 來做視覺特效，效能會比原始的CSS2還要好，所以本篇就利用css transform 以及hover來簡單做一個互動的效果吧！","text":"在先前範例中可以得知，CSS transform 來做視覺特效，效能會比原始的CSS2還要好，所以本篇就利用css transform 以及hover來簡單做一個互動的效果吧！ 本篇重點利用hover結合css transform來作出簡易互動效果，而本篇主要是CSS3，所以將會使用sass做範例。 Demo滑鼠移過下方的區域時，下方的兩個角色會靠近，另外在滑鼠在角色的圖片上時，角色會從模糊變成清楚。 圖片來源：英雄聯盟 原理在這範例用的是用CSS 3D，而在滑鼠移過時，會移動兩個角色的X軸，使其有簡易的視差效果。 .transform3d height: 500px +transform-style(preserve-3d) //如果要做3D效果，其外層必須要有transform-style(preserve-3d) &amp;:hover //滑鼠滑過時執行以下效果 .ez //左邊那個手指男 +transform(translate3d(50%,0,0)) //X軸向右位移50% .ziggs //右方的炸彈男 +transform(translate3d(-50%,0,0)) //軸向左位移50% 製作先來看看html結構，如果要使用transform 3d，記得其外層一定要有transform-style(preserve-3d)這個屬性transform3d這一個class就是這個用途，而span內分別包著一張角色圖片。 &lt;div class=&quot;demo&quot; data-demo=&quot;Hover me!&quot;&gt; &lt;div class=&quot;transform3d&quot;&gt; &lt;span class=&quot;ez&quot;&gt;&lt;img src=&quot;/images/2013-12-23-lol-f.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt; &lt;span class=&quot;ziggs&quot;&gt;&lt;img src=&quot;/images/2013-12-23-lol-zig.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 完整sass大部份的功能，都直接寫在註解裡，這樣比較容易理解，另外filter是比較耗效能，建議不要結合transition(等等下方會有範例)。 .demo position: relative //定位角色初始位置 .transform3d height: 500px +transform-style(preserve-3d) //如果要做3D效果，其外層必須要有transform-style(preserve-3d) &amp;:hover //滑鼠滑過時執行以下效果 .ez //左邊那個手指男 +transform(translate3d(50%,0,0)) //X軸向右位移50% .ziggs //右方的炸彈男 +transform(translate3d(-50%,0,0)) //軸向左位移50% span //定義角色共通屬性 width: 40% display: block position: absolute bottom: 0 +transition(transform 1s ease-in-out) //動態轉場效果(僅對transform有效) img +filter(blur(5px)) //模糊濾鏡 width: 100% &amp;:hover +filter(blur(0)) .ez //手指男靠左 left: 0 .ziggs //炸彈男靠右 right: 0 再一次demo 增加filter 效果這部分在增加一個filter的drop-shadow效果，這樣會更有層次，但是效能會更差一點。而這邊要表現的效果，就是角色後方的陰影，會因為hover而改變位置。因filter效能不好，較好的方式還是在後方增加一層圖片，然後再用transform去改變其位置。 .ez +filter(drop-shadow(-5px 0 0 rgba(black ,.5))) .ziggs +filter(drop-shadow(5px 0 0 rgba(black ,.5))) &amp;:hover .ez +transform(translate3d(50%,0,0)) +filter(drop-shadow(5px 0 0 rgba(black ,.5))) .ziggs +transform(translate3d(-50%,0,0)) +filter(drop-shadow(-5px 0 0 rgba(black ,.5)))","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"效能更好的banner animation","slug":"banner-animation-2","date":"2013-12-18T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/12/19/banner-animation-2/","link":"","permalink":"https://wcc723.github.io/css/2013/12/19/banner-animation-2/","excerpt":"之前有一篇介紹利用background-position製作動態的banner，不久後就接到效能不好的問題，所以我就重新用另一種方式製作，發現效能有明顯的提升，也很有成就感，本篇就介紹不同的動態banner作法。","text":"之前有一篇介紹利用background-position製作動態的banner，不久後就接到效能不好的問題，所以我就重新用另一種方式製作，發現效能有明顯的提升，也很有成就感，本篇就介紹不同的動態banner作法。 本篇重點利用css transform的方式，去改善動態banner的效能。(由於本篇主要是CSS3，所以會用sass作範例。) Demoiframe 連結 原理這是利用transform配合animation來進行位移。 +keyframes(&quot;banner-slider&quot;) //建立一個keyframe from +transform(translate3d(0, 0, 0)) //起始點 to +transform(translate3d(image-width(&quot;banner-01.png&quot;), 0, 0)) //位移x，值為圖片的寬度 而如果直接套用，則會有另一個問題，就是圖片是位移了，但是不夠大。如下圖，紅框假設是使用者所見到的位置，淺色的部分是目前的圖片，黑色是期望有出現，但並沒有的顯示的圖片；因為這個問題，所以需要另外再補上一張圖片。 在這邊我是利用偽元素:pseudo-element來複製出所需要的圖片，目的就是要在目前的左方先補上一張相同的圖片。 製作由於製作方式不同，所以html的結構也有所改變，目前的html如下。 &lt;div class=&quot;banner&quot;&gt; &lt;div class=&quot;banner-wrap&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; class=”banner” 主要是用來定位，以及裁切多餘的部分 class=”banner-wrap” 主要用來做動畫 span 圖片的位置 Sass首先製作keyframe的部分 //由於compass 目前沒有animation，所以可以自己做animation的功能 =keyframes($name) //keyframes @mixin @-webkit-keyframes #&#123;$name&#125; @content @-moz-keyframes #&#123;$name&#125; @content @-ms-keyframes #&#123;$name&#125; @content @keyframes #&#123;$name&#125; @content =animation($content) //animation @mixin -webkit-animation: $content -moz-animation: $content -o-animation: $content animation: $content +keyframes(&quot;banner-slider&quot;) //建立一個keyframe from +transform(translate3d(0, 0, 0)) //起始點 to +transform(translate3d(image-width(&quot;banner-01.png&quot;), 0, 0)) //位移x，值為圖片的寬度 //這部分我原本是用translate3d去做 //後來改成2D效果及效能也是差不多的 class的樣式如下 .banner position: relative min-height: $headerHeight width: 100% overflow: hidden //超出範圍的部分不顯示 .banner-wrap +animation(banner-slider 180s infinite linear) //載入剛剛的動畫keyframe span,span:after //span以及其偽元素的樣式 display: block min-height: $headerHeight width: 100% background: image-url(&quot;banner-01.png&quot;) top left repeat-x //top left的功能是要讓圖片從左邊開始 span:after //補上偽元素所需要的屬性 background-position: top right //偽元素從右邊開始，使其可以左右相接 content: &quot;&quot; +transform(translate(-100%, 0)) //將偽元素移到目前位置左方 效能原本的background-position作法我在測試時都是用不太差的桌上型主機做測試，所以完全沒注意到效能的問題，但經過反映以後，利用chrome去測試，效能真的不好。 background-position的效能 transform的效能(幾乎沒有感覺啊!!) 本篇是用sass做介紹，如果想了解所產生的css，可以參考http://codepen.io/Wcc723/pen/wFrCn。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"jQuery step by step 教學","slug":"jquery-step-by-step","date":"2013-12-17T16:00:00.000Z","updated":"2016-10-12T06:16:05.000Z","comments":true,"path":"jquery/2013/12/18/jquery-step-by-step/","link":"","permalink":"https://wcc723.github.io/jquery/2013/12/18/jquery-step-by-step/","excerpt":"不久前在高雄前端社群有介紹jquery教學，我的部分盡量做成一個步驟一個步驟，且就算沒有人教，也可以看著講義做下去。","text":"不久前在高雄前端社群有介紹jquery教學，我的部分盡量做成一個步驟一個步驟，且就算沒有人教，也可以看著講義做下去。 本篇重點jQuery和純javascript而言相對容易非常多，而網頁設計師如果需要一些效果，不妨先試試看jQuery來做看看，而透過以下範例，一步步的學會jquery的一些效果(本篇”不”適合用手機看)。 教學頁面下面的頁面裡，每一個效果都有另一個空白試題，透過空白試題更能輕鬆地了解每個效果的寫法。 iframe 連結","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"}]},{"title":"純 \"CSS\" Banner animation教學","slug":"banner-slider","date":"2013-12-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/12/16/banner-slider/","link":"","permalink":"https://wcc723.github.io/css/2013/12/16/banner-slider/","excerpt":"在座這網站的時候，上方有保留一塊區域打算放banner，一般來說banner都會用jquery跑馬燈的方式去做，但是對我來說那要做好幾張圖…好麻煩，所以我就做一張連續圖片(左右可以相連的圖片)，讓他不斷的向右移動。","text":"在座這網站的時候，上方有保留一塊區域打算放banner，一般來說banner都會用jquery跑馬燈的方式去做，但是對我來說那要做好幾張圖…好麻煩，所以我就做一張連續圖片(左右可以相連的圖片)，讓他不斷的向右移動。 本篇重點本篇會介紹如何用css寫出類似本站上方的banner。 CSS範例 準備圖片一開始當然要先做一張圖，圖的重點是左右方可以相連的，如下圖最左方的chrome是被切一半，和右方的另一半chrome剛好可以接起來。另外這banner的寬度是”1122px”，等等會用到這寬度。 CSS直接介紹CSS的寫法，會比較容易了解其原理，這是利用css3 Animation的語法製作，Animation 包含keyframes 及 animation，前者是物件運動的時間軸，相當於劇本；後者是keyframes所呈現的方式(directive)，這兩者都是必要的，缺一不可。 首先介紹keyframes @keyframes banner-slider &#123; /*banner-slider 是自訂義命名，本篇命名為banner-slider*/ from &#123; /*開始*/ background-position: 0 0; &#125; to &#123; /*結束，在結束時background-position的x移動了1122px*/ background-position: 1122px 0; &#125; &#125; 介紹animation animation: banner-slider 180s infinite linear; /*banner-slider 是keyframe的名稱*/ /*180s 是整段keyframes的時間*/ /*infinite 無限次輪播*/ /*linear 播放速率是固定的(線性)*/ 完成CSS3是很麻煩的語法，要依瀏覽器寫入對應的前輟詞，如果有興趣的設計師，可以直接複製下方CSS，然後把圖片略做修改就可以玩看看囉。 .banner &#123; background: url(&apos;/images/banner-01.png&apos;) center repeat-x; min-height: 300px; -webkit-animation: banner-slider 180s infinite linear; -moz-animation: banner-slider 180s infinite linear; -o-animation: banner-slider 180s infinite linear; animation: banner-slider 180s infinite linear; &#125; @-webkit-keyframes banner-slider &#123; from &#123; background-position: 0 0; &#125; to &#123; background-position: 1122px 0; &#125; &#125; @-moz-keyframes banner-slider &#123; from &#123; background-position: 0 0; &#125; to &#123; background-position: 1122px 0; &#125; &#125; @-ms-keyframes banner-slider &#123; from &#123; background-position: 0 0; &#125; to &#123; background-position: 1122px 0; &#125; &#125; @keyframes banner-slider &#123; from &#123; background-position: 0 0; &#125; to &#123; background-position: 1122px 0; &#125; &#125; 如果本篇有任何疑問，也歡迎在下方留言。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"aShare使用技術","slug":"ashare-technology","date":"2013-12-13T16:00:00.000Z","updated":"2016-10-12T06:01:22.000Z","comments":true,"path":"jekyll/2013/12/14/ashare-technology/","link":"","permalink":"https://wcc723.github.io/jekyll/2013/12/14/ashare-technology/","excerpt":"上一篇簡單介紹了本站為什麼選擇jekyll，但是這其中並不是只有這一項技術就可以達成，其中除了我已經很熟悉的html、css、sass外，必須要了解Git、Liquid、Markdown等等的技術，當然其中會有許多困難，但是不斷的突破困境是進步最快的方式。 本站所使用的技術如下 Jekyll Liquid github github page Markdown Sass compass fire.app","text":"上一篇簡單介紹了本站為什麼選擇jekyll，但是這其中並不是只有這一項技術就可以達成，其中除了我已經很熟悉的html、css、sass外，必須要了解Git、Liquid、Markdown等等的技術，當然其中會有許多困難，但是不斷的突破困境是進步最快的方式。 本站所使用的技術如下 Jekyll Liquid github github page Markdown Sass compass fire.app 為何要建立一個使用這麼多技術的blog雖然這些技術看起來非常的多，但有一半已經是經常使用的，而另一部份是應該去學習，卻一直沒有機會，如果可以透過建立blog的方式順便學習，還真的是挺划算的。 Jekyll Jekyll是這個blog的核心，它是一個靜態網站的生成器，還多裡面運行了Textile、Markdown或Liquid的編譯器，透過這些功能可以產生一個完整的靜態網站。 光是這樣介紹真的很模糊，未來的章節會介紹如何建置jekyll靜態網站。 Liquid本站上主要的版型模組都是用Liquid建置，像是右邊的Related Posts、Recent Posts、Tags等等。而這我並不是很擅長，但也不是很難…，只要看得懂html，大部分都是複製、貼上，重新修改就可以了。 Git &amp; Github &amp; Github page 這三個有連帶關係，因為我是放在github page上，所以要用github，因為要用github所以一定要用git。git是版本控管的工具。任何專案保存的過程中，其演進的歷程及紀錄都是非常重要的，而git就是紀錄這些的工具。 github則是git的大型線上儲存庫，讓使用者可以透過雲端的管理，在不同的地方都可以進行作業(git相當複雜，有興趣可以參考保哥的介紹)。 github page，是github提供的額外服務，他可以將push到github上的檔案，透過jekyll轉換成靜態頁，github page優勢如下： 快速 html靜態頁就是快速。 穩定 大廠牌”github” 就是穩定。 免費 free! 容量無限 只要會git commit、git push。 MarkdownMarkdown的主要目的就是要拿來寫作用，由於html的標籤有一點點混亂，所以在編寫時有一點點麻煩，Markdown簡化了許多寫法。 Markdown範例 html的寫法 &amp;lt;h1&amp;gt;Markdown&amp;lt;/h1&amp;gt; Markdown的寫法 # Markdown 它就是簡化寫法的語言而已，不過如果沒用Markdown，純html寫blog找段文字都會看到眼瞎是真的。 Sass &amp; Compass &amp; Susy sass是CSS的高階語言，透過sass可以一行抵三行，有效率的編寫及管理CSS，說實在沒用這類型的東西，我不知道該怎麼寫好CSS了。 而Compass是sass的擴充framework，compass有許多擴充功能如css3 前輟詞以及提供許多@mixin以供使用者運用。 另外的susy是基於sass、compass的版型framework，優勢在於可以快速建立responsive web，和其他grid system (ex:bootstrap)不同的是html乾淨、自由、class 語意化，熟悉susy的使用者在建立responsive web可以比bootstrap更快速。 製作小心得本站在結束ashareaday後大概兩周就大致完成了，第一周花了很多時間在學習git以及測試jekyll，只會用github for windows的情況下開始學，到現在主要都用github shell或是mac 終端機在作業了，以上是題外話…。 測試jekyll時遇到超多的問題，之後再介紹jekyll時會有詳細的介紹，而剛開始我是用jekyll bootstrap做測試，在許多的問題都克服(如中文、編譯錯誤等)以後，才開始正式執行。 第一周測試完後，第二周開始製作版型，說實在sass、compass、susy加起來真的太快了(大推…)，配合自己平常準備的模組，一個早上就完成大部分的。而這個網站在設計上，當然就是走現在主流的扁平化設計，簡單且沒有太多的裝飾。 在版型完成後，就替換掉jekyll bootstrap，把原本的html css抽換，保留許多的Liquid模組，就大致完成了aShare，而許多不足的地方，就是不斷地搜尋及測試。 ashareaday是在2013/11/30結束，它讓我學習太多了，而這個網站會保留其大部分文章，且會以更精緻的方式執行下去。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"intro","slug":"intro","permalink":"https://wcc723.github.io/tags/intro/"},{"name":"beginner","slug":"beginner","permalink":"https://wcc723.github.io/tags/beginner/"},{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"Just Another Beginner~","slug":"just-another-beginner","date":"2013-12-09T16:00:00.000Z","updated":"2016-10-12T05:59:44.000Z","comments":true,"path":"jekyll/2013/12/10/just-another-beginner/","link":"","permalink":"https://wcc723.github.io/jekyll/2013/12/10/just-another-beginner/","excerpt":"告別了一百多天的aShareaDay，在這裡即將有新的開始。在結束aShareaDay前一直在思考要用什麼樣的平台繼續寫文章，其中的選項有： 目前超夯的logdown 自由簡單的wordpress 以及jekyll 當然，看到我這網站的位置，就是使用Jekyll in Github page，本篇就是要說明我用jekyll的原因。","text":"告別了一百多天的aShareaDay，在這裡即將有新的開始。在結束aShareaDay前一直在思考要用什麼樣的平台繼續寫文章，其中的選項有： 目前超夯的logdown 自由簡單的wordpress 以及jekyll 當然，看到我這網站的位置，就是使用Jekyll in Github page，本篇就是要說明我用jekyll的原因。 aShareaDay 的問題在很久之前有參加一次KSDG的活動(忘記活動名稱了..，大約是半年前吧)，那次是介紹github page，也在那一次聽說了jekyll，那次只是個開始。約幾個月後，我開始寫aShareaDay，aShareaDay是利用ajax撈其他頁面的資料，而每天的post都是一個html檔，利用ajax載入，這樣可以做出類似CMS的管理效果，但是…我的js並不是很強，所以aShareaDay其實並不完美，尤其是google analytic一直沒有辦法完整的分析，以及搜尋工具無法搜尋到aShareaDay的文章資料。 aShareaDay的優缺點優點： 會寫html就可以上傳文章 做demo超方便(如果是用codepen寫demo有連續性的問題) ftp輕鬆上傳，輕鬆改 缺點： 沒有留言功能…(這樣就沒有回饋) google搜尋不到文章內容(我試過了，最多我只能讓他搜尋到ajax的menu…) 在aShareaDay快結束前，我開始尋找其他解決方案，列入考慮的就是摘要所提的那三點(logdown、wordpress、jekyll)。 logdown 目前來說，這是一個很夯的blog，markdown、拖曳上傳這些方式都能有效的減少文章編寫的時間，如果硬要說他的缺點就是 1.不好做demo，2.內建的樣板……真的….讓人沒有付費的勇氣。 wordpress 其實，他除了樣板多及可以架在自己的server上缺點還挺多的…，除了logdown的不好做demo缺點外它還有幾個缺點 1.寫文章很困難，2.高流量的問題，3.有點慢。 jekyll 我不能說它能解決所有的問題，畢竟我還是在測試中，它至少可以解決原本aShareaDay的問題，以及保有aShareaDay的優缺點的優點，所以我目前考慮用jekyll。 Jekyll透過 Jekyll 可以將靜態 html 或是 markdown 快速生成一個blog，而他所產生的blog是沒有包含資料庫的純靜態html網頁，在技術上的好處當然就是速度快、簡單，缺點就是留言等功能必須仰賴DISQUS等。 Github 提供靜態網頁的服務，稱作為github page，而他也支援jekyll(如何使用在未來有機會在介紹)，兩個在一起就是無線流量、容量的blog，只要寫好新的文章commit就可以post新的文章。 缺點：馬的，明明就很難 !","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"intro","slug":"intro","permalink":"https://wcc723.github.io/tags/intro/"},{"name":"beginner","slug":"beginner","permalink":"https://wcc723.github.io/tags/beginner/"},{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"jQuery Mobile 載入google map顯示不完全的問題","slug":"jqm-and-google-map","date":"2013-11-08T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/09/jqm-and-google-map/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/09/jqm-and-google-map/","excerpt":"Jquery Mobile的頁面載入google map會有一個bug(如第一個Go map button)，這一個bug會造成map只有顯示一小塊(如果螢幕大一點的裝置，就真的是很小一塊了)。","text":"Jquery Mobile的頁面載入google map會有一個bug(如第一個Go map button)，這一個bug會造成map只有顯示一小塊(如果螢幕大一點的裝置，就真的是很小一塊了)。 問題 會這樣的原因是jquery mobile在未載入的頁面會是display: none，所以在載入google map時就會有空間不夠大的問題，這邊有兩種解決方式提供給大家參考。 initialize() //這是載入地圖的function google map api參考：https://developers.google.com/maps/documentation/javascript/examples/map-simple 關閉轉場動畫 效果參考Go Map2 (no transition)的按鈕。 $('#Map2').on('click',function(){ $.mobile.changePage( \"#map\", { transition: \"none\", changeHash: true }); //把換頁的動畫設成none initialize(); }); 延遲執行 效果參考Go Map3 (time out function)的按鈕。 var mytimeout; $('#delayMap').on('click',function(){ mytimeout = window.setTimeout(initialize, 500); //延遲載入地圖的時間 }); JS Bin","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"mobile","slug":"mobile","permalink":"https://wcc723.github.io/tags/mobile/"}]},{"title":"利用json取得公開資料(3) 並繪製圖表","slug":"js-json4","date":"2013-11-05T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/06/js-json4/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/06/js-json4/","excerpt":"上次已經把資料放進表格內，接下來我們可以透過一些圖表功能來視覺化這些資料，這邊可以透過一些線上資源來繪製圖表。 圖表plugin：http://www.open-open.com/ajax/ajax20090708091447.htm","text":"上次已經把資料放進表格內，接下來我們可以透過一些圖表功能來視覺化這些資料，這邊可以透過一些線上資源來繪製圖表。 圖表plugin：http://www.open-open.com/ajax/ajax20090708091447.htm 圖表 上面有我找到的一個圖表插件，就來試試看吧。不過在做之前要先注意到，json在取得之後並且放入表格是需要時間的，而圖表匯製的function也必須要在表格完成後執行，所以繪製的function必須放在json載入並寫入表格後執行。 上一次的資料不適合繪製圖表，所以換成\"空氣汙染\"的。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/AQX/?$orderby=SiteName&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '台南市' $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ list = ''+ item.SiteName+''+ item.PSI+''+ item.SO2+''+ item.NO2+''+ item.O3+''; $('.itemlist').append(list); }; }); //$('#chartData').visualize({type: 'pie', pieMargin: 10, title: '2013 台南區 PSI圓餅'}); $('#chartData').visualize({type: 'line'}); //$('#chartData').visualize({type: 'area'}); }); })(); //記得先載入以下的js 及 CSS //visualize.jQuery.js //visualize.jQuery.css (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/AQX/?$orderby=SiteName&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '台南市' //地點換成台南市 $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ list = '&lt;tr&gt;&lt;th&gt;'+ item.SiteName+'&lt;/th&gt;&lt;td&gt;'+ item.PSI+'&lt;/td&gt;&lt;td&gt;'+ item.SO2+'&lt;/td&gt;&lt;td&gt;'+ item.NO2+'&lt;/td&gt;&lt;td&gt;'+ item.O3+'&lt;/td&gt;&lt;/tr&gt;'; //表格列結構及資料 $('.itemlist').append(list); //將表格列插入table }; }); $('#chartData').visualize({type: 'line'}); //繪製圖表的function }); })(); 二氧化硫濃度 一氧化碳 二氧化氮 臭氧濃度","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"利用json取得公開資料(2)","slug":"js-json3","date":"2013-11-04T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/05/js-json3/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/05/js-json3/","excerpt":"在上回已經取得資料，這次就來把取回來的資料放入到表格內。","text":"在上回已經取得資料，這次就來把取回來的資料放入到表格內。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '高雄市' $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ list = ''+ item.SiteName+''+ item.PublishTime+''+ item.TWD97Lon+''+ item.UVI+''; $('.itemlist').append(list); }; }); }); })(); $.each 取回的資料是很多個物件，物件內還有著陣列，陣列內都包含著一個名稱及一個值(如下圖)，物件內包含著\"SiteName\"的名稱及\"嘉義\"等地名的值，首先要把每一個物件拆開，就需要用到$.each。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { //把每一個物件拆開來執行一次function console.log(item); }); }); })(); 接下來的console(item)就會看到上面那張圖的內容。 取出個別的資料 這份資料相當的多，所以要先做個過濾，從上面得知的結果，他有一個county的名稱，裡面有不同的縣市名稱，試試看取出高雄市的資料就好。先定義一個變數\"_DefaultContry\"其值為高雄市。 另外在資料可以用item.SiteName的方式取出，等等就一次做完吧~。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '高雄市' //定義高雄市的變數 $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ //假設是高雄市才執行 list = ''+ item.SiteName+''+ item.PublishTime+''+ item.TWD97Lon+''+ item.UVI+''; //利用item.值，把每一個值取出，並寫成一個html存在list的變數內 $('.itemlist').append(list); //最後把剛剛的html放到表格內 }; }); }); })(); 最後就會產生如下的結果(如果沒有失聯的話，下面是有內容的...)。 測站名稱 發布時間 經度(TWD97) 紫外線指數","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"利用json取得公開資料","slug":"js-json2","date":"2013-11-03T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/04/js-json2/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/04/js-json2/","excerpt":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。 今天就來試試看抓政府的公開資料吧。","text":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。 今天就來試試看抓政府的公開資料吧。 找一個公開的json資料 政府現在有許多公開資料，是使用json格式，而最近工作的關係，剛好知道環保署有提供公開資料。 環境資源資料開放平台：http://opendata.epa.gov.tw/ 紫外線即時監測資料http://opendata.epa.gov.tw/Data/Contents/UV/ 資料非常多，就找一個較短的來做測試，所以就用紫外線資料來做測試吧。 取得資料 我們把jquery官網上所提供的API拿過來改看看，看看能不能得到我們想要的資料。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { console.log(data); //$.each( data.items, function( i, item ) { // console.log(item) //}); }); })(); (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json\"; $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { console.log(data); }); })(); 把上面的code改完以後，看一下console的結果，會發現下面的回應。而主要原因是javascript不能夠跨網域，所以必須做一些調整。 XMLHttpRequest cannot load http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json. Origin http://127.0.0.1:24681 is not allowed by Access-Control-Allow-Origin. 在網址的後方加上&callback=?，這樣js就可以進行跨網域的請求。 參考：http://blog.johnsonlu.org/javascript%E9%80%8F%E9%81%8Ejsonp%E5%AE%8C%E6%88%90%E8%B7%A8%E7%AB%99%E8%AB%8B%E6%B1%82/ (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; //加上&callback=? $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { console.log(data); }); })(); 如果可以傳回像下面這些物件資料，就已經算是取得資料了，而把物件點打開，就可以得到各縣市的空氣品質資料，再配合環保局所提供的API，可以了解個欄位所代表的意義。 [Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object] County: \"嘉義市\" PublishAgency: \"中央氣象局\" PublishTime: \"2013-11-04 08:00\" SiteName: \"嘉義\" TWD97Lat: \"23,29,52\" TWD97Lon: \"120,25,28\" UVI: \"0\"","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Json","slug":"js-json","date":"2013-10-31T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/01/js-json/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/01/js-json/","excerpt":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。","text":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。 Json http://zh.wikipedia.org/zh-tw/JSON 如果需要看簡介，可以看wiki的介紹，不過要特別注意的就是他的結構。 //物件 （object） //利用{}所包起來的 {name:value} //陣列 Array //利用[]所包起來的 [collection, collection] 如果對js有一咪咪概念的話，相信會對後面的介紹很容易了解。 Jquery 小朋友都愛寫jQuery，因為比較簡單，所以在這就用jQuery介紹json。 http://api.jquery.com/jQuery.getJSON/ 如果打開jQuery介紹json的網頁，可以會得到向下面的code，只要把下面的code貼到網頁的script內，再新增一個id=\"images\"的容器，就可以看到載入幾張flicker的圖片。 (function() { var flickerAPI = \"http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?\"; $.getJSON( flickerAPI, { tags: \"mount rainier\", tagmode: \"any\", format: \"json\" }) .done(function( data ) { $.each( data.items, function( i, item ) { $( \"&lt;img&gt;\" ).attr( \"src\", item.media.m ).appendTo( \"#images\" ); if ( i === 3 ) { return false; } }); }); })(); &lt;div id=&quot;images&quot;&gt;&lt;/div&gt; (function() { var flickerAPI = \"http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?\"; $.getJSON( flickerAPI, { tags: \"mount rainier\", tagmode: \"any\", format: \"json\" }) .done(function( data ) { $.each( data.items, function( i, item ) { console.log(item) $( \"\" ).attr( \"src\", item.media.m ).appendTo( \"#images\" ); if ( i === 3 ) { return false; } }); }); })(); Console.log 利用console.log()可以將javascript的值輸出到browser的開發者工具，藉此來偵錯或是了解值的結構。 如以下範例，在剛剛的script中插入console.log(item)，就可以看到範例所抓取的json有什麼樣的資料，藉此能夠了解如何運用這些資料。 $.each( data.items, function( i, item ) { console.log(item) $( \"&lt;img&gt;\" ).attr( \"src\", item.media.m ).appendTo( \"#images\" ); if ( i === 3 ) { return false; } 從他所產生的結果，其實可以了解這範例僅有取用media的圖檔位置而已，其實還有許多值還沒有用到，有興趣的人可以把它其他的值抓出來玩玩看，或許可以讓內容豐富更多~。","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"Transform3D 翻牌效果","slug":"css3-180-flip","date":"2013-10-30T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/31/css3-180-flip/","link":"","permalink":"https://wcc723.github.io/css/2013/10/31/css3-180-flip/","excerpt":"再經過一連串的CSS3苦練之後...，發現我對CSS transform3D挺有興趣的，但是一個3D的Demo都要花很多的時間才做得出來...，如果不嫌棄就先看一些以前做的吧~。","text":"再經過一連串的CSS3苦練之後...，發現我對CSS transform3D挺有興趣的，但是一個3D的Demo都要花很多的時間才做得出來...，如果不嫌棄就先看一些以前做的吧~。 翻牌效果 翻牌效果是CSS3中算比較容易的，但是在定位就比較麻煩一些，由於要先將兩張圖重疊，所以用的是position: absolute，剩下的部分就直接在sass code中介紹吧。 //sass code @mixin turn180($zIndex: 10) position: relative //因為要用 absolute定位，所以外圍當然要用relative囉~ +perspective(1000) //透視 .flipper +transform-style(preserve-3d) //transform3D必要 +transition(all 0.8s) //動畫轉換效果 &:hover +transform(rotateY(180deg)) //滑入之後，整體旋轉180度 &:first-child //這邊是要將兩張圖的前後位置對調 z-index: $zIndex + 1 & + * //相鄰的第二張圖要放在前方 z-index: $zIndex + 2 & > * //這邊用全域選取器，也可以換成其他的~ position: absolute top: 0 +transform-style(preserve-3d) &:first-child //這邊就是先將第一張圖放在前方 z-index: $zIndex + 2 left: 0 +backface-visibility(hidden) //CSS3D 不顯示背面的圖 & + * //相鄰的第二個元素 z-index: $zIndex + 1 right: 0 +transform(rotateY(180deg)) //第二張圖先反轉到背面 +backface-visibility(hidden) .turn180 +turn180 //include上面那個@mixin backface-visibility backface-visibility是用來決定transform3D的元素背面是否顯示，預設值是顯示。沒有將背面隱藏，會類似下面的效果(下方範例只有一張圖)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS - pure CSS 星球公轉(3D)","slug":"solar-system","date":"2013-10-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/29/solar-system/","link":"","permalink":"https://wcc723.github.io/css/2013/10/29/solar-system/","excerpt":"有些時候技術光學習還不夠，必須想一些作品來實作，而這邊我要展示一個星球公轉效果，接下來介紹一些這當中所遇到的問題。","text":"有些時候技術光學習還不夠，必須想一些作品來實作，而這邊我要展示一個星球公轉效果，接下來介紹一些這當中所遇到的問題。 2D 公轉 在製作成3D公轉前，可以先做一個2D公轉，這兩者基本上是很類似的，最大的問題會是在轉換成3D，而這部份我就不另外提供CSS，大家可以用開發者工具看看這結構是如何(如果真的沒寫好，請指教>","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 Flex的對齊","slug":"css-flex-3","date":"2013-10-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/26/css-flex-3/","link":"","permalink":"https://wcc723.github.io/css/2013/10/26/css-flex-3/","excerpt":"今天參加了MOPCON，所以來介紹簡單一點的。承前篇，Flex是為了改善過去的CSS2排版模式所衍生出的新語法，本章則要介紹他的對齊方式。 大量參考：http://www.w3.org/html/ig/zh/wiki/Css3-flexbox","text":"今天參加了MOPCON，所以來介紹簡單一點的。承前篇，Flex是為了改善過去的CSS2排版模式所衍生出的新語法，本章則要介紹他的對齊方式。 大量參考：http://www.w3.org/html/ig/zh/wiki/Css3-flexbox align-items 名稱： align-items 值： flex-start | flex-end | center | baseline | stretch 對其物件的垂直點，上面是其對應的參數，而下方式示意圖。 stretch，也是預設值，把整個拉開來。 100px 200px flex: 1 flex-start 100px 200px flex: 1 flex-end 100px 200px flex: 1 center 100px 200px flex: 1 baseline，這是比較特例的，可以配合文字的行高(line-height)，將元素第一行文字對齊。 100px 200px flex: 1 justify-content 水平的對齊方式，配合以下的這張圖和下面的範例可以了解其功能。 名稱： justify-content 值： flex-start | flex-end | center | space-between | space-around center 100px 200px 100px flex-start 100px 200px 100px flex-end 100px 200px 100px space-between 100px 200px 100px space-around 100px 200px 100px","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 Flex的排版方式","slug":"css-flex-2","date":"2013-10-24T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/25/css-flex-2/","link":"","permalink":"https://wcc723.github.io/css/2013/10/25/css-flex-2/","excerpt":"flex是用來排版的CSS屬性，在本章就用所了解的flex來排版看看，並且在介紹幾個flex屬性。","text":"flex是用來排版的CSS屬性，在本章就用所了解的flex來排版看看，並且在介紹幾個flex屬性。 flex-wrap: wrap Flex-wrap的功能其實就是把超過100%的元素換行，這邊就直接來做個實驗就可以了解。 //以下兩個html範例結構如下 &lt;div class=&quot;container&quot;&gt; &nbsp; &nbsp; &lt;menu&gt;Menu&lt;/menu&gt; &nbsp; &nbsp; &lt;nav&gt;Nav&lt;/nav&gt; &nbsp; &nbsp; &lt;article&gt;Article&lt;/article&gt; &nbsp; &nbsp; &lt;footer&gt;Footer&lt;/footer&gt; &lt;/div&gt; //sass code header,menu,footer width: 100% nav width: 120px article flex: 1 Header Menu Nav Article Footer 如果沒有加上flex-wrap: wrap，以上的元素就會像是車禍一樣撞在一起，原因就是所有元素都被排成一排；只要加上了flex-wrap: wrap，超過100%的元素將會被換行。 .container display: flex flex-wrap: wrap Header Menu Nav Article Footer 接下來也可以是著加上一些內容看看。 Header Menu 為什麼 這邊 也會 有選單 ? 內容標題 「圓仔」喝媽媽的乳汁越長越大，「圓圓」呵護備至，常常攬在懷裡，但「圓仔」也有回饋，因為牠的便便可說是「圓圓」的營養劑。 台北市立動物園今天說，「圓仔」一百零九日齡大，體重已經突破七千兩百四十六公克。目前「圓仔」唯一的食物就是媽媽「圓圓」的乳汁，儘管觀察到「圓圓」一天只有哺乳一至兩次，但「圓仔」的體重穩定上升。 Footer Order 這是定義元素的排列位置，下面有一個簡單的範例，只要點選的元素，該元素的order會被定義成-1，這樣他就會被排到最前面。 //sass code //這是用純css製作的範例，可以參考之前的Checkbox的妙用 input:checked & + label order: -1 background: #375F99 1 2 3 4 垂直水平置中 在過去的CSS都要用盡各種奇怪的方式才能垂直水平置中(table、light-height等等)，現在可以容易達到垂直水平置中(還不只一種方式噢～) Margin 置中 方法和以前差不多，只要設定margin: auto即可。 div margin: auto this is away center. Align-items & justify-content 簡單來說，就是從外層去設定內層物件的置中，在flex外層的對齊設定相當多樣，下一章會繼續介紹。 .container align-items: center justify-content: center this is away center.","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 display:flex","slug":"css-flex-1","date":"2013-10-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/24/css-flex-1/","link":"","permalink":"https://wcc723.github.io/css/2013/10/24/css-flex-1/","excerpt":"display: box及display: flex，兩者是類似的伸縮排版語法但現在已經改成display: flex。 display: box; is a version of 2009. display: flexbox; is a version of 2011. display: flex; is the actual version. display: box是存在的版本，但是它是過去的，現在使用的是display: flex。 目前compass的核心也還是使用display: box","text":"display: box及display: flex，兩者是類似的伸縮排版語法但現在已經改成display: flex。 display: box; is a version of 2009. display: flexbox; is a version of 2011. display: flex; is the actual version. display: box是存在的版本，但是它是過去的，現在使用的是display: flex。 目前compass的核心也還是使用display: box display: flex 這是相當正式的版本，以我目前手上的firefox及chrome都是不需要前輟詞就可以運作。 //sass code .display-box display: flex width: 100% 和display: box設定其實差不多，外層設定只是把box換成了flex，且不需要前輟詞(目前我測試chrome & Firefox是可以正常顯示，IE10不行，safari不行)。 //sass code .flex3 flex: 3 .flex5 flex: 5 內層只要設定flex加上值就可以，下面的結果就是左邊的1加上右邊的3得到4，左邊就會顯示1/4的黃色，右邊則是3/4的深藍色。 flex: 1 flex: 3 一樣可以插入更多的flex，如以下範例就是被分成九等份，再由三個flex去分配。 flex: 1 flex: 3 flex: 5 與固定值共用 接下來，我們插入一個固定值200px，那麼空間會保留200px的大小，剩於的再由flex去分攤，flex依然會在剩下的空間分為四等分(如下範例)。 200px flex: 1 flex: 3 混合使用 在過去這樣的問題相當難解決，透過CSS3我們可以將許多種單位混用，如下範例，可以先切200px，在切20%，剩餘的區域在分為1/4與3/4。 20% flex: 1 flex: 3 200px flex-direction flex-direction等於box-direction的強化版，可以決定垂直排列及反轉排列。 名稱： flex-direction 值： row | row-reverse | column | column-reverse 正常版 預設值就是flex-direction: row，水平由左至右排列。 flex: 3 flex: 1 flex: 5 水平反轉 flex-direction: row-reverse，就可以水平反轉排列。 flex: 3 flex: 1 flex: 5 垂直柱狀 而將值設定為column，就可以垂直排列(如果換成column-reverse就可以垂直反轉噢～)。 flex: 3 flex: 1 flex: 5 在柱狀排列下，也可以設定百分比排列(box-flex的情況，firefox不支援垂直百分比。) flex: 3 flex: 1 height: 50%","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 垂直文字書寫","slug":"Vertical-write","date":"2013-10-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/20/Vertical-write/","link":"","permalink":"https://wcc723.github.io/css/2013/10/20/Vertical-write/","excerpt":"html最早都是應用於拉丁文上，而拉丁文主要是水平由左到右的書寫方式，而到了其他的語系國家，文字也只能用水平由左到右的書寫方式；而漢字是屬於垂直書寫由右到左的書寫方式，現在也能透過CSS的writing-mode改變，就來看一下範例吧。","text":"html最早都是應用於拉丁文上，而拉丁文主要是水平由左到右的書寫方式，而到了其他的語系國家，文字也只能用水平由左到右的書寫方式；而漢字是屬於垂直書寫由右到左的書寫方式，現在也能透過CSS的writing-mode改變，就來看一下範例吧。 正常版 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 這是最正常的水平書寫方式，但我們都知道古詩還是直行的比較習慣。 Writing-mode 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 -webkit-writing-mode: vertical-lr writing-mode: vertical-lr 透過writing-mode，值設定為 vertical-lr，就可以把文字改為直書，透過小學課本我們可以了解不只是直書還要由右到左。 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 -webkit-writing-mode: vertical-rl writing-mode: vertical-rl 再把值改為vertical-rl，就可以直書且由右到左。 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 如果還不夠，可以把字體換成標楷體...，就可以重現小學課本上的古詩了...。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Animation 的各項設定值","slug":"css-animation-setting","date":"2013-10-17T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/18/css-animation-setting/","link":"","permalink":"https://wcc723.github.io/css/2013/10/18/css-animation-setting/","excerpt":"和其他屬性一樣，animation有許多屬性可以設定，當然也可以用一個animation涵蓋全部，以下會分別介紹以下屬性的用途。 來源：http://css.doyoe.com/ [ animation-name ]：設置物件所應用的動畫名稱(必填) [ animation-duration ]：檢索或設置對象動畫的持續時間(必填) [ animation-timing-function ]：檢索或設置物件動畫的過渡類型 [ animation-delay ]：檢索或設置對象動畫延遲的時間 [ animation-iteration-count ]：檢索或設置物件動畫的迴圈次數 [ animation-direction ]：檢索或設置物件動畫在迴圈中是否反向運動","text":"和其他屬性一樣，animation有許多屬性可以設定，當然也可以用一個animation涵蓋全部，以下會分別介紹以下屬性的用途。 來源：http://css.doyoe.com/ [ animation-name ]：設置物件所應用的動畫名稱(必填) [ animation-duration ]：檢索或設置對象動畫的持續時間(必填) [ animation-timing-function ]：檢索或設置物件動畫的過渡類型 [ animation-delay ]：檢索或設置對象動畫延遲的時間 [ animation-iteration-count ]：檢索或設置物件動畫的迴圈次數 [ animation-direction ]：檢索或設置物件動畫在迴圈中是否反向運動 以下範例都是用相同的keyframes作介紹，僅調整animation的屬性。 +keyframes(ifinityCircles) from +transform(rotate(0)) to +transform(rotate(360deg)) Name 及 Duration 就像上面所說的，就算是每個屬性可以分開設定，但其實也是可以用一個animation寫一起，以下的範例都是寫一起，就不分開設定了。 Name和Duration都是必填屬性，所以必須一起介紹，在這邊都是引用上面的那一組keyframe。 +animation(ifinityCircles 3s) //ifinityCircles 是 keyframe的name //3s 是duration 除了name相同外，我們改變時間，動畫時間會明顯的變長。 +animation(ifinityCircles 8s) Timing-function 速率的timing-function可以參考: /css/2013/08/24/css-transtion-speed/ 建議可以參考上面的範例，animation和transition所使用的timing-function是相同的，所以可以先把常用的記起來~。 +animation(ifinityCircles 3s ease) //ease就是 timing-function的預設值 在這種旋轉的動畫，我喜歡設定線性(linear)的timing-function。 +animation(ifinityCircles 3s linear) Delay 如同字義的意思，就是延遲撥放動畫，有些時候可以用這效果讓多個動畫做出層次感。 +animation(ifinityCircles 3s) //沒有delay +animation(ifinityCircles 3s 1.5s) //第二個秒數設定，會被判定為delay Iteration-count 動畫重複的次數，預設值是1次，如果要多次直接輸入次數即可，而無限次數就要輸入infinite。 +animation(ifinityCircles 1.5s 2) //重複2次 +animation(ifinityCircles 1.5s infinite) //重複無限次 Direction 決定動畫順轉或是逆轉的模式，這邊的範例用無限次撥放比較好說明。 +animation(ifinityCircles 1.5s reverse infinite) //一直保持逆轉的模式 +animation(ifinityCircles 1.5s alternate-reverse infinite) //先逆轉，然後再順轉回去 +animation(ifinityCircles 1.5s alternate infinite) //首先是順轉，會在逆轉回去","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Animation 和 keyframe","slug":"css-animation-keyframe","date":"2013-10-16T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/17/css-animation-keyframe/","link":"","permalink":"https://wcc723.github.io/css/2013/10/17/css-animation-keyframe/","excerpt":"CSS的Animation分為兩個部分，一個是決定動畫該如何跑的Keyframe，另一個是將動畫載入元素的Animation。簡單來說，就是先製作一個keyframe來決定動畫的影格動作，在將動作載入元素，而這兩個都是必要的。","text":"CSS的Animation分為兩個部分，一個是決定動畫該如何跑的Keyframe，另一個是將動畫載入元素的Animation。簡單來說，就是先製作一個keyframe來決定動畫的影格動作，在將動作載入元素，而這兩個都是必要的。 Sass中 Keyframe , Animation的@mixin Compass目前版本似乎沒有支援animation，首先要先準備兩個mixin，一個是keyframe，另一個是animation。 參考：https://gist.github.com/ericam/1607696 //@mixin for keyframe =keyframes($name) @-webkit-keyframes #{$name} @content @-moz-keyframes #{$name} @content @-ms-keyframes #{$name} @content @keyframes #{$name} @content //@mixin for animation =animation($content) -webkit-animation: $content -moz-animation: $content -o-animation: $content animation: $content 如果沒有意外，這些sass就可以對應各種瀏覽器的前輟詞，現在就立馬做一個簡單的demo吧！ Demo %box height: 100px width: 100px margin: 0 auto background: orange +keyframes(ifinityCircles) from +transform(rotate(0)) to +transform(rotate(360deg)) div @extend %box +animation(ifinityCircles 3s infinite linear) 就這樣馬上就能完成animation，輕鬆愜意～ Keyframe Keyframe在設定上也很容易，我們直接看下面的demo就可以了。 keyframe設定 //sass code //我們製作兩款keyframe樣式，一款是from to，另一款就是百分比。 //這一款from to 其實就是0%~100%的意思 +keyframes(ifinityCircles) from +transform(rotate(0)) //不管事百分比或是from to，都可以直接在這邊設定每個階段的動作 to +transform(rotate(360deg)) //如果另外設定百分比，就可以設定更細節的設定 +keyframes(ifinityCircles2) 0% +transform(rotate(0)) 50% +transform(translateX(-100%) rotate(180deg)) 100% +transform(translateX(100%) rotate(360deg)) 元素的animation設定 .box +animation(ifinityCircles 3s infinite linear) //這邊可以就可以直接引用剛剛的keyframe //ifinityCircles : keyframe自訂義名稱 //3s : 持續時間 //infinite : 反覆次數(無限) //linear : 動畫曲線(速率一致就對了) .box1 +animation(ifinityCircles2 3s infinite linear alternate) //alternate : 動畫在結束時，會反轉回去","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 鐵人賽不是開始，也不是結束","slug":"css-ironman","date":"2013-10-14T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/15/css-ironman/","link":"","permalink":"https://wcc723.github.io/css/2013/10/15/css-ironman/","excerpt":"在鐵人賽前一個月，我在進行一個計劃，就是挑戰100天發文，內容以前端為主，雖然每天都有新的文章，但我都不會特別去核對文章的內容。而鐵人賽開始後，將主題調整為CSS為主，內容也不是只將demo貼上後隨便貼個原始碼就結束了，許多內容都必須去尋找相關的資料，讓主題及內容更加可看性，這過程中也讓CSS的基礎更上一層樓...。","text":"在鐵人賽前一個月，我在進行一個計劃，就是挑戰100天發文，內容以前端為主，雖然每天都有新的文章，但我都不會特別去核對文章的內容。而鐵人賽開始後，將主題調整為CSS為主，內容也不是只將demo貼上後隨便貼個原始碼就結束了，許多內容都必須去尋找相關的資料，讓主題及內容更加可看性，這過程中也讓CSS的基礎更上一層樓...。 這三十天還有很多CSS3沒有介紹到，也有沒補足的地方，像是animation、flex layout等等，有興趣的人可以繼續關注http://ashareaday.wcc.tw/，我會持續發表和CSS及前端有關的文章。現在已經移到http://wcc723.github.io/囉～(2013/12/25) 每天文章的開始 起因 http://jenniferdewalt.com/ 中文介紹 http://techorange.com/2013/08/01/i-am-making-one-website-a-day-for-180-days/ 幾個月前我看到上面這個網站，他的目標就是在180天做180個網站(後來挺精彩的...)，用這個方式來精進自己的技術，因此我也挑戰每天發文，由於每日都需要有不同的內容，有時想要新的挑戰，必須不斷地思考及尋找新的資料，這樣果真進步神速...。 A share a day的架構是用靜態html配合ajax，沒有資料庫，主要原因是為了在製作demo更容易，以及方便上傳更新。 A share a day 還沒結束 A share a day 在鐵人賽前已經進行了約30日，所以在鐵人賽後離目標的100日還有40日左右，許多在鐵人賽中沒有介紹到的內容還會繼續地進行，另外主題也會回到以前的多種前端技術，並不會侷限於CSS。雖然在這過程中有許多新的想法，但不能因此中斷每日的計劃！ 接下來的規劃 A share a day 並不是一個好的架構，他連SEO都有問題，只是在DEMO上真的很方便。所以除了繼續進行下去外，也會開始尋找合適的方式記錄這些文章(我原本是用wordpress，我認為還是不方便)，可能會是logdown吧～ 另外會開始挑戰用CSS做更有趣的作品，就像是Codepen上的一樣，但...應該要再過個幾週後吧...。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS 的相關資料","slug":"css-collection","date":"2013-10-13T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/14/css-collection/","link":"","permalink":"https://wcc723.github.io/css/2013/10/14/css-collection/","excerpt":"今天沒有要介紹任何效果，是要介紹這些CSS資料是從何處獲得的。","text":"今天沒有要介紹任何效果，是要介紹這些CSS資料是從何處獲得的。 前端社群 台灣的前端社群也是高手雲集的地方，如果想要知道最新的技術資訊，從社群進入是最快的方式，這邊就簡單介紹幾個與CSS有關的Facebook社群。 HTML5 與 CSS3 :https://www.facebook.com/groups/htmlfive/ Front-End Developers Taiwan :https://www.facebook.com/groups/521085554595481/ RGBA :https://www.facebook.com/groups/rgba.tw/ RGBA 資源 :https://www.facebook.com/rgba.tw?fref=ts 高雄前端社群 :https://www.facebook.com/groups/358503154261390/ 靈感來源 在不清楚CSS可以做些什麼之前，我們可以先四處蒐集靈感，有好的範例後，我們可以從中拆解學習其CSS的效果組成原理，並且轉化成日後專案的利器。 Codepen :http://codepen.io/ Codrops :http://tympanus.net/codrops/ Codepen 這網站上有很多高手實驗性的作品，本站的很多效果也是參考其中實驗性的作品。 Codrops 這邊會蒐集許多細膩的前端效果，許多不只創新，還相當有質感。 前端字典 找到了效果後，在拆解的過程中如果有不了解的問題，一定要追根究柢，所以字典是非常重要的，當然這邊也是介紹和CSS有關的字典。 Devdocs : http://devdocs.io/ Overapi : http://overapi.com/css/ Devdocs 這是我主要查詢程式碼的網站，內容詳盡，且有標示相關來源，值得推薦。 Overapi 主要是清單列表相當清楚，配合ctrl+f很快可以找到要的屬性。 優秀的設計網站 除了實驗性的效果，我們也可以看看大家是怎們把效果實作在產品上。以下都是相當棒的網站，就不一一介紹了，而Media Queries和其他比較起來是較中規中矩，但每一個網站都符合各裝置，且品質都相當具有指標性。 Flatdsgn : http://flatdsgn.com/ CSS Winner : http://www.csswinner.com/ CSS Design awards : http://www.cssdesignawards.com/ Awwwards : http://www.awwwards.com/ Media Queries : http://mediaqueri.es/ Flatdsgn CSS Winner CSS Design awards Awwwards Media Queries 網路上的資源絕對不止這些，但以上所挑選的網站都是會不斷地更新資料，如果有興趣的朋友可以不定期的看這些網站。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - pure CSS 專輯列表效果","slug":"css-album-list","date":"2013-10-11T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/12/css-album-list/","link":"","permalink":"https://wcc723.github.io/css/2013/10/12/css-album-list/","excerpt":"鐵人賽快要結束了，今明兩天會介紹純CSS可以做些什麼特別的效果。今天要介紹的是專輯相簿的效果。","text":"鐵人賽快要結束了，今明兩天會介紹純CSS可以做些什麼特別的效果。今天要介紹的是專輯相簿的效果。 來源 : http://codepen.io/anon/pen/hixjL 建立html 為愛而生 遠端遙控器 &lt;div class=&quot;cover&quot;&gt; &lt;div class=&quot;coverflow-list&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;cover-item&quot; id=&quot;cover-1&quot;&gt; &lt;div class=&quot;coverflow-item&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt; &lt;figure class=&quot;album-cover&quot;&gt; &lt;img src=&quot;/images/mayday/001.jpg&quot; alt=&quot;&quot;&gt; &lt;/figure&gt; &lt;figcaption class=&quot;album-name&quot;&gt;為愛而生&lt;/figcaption&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;controllor&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt;遠端遙控器&lt;/label&gt; &lt;/div&gt; 首先準備好需要的html，有些重點可以讓大家了解。 checkbox 中的id記得設定 id是唯一的 label中的for的值會對應到checkbox的id label可以重複使用，for的值對應相同ID即可 設定基本樣式 這一部分只是先設定基本樣式，就不多闡述了。 為愛而生 遠端遙控器 .coverflow-item display: inline-block position: relative margin: 0 auto text-align: center .album-cover height: 150px width: 150px img opacity: 0.5 .album-name text-align: center display: block color: #777 label display: block 設定3D樣式 在先前的文章有依序介紹許多transform的樣式設定，如果仔細看其實都是前幾個章節介紹的。 為愛而生 遠端遙控器 .coverflow-list +perspective(900px) //設定3D景深距離 +transform-style(preserve-3d) +perspective-origin(100% 30%) //3D透視的視點 .coverflow-item +transition(all .3s ease) //transition動畫 +transform(rotateY(45deg)) //y軸旋轉45度，這邊都是用中心點都軸心 套用checkbox效果 這步驟有兩個重點一個是checked(被選取)另一個則是+(相鄰)，所以要進行變化的元素必須緊貼著checkbox元素。 為愛而生 遠端遙控器 input[type=\"checkbox\"] display: none //隱藏checkbox &:checked //如果被選取時的效果 &+.coverflow-item //如果被選取時 其他相鄰元件效果 +transition(all .3s ease) +transform(rotateY(0.1deg)) margin: 0 auto img opacity: 1 .album-name color: #333 只要善用label中的for對應input的ID，無論多遠的距離的可以控制，接下來只要就是控制checkbox的相鄰物件狀態，就可以達到這樣的效果。 Demo 為愛而生 我們是五月天 神的孩子都在跳舞 後青春期的詩 人生海海 神的孩子都在跳舞 1 2 3 4 5 6 這一個部分是用html+CSS構成，而其中的重點是上面所介紹的label及checkbox，在本區雖然把checkbox換成了radio，但概念上是差不多的；另外一個重點則是Css selector中的~，他可以選取目前元素後方所有同層級的元素，讓這一個CD相簿有三種角度。 Html 原始碼 原始碼相當的長，我就只擷取部分作為範例。 &lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;cover&quot;&gt; &lt;ul class=&quot;coverflow-list&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;cover-item&quot; id=&quot;cover-1&quot;&gt; &lt;li class=&quot;coverflow-item&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt; &lt;figure class=&quot;album-cover&quot;&gt; &lt;img src=&quot;/images/mayday/001.jpg&quot; alt=&quot;&quot;&gt; &lt;/figure&gt; &lt;figcaption class=&quot;album-name&quot;&gt;為愛而生&lt;/figcaption&gt; &lt;/label&gt; &lt;/li&gt; ...略 &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;controllor&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt;1&lt;/label&gt; &lt;label for=&quot;cover-2&quot;&gt;2&lt;/label&gt; &lt;label for=&quot;cover-3&quot;&gt;3&lt;/label&gt; &lt;label for=&quot;cover-4&quot;&gt;4&lt;/label&gt; &lt;label for=&quot;cover-5&quot;&gt;5&lt;/label&gt; &lt;label for=&quot;cover-6&quot;&gt;6&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; 如果有少Div結尾，請不要太在意，只是我沒copy到而已... 這一段html和上次比較不同的地方，就是把checkbox改成了radio，radio在用法上是屬於單選題，而checkbox是屬於多選題；只要input屬性name都是相同的，都算是一個群組，而這一個群組就只能一個被選擇。 Sass .coverflow-item display: inline-block position: relative margin: 0 auto text-align: center margin: 0 -45px background-color: white .album-cover height: 150px width: 150px -webkit-box-reflect: below 22px -webkit-linear-gradient(rgba(255,255,255,0)85%, white 150%) box-reflect: below 22px linear-gradient(rgba(255,255,255,0) 85%, white 150%) //專輯反射 img opacity: 0.5 .album-name text-align: center display: block color: #777 label display: block .coverflow-list +perspective(900px) +transform-style(preserve-3d) +perspective-origin(100% 30%) .coverflow-item +transition(all .3s ease) +transform(rotateY(45deg)) input[type=\"radio\"] display: none &:checked &+.coverflow-item +transition(all .3s ease) +transform(rotateY(0.1deg)) margin: 0 auto img opacity: 1 .album-name color: #555 &~.coverflow-item +transform(rotateY(-45deg)) //重點語法 將被選取的Radio後方全部都反方向轉45度 .controllor margin-top: 40px label cursor: pointer color: #999 padding: 8px border: 1px solid #ccc background-color: #fafafa +transition(all .3s) &:hover color: #555 border: 1px solid #555 這一部分可以著重的重點就是放在CSS selector的~語法，再被選取的radio後方，進行反向Y軸旋轉的動作。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform-3D的透視(perspective)","slug":"css-perspective","date":"2013-10-10T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/11/css-perspective/","link":"","permalink":"https://wcc723.github.io/css/2013/10/11/css-perspective/","excerpt":"本篇介紹的transform 3D的透視，如果沒有設定透視(perspective)，transform 3D就會像平面一樣呈現。所以在3D的物件上，一定要設定好\"適合\"的透視，怎樣是適合，來看看以下範例就能夠了解。","text":"本篇介紹的transform 3D的透視，如果沒有設定透視(perspective)，transform 3D就會像平面一樣呈現。所以在3D的物件上，一定要設定好\"適合\"的透視，怎樣是適合，來看看以下範例就能夠了解。 重要性 本篇文章都是用同一個正方形，設定值也都相同，大家依序看下去就可以了解透視對transform 3D 的影響。 上面這一個方塊並沒有設定透視，他確實也是3D，由於沒有透視所以也感覺不到它是個立方體。 +perspective(500px) perspective的設定值只要設定距離長度即可，其屬性也只需要設定在父元素。上面這範例perspective的值就設定500px，這樣也就能獲得簡單的透視效果。 各種設定 +perspective(1500px) 而perspective的值我們可以想像成物件距離螢幕的距離，如果值越大代表越遠。 +perspective(250px) 反之，數值越小代表離螢幕越近，而越貼近則會有透視越強烈的感覺，在適當的時候，這麼貼近的視覺效果也是不錯的表現手法。 +perspective(500px) +perspective-origin(center 0%) 除了距離外，也可以設定視點的位置；如上範例，紅點是虛擬的視點，由正方形的頂端往下看，就不會看到正方形上面的面，下面的那一塊感覺也會比平常的大些。 設定視點的屬性就是用perspective-origin，預設值也是center center，也就是正中央。 +perspective(500px) +perspective-origin(right bottom) 而把視點放在下方底部，可以凸顯出圖形的氣勢，如果需要有張力的表現，也可以試試看把視點放在下方。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform-origin","slug":"css-transform-origin","date":"2013-10-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/10/css-transform-origin/","link":"","permalink":"https://wcc723.github.io/css/2013/10/10/css-transform-origin/","excerpt":"本篇介紹transform的起始點，一般來說變形的起始點都在物件的中心點，但如果需要像時鐘的分秒針一樣，中心點並不再物件的中心，就需要靠transform-origin去設定物件變形的起始點。","text":"本篇介紹transform的起始點，一般來說變形的起始點都在物件的中心點，但如果需要像時鐘的分秒針一樣，中心點並不再物件的中心，就需要靠transform-origin去設定物件變形的起始點。 x-50pxy-100px 在html裡的基準點都是從左上開始，從水平開始往右稱為x軸，垂直往下稱為y軸，CSS在編寫習慣上也是先寫x軸再寫y軸，如50px 100px，結果會是x軸向右50px，y軸垂直向下100px。而tranaform的屬性中，坐標將是相當重要的關鍵。 Rotate .rotate +transform(rotate(30deg)) 在這一個demo中，只有設定rotate旋轉50度，並沒有設定起始點。因為此時的物件預設值坐標是50% 50%， .rotate2 +transform(rotate(30deg)) +transform-origin(0,0) 在設定玩起始點後，2D變形物件會依起始點開始作變形，如範例中就是從x-0 y-0，左上角開始跑，所以在設定transform必須要清楚瞭解到要變型物件的起始點。 Scale Scale是屬於transform2D的縮放變形效果，值為x軸及y軸倍率，而他一樣會受物件起始點的影響。 .scale +transform(scale(1.5, 1.5)) .scale2 +transform(scale(1.5, 1.5)) +transform-origin(0,0) 由上面兩個scale範例中可以瞭解到基準點對於變形的重要性，而這將會影響版面的規劃以及其他物件之相對關係。 Rotate 3D .rotate3 @extend .box +transform-style(preserve-3d) +transform(rotateY(0deg)) +transform-origin(0,0) &:hover +transform(rotateY(90deg)) .rotate4 @extend .box +transform-style(preserve-3d) +transform(rotateY(0deg)) +transform-origin(100%,0) &:hover +transform(rotateY(-90deg)) 當然3D也不例外，如果設定好基準點，物件才能依設定的軸心旋轉，如果把軸心放在最左邊及最右邊，就可以向上方這開門的效果。 旋轉吧 時鐘 就如同最開始所說的，如果設定好起始點，畫一個時鐘也不是問題。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform 軸線的謊言","slug":"css-transform-mistake","date":"2013-10-08T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/09/css-transform-mistake/","link":"","permalink":"https://wcc723.github.io/css/2013/10/09/css-transform-mistake/","excerpt":"從小上數學課，都會知道X軸是左右，Y軸是垂直，看起來就是這麼容易，但是一到了CSS上卻是常常分不清楚，而其中最大的陷阱就是旋轉(rotate)。這篇會用簡單的動態效果，讓大家了解旋轉與軸線之間的關係(本篇都是使用sass)。","text":"從小上數學課，都會知道X軸是左右，Y軸是垂直，看起來就是這麼容易，但是一到了CSS上卻是常常分不清楚，而其中最大的陷阱就是旋轉(rotate)。這篇會用簡單的動態效果，讓大家了解旋轉與軸線之間的關係(本篇都是使用sass)。 先了解軸線的方向 X軸線就是左右，很容易，但別急，我們慢慢看下去。 Y軸線就是垂直，也是很容易。 這邊我把平面旋轉了Y軸(垂直軸)，讓大家了解Z軸的位置，而Z軸就是垂直於剛剛的平面之上，這在transform3D會使用到。 增加些動態吧 水平移動 接下來我用translate的語法，讓這個方塊水平移動。 &:hover .box +transform(translateX(100%)) //滑鼠滑入時，沿著X軸移動100% 先移動在旋轉 接下來我們讓這個物件移動並且旋轉，這邊就是陷阱的開始，目前還沒有異樣。 &:hover .box +transform(translateX(100%) rotate(30deg)) //在位移的語法後方增加上旋轉 先旋轉在移動 雖然這部分我是做成animation，但其實結果是一樣的，只是要讓大家容易了解。 如果將旋轉的語法放在前面，那麼物件的X軸也會跟著變化，所以CSS的transform是以物件為基準點，當物件旋轉時，物件的基準點也會跟著改變。 @-webkit-keyframes Rline 0% 30% +transform(rotate(30deg)) 100% +transform(rotate(30deg) translateX(200px)) 同樣的理論，我們來看看3D 首先旋轉Y軸(垂直軸)90度，然後以物件為基準朝向Z軸移動。 &:hover .box +transform(rotateY(90deg) translateZ(500px)) //維持原本的90度Y軸旋轉，並且朝向Z軸移動 和剛剛一樣，先加入旋轉在移動物件。 @-webkit-keyframes Zline 30% +transform(rotateY(90deg) rotateX(-10deg)) //維持90度Y軸旋轉，然後在旋轉X軸10度 100% +transform(rotateY(90deg) rotateX(-10deg) translateZ(500px)) //在旋轉後，往Z軸的方向移動 經過以上的實驗，相信會更了解物件的軸線吧(!?)。了解後，對於學習CSS transform也會有很大的幫助，接下來會介紹transform的基準點，敬請期待。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform 概觀","slug":"css-transform","date":"2013-10-07T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/08/css-transform/","link":"","permalink":"https://wcc723.github.io/css/2013/10/08/css-transform/","excerpt":"接下來要介紹CSS transform，CSS3許多新功能中，我認為transform和animation是相當有難度的，但也是最有趣的，尤其在兩者搭配後，能夠展現出類似過去flash的動態效果，但卻能保持html原有的互動性。 而在接下來的四至五天會分享transform相關的屬性運用。","text":"接下來要介紹CSS transform，CSS3許多新功能中，我認為transform和animation是相當有難度的，但也是最有趣的，尤其在兩者搭配後，能夠展現出類似過去flash的動態效果，但卻能保持html原有的互動性。 而在接下來的四至五天會分享transform相關的屬性運用。 transform概觀 本篇不會介紹以下範例的原始碼，主要會介紹transform有哪些特色，相關的原始碼會在後面的文章依序介紹。 增加網頁的動態視覺效果 過去的動態效果主要會以flash呈現，主因當然是因為html早期屬於靜態畫面呈現，如果說要吸引使用者的目光就會用些flash的效果；但在近幾年由於行動裝置的崛起，flash的應用在網頁上已經逐漸減少，如果要用動態效果可以來試試看transform吧 +transform (rotate(360deg)) 使動態更為流暢 動態效果除了CSS外，js也能夠達到，但其實js的動態效果也是基於CSS上，所以執行的效率上，還是CSS優於js。 CSS transform3D能夠開啟GPU硬體加速以提升效能(2013-12-25)。 +transform (scale(2,2)) 3D的呈現 transform除了2D外，現在也有3D的效果(點擊以下方塊)。 有趣的視覺動態 不論是2D或是3D，都有著相當豐富的參數，在這些參數混合使用下，它能夠達到許多豐富的效果，我們可以試試看用這些有趣的效果來迷惑使用者的眼睛~。 1 3 5 6 4 2 1 2 3 4 5 6 不只有趣 還可以實用 說了那麼多，不如就慢慢地套用一些效果在我們的網站上吧。 Menu 01 Menu 02 Menu 03 這篇文章或許不長，但是Demo做超久的...，主要還是想讓大家知道transform有很多有趣的地方(還有順便準備後面章節的內容...)，這周就來一起研究transform吧~。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Checkbox的妙用","slug":"css-chechbox","date":"2013-10-06T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/07/css-chechbox/","link":"","permalink":"https://wcc723.github.io/css/2013/10/07/css-chechbox/","excerpt":"CSS3 新增了:checked的偽元素，它可以判斷目前的checkbox 及 radio 是否有被選核，這樣html就能夠做出基本的點擊功能；並且結合label標籤，label標籤能夠讓樣式的套用更為自由，藉此增加畫面的豐富性。","text":"CSS3 新增了:checked的偽元素，它可以判斷目前的checkbox 及 radio 是否有被選核，這樣html就能夠做出基本的點擊功能；並且結合label標籤，label標籤能夠讓樣式的套用更為自由，藉此增加畫面的豐富性。 Selector \"~\" 在介紹checked之前，先介紹另一個selector \"~\"，許多人應該都有用過\"+\"這一個selector，它的功能是選擇相鄰的下一個元素，而\"~\"的功能是選擇同層級的後方元素，下面來看個簡單範例。 //html code &lt;div class=&quot;demo1&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; //sass code div &:hover background: orange &:hover ~ div background: #B0095C 它的功能就像上面所顯示一樣，可以選取後方複數以上的同層級元素，而在結合:hover等等偽元素，它能有更多的效果，而等等就會拿來結合:checked。 :checked //html code &lt;input type=&quot;checkbox&quot; id=&quot;a1&quot;&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; //sass code [type=\"checkbox\"] &:checked ~ label //當checkbox被選取時，改變label顏色 background: #B0095C &:before content: \"Checkbox is checked.\" 上面有兩個元素，一個是checkbox，另一個是label，不管點哪一者都會得到一樣的結果，其原理是用 label for 對應checkbox的id，這樣兩者就會產生連動效果(html 的概念)；再利用CSS的選取器\"~\"改變label的樣式。 複數 label也可以執行 //html code &lt;input type=&quot;checkbox&quot; id=&quot;a1&quot;&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; 在html的規定id是不能夠重複的，但是label for是可以重複使用。 隱藏checkbox &lt;input type=&quot;checkbox&quot; id=&quot;a3&quot;&gt; &lt;label for=&quot;a3&quot;&gt;&lt;/label&gt; &lt;div class=&quot;circles&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circles&quot;&gt;&lt;/div&gt; //sass code .demo3 [type=\"checkbox\"] display: none //隱藏checkbox &:checked + label background: #B0095C //當checkbox被選取時，和checkbox相鄰的 label改變顏色 &:before content: \"Checkbox is checked.\" & ~ .circles //和checkbox同層的元素，開始進行animation animation: ifinityCircles 3s linear infinite -webkit-animation: ifinityCircles 3s linear infinite 剛剛有提到，label可以讓樣式設定更為容易，所以我們可以把checked隱藏起來，讓使用者只有看到label，這樣在畫面的設計上會更為自由。 而這互動效果，在後面的章節會有更豐富的運用，敬請期待!","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3 Fliter 效果","slug":"css-fliter","date":"2013-10-05T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/06/css-fliter/","link":"","permalink":"https://wcc723.github.io/css/2013/10/06/css-fliter/","excerpt":"假日都來介紹些單篇的主題吧~，今天要介紹的是filter。","text":"假日都來介紹些單篇的主題吧~，今天要介紹的是filter。 box-shadow 圖片來源：火影忍者 box-shadow在先前介紹過，他是\"盒狀\"元素的陰影，所以稱作為\"box\" shadow，所以應用在圖片上，它自然就是以整個圖片的外框做陰影，這固然是正確的，但不一定是我們所想要的；上面這一張是png圖片，如果想要只在人物外框增加陰影，勢必要另外做一張圖了。 Filter filter是一種濾鏡效果，就像是繪圖軟體的濾鏡，他會以目前畫面上的圖形來套用效果，因此透明的區域就不會有效果。 參考：http://devdocs.io/css/filter drop-shadow //sass code img +filter(drop-shadow(5px 5px 5px rgba(black,.5))) 我們把類似box-shadow效果的drop-shadow同樣套用在這張圖上，它不再是以圖片外框來做陰影，而是以圖片的內容套用濾鏡陰影效果。 contrast img +filter(contrast(300%)) 目前他提供約10種的濾鏡，像這就是提高對比。 grayscale img +filter(grayscale(100%)) 很多圖片預覽也可以像這樣做成灰色的，然後在滑鼠hover時在轉換為彩色，在過去須配合js或是兩張的圖片，如果使用filter也可以達到這樣的效果。 hue-rotate img +filter(hue-rotate(180deg)) 這簡直就像簡易版的photoshop，旋轉色相這效果也有! blur img +filter(blur(10px)) 如果大家是用-webkit-瀏覽器，應該就能感受到這些豐富的效果，如果是firefox、IE10等等瀏覽器，如果沒看到以上效果應該就能了解到了吧，這些效果固然非常有趣，但目前只有-webkit-有支援，相信firefox等瀏覽器在不久的未來都會支援這些效果。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"自己做web fonts icons","slug":"web-fonts-2","date":"2013-10-04T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/05/web-fonts-2/","link":"","permalink":"https://wcc723.github.io/css/2013/10/05/web-fonts-2/","excerpt":"承上一篇，本篇會介紹自己做web fonts icons，讓會手癢的設計師可以自行設計web font icon。","text":"承上一篇，本篇會介紹自己做web fonts icons，讓會手癢的設計師可以自行設計web font icon。 先看看成品 @font-face { font-family: \"drangon\"; src: url('/demoFile/css/fonts/normal'); src: url('/demoFile/css/fonts/normal?#iefix') format('eot'), url('/demoFile/css/fonts/icomoon.eot') format('embedded-opentype'), url('/demoFile/css/fonts/icomoon.ttf') format('truetype'), url('/demoFile/css/fonts/icomoon.woff') format('woff'), url('/demoFile/css/fonts/icomoon.svg') format('svg'); font-weight: normal; } g 這次的目標是做出七龍珠裡的一星球，使用的繪圖軟體是illustrator，而製作成web font是http://icomoon.io/app 這個網站。 步驟 繪製向量檔 這是illustrator的畫面，用哪套軟體倒是沒什麼關係，只要能夠轉SVG就可以了，但另外有一個重點，如果有用到線段要記得展開，轉SVG比較不會有問題。 存檔的時候，就選SVG就對了。 SVG選項請調整成SVG Tiny。 開始製作webfont 第一個步驟，就是先打開http://icomoon.io/app 的網頁 把剛剛的檔案匯入到這個網站，選import或是直接拖曵檔案到網頁裡皆可。 SVG都匯入後，就可以點網頁下方的Font，這邊就只有一顆一星球。 接下來可以為每個一icon指定一個符號、英文或是數字，在這邊可以注意到我設定的是g，都確定後就點Download吧。 下載後的壓縮檔裡面有完整的範例檔，基本上只要按照範例檔去設定就可以了。 使用自己做的Web font Icon 由他所提供的範例檔可以得知，它的使用方式有兩種，一種是設定data，而另一種是設定Class。而不論是哪一種都必須載入他所提供的@font-face。 /*@font-face 設定*/ @font-face { font-family: 'icomoon'; src:url('fonts/icomoon.eot'); src:url('fonts/icomoon.eot?#iefix') format('embedded-opentype'), url('fonts/icomoon.woff') format('woff'), url('fonts/icomoon.ttf') format('truetype'), url('fonts/icomoon.svg#icomoon') format('svg'); font-weight: normal; font-style: normal; } 利用Data-icon設定 [data-icon]:before { font-family: 'icomoon'; content: attr(data-icon); speak: none; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } 這一個的原理是利用CSS的屬性選取器，選則html標籤裡有data-icon屬性的元素，並利用偽元素新增content，而content的內容會對應data-icon的值。如範例我的data-icon的值為\"g\"，就是當時設定的一星球。 利用Class設定 .icon-dragonBall { font-family: 'icomoon'; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; -webkit-font-smoothing: antialiased; } .icon-dragonBall:before { content: \"\\67\"; } 這是他所提供的另一個方式，設定Class他就能將指定的圖形載入，這作法也是比較基本且容易的。 g 而我們也可以單獨把上面的Class拆出來用，直接輸入\"g\"一樣有效果。 g 相容性誤解 在上一篇的時候，我有說明到 web-font icon的相容性，在此可能要重新說明一下。上一篇所使用的 web font(ligature_symbols) 和本篇的 web font(icomoon.io) 有些不同。ligature_symbols的web font有再利用CSS3的語法(text-rendering)讓單字可以轉為icon；而本篇(icomoon)的是屬於基本款的web font，大部分的瀏覽器都有支援，造成誤會敬請見諒。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Web-font & icons","slug":"web-fonts","date":"2013-10-03T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/04/web-fonts/","link":"","permalink":"https://wcc723.github.io/css/2013/10/04/web-fonts/","excerpt":"本篇所用的範例是Ligature Symbols，它所提供的的icons非常多，而且簡單易用。","text":"本篇所用的範例是Ligature Symbols，它所提供的的icons非常多，而且簡單易用。 @font-face { font-family: \"LigatureSymbols\"; src: url('/demoFile/css/fonts/normal'); src: url('/demoFile/css/fonts/normal?#iefix') format('eot'), url('/demoFile/css/fonts/LigatureSymbols-2.05.eot') format('embedded-opentype'), url('/demoFile/css/fonts/LigatureSymbols-2.05.ttf') format('truetype'), url('/demoFile/css/fonts/LigatureSymbols-2.05.woff') format('woff'), url('/demoFile/css/fonts/LigatureSymbols-2.05.svg#LigatureSymbols') format('svg'); font-weight: normal; } .lsf { font-family: \"LigatureSymbols\"; font-size: 300%; -webkit-text-rendering: optimizeLegibility; -moz-text-rendering: optimizeLegibility; -ms-text-rendering: optimizeLegibility; -o-text-rendering: optimizeLegibility; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-font-smoothing: antialiased; -ms-font-smoothing: antialiased; -o-font-smoothing: antialiased; font-smoothing: antialiased; -webkit-font-feature-settings: \"liga\" 1, \"dlig\" 1; -moz-font-feature-settings: \"liga=1, dlig=1\"; -ms-font-feature-settings: \"liga\" 1, \"dlig\" 1; -o-font-feature-settings: \"liga\" 1, \"dlig\" 1; font-feature-settings: \"liga\" 1, \"dlig\" 1; } Ligature Symbols 本篇所用的範例是Ligature Symbols，它所提供的的icons非常多，而且簡單易用。 http://kudakurage.com/ligature_symbols/ 首先當然是先下載他們所提供的檔案，解壓縮後有完整的html以及CSS範例，先找到LigatureSymbols-2.05.ttf的字型檔，將字型檔放在本地端的資料夾，本範例會放在sylesheets的fonts資料夾內。 在他們的網頁下方有提供完整的CSS，包含@font-face以及.class的設定，基本上直接拷貝即可；這邊將會用sass作範例。 //sass code //compass 的font-face@include，而其中的format在compass是不需要設定的 +font-face(\"LigatureSymbols\",font-files(\"LigatureSymbols-2.05.eot\",\"LigatureSymbols-2.05.ttf\",\"LigatureSymbols-2.05.woff\",\"LigatureSymbols-2.05.svg#LigatureSymbols\"),normal,normal) .lsf font-family: 'LigatureSymbols' font-size: 300% -webkit-text-rendering: optimizeLegibility -moz-text-rendering: optimizeLegibility -ms-text-rendering: optimizeLegibility -o-text-rendering: optimizeLegibility text-rendering: optimizeLegibility //文字的渲染方式 -webkit-font-smoothing: antialiased -moz-font-smoothing: antialiased -ms-font-smoothing: antialiased -o-font-smoothing: antialiased font-smoothing: antialiased //文字的平滑模式 -webkit-font-feature-settings: \"liga\" 1, \"dlig\" 1 -moz-font-feature-settings: \"liga=1, dlig=1\" -ms-font-feature-settings: \"liga\" 1, \"dlig\" 1 -o-font-feature-settings: \"liga\" 1, \"dlig\" 1 font-feature-settings: \"liga\" 1, \"dlig\" 1 //在OpenType 有更進階的設定，但這邊沒有特別研究 //html &lt;div class=&quot;lsf&quot;&gt;twitter&lt;/div&gt; 查詢一樣在這邊：http://kudakurage.com/ligature_symbols/ 接下來只要輸入對應的class，然後再到該頁面查詢對應的單字就可以套用，如範例我只要輸入class，在class內在填入twitter就可以獲得twitter的icon。 Web font icon有什麼優點? 1.可以被搜尋 如以下範例，使用者可以在瀏覽器(Ctrl+f)搜尋twitter，然後選取到以下圖形。 twitter 2.可以改變大小不失真 他是個文字，只要調整font-size，就可以改變其大小。 font-size: 50px twitter 3.可以改變顏色(單色為主) 同上，它是個文字，只要改變color就可以改變顏色。 color: #00ACEE twitter 3.各種CSS文字屬性 當然它可以套用任何文字效果，如italic。 font-style: italic twitter 4.陰影 在web-font icon下，text-shadow會更適合。 text-shadow: 1px 1px 5px rgba(black,.5) twitter 5.動態效果不失真 由於它不是點陣圖形，再放大縮小等動態效果，並不會有模糊及解析度不夠的問題。 .demo6 font-size: 40px +transition(all .5s) ... &:hover font-size: 50px twitter 6.各種文字的效果混合使用 這是我之前做的立體文字效果，當然它也能夠套用在web-font icon上。 //立體文字的mixin @mixin text-cubicStyle($lenght: 15,$rgb: #dfdfdf) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,darken($rgb,$i/1.6)),comma) text-shadow: $all,$lenght+1px $lenght+1px 1px rgba(0,0,0,.3),$lenght+2px $lenght+2px 10px rgba(0,0,0,.6) //@include 上面的立體效果 .demo5 +text-cubicStyle ... twitter 缺點 注意，這會有支援性的問題。 明天將會介紹怎麼做web-font icon，敬請期待!!","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Transition 實作波動拳動圖","slug":"transition","date":"2013-10-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/10/02/transition/","link":"","permalink":"https://wcc723.github.io/sass/2013/10/02/transition/","excerpt":"CSS3除了有更多的樣式外，其中一個重點就是動態，而transition是動態效果最容易達成的；所以本篇主要要介紹的是transition，以及transition的timing-function。","text":"CSS3除了有更多的樣式外，其中一個重點就是動態，而transition是動態效果最容易達成的；所以本篇主要要介紹的是transition，以及transition的timing-function。 小範例 .demo{ background: red; -webkit-transition: background 1s; -moz-transition: background 1s; -o-transition: background 1s; transition: background 1s; ... } .demo:hover { background: blue; } 如果要做一個hover的動態效果，只要在原物件上新增transition語法，並且在隨後的hover新增改變後的效果即可(如上範例)，而其中必填的參數為1.運動屬性 及 2.運動秒數。 而在本篇另外介紹timing-function，此屬性是改變動態效果的時間曲線(參考http://devdocs.io/css/timing-function)，善用timing-function，可以獲得更豐富的效果。 參考 : http://www.w3schools.com/cssref/css3_pr_transition-timing-function.asp http://devdocs.io/css/transition-timing-function Demo中的共通sass div width: 50px height: 50px background: red +transition-property(margin-left) +transition-duration(5s) .demo:hover > div margin-left: calc(100% - 50px) timing-function 各種transition-timing-function的效果，主要有以下幾種屬性。 +transition-timing-function(ease) //緩慢的開始，中間變快，又變慢慢結束。相當於cubic-bezier(0.25,0.1,0.25,1)。 +transition-timing-function(ease-in) //ease-in：緩慢的開始。相當於cubic-bezier(0.42,0,1,1)。 +transition-timing-function(ease-out) //ease-out：緩慢的結束。相當於cubic-bezier(0,0,0.58,1)。 +transition-timing-function(ease-in-out) //ease-in-out：緩慢的開始和結束。相當於cubic-bezier(0.42,0,0.58,1)。 +transition-timing-function(linear) linear：表示從開始到結束的速度一致。相當於cubic-bezier(0,0,1,1)。 +transition-timing-function(cubic-bezier(0.1, 0.7, 1.0, 0.1)) cubic-bezier(n,n,n,n)：自由定義cubic-bezier函數，每個值為0到1之間的數字。 cubic-bezier +transition-timing-function(step-start) +transition-timing-function(step-end) //這兩個....是來鬧得? +transition-timing-function(steps(4, end)) //分為4個階段 Togather! ease ease-in ease-out ease-in-out linear cubic-bezier step-start step-end steps(4, end) 波動拳動圖 這邊先準備快打旋風的圖，裡面有14張的龍發動波動拳的姿勢，而這不是一張Gif，而是一連串動作組成的png。 .ryu +transition(background 1s) +transition-timing-function(steps(13, end)) background: url(\"images/20131002.png\") left bottom no-repeat ... &:hover background-position: right bottom 然後利用階段性的function來實作動圖的效果，把背景圖設定transition動態，並且設定13階段的timing-function，最後只要將hover的結果設定在最後一張動作位置就完成囉。 如果用animation做更棒喔! 不過這似乎不是本篇重點...，在後面的文章會再另外介紹animation~，本篇就先到此為止。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"用sass 做long shadow","slug":"sass-long-shadow","date":"2013-09-30T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/10/01/sass-long-shadow/","link":"","permalink":"https://wcc723.github.io/sass/2013/10/01/sass-long-shadow/","excerpt":"網頁設計的趨勢從擬物轉換為扁平化，而扁平化顧名思義就是較扁、較平，去除了真實化實體，扁平化也延伸出許多的視覺風格，而long shadow就是其中一種，讓扁平的世界裡，增添一些的立體感。","text":"網頁設計的趨勢從擬物轉換為扁平化，而扁平化顧名思義就是較扁、較平，去除了真實化實體，扁平化也延伸出許多的視覺風格，而long shadow就是其中一種，讓扁平的世界裡，增添一些的立體感。 B 先了解基本的原理 B text-shadow: 1px 1px 0 rgba(239, 89, 54, 0.95), 2px 2px 0 rgba(239, 89, 54, 0.5), 3px 3px 0 rgba(239, 89, 54, 0.35), 4px 4px 0 rgba(239, 89, 54, 0.275), 5px 5px 0 rgba(239, 89, 54, 0.23), 6px 6px 0 rgba(239, 89, 54, 0.2), 7px 7px 0 rgba(239, 89, 54, 0.17857), 8px 8px 0 rgba(239, 89, 54, 0.1625), 9px 9px 0 rgba(239, 89, 54, 0.15), 10px 10px 0 rgba(239, 89, 54, 0.14), 11px 11px 0 rgba(239, 89, 54, 0.13182), 12px 12px 0 rgba(239, 89, 54, 0.125), 13px 13px 0 rgba(239, 89, 54, 0.11923), 14px 14px 0 rgba(239, 89, 54, 0.11429), 15px 15px 0 rgba(239, 89, 54, 0.11), 16px 16px 0 rgba(239, 89, 54, 0.10625), 17px 17px 0 rgba(239, 89, 54, 0.10294), 18px 18px 0 rgba(239, 89, 54, 0.1), 19px 19px 0 rgba(239, 89, 54, 0.09737), 20px 20px 0 rgba(239, 89, 54, 0.095), 21px 21px 0 rgba(239, 89, 54, 0.09286), 22px 22px 0 rgba(239, 89, 54, 0.09091), 23px 23px 0 rgba(239, 89, 54, 0.08913), 24px 24px 0 rgba(239, 89, 54, 0.0875), 25px 25px 0 rgba(239, 89, 54, 0.086), 26px 26px 0 rgba(239, 89, 54, 0.08462), 27px 27px 0 rgba(239, 89, 54, 0.08333), 28px 28px 0 rgba(239, 89, 54, 0.08214), 29px 29px 0 rgba(239, 89, 54, 0.08103), 30px 30px 0 rgba(239, 89, 54, 0.08), 31px 31px 0 rgba(239, 89, 54, 0.07903), 32px 32px 0 rgba(239, 89, 54, 0.07813), 33px 33px 0 rgba(239, 89, 54, 0.07727), 34px 34px 0 rgba(239, 89, 54, 0.07647), 35px 35px 0 rgba(239, 89, 54, 0.07571), 36px 36px 0 rgba(239, 89, 54, 0.075), 37px 37px 0 rgba(239, 89, 54, 0.07432), 38px 38px 0 rgba(239, 89, 54, 0.07368), 39px 39px 0 rgba(239, 89, 54, 0.07308), 40px 40px 0 rgba(239, 89, 54, 0.0725); CSS製作的long shadow是利用CSS的box-shadow，然後不斷的重複，每一個像素都產生一個新的陰影，產生出延長的視覺效果，所以如果用CSS寫會非常的壟長，且每個階段的透明度也不同，如果20階會有點想哭哭，如上範例。 box-shadow B //新增一個mixin，名稱為box-longShadow，並且新增兩個變數。 @mixin box-longShadow($lenght: 20,$rgb: #000) $all: () //先準備一個空的變數 @for $i from 1 through $lenght //利用for 迴圈決定長度 $all: append($all, append(#{$i}px #{$i}px 0 ,rgba(darken($rgb,10%),1/$i)),comma) //將陰影的效果利用迴圈的方式不斷的增加到$all +box-shadow($all) //將$all的變數增加到box-shadow裡 這是box部分的mixin，其中可以注意的就是我把長度($lenght)和顏色($rgb)提出來，讓每次使用都可以重新調整色彩。 .test +box-longShadow($lenght: 80,$rgb: #ef5936) //增加到sass樣式 margin: 25px auto background: #25aae2 width: 1em height: 1em padding: 0.1em text-align: center +border-radius(5px) overflow: hidden box-longShadow增加到CSS裡。 text-shadow B //這部分和box幾乎相同，只有在最後一行改成text-shadow @mixin text-longShadow($lenght: 20,$rgb: #000) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,rgba($rgb,0.9/$i + 0.05)),comma) text-shadow: $all .test +text-longShadow($lenght: 40,$rgb: #578199) text-shadow和box上較為接近，只是在使用時要特別注意文字，如果較細的字體，效果沒那麼好，所以使用的時候可以試試看許多不同的字體。 Finish(動畫版) B 而這只是靠兩種CSS3語法就能達到的效果，再結合更多的語法，也會有更豐富的變化，所以CSS是沒有極限的!!","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3 :target選取器","slug":"css-target","date":"2013-09-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/29/css-target/","link":"","permalink":"https://wcc723.github.io/css/2013/09/29/css-target/","excerpt":"CSS3多了相當多的selectors，而:target是其中一個，它可以讓html的id被套用上新的樣式，而這功能也可以讓html的互動性更高。","text":"CSS3多了相當多的selectors，而:target是其中一個，它可以讓html的id被套用上新的樣式，而這功能也可以讓html的互動性更高。 :target 按我開始旋轉 點我可以停 //html &lt;a href=&quot;#test1&quot; &gt;按我開始旋轉&lt;/a&gt; //這個a的重點在於#test1，目標會因為這個ID被啟動 &lt;a href=&quot;#2013-09-29&quot; class=&quot;circles&quot; id=&quot;test1&quot;&gt;&lt;span&gt;點我可以停&lt;/span&gt;&lt;/a&gt; //class = circles 是他的樣式設定 //id = test1 是他被啟動的名字 /CSS 重點code .circles:target animation: ifinityCircles 3s linear infinite 當.circles的id被啟動時，就會開始旋轉 .circles //其他樣式設定 簡單來說它是利用class來做基本樣式的設定，透過連結讓ID被啟用新的樣式，新的樣式會被寫在.circles:target；而要將:target的效果關閉，只要其他的id被啟動即可。 lightbox 來源：http://devdocs.io/css/:target 五月天 lightBox //html &lt;a class=&quot;lightbox d0929&quot; id=&quot;example1&quot; href=&quot;#2013-09-29&quot;&gt; //利用a作為外框，是為了讓使用者點任何區域，都可以關閉:target的效果 &lt;figure&gt; &lt;figcaption&gt; &lt;img src=&quot;/images/mayday/009.JPEG&quot; alt=&quot;&quot;&gt; &lt;/figcaption&gt; &lt;/figure&gt; &lt;/a&gt; //sass &.lightbox:target //樣式啟動 display: table &.lightbox position: fixed left: 0 top: 0 width: 100% height: 100% z-index: 20 background: rgba(00,00,00,.8) display: none //這一段是為了做出淺黑色的底 figure display: table-cell vertical-align: middle text-align: center //這邊是要讓lightbox完全置中 figcaption display: inline-block margin: auto padding: 15px background: rgba(00,00,00,.6) +border-radius(5px) //而這就是五月天所登場的樣式了 這功能可以做出簡單的 nojs版本的lightbox，而註解我都寫在程式碼中，這邊就不再另述了。不過根據所查詢到的資料，:target要ie10才能夠run(哭哭)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS藏頭詩 Selection","slug":"css-selection","date":"2013-09-27T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/28/css-selection/","link":"","permalink":"https://wcc723.github.io/css/2013/09/28/css-selection/","excerpt":"這是一個很簡單的技術，就是可以改變文字反選後的樣式，而支援的樣式並不多，目前僅有Color、background、background-color、text-shadow在內。","text":"這是一個很簡單的技術，就是可以改變文字反選後的樣式，而支援的樣式並不多，目前僅有Color、background、background-color、text-shadow在內。 這是一段文章，知情人士已透露，除了價格的競爭，蘋果將推出低價iPhone，以及iPhone 5升級版。 上面這一段，是正常版本的，只是做個陰影，沒有任何效果，只是要做個對照。 正式開始 這是一段文章，知情人士已透露，除了價格的競爭，蘋果將推出低價iPhone，以及iPhone 5升級版。 上面這一段讓底色可以變黑，文字變成白色，但是我們可以注意到陰影在反白後，會影響閱讀。 div &::-moz-selection background: black color: white &::selection background: black color: white 建議移除text-shadow效果 這是一段文章，知情人士已透露，除了價格的競爭，蘋果將推出低價iPhone，以及iPhone 5升級版。 像是這一段，另外再把text-shadow移除，是不是更好閱讀呢? div &::-moz-selection background: red color: white text-shadow: none &::selection background: red color: white text-shadow: none ::selection可以玩什麼 來源https://54.sp88.tw/poetry_list.php?page=1&so=1&keyname=po_ti&keyword=%E9%99%B3%E8%88%8A%E4%BD%A0%E6%88%91 英式濃茶的濃郁芬芳 經久不息的牽連妳我 那時妳同我烘焙釀造 陳舊了這紅銅色回憶 一個又一個鏽在我心 妳如壺中泉水的溫熱 再次纏繞如那母愛般 溶消極冰浮沈於腦海 而被溫順開展的那 萎縮的葉 是在極光下 畏縮的我 在我思考了很久之後，看來它只能玩藏頭詩...。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS的新\"文字\"及\"尺寸\"單位","slug":"new-size-unit","date":"2013-09-26T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/27/new-size-unit/","link":"","permalink":"https://wcc723.github.io/css/2013/09/27/new-size-unit/","excerpt":"CSS3 新的文字單位 大多數網站在文字的單位都是使用px，尤其在台灣多數使用者都是用windows系統，不管是什麼瀏覽器，在windows下都是以單數px是較為清楚的，如13xp．15px等，而px在建立網站時也是較為方便及準確的，但他的彈性是比較差的。","text":"CSS3 新的文字單位 大多數網站在文字的單位都是使用px，尤其在台灣多數使用者都是用windows系統，不管是什麼瀏覽器，在windows下都是以單數px是較為清楚的，如13xp．15px等，而px在建立網站時也是較為方便及準確的，但他的彈性是比較差的。 font-size:12px font-size:13px font-size:14px font-size:15px 彈性差的部分就來做一個實驗，就是將他們的外層在增加一個放大的文字屬性。 font-size: large font-size:12px font-size:13px font-size:14px font-size:15px EM 而用另一個文字單位em，em隨著外圍的文字大小調整，當然這是他的優點，也是他的缺點。 本站預設為13px。 font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em 我們可以調整外圍的font-size，就可以影響到內部的文字大小，但是要注意，如果外層也有設定em他也會繼承下去(GG)。 font-size: 15px font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em font-size: 1.4em font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em font-size: 1.4em font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em 由上面的範例可得知，一不小心還是會失控的。 REM rem是新的文字單位，他和em用法類似，但是他不會繼承，只會受最根部的單位影響，html的font-size(優點是ie需要9以上才支援)。 font-size: 1.4em font-size:1.1rem font-size:1.2rem font-size:1.3rem font-size:1.4rem font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em html font-size: 13px .f2rem font-size: 1.2rem .f3rem font-size: 1.3rem .f4rem font-size: 1.4rem 注意在使用時，它只會受html的font-size影響，body以下的都不會影響。 CSS3 新的尺寸單位 不久前我有一個問題，就是在自適應的情況下，正方形的CSS語法該如何寫。直接寫px然後配合media query似乎是一個辦法，但如果我的水平都要保持三個等\"百分比\"的正方形，似乎就不太可能了。 vh vw vh vm是CSS3新單位，是指裝置的畫面高度及畫面的寬度百分比。 .vw width: 10vw height: 10vw margin: 0 8px 這個部分我就單只用vw做範例，建議大家也可以調整瀏覽器大小並重新整理看看，下方是比較小畫面的螢幕截圖，這時的正方形其實和上方的100px大小差不多。 這時我把視窗拉滿了16:9的寬度，正方形明顯大很多。 我又繼續拉滿兩個16:9的螢幕，正方形已經突破天際了。 vmin 除此之外，還有一個單位稱為vmin，是裝置中寬度or高度較小的那個值，如果使用者裝置轉來轉去就很有效果!? 以上是不錯的新單位，但在目前還有許多瀏覽器不支援(android內建browser不支援)，使用前請先注意，","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS的運算","slug":"css-calc","date":"2013-09-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/26/css-calc/","link":"","permalink":"https://wcc723.github.io/css/2013/09/26/css-calc/","excerpt":"今天來介紹CSS最犯規的function calc，通常會用來做數值的運算，尤其是針對於長寬等等，而他最特別的是運算的數值\"不需要\"相同單位。","text":"今天來介紹CSS最犯規的function calc，通常會用來做數值的運算，尤其是針對於長寬等等，而他最特別的是運算的數值\"不需要\"相同單位。 基本運算 簡單來說就是css具有運算的功能，包含了基本的加減陳除。詳細介紹 這是一段範例，這段寬100% - 80px。 //html的code &lt;p class=&quot;test2&quot; &gt; 這是一段範例，這段寬100% - 80px。&lt;/p&gt; //sass的重點code .test2 width: calc(100% - 80px) 由這範例可得知，他的運算方式是不需要相同的\"單位\"，在這樣的情況下可以有相當多的變化。 這是一段範例，這段寬100% / 6。 .class width: calc(100% / 6) 有了基本的運算，100%/6就會出現六分之一的結果。 這是一段範例，這段left: calc(10% + 20px)。 這個運算方式就是這麼豐富，但是殘酷的來了...，calc須ie9以上。 排版 width: calc(100% - 200px - 1em) width: 200px 稍微拉動視窗看看 &lt;div class=&quot;test6&quot;&gt; &lt;div class=&quot;all1&quot;&gt;width: calc(100% - 200px - 1em)&lt;/div&gt; &lt;div class=&quot;w300&quot;&gt;width: 200px&lt;/div&gt; &lt;/div&gt; //sass .w200 width: 200px float: right .all1 width: calc(100% - 200px - 1em) //1em是間距的距離 100pxwidth: calc(100% - 200px)100px &lt;div class=&quot;test6&quot;&gt; &lt;div class=&quot;wl100&quot;&gt;100px&lt;/div&gt; &lt;div class=&quot;all2&quot;&gt;width: calc(100% - 200px - 2em)&lt;/div&gt; &lt;div class=&quot;wr100&quot;&gt;100px&lt;/div&gt; &lt;/div&gt; //sass .wr100 float: right width: 100px .wl100 float: left width: 100px .all2 width: calc(100% - 200px - 2em) //間距的距離 margin: 0 1em //間距的距離 Calc的好處就是彈性很大，所以再版型的規劃上，不再限定那麼多，所以在範例上可以了解，這樣的方式兩欄或是三欄都是難不倒它的，相信這屬性，在未來的RWD(自適應網頁)是有很多的幫助。 Toy 來源：http://codepen.io/th61855/pen/tAzBC .demo div width: calc(100% - 4em) height: calc(100% - 4em) +border-radius(50%) 而這是一個等距離的圓圈，利用的就是calc(100% - 4em)，做出的等距離效果，而他的動畫，根本次要說明的範例毫無關係>","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 意想不到的background-attachment","slug":"background-att","date":"2013-09-24T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/25/background-att/","link":"","permalink":"https://wcc723.github.io/css/2013/09/25/background-att/","excerpt":"background-attachment是背景固定模式的屬性，而不同的固定方式就能夠有不同的視覺效果，而人類的視覺是很容易欺騙的，適當的利用可以有意想不到的效果。","text":"background-attachment是背景固定模式的屬性，而不同的固定方式就能夠有不同的視覺效果，而人類的視覺是很容易欺騙的，適當的利用可以有意想不到的效果。 scroll background-attachment: scroll scroll模式也是預設值，背景圖會隨著外圍頁面滾動而移動。 fixed background-attachment: fixed fixed模式，不管外面、裡面怎麼滾，他都是不會動的。 local (new) background-attachment: local local模式，主要的特色就是，自己的區塊內如果滾動時，背景圖也會跟著移動。 利用local + scroll做出的效果 (想不出名字...) 參考來源：http://lea.verou.me/more-css-secrets/#background-attachment 請滾動畫面中卷軸、請滾動畫面中卷軸 麻煩 請 捲動 旁邊 的卷軸 謝謝。 麻煩 請 捲動 旁邊 的卷軸 謝謝。 //css .class{ background: linear-gradient(white 30%, hsla(0,0%,100%,0)), linear-gradient(hsla(0,0%,100%,0), white 70%) bottom, radial-gradient(at top, rgba(0,0,0,.2), transparent 70%), radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom; background-repeat: no-repeat; background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px; background-attachment: local, local, scroll, scroll; } 在這效果下，我們可以做出向上或是向下未讀完錯覺(請滾動畫面中卷軸)，而簡單來說他利用了兩種模式的交叉運用，做出的視覺效果。 Scroll 層 background: radial-gradient(at top, rgba(0,0,0,.2), transparent 70%), radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom background-repeat: no-repeat background-size: 100% 18px, 100% 18px background-attachment: scroll, scroll 我們先看scroll層，上下都有著固定的陰影，在那邊不會移動，就算到了最上層及最底層也不會有變化。 Local 層 background: linear-gradient(black 30%, rgba(black,0)), linear-gradient(rgba(black,0), black 70%) bottom background-repeat: no-repeat background-size: 100% 40px, 100% 40px background-attachment: local, local 這一段把local層改成了黑色，可以看得比較清楚，可以發現local層是到了最上層及最底層後才會出現，利用這個方式蓋住上一層。當然到時候要記得改回白色。 在完成一次的demo 麻煩 請 捲動 旁邊 的卷軸 謝謝。 麻煩 請 捲動 旁邊 的卷軸 謝謝。 參考來源：http://lea.verou.me/more-css-secrets/#background-attachment","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3的漸層","slug":"css-background","date":"2013-09-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/24/css-background/","link":"","permalink":"https://wcc723.github.io/css/2013/09/24/css-background/","excerpt":"本篇介紹CSS3的漸層，而就漸層這功能聽起來，似乎沒有什麼樣的變化，但其實透過復合式的背景可以堆疊出相當多的變化。","text":"本篇介紹CSS3的漸層，而就漸層這功能聽起來，似乎沒有什麼樣的變化，但其實透過復合式的背景可以堆疊出相當多的變化。 漸層 .gradient { background: #bf2c73; background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #ff3b99), color-stop(100%, #7f1d4d)); background-image: -webkit-linear-gradient(#ff3b99, #7f1d4d); background-image: -moz-linear-gradient(#ff3b99, #7f1d4d); background-image: -o-linear-gradient(#ff3b99, #7f1d4d); background-image: linear-gradient(#ff3b99, #7f1d4d); } CSS3漸層在各個瀏覽器的前輟詞並不相同，但在這邊不會特別介紹，主要會利用sass做範例(必須承認，不用sass寫那些前輟詞真的很痛苦...) +background-image(linear-gradient(left, #E80C7A,rgba(#E80C7A,.5), #E85D2D)) +background-image(linear-gradient(bottom, #E80C7A,rgba(#E80C7A,.5), #E85D2D)) //從下方開始 +background-image(linear-gradient(-35deg, #E80C7A,rgba(#E80C7A,.5), #E85D2D)) //旋轉 這是最基本的漸層，除了垂直之外也可以改成水平甚至是有角度的。 +background-image(radial-gradient(#E80C7A,rgba(#E80C7A,.5), #E85D2D)) //放射狀 另外還有放射狀的漸層。 多重背景 +background-image(linear-gradient(left, rgba(#E80C7A,.5) 20%, transparent 50%)) +background-image(linear-gradient(top, rgba(#E80C7A,.5), transparent 70%)) 這邊是兩個不同方向的漸層，下面要將他們合併。 +background(linear-gradient(left, rgba(#E80C7A,.5) 20%, transparent 50%),linear-gradient(top, rgba(#E80C7A,.5), transparent 70%)) //兩個漸層只要用逗點隔開即可，這樣就可以做出多層次的漸層 在CSS3中背景可以做兩層以上，而不只是漸層，所有的背景圖案都可以，只要用逗點隔開就可以一直堆疊下去；所以在這邊我們只要把漸層語法用逗點隔開，就可以堆疊漸層。 圖樣背景 來源：http://codepen.io/html5web/pen/HDCrK +background-image(linear-gradient(-45deg, #000 5px, transparent 50px)) background-size: 50px 50px //利用background-size去控制每個背景的大小 如果要做類似圖樣的背景，我們可以設定背景的大小background-size，就可以做出一塊一塊的圖樣。 +background-image(radial-gradient(#fff 3px, transparent 5px, #fff 7px, transparent 9px, #fff 11px, transparent 13px, #fff 15px, transparent 17px, #fff 19px, transparent 21px, #fff 23px, transparent 25px, #fff 27px, transparent 29px, #fff 31px, transparent 33px)) background-color: #111 background-size: 30px 30px //漸層還可以設定每個顏色的距離，只要在顏色後方輸入數值 漸層還可以設定每個顏色的區段距離，只要在色彩後方輸入數值就可以了。 旋轉吧漸層 來源：http://codepen.io/agriboz/pen/izLak +background(linear-gradient(45deg, #557777 50%, transparent 50%),linear-gradient(90deg, #ee6655 100%, transparent 100%),linear-gradient(135deg, #ffeebb 50%, transparent 50%) 100% 0%,linear-gradient(180deg, #ffcc55 100%, transparent 100%) 100% 0%,linear-gradient(225deg, #ffaa22 50%, transparent 50%) 100% 100%,linear-gradient(270deg, #ccddaa 100%, transparent 100%) 100% 100%,linear-gradient(315deg, #77aa88 50%, transparent 50%) 0% 100%,linear-gradient(360deg, #99cc99 100%, transparent 100%) 0% 100%) //很抱歉，這顏色就是那麼的....長 background-repeat: no-repeat background-size: 50% 50% +border-radius(50%) margin: 0 auto width: 150px height: 150px border: 1em solid tomato +transition(all, 3s) //加點動態 &:hover +transform(rotate(3600deg)) 甚至結合其他語法，可以有更豐富的玩法，像是這結合了border-radius、transition、transform等等，讓這個元素像是轉盤一樣在旋轉。 +background(linear-gradient(45deg, #557777 50%, transparent 50%),linear-gradient(90deg, #ee6655 100%, transparent 100%),linear-gradient(135deg, #ffeebb 50%, transparent 50%) 100% 0%,linear-gradient(180deg, #ffcc55 100%, transparent 100%) 100% 0%,linear-gradient(225deg, #ffaa22 50%, transparent 50%) 100% 100%,linear-gradient(270deg, #ccddaa 100%, transparent 100%) 100% 100%,linear-gradient(315deg, #77aa88 50%, transparent 50%) 0% 100%,linear-gradient(360deg, #99cc99 100%, transparent 100%) 0% 100%) background-repeat: no-repeat background-size: 50% 50% //移除動態及一些其他設定，僅保留重要的設定值 而這個效果很特別他每個漸層顏色是設定50%有色彩，另外50%是透明，然後每45度做一次顏色。 +background(linear-gradient(45deg, #557777 50%, transparent 50%),linear-gradient(90deg, #ee6655 100%, transparent 100%),linear-gradient(135deg, #ffeebb 50%, transparent 50%) 100% 0%,linear-gradient(180deg, #ffcc55 100%, transparent 100%) 100% 0%,linear-gradient(225deg, #ffaa22 50%, transparent 50%) 100% 100%,linear-gradient(270deg, #ccddaa 100%, transparent 100%) 100% 100%,linear-gradient(315deg, #77aa88 50%, transparent 50%) 0% 100%,linear-gradient(360deg, #99cc99 100%, transparent 100%) 0% 100%) background-repeat: no-repeat //在移除background-size: 50% 50% 並且每個漸層色只有50%*50%的大小，就是1/4的區域，如果沒有background-size: 50% 50%，他就會像上面這範例這樣。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - text-shadow初試身手","slug":"css-text-shadow","date":"2013-09-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/23/css-text-shadow/","link":"","permalink":"https://wcc723.github.io/css/2013/09/23/css-text-shadow/","excerpt":"text-shadow算是CSS3中較早出現的語法，而且不需要打前輟詞就能夠執行。","text":"text-shadow算是CSS3中較早出現的語法，而且不需要打前輟詞就能夠執行。 text-shadow的原理 入陣曲 &lt;div class=&quot;text1&quot;&gt;入陣曲&lt;/div&gt; .text1 { color: red; text-shadow: 4em 0 0 gray; } 由上範例可得知，紅色的文字是html的純文字，另外灰色的文字就是text-shadow所產生的新元素。 所以探究text-shadow的原理，其實他是從原本的文字衍伸出相同的元素，並且額外調整其衍伸出的外觀屬性，調整位置、透明度以及調整模糊的程度。而他的語法結構text-shadow: X值 Y值 blur值 色彩。 text-shadow的範例 來源參考：http://www.w3cplus.com/blog/52.html 當一座城牆 只為了阻擋 所有自由渴望 文字來源 五月天 入陣曲 //html &lt;div class=&quot;text&quot;&gt;當一座城牆 只為了阻擋 所有自由渴望&lt;/div&gt; 這一部分都是用同一段文字作為範例。 一般模式 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 1px 1px 5px gray; 這是最正常的版本，就只是當作一般的陰影在使用，但是這種版本其實會影響閱讀，所以建議不使用。 小陰影 當一座城牆 只為了阻擋 所有自由渴望 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 1px 1px 0 white; text-shadow: -1px -1px 0 white; 在陰影的blur值設定為0，和底色的顏色只要做一點點的落差，就能適度的提升閱讀性。而這樣的效果，也會有凹陷的視覺感。 立體字 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ color: #ccc; text-shadow: -1px -1px 0 white, 1px 1px 0 #333,1px 1px 0 #444; text-shadow不只可以使用一次，可以利用逗點分隔，不斷地增加新的陰影屬性，而立體字就是這樣的效果。 光暈 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 0 0 20px orange color: white 也可以將文字做成白色，然後將陰影的模糊程度調高，製造類似光暈的效果。 霓虹燈 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ color: white text-shadow: 0 0 5px white,0 0 10px white,0 0 15px white,0 0 40px #ff00de,0 0 70px #ff00de 同上效果，但是不斷的堆疊層次，內層先使用白色，外層堆疊高彩度的色彩，製造出類似霓虹燈的效果。 復古字 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 3px 3px 0 #555, 5px 5px 0 white color: white 是利用兩個陰影堆疊出來的，可惜的是第一個陰影必須與背景相同顏色。 而其實text-shadow是一個很簡單的效果，但是可以有非常多的變化，以上範例只是一小部分，而說不定現在正在看的各位，已經有新的想法，可以做出新的效果，有機會就分享來給大家知道喔~!","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 別忘了偽元素","slug":"css-pseudo-element","date":"2013-09-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/22/css-pseudo-element/","link":"","permalink":"https://wcc723.github.io/css/2013/09/22/css-pseudo-element/","excerpt":"偽元素在IE8之後全面都有支援，而這樣功能在CSS3可以創造出更多的效果。","text":"偽元素在IE8之後全面都有支援，而這樣功能在CSS3可以創造出更多的效果。 偽元素介紹 圖片來源：動畫 火影忍者 在火影忍者中的鳴人，在劇情開始不久學會了強大的影分身術，透過影分身術這個忍術，鳴人可以額外創造出有戰鬥力的分身。而偽元素也是類似影分身術，在一個html的標籤內在新增至多兩個元素，透過這個元素我們可以做許多額外的變化，就像上面這個範例，鳴人是一個元素，在hover後可以再產生兩個元素，並且利用動畫來增加視覺效果。 偽元素的用法 &lt;!--HTML--&gt; &lt;div class=&quot;naruto&quot;&gt;&lt;/div&gt; 鳴人這一個範例中，只使用了一個div標籤，而左右兩個鳴人是是利用偽元素產生，如果需要使用偽元素，content: \"\"屬性則是重點，他可以產新的元素來使用。 /*重點css code/* .naruto{ background-image: url(\"/images/naruto.png\") position: relative; /*相對位置*/ ... } .naruto:before,.naruto:after{ /*選取.naruto的前方偽元素及後方偽元素*/ content: \"\"; /*產生一個空的元素*/ position: absolute; /*利用absolute定位*/ left: 150px; /*調整位置*/ background-image: (...) /*插入圖片*/ ... } 偽元素的位置 心未涼 歌詞引用自：五月天 入陣曲 &lt;!--HTML--&gt; &lt;div class=&quot;mayday&quot;&gt;心未涼&lt;/div&gt; 在這個部分我用純文字作範例，偽元素我們可以假想它是在div標籤中新增before及after標籤，而它的位置會是在div標籤內的最前方及最後方，所以在使用必須切記它的位置，或者是用position: absolute，來忽略它所存在的位置。 &lt;div class=&quot;mayday&quot;&gt; &lt;before&gt;淚未乾 &lt;/before&gt; 心未涼 &lt;after&gt; 是什麼依然在滾燙&lt;/after&gt; &lt;/div&gt; 偽元素的範例 如此區塊下的陰影。 幼無糧 民無房 誰在分贓 //對話框 //sass code $color: #f74b48 .box-withArrow background: $color color: white +border-radius(5px) position: relative ... &:after content: \"\" width: 0 height: 0 position: absolute left: 10px bottom: -20px border: transparent 10px solid border-top: $color 10px solid //繪製小箭頭，並且定位置左下方 //讓這一個框框就像是對話框呈現 歌詞引用自：五月天 入陣曲 偽元素的用途多不勝數，且只要在ie8以上就能夠執行，而在本篇會特別提及的原因，就是偽元素能夠過CSS3做相當多的變化，例如旋轉、陰影、漸層色甚至是結合動態效果，且偽元素也能適當的減少html的標籤使用，讓html的維護更輕鬆。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3的色彩","slug":"css-color","date":"2013-09-20T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/21/css-color/","link":"","permalink":"https://wcc723.github.io/css/2013/09/21/css-color/","excerpt":"在過去我們只要使用色碼來表示顏色，色碼是用三組十六進制數位表示，每位元組從00到FF，相當十進位數位從0到255...，而現在我們有了新的屬性alpha(透明度)。","text":"在過去我們只要使用色碼來表示顏色，色碼是用三組十六進制數位表示，每位元組從00到FF，相當十進位數位從0到255...，而現在我們有了新的屬性alpha(透明度)。 RGBA RGB在色彩學上定義為色光三原色，分為紅、綠、藍三色，而其混色模式為加法混色，在三種顏色相加後會變成白色；而另一種混色模式為印刷色料，是屬於減法混色，由CMYK四色組成，顏色在混和後會變成黑色。三原色的呈現主要適用於電視及電腦的顯示器，因此網頁也是利用RGB三原色。 圖片來源 http://zh.wikipedia.org/wiki/RGB_%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4 RGB相信對於一般視覺設計師來說非常的熟悉，是開啟繪圖軟體後經常會使用的色彩模式之一，其數值為0~255之間，三種數值如果都為255會顯示白色；如果三種顏色都為0則會是黑色。 圖片來源 Illustrator 在CSS3中新增了一個新的屬性alpha，alpha一般用作不透明度參數，數值從0~1之間，0是透明，而1代表不透明。 /css .rgba1 { background: rgba(232, 12, 122, 0.2); } .rgba2 { background: rgba(232, 12, 122, 0.4); } .rgba3 { background: rgba(232, 12, 122, 0.6); } .rgba4 { background: rgba(232, 12, 122, 0.8); } .rgba5 { background: #e80c7a; } 編寫方式為屬性：rgba(R值,G值,B值,alpha值)。 HSLA HSL是由色相(H)、飽和度(S)、亮度(L)組成，飽和度以及明度的值為0~100%，而色相是利用色彩學的色相環概念(如下圖的H)，所以值是由0~360，他所表現的也是一個圓環上的各個顏色。 圖片來源 http://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4 如上圖，和HSL類似的色彩模式為HSV，主要差異為明度(V)換成了亮度(L)，而CSS3所採用的色彩模式為HSL，兩者比較可以參考 http://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4。 僅調整色相(H)的效果 //利用sass調整其色相(H)的數值 @for $i from 1 through 6 //分為6階 .h#{$i} //class h1~h6 background: hsla(60 * $i,100%,50%,1) //色相(H)60為1階，乘以6階，飽和度100，明度50，alpha為1(不透明) 僅調整飽和度(S)的效果 //利用sass調整其飽和度(S)的數值 @for $i from 1 through 6 .s#{$i} background: hsla(120,(20% * $i - 20),50%,1) //色相(H)為120，飽和度20為1階分為6階，明度50，alpha為1(不透明) 僅調整明度(L)的效果 //利用sass調整其飽和度(S)的數值 @for $i from 1 through 6 .l#{$i} background: hsla(120,100%,(20% * $i - 20),1) //色相(H)為120，飽和度100，明度20為1階分為6階，alpha為1(不透明) Hsla編寫方式為屬性：hsla(h值,s值,l值,alpha值)。 Kuler https://kuler.adobe.com 這是Adobe公司所出的顏色工具，不管事RGB或是色碼都可方便轉換及調整。 支援程度 主要會有支援問題的是alpha屬性，所以在使用時須考慮替代方案，如先設定好沒有alpha的色彩，在設定有alpha屬性的色彩。 Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) keywords colors 1.0 1.0 (1.0) 3.0 [*] 3.5 1.0 (85) #RRGGBB | #RGB 1.0 1.0 (1.0) 3.0 3.5 1.0 (85) rgb() 1.0 1.0 (1.0) 4.0 3.5 1.0 (85) hsl() 1.0 1.0 (1.5) 9.0 9.5 3.1 (525) rgba() 1.0 3.0 (1.9) 9.0 10.0 3.1 (525) hsla() 1.0 3.0 (1.9) 9.0 10.0 3.1 (525) currentColor 1.0 1.5 (1.8) 9.0 9.5 4.0 (528) transparent 1.0 3.0 (1.9) 9.0 [**] 10.0 3.1 (525)","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Sass 與 Compass(2)","slug":"compass-2","date":"2013-09-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/20/compass-2/","link":"","permalink":"https://wcc723.github.io/css/2013/09/20/compass-2/","excerpt":"承上篇，上一篇主要是介紹Sass和Compass是什麼，而本篇會介紹Sass和Compass究竟對CSS的撰寫有什麼樣的影響，讓許多工程師及設計師都說已經回不去了(回不去CSS)，現在就讓大家瞧瞧，它是多麼的強大吧(本篇介紹主要語法將會以Sass為主，並非使用Scss)。","text":"承上篇，上一篇主要是介紹Sass和Compass是什麼，而本篇會介紹Sass和Compass究竟對CSS的撰寫有什麼樣的影響，讓許多工程師及設計師都說已經回不去了(回不去CSS)，現在就讓大家瞧瞧，它是多麼的強大吧(本篇介紹主要語法將會以Sass為主，並非使用Scss)。 小試牛刀 - 巢狀 我最愛 在單槓上 練劈腿 /*CSS*/ ul { color: #e80c7a; } ul li { border-bottom: #cccccc solid 1px; } /*sass*/ ul color: #E80C7A li border-bottom: #ccc solid 1px 向這樣的巢狀寫法，父層的selector只需要寫一次，子層的只要縮排依序寫下去，在編譯後就會編譯成如上方的CSS，這樣的功能尤其是在menu及Table特別有感...。且在父層Selector需要改變時，也只要改變一次父層Selector。 小試牛刀 - 變數 /*sass*/ $color: #E80C7A ul color: $color li border-bottom: #ccc solid 1px 變數在sass使用頻率相當高，對於設計師來說，可以將變數設想為Illustrator的色票，可以不斷地重複使用。而在往後如果變數需要修改，所有引用此參數的屬性也可套用新的變數，可有效減少修改的時間。 來點厲害的 - 數學運算 150 + 10 + 10 = 170px 太寬了~ 150 - 10 * 2 = 120px 這才是想要的 這邊以box來作範例，假設我們需要150px X 150px的div，但一般來說border會增加在所設定的寬度外圍，所以box的寬高會如上圖左，在sass中我們可以如下編寫方式得到我們想要的寬高，而優點當然是不用每次修改都手動重新計算數值。 $boxSize: 150px $boxBorder: 10px .box2 border: $color solid $boxBorder //border寬度 width: $boxSize - $boxBorder*2 //div的寬度減掉左右邊的border寬 height: $boxSize - $boxBorder*2 //記得 先乘除後加減... ... 來點厲害的 - 色彩運算 background: #E80C7A background: #b80961 設計師應該會都聽過一句話：顏色在深一點點，而顏色在深一點點，在繪圖軟體上好辦事，但是這六個號碼的色碼，就好像是馬賽克一樣，怎麼樣都令人摸不清。而sass的色彩運算可以將顏色加深、調淡，甚至是旋轉色相、調整飽和度等功能。 $color: #E80C7A .box background: darken($color,10%) 來點厲害的 - Mixin 標題 標題 標題 內容 內容 內容 標題 標題 標題 內容 內容 內容 mixin在sass是相當重要的功能，其功能是將CSS模組化，並且可將變數另外設定，讓引用mixin時去做變數的調整。而對於設計師來說，可以將mixin設想為Flash的元件或是Illustrator的圖樣功能，只要設定一次，在後面可以重複性的使用。 //設定mixin，並且將背景色設定為變數 @mixin table-base($color: #E80C7A) border-collapse: collapse width: 100% th text-align: center background: $color color: white td,th padding: 6px border: 1px solid #ccc table.table1 +table-base //mixin匯入，只需要輸入@include mixin名稱 //或者在.sass可以輸入+mixin名稱 table.table2 +table-base($color: #9d6bda) //mixin匯入後，重新設定變數 Compass 一起來吧 Compass內建CSS3的mixin，所以在導入CSS3是相當方便的。 /sass $color: #E80C7A .box +background-image(linear-gradient($color,darken($color,20%))) //漸層色效果 ... //CSS .box{ background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #e80c7a), color-stop(100%, #870747)); background-image: -webkit-linear-gradient(#e80c7a, #870747); background-image: -moz-linear-gradient(#e80c7a, #870747); background-image: -o-linear-gradient(#e80c7a, #870747); background-image: linear-gradient(#e80c7a, #870747); ... } Sass + Compass 標題 標題 標題 內容 內容 內容 而在sass及compass合體後，就能明顯增加工作效率，而多餘的時間將能夠開發更多的CSS效果，以提升專案的品質。 //將mixin 導入CSS3 @mixin table-base2($color: #E80C7A) border-collapse: collapse width: 100% th text-align: center background: $color +background-image(linear-gradient($color,darken($color,20%))) color: white td,th padding: 6px border: 1px solid #ccc table.table3 +table-base2 //在引用後，會自動計算漸層色彩 本篇所介紹的Sass和Compass的功能只是其中一部份，但其實在使用上已經很充足，畢竟Sass也是屬於一種工具，與其學的精，不如先發揮其所能，希望有興趣的朋友們，來一起嘗試看看吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Sass 與 Compass(1)","slug":"compass-1","date":"2013-09-18T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/19/compass-1/","link":"","permalink":"https://wcc723.github.io/css/2013/09/19/compass-1/","excerpt":"在先前的幾篇，有提過好幾次的Sass以及Compass、Fire.app等工具，在這邊就來釐清這些是什麼樣的工具。 Sass官方網站：http://sass-lang.com/","text":"在先前的幾篇，有提過好幾次的Sass以及Compass、Fire.app等工具，在這邊就來釐清這些是什麼樣的工具。 Sass官方網站：http://sass-lang.com/ Q1:他是類似Dreamweaver或是什麼樣的軟體嗎? 為何有這樣的問題呢?因為一開始我真的這麼認為。我以為它是XX軟體或是XX軟體的外掛元件，只要下載安裝就可以了，而到了Sass官網，我找不到Download或是我能理解的安裝方法，發現我真的無法理解...。 以上是題外話，Sass並不是一套軟體，它算是CSS的進階語言，透過Ruby環境編譯成一般CSS，而在編寫的過程中Dreamweaver、Sublime text、Visual Studio、記事本只是編寫的工具，並不會影響到編譯後的結果。 建議對Sass有興趣的設計師或工程師，請繼續看下去，Sass是非常優秀的CSS進階語言，而入門並沒有想像中的困難。 Q2:Ruby又是什麼? 是一種程式語言，而Sass就是用Ruby所編寫，所以在Sass編譯時需要有Ruby的編譯能力。 Ruby繁體中文 Q3:Sass，為何又有人說scss? 兩者都屬於sass，而差在附檔名以及編寫方式的不同。 .sass是屬於原生的sass語法，明顯的特徵是利用縮排取代大括號。.scss後來衍生出來的語法，為了讓新一代的設計師可以承受較少的痛學習sass，所以在結構上相當類似CSS。 /*CSS Code*/ .error { border: 1px #f00; background: #fdd; } /*SCSS Code*/ .error { border: 1px #f00; background: #fdd; } /*Sass Code*/ .error border: 1px #f00 background: #fdd 由以上範例可以看出SCSS其實和CSS幾乎是一樣的，而Sass就少了大括號以及分號。而我喜歡sass的簡潔，尤其是少了大括號可以增加CSS的閱讀性，但如果在專案進行時，建議與同伴們討論好要以哪一種語法執行，避免造成日後維護的困擾。 Q4:Less 又是什麼? 他也是類似sass的CSS擴充語言，不同的是sass是在Ruby環境下，而less是Javascript library。本篇不太會介紹到Less，如知詳情請參考此比較網站(http://www.hongkiat.com/blog/sass-vs-less/)。 Q5:sass 可以運用在現在的專案嗎? 由於前方有介紹到Scss的語法結構與CSS類似，只要有編譯環境後，將CSS的副檔名修改成.scss就可以開始嘗試了，而從現有的專案開始練習，也可以快速了解其優點。 Q6:Compass又是什麼? Compass是sass的擴充語言，而其中最常使用的就是CSS3的mixin(在下一篇會介紹mixin)。 /*SCSS Code*/ .demo{ @include border-radius(5px); ... } /*Sass Code*/ .demo +border-radius(5px) ... /*CSS code*/ .demo{ -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; ... } 由以上範例可得知，寫一行抵別人寫5行，怎麼可能會輸? Q7:該怎麼開始? 以正常流程來說，首先需要有Ruby環境，然後安裝Sass、Compass等等，而在這邊我推薦使用Fire.app (http://fireapp.handlino.com/)，可以讓使用者快速進入Sass。當然，Sass在學習時需要許多的耐心與愛心，需要慢慢地去理解，接著去尋找其他人所了解的答案，最後在自己的能力範圍內去教導其他人使用。 以下為相關入門文章(網路文章非常非常的多，請選擇自己容易理解的去閱讀) 環境建立------ 安裝ruby及sass環境 http://ashareaday.wcc.tw/#2013-09-02 使用Fire.app http://ashareaday.wcc.tw/#2013-09-03 使用Fire.app http://demo.tc/Post/757 語法教學------ 30天挑戰Sass http://ithelp.ithome.com.tw/profile?id=20040221 ashareaday天天都分享ashareaday 其他相關文章------ 利用 Compass / Sass 快速開發版型 http://www.slideshare.net/kurotanshi/compass-sass?ref=http://127.0.0.1:24681/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 瀏覽器的戰爭","slug":"css-web","date":"2013-09-17T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/18/css-web/","link":"","permalink":"https://wcc723.github.io/css/2013/09/18/css-web/","excerpt":"承上篇，瀏覽器的數量越來越多，有許多需要克服。如老不死的IE瀏覽器、各式各樣的瀏覽器前輟詞、各種CSS語法的支援程度，都是需要去注意的。","text":"承上篇，瀏覽器的數量越來越多，有許多需要克服。如老不死的IE瀏覽器、各式各樣的瀏覽器前輟詞、各種CSS語法的支援程度，都是需要去注意的。 CSS hack CSS hack，在學習網頁設計的這一個年頭，感謝他一直陪伴著我，深信著他還會繼續陪伴我...在這幾年...。 需要進行hack的瀏覽器，主要是以舊版的IE為主，雖然許多國際的公司已不再支援IE7以下的瀏覽器(ie7,ie6)，但就我所了解，目前台灣還有許多的使用者是使用IE7的瀏覽器。而IE的使用者中，有很大的部分是不清楚瀏覽器的分別，更別說哪一種速度快、安全性高等等，對這些使用者來說，點兩下出現的那個瀏覽器就是正確的瀏覽器，而除非所需要製作的網站沒針對這些使用者的需求，不然IE這部分也是需要考慮的。 .class{ background-color:red\\0; /* ie 8/9*/ background-color:blue\\9\\0; /* ie 9*/ *background-color:#dddd00; /* ie 7*/ _background-color:#CDCDCD; /* ie 6*/ } 參考：http://www.css88.com/archives/3746 上方的CSS範例簡單介紹CSS在IE上常用的hack，以大部分瀏覽器來說，會看到的結果為橘色，而在ie6會看到灰色，ie7為黃色，ie8為紅色，ie9為藍色。就我的習慣，在進行專案時版面的編排會盡力符合ie8，必要時再使用hack配合ie7，其他酷炫的效果，在不影響編排的情況下慢慢的增加上去。這就像是電扶梯理論，電扶梯再有電的時候可以讓人輕鬆的上下樓，而就算沒電了，他還是能夠讓行人行走。 Can I use 而在加裝電扶梯的時候，也要先確認要裝設的建築物是否可以架設電扶梯；CSS也是如此，在增加效果時可以先查詢有哪些瀏覽器可以顯示該效果。 http://caniuse.com/ http://devdocs.io/ 這邊推薦兩個網站用來查詢CSS對於瀏覽器的相容性，caniuse用表格及顏色顯示各個瀏覽器以及版本的相容性，如上圖如果需要知道IE8是否支援@font-face就會知道只有部分支援，藉此來考慮是否用@font-face語法；而devdocs則會列出CSS語法的各項細節的相容性，並且會詳細介紹該語法的使用方法、支援的值等等。 確認好專案的版本 而有些細節，需要痛過過才會記住，就如同display: inline-block，有些文件寫支援ie7，而有些是寫支援ie8；主要原因是ie7的inline-block必須要行內樣式才能夠執行，行內樣式就如a、em、span等等，而塊級元素如div就不能套用。 http://yui.github.io/gridbuilder/ purecss是Yahoo所提供的framework，而他的grid網格系統就是利用inline-block來進行排版，所以如果有ie7的需求，在執行時就要多注意這個問題。 IE的測試 而一直提到ie789，但是一台電腦通常只有一種版本的ie，這時候我們可以使用ie的F12開發人員工具(很明顯是按F12可以叫出來)，同時調整工具列中的瀏覽器模式及文件模式的版本(僅能向下支援，且並不是完全相同)，就可以預覽該版本的CSS渲染結果(如下圖)。 IE10 模擬IE7，等等...這怎麼回事，這不是微軟的MSN台灣首頁嗎? CSS3前輟詞 談論ie的話題就到這邊為止了，本篇的重點還是會偏向於CSS3。目前許多瀏覽器對於CSS3的支援度都有明顯的改進，但是還有一個問題，就是麻煩的前輟詞。 .class{ -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; } border-radius是一個圓角的語法，正常的情況下應該就是border-radius: 值;，但許多的瀏覽器必須加上前輟詞才能正常瀏覽這個效果。在上一集有提過瀏覽器的核心，而-webkit-就是其中一種，不同的核心有不同的渲染方式，Chrome與Safari正是用webkit核心；-moz-則是Mozilla公司的縮寫(Gecko核心)，代表瀏覽器為Firefox；-o-是Opera瀏覽器的縮寫(Presto核心)；-ms-微軟的縮寫...，代表瀏覽器是ie。 雖然目前部分瀏覽器不需要寫前輟詞就能瀏覽CSS3，但為了能夠在大部分瀏覽器正常瀏覽，還是建議補上。 CSS3是很炫，不過還要注意到替代方案 CSS3雖然很炫，但要注意並不是所有瀏覽器都支援CSS3，所以新的效果前，請將CSS3語法前補上CSS2語法。如以下範例： 假設 不支援CSS3瀏覽器 支援CSS3瀏覽器 background: #bf2c73; /*不支援CSS漸層的瀏覽器，將會顯示此色彩*/ background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #ff3b99), color-stop(100%, #7f1d4d)); background-image: -webkit-linear-gradient(#ff3b99, #7f1d4d); background-image: -moz-linear-gradient(#ff3b99, #7f1d4d); background-image: -o-linear-gradient(#ff3b99, #7f1d4d); background-image: linear-gradient(#ff3b99, #7f1d4d); 這是CSS3漸層效果，為了避免不支援的瀏覽器看不到顏色，請先將background: #bf2c73;放在CSS3語法前方，讓不支援CSS3的瀏覽器也能看到單一的色彩，而支援的瀏覽器將會依條件顯示正常的漸層色彩。 往後的內容將會越來越精彩，敬請期待>O","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS 的改變","slug":"css-change","date":"2013-09-16T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/17/css-change/","link":"","permalink":"https://wcc723.github.io/css/2013/09/17/css-change/","excerpt":"本篇內容同步發表於http://ashareaday.wcc.tw/#2013-09-17 (建議使用Chrome瀏覽器) CSS是用來決定網頁的顏色、字型、排版等顯示的特性，現在除了以上功能外，CSS3增加了更多的效果，不僅可以增加網頁的閱讀性，還可以吸引使用者的目光。而許多的改變，正在影響著CSS的進化。","text":"本篇內容同步發表於http://ashareaday.wcc.tw/#2013-09-17 (建議使用Chrome瀏覽器) CSS是用來決定網頁的顏色、字型、排版等顯示的特性，現在除了以上功能外，CSS3增加了更多的效果，不僅可以增加網頁的閱讀性，還可以吸引使用者的目光。而許多的改變，正在影響著CSS的進化。 裝置的改變 圖片來源 : http://johnpolacek.github.io/scrolldeck.js/decks/responsive/ 自從蘋果發表了第一台iphone以來，就代表了行動裝置的時代的來臨。每個使用者都很開心地在小小的畫面上滑來滑去，但每次的滑動，都是工程師的心血。而在幕後的工程師，小心翼翼的測試每一種的裝置，是否可以正常的瀏覽所設計的頁面，深怕使用者在使用時說了一聲：「靠杯，怎麼看不到。」，就再也不回頭欣賞這心血的結晶。 過去網頁製作只要桌上型個人電腦即可，到現在除了桌上型還有Tablet、smart phone，雖然隨著經驗的累積，可以不斷的衍伸各種製作方式，但...，新的裝置不斷的出，每次Size都不一樣，有的還越來越長...。 瀏覽器的多樣化 早期的瀏覽器多以IE為主，直到Mozilla 維持網路自由選擇、確保網路科技不斷創新的理念下，創造了Firefox瀏覽器，自此瀏覽器進入了戰國時代...，如下圖。 圖片來源 : http://evolutionofweb.appspot.com/?hl=zh 瀏覽器的增加，對使用者來說，有了更多的選擇，但對工程師來說，卻有了大問題...。目前主流的瀏覽器有Google的Chrome、Apple的Safari、Mozilla的Firefox、微軟的IE，以上都有著不同的瀏覽器核心(參考)，而同樣的CSS語法在不同的核心下，所渲染出來的畫面不同。如下圖，每位美女的需求喜好不同，如果要達到每位美女的需求，勢必要一位一位地去了解，才能獲得他們的芳心。 圖片來源：http://pashutaphotography.blogspot.tw/2013/08/what-if-girls-were-internet-browsers.html 工具的改變 圖片來源：http://fireapp.handlino.com 新的工具出現，大大的縮短工作的時程，有效的增加工作效率，這邊以Fire.app為例(連結)，它包含了Sass、Compass、livereload等CSS工具。 Sass是屬於CSS高階語法，包含了變數、運算、function等等，就像是網路遊戲中玩家從1級升級到了60級的改變。但老玩家應該都清楚，只有高的等級是不夠的，更重要的是裝備，而Compass就是Sass的傳奇裝備，這兩個工具在後面的章節會有獨立的介紹。 livereload是可以自動重新整理瀏覽器頁面，減少F5的磨損(參考)。透過以上的工具，可以有效的工作效率外，也可以有效率的研究新效果，並且結交新朋友(疑!?不過這也是實話...)。 新增的功能 過去的網頁，主要是在表格內製作，所以內容很多會局限在垂直與水平的格線內，到了CSS3已經可以突破在垂直與水平的空間內，並且新增許多如圓角、變形、漸層、透明...等許多的效果，而我們將會透過這些新的效果來完成更豐富的作品。 功能的強化 This is The Girl Next Door. CSS是透過「選擇器」（selector）、「屬性」（property）和「值」（value）組成，而CSS3不僅保留之前的語法，並且新增更多。如以上範例，font-family不僅可以定義字型，還可以透過font-face來自定義字型，讓支援CSS3的瀏覽器都能夠統一字型，達到設計的統整性。 運動的物件 及 3D 參考：http://desandro.github.io/3dtransforms/examples/cube-01-steps.html 在Flash流行的年代，運動的物件多會靠flash去執行，現在已經不需要依靠flash就可以達到許多相同的效果，如以上的範例，主要透過transition及transform完成。 而以上的效果，在剩下的28篇文章會有更詳細的介紹，讓網頁一起動起來吧~。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"網頁設計 技能樹!","slug":"web-skill","date":"2013-09-14T16:00:00.000Z","updated":"2016-10-12T03:37:37.000Z","comments":true,"path":"html/2013/09/15/web-skill/","link":"","permalink":"https://wcc723.github.io/html/2013/09/15/web-skill/","excerpt":"每天分享一篇文章，到今天差不多一個月了。剛好，明天開始是IT邦的鐵人賽，而這邊我會希望和鐵人賽的文章同步，不只整理過去的文章，並且以更細膩的文字去描述CSS的語法。","text":"每天分享一篇文章，到今天差不多一個月了。剛好，明天開始是IT邦的鐵人賽，而這邊我會希望和鐵人賽的文章同步，不只整理過去的文章，並且以更細膩的文字去描述CSS的語法。 而在建立這網頁後，不斷(偶爾)的調整與修改頁面風格，以及每日的上傳新的分享，可以更確定自己想要的是什麼，還有缺乏的是什麼。持續的去執行，才會瞭解過程中的問題。 而很剛剛好地，這幾天發現了一個有趣的玩具，它是模仿RPG遊戲的技能樹，改變成網頁開發者的技能樹。 http://www.dungeonsanddevelopers.com/ 目標天賦 而不斷的挑戰自己，就是朝目標前進最快的方式，保持著一樣的心情，迎接明天新的篇章。","categories":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/categories/html/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"}]},{"title":"立體字風格","slug":"cubic-font","date":"2013-09-05T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/09/06/cubic-font/","link":"","permalink":"https://wcc723.github.io/sass/2013/09/06/cubic-font/","excerpt":"今天在Fb上看到justfont發了一篇文，就是他們官網上的字可以做立體的風格，我看到這個立體字，突然想到和之前long-shadow有一點點像，所以我決定來試試看sass版本的立體字。","text":"今天在Fb上看到justfont發了一篇文，就是他們官網上的字可以做立體的風格，我看到這個立體字，突然想到和之前long-shadow有一點點像，所以我決定來試試看sass版本的立體字。 先用上次的long-shadow套看看 很明顯，不是這樣。 如果仔細看，其實立體字的背景不是透明的，他是白色到淺灰色，所以要先把套明改掉。 立體字風格 .class $all: () $lenght: 20 $rgb: #000 @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,rgba($rgb,0.9/$i + 0.05)),comma) text-shadow: $all 調整成不透明版本 恩~，有立體一點點了，但是還少了陰影。 立體字風格 .class $all: () $lenght: 20 $rgb: #fff @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,darken($rgb,$i/1.6)),comma) text-shadow: $all 完成 立體字風格 恩...，由於windows預設是明體...，有興趣還是可以自行拿去套信黑體。當然還是要送給大家@mixin。 @mixin text-cubicStyle($lenght: 15,$rgb: #dfdfdf) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,darken($rgb,$i/1.6)),comma) text-shadow: $all,$lenght+1px $lenght+1px 1px rgba(0,0,0,.3),$lenght+2px $lenght+2px 10px rgba(0,0,0,.6)","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS的小箭頭","slug":"css-arrow","date":"2013-09-03T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/04/css-arrow/","link":"","permalink":"https://wcc723.github.io/css/2013/09/04/css-arrow/","excerpt":"常常在很多網站會看到小三角形箭頭，當期都是使用圖片去製作，而時代的改變，就是要用寫的比較潮，為了趕上流行，所以在這分享小箭頭的製作方法。","text":"常常在很多網站會看到小三角形箭頭，當期都是使用圖片去製作，而時代的改變，就是要用寫的比較潮，為了趕上流行，所以在這分享小箭頭的製作方法。 用Border畫箭頭 我們先來看上面的demo，他是一個div，寬及高都是0，而上面的四個顏色都是border組成的，利用四個邊都是20px寬的border，且在不同的色彩下，他就會造成這樣的結果。 .arrow width: 0 height: 0 border-top: red 20px solid border-right: orange 20px solid border-bottom: blue 20px solid border-left: green 20px solid 再由程式碼得知，上右下左的色彩對應，如果我們想要一個向上、藍色的箭頭，我們就需要bottom的border。 正式開始 冤冤相報何時了，往事知多少。 我們需要先來一個文字方塊，它的CSS裡面一定需要position: relative，等等會用position: absolute去控制箭頭的位置。 冤冤相報何時了，往事知多少。 .bottomarrow width: 0 height: 0 position: absolute left: 10px bottom: -20px border: transparent 10px solid border-top: $color 10px solid 接下來我們把箭頭加上去，border可以先全部設定transparent 10px solid，最後再補上需要的部分。利用position: absolute去控制位置，另外需要注意的是如果箭頭要增加在下面，bottom的距離，需要是border的兩倍。 偽元素 冤冤相報何時了，往事知多少。 當然，我們也可以用偽元素去增加箭頭，做法是一樣的。 &:after content: \"\" width: 0 height: 0 position: absolute left: 10px bottom: -20px border: transparent 10px solid border-top: $color 10px solid","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"開始使用fire.app","slug":"start-fire-app","date":"2013-09-02T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/09/03/start-fire-app/","link":"","permalink":"https://wcc723.github.io/sass/2013/09/03/start-fire-app/","excerpt":"上一篇介紹ruby的安裝並使用它來編譯sass，本篇就要介紹如何開始使用fire.app。 官方網站 : http://fireapp.handlino.com/","text":"上一篇介紹ruby的安裝並使用它來編譯sass，本篇就要介紹如何開始使用fire.app。 官方網站 : http://fireapp.handlino.com/ Fire.app的功能 Sass + Compass 這部分介紹了許多次，所以不再重複介紹了~。 Template languages 樣板語言，內建了Haml/Slim/ERB/Markdown格式，這些樣板功能在視覺設計師眼裡就像是indesign的主板功能，他可以定義很多預設樣式，可以有效改善編輯時的效率，而在程式設計師眼中就像是include的功能。 CoffeeScript CoffeeScript讓javascript寫起來更直覺容易。 Auto Refresh 這功能就是同Livereload，在每次修改檔案他都會自動重新整理瀏覽器，少去了按f5的時間，減少鍵盤f5的故障率。 Build Project 在開發新專案時可以立即的建立基礎專案模板，並且在之後開啟只要輕輕點擊一下，就可以到該專案。 Cross-Platform Fire.app可以在各系統上使用，mac、windows、Linux，都可以輕鬆執行。 正式開始 在開始之前，可能還是要花點小錢($14USD)，在購買後不久就能收到軟體。本軟體不需要安裝，只要解壓縮就可以用，但建議還是解壓縮在英文目錄下比較穩定。 在一開始打開時，會出現在畫面的右下角，並且是黑色的，對他點右鍵。 選擇第一個Watch a Folder，可以試試看目前已經執行的專案，或者是簡單先做一個靜態的網頁。 在開啟後，右下角的火球會變成彩色，並且選單會有所改變，如果需要停止，只要點第一個stop XXX就可以了。 接下來馬上來測試有沒有成功，只要在網址列上輸入http://127.0.0.1:24681/的網址，如果有出現目前的網頁就算是成功了。 Auto Refresh 這功能可以在每次存檔時重新整理瀏覽器網頁，這和livereload相同，在使用之前建議先在瀏覽器安裝擴充套件(限定chrome,firefox)，本篇將用chrome做範例。 首先先到chrome線上應用程式商店，尋找LiveReload，並且安裝。 回到剛剛http://127.0.0.1:24681/的頁面，如果點擊右上方的圓圈，可以如圖呈現黑色，就恭喜你成功了。接下來在修改網頁後的每次存檔，你的chrome都會自動重新整理網頁。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"fire.app","slug":"fire-app","permalink":"https://wcc723.github.io/tags/fire-app/"}]},{"title":"安裝ruby以及sass環境","slug":"start-ruby","date":"2013-09-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/09/02/start-ruby/","link":"","permalink":"https://wcc723.github.io/sass/2013/09/02/start-ruby/","excerpt":"使用sass前的準備分為兩個部分: 文字編輯器 編譯環境 文字編輯器對於視覺設計師有Dreamweaver，而對於程式設計師則有vim、Visual studio等，除了以上之外這邊還會推薦使用sublime text，但本篇主要會先介紹編譯環境，所以在此不多敘述。 編譯環境是踏入sass最困難的一步，先前有提過sass是透過ruby所編譯的，所以在編譯前還需要有ruby，本篇會從如何建立ruby環境到sass的安裝。 說實在，本篇範例不建議使用，編譯sass並沒有這麼困難，但會讓大家了解ruby是怎樣的東西，這安裝流程是怎麼樣的，這有助於更了解sass，後面會介紹其他編譯sass的方式。","text":"使用sass前的準備分為兩個部分: 文字編輯器 編譯環境 文字編輯器對於視覺設計師有Dreamweaver，而對於程式設計師則有vim、Visual studio等，除了以上之外這邊還會推薦使用sublime text，但本篇主要會先介紹編譯環境，所以在此不多敘述。 編譯環境是踏入sass最困難的一步，先前有提過sass是透過ruby所編譯的，所以在編譯前還需要有ruby，本篇會從如何建立ruby環境到sass的安裝。 說實在，本篇範例不建議使用，編譯sass並沒有這麼困難，但會讓大家了解ruby是怎樣的東西，這安裝流程是怎麼樣的，這有助於更了解sass，後面會介紹其他編譯sass的方式。 Ruby & Sass安裝流程 本篇以windows為例 安裝Rubyinstaller 使用 Command Prompt with Ruby (Ruby的命令提示字元…硬要翻) 安裝sass、系統更新、安裝compass 使用 步驟1.安裝Rubyinstaller 首先連結到官網安裝Rubyinstaller(http://rubyinstaller.org/downloads/)，應該不會有人卡在這邊...，如果卡在這邊，建議先去找個網路遊戲下載安裝試試看。 步驟2.使用 Command Prompt with Ruby 在這個階段，只要找到你的Command Prompt with Ruby，並且打開就可以了。 步驟3.安裝sass 果你成功打開這個像DOS的東西，那應該就成功三分之一了，接下來就依序輸入指令碼，依序系統更新、安裝sass、安裝compass。 請依序輸入以下指令碼。 gem update –system gem install sass gem install compass 步驟4.使用sass 這個步驟的重點就是...怎麼使用dos指令，首先，就直接在桌面建立一個資料夾開始吧! (1)在桌面開了一個資料夾叫做SCSS，路徑是C:\\Users\\使用者ID\\Desktop\\scss (使用者ID) 裡面包含了兩個資料夾1.css 2.scss (2)接下來就是進入到你所建立的資料夾 輸入cd\\ (移動到根目錄) 輸入cd C:\\Users\\使用者ID\\Desktop\\scss (3)在你的C:\\Users\\使用者ID\\Desktop\\scss\\scss資料夾中，創一個test.scss的檔，並在檔案裡面輸入CSS，也可參考官網http://sass-lang.com/來做測試。 (4)回到你的Command Prompt with Ruby，輸入sass –watch scss:css，他將會把scss資料夾內的檔案編譯成CSS，並存在CSS這個資料夾。 sass –watch scss:css (5)神奇的事情發生了，SCSS被編譯成CSS檔，而且在你每次的SCSS存檔，都會被編譯。 完成! 只要Command Prompt with Ruby，沒有被中止，他就會持續監控你的SCSS檔，所以每次存檔都會被編譯。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"ruby","slug":"ruby","permalink":"https://wcc723.github.io/tags/ruby/"}]},{"title":"Sass 開始前的問與答","slug":"why-sass","date":"2013-08-30T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/08/31/why-sass/","link":"","permalink":"https://wcc723.github.io/sass/2013/08/31/why-sass/","excerpt":"sass官方網站 : http://sass-lang.com/ 如何開始使用sass呢? 在開始前，還是先認識一下這是怎樣的東西。","text":"sass官方網站 : http://sass-lang.com/ 如何開始使用sass呢? 在開始前，還是先認識一下這是怎樣的東西。 他是不是像Dreaweaver的軟體，安裝完後就可以用了? 很可惜不是，Sass是一種基於Ruby編寫的CSS擴充語言，所以要使用就要先有Ruby環境。 Sass，為何又有人說scss? 兩者都屬於sass，而差在附檔名以及編寫方式的不同。 .sass 是屬於舊式的sass語法，明顯的特徵是利用縮排取代大括號。 .scss 是較新的語法，為了讓新一代的設計師可以承受較少的痛學習sass，所以在結構上相當類似CSS。 (本站是用sass，只因為覺得大括號要找頭尾很麻煩。) Less 又是什麼? 他也是類似sass的CSS擴充語言，不同的是sass是在Ruby環境下，而less是Javascript library。 這邊有一個比較網站，可以自行參考看看。 Ruby環境，安裝是不是很麻煩? 對於沒有安裝類似環境的人來說，真的有夠麻煩...，但是很多時候痛一次就過了，當然也有花點小錢解決事情的方法~。 花點小錢的解決方法!? Fire.app Fire.app就...讚。 prepros prepros是免費的，但是在多次使用後發現有些bug，以及他的livereload只針對他所編譯的檔案才有效，所以現在比較沒有使用了。 sass 可以運用在現在的專案嗎? scss 是不錯的選擇，只要環境準備好，將CSS檔名修改成.scss 就可以開始了，而且從現有的專案開始慢慢學習，也不會有太大的挫折感。 Compass又是什麼? 自己去看上一集! 如果看完以上文章，還不是很了解的話，在接下來的文章會教大家如何使用，從實際範例中慢慢的認識sass。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass 基礎教學-為何要學Sass","slug":"why-sass","date":"2013-08-29T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/08/30/why-sass/","link":"","permalink":"https://wcc723.github.io/sass/2013/08/30/why-sass/","excerpt":"Sass官網 看不到簡報請點此連結http://www.slideshare.net/slideshow/embed_code/11639772 上面這個簡報介紹了的很清楚，在經過一段時間的使用，發現已經回不去了(相信用過的都有這種感覺!)。為何要用Sass ?這用說的都是說不清楚，看範例比較清楚~。","text":"Sass官網 看不到簡報請點此連結http://www.slideshare.net/slideshow/embed_code/11639772 上面這個簡報介紹了的很清楚，在經過一段時間的使用，發現已經回不去了(相信用過的都有這種感覺!)。為何要用Sass ?這用說的都是說不清楚，看範例比較清楚~。 Demo B 像是這前幾天做的效果，sass的code如下。 @mixin longShadow($lenght: 20,$rgb: #000) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,rgba($rgb,0.9/$i + 0.05)),comma) text-shadow: $all 這是一個text-shadow的@mixin，換句話說是一個樣式模組，可以將它匯入至樣式表內，讓這一個text-shadow編譯成CSS。 text-shadow: 1px 1px 0 #b3b3b3, 2px 2px 0 rgba(179, 179, 179, 0.5), 3px 3px 0 rgba(179, 179, 179, 0.33333), 4px 4px 0 rgba(179, 179, 179, 0.25), 5px 5px 0 rgba(179, 179, 179, 0.2), 6px 6px 0 rgba(179, 179, 179, 0.16667), 7px 7px 0 rgba(179, 179, 179, 0.14286), 8px 8px 0 rgba(179, 179, 179, 0.125), 9px 9px 0 rgba(179, 179, 179, 0.11111), 10px 10px 0 rgba(179, 179, 179, 0.1), 11px 11px 0 rgba(179, 179, 179, 0.09091), 12px 12px 0 rgba(179, 179, 179, 0.08333), 13px 13px 0 rgba(179, 179, 179, 0.07692), 14px 14px 0 rgba(179, 179, 179, 0.07143), 15px 15px 0 rgba(179, 179, 179, 0.06667), 16px 16px 0 rgba(179, 179, 179, 0.0625), 17px 17px 0 rgba(179, 179, 179, 0.05882), 18px 18px 0 rgba(179, 179, 179, 0.05556), 19px 19px 0 rgba(179, 179, 179, 0.05263), 20px 20px 0 rgba(179, 179, 179, 0.05), 21px 21px 0 rgba(179, 179, 179, 0.04762), 22px 22px 0 rgba(179, 179, 179, 0.04545), 23px 23px 0 rgba(179, 179, 179, 0.04348), 24px 24px 0 rgba(179, 179, 179, 0.04167), 25px 25px 0 rgba(179, 179, 179, 0.04), 26px 26px 0 rgba(179, 179, 179, 0.03846), 27px 27px 0 rgba(179, 179, 179, 0.03704), 28px 28px 0 rgba(179, 179, 179, 0.03571), 29px 29px 0 rgba(179, 179, 179, 0.03448), 30px 30px 0 rgba(179, 179, 179, 0.03333), 31px 31px 0 rgba(179, 179, 179, 0.03226), 32px 32px 0 rgba(179, 179, 179, 0.03125), 33px 33px 0 rgba(179, 179, 179, 0.0303), 34px 34px 0 rgba(179, 179, 179, 0.02941), 35px 35px 0 rgba(179, 179, 179, 0.02857), 36px 36px 0 rgba(179, 179, 179, 0.02778), 37px 37px 0 rgba(179, 179, 179, 0.02703), 38px 38px 0 rgba(179, 179, 179, 0.02632), 39px 39px 0 rgba(179, 179, 179, 0.02564), 40px 40px 0 rgba(179, 179, 179, 0.025); 這個陰影在匯入後，可以轉成這麼長的CSS，而且透過變數的修改，可以另外再調整陰影長度及陰影顏色，如果這樣的陰影，如果客戶說太短，想要在加長50%，就可以感覺到CSS與SASS效率上的差異了。 Sass 與 Compass Compass 官方網站 Compass是基於sass的擴充函式庫，最常用到的就是CSS3 @mixin (又是@mixin!?)，還是用範例來解釋吧。 上面這段陰影的CSS code大家應該都很熟悉，目前的版本要這樣打... -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.6); -moz-box-shadow: 0 0 10px rgba(0, 0, 0, 0.6); box-shadow: 0 0 10px rgba(0, 0, 0, 0.6); 但是如果是sass with compass，就只要如下方式輸入... @include box-shadow(0 0 10px rgba(00,00,00,.6)) 只要匯入Css3 @mixin後，他就會幫你自動加入CSS個瀏覽器的hack，很棒吧~，在接下來的分享如何開始使用Sass與compass。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass HSL function","slug":"sass-hsl-funtion","date":"2013-08-25T16:00:00.000Z","updated":"2019-12-23T02:20:34.993Z","comments":true,"path":"sass/2013/08/26/sass-hsl-funtion/","link":"","permalink":"https://wcc723.github.io/sass/2013/08/26/sass-hsl-funtion/","excerpt":"sass在顏色的處理有許多function可以用，如果多善用這些function可以讓網頁有更多的變化，並且提高網頁的一致性。","text":"sass在顏色的處理有許多function可以用，如果多善用這些function可以讓網頁有更多的變化，並且提高網頁的一致性。 HSL Functions HSL function 是我使用頻率較高的function，而HLS就是色彩學中的色相、明度、彩度，如果不清楚可以看一下Adobe所提供的色相環，自己親自玩看看就會比較了解了。 一開始我們先定義一個有點橘，但不會太橘的顏色(這樣等等demo會比較明顯)。 #F09671 $color: #F09671 //然後我們要給他一個變數，就叫做&lt;code&gt;$color&lt;/code&gt; Darken & Lighten 明亮度 先來點簡單的，調整明亮度Darken & Lighten。 lighten($color, $amount) //Makes a color lighter. darken($color, $amount) //Makes a color darker. darken($color,15%) = #e35318$color = #F09671lighten($color,15%) = #fadacd Saturate & Desaturate 飽和度 saturate($color, $amount) //Makes a color more saturated. desaturate($color, $amount) //Makes a color less saturated. saturate($color,15%) = #fc9165$color = #F09671desaturate($color,15%) = #e49b7d Hue 其實就是取得顏色在色相環的位置，所以這個demo是錯誤地~。 hue($color) //Gets the hue component of a color. $color = #F09671hue($color) = 17.48031deg Adjust-hue 調整色相環位置。 adjust-hue($color, $degrees) //Changes the hue of a color. $color = #F09671hue($color) = #f0b671 lightness 喔喔~又是一個錯誤的demo，這是取得顏色的目前明度值。 lightness($color) //Gets the lightness component of a color. $color = #F09671lightness($color)= 69.21569% 我們可以看到剛剛的lighten + 15%，他的明度值確實也提高了15%。 $color = #F09671lighten($color,15%)= 84.21569% Grayscale 將顏色調整為灰階，調整為灰階明度是不會改變的。 grayscale($color) //Converts a color to grayscale. $color = #F09671grayscale($color)= #b1b1b1 lightness(grayscale($color)) = 69.21569% Complement 互補色 complement($color) //Returns the complement of a color. $color = #F09671complement($color)= #71cbf0 Invert 這我有點不清楚怎麼解釋，就看一下他在色相環的 結果 ```sass Invert($color) //Returns the inverse of a color. ```sass $color = #F09671complement($color)= #0f698e","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS transition 各種速率","slug":"css-transtion-speed","date":"2013-08-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/08/24/css-transtion-speed/","link":"","permalink":"https://wcc723.github.io/css/2013/08/24/css-transtion-speed/","excerpt":"今天要介紹的是CSS transition中的timing-function，transition語法在CSS3動態中是相當容易被使用，如果再改變他的timing-function，可以獲得更豐富的效果。","text":"今天要介紹的是CSS transition中的timing-function，transition語法在CSS3動態中是相當容易被使用，如果再改變他的timing-function，可以獲得更豐富的效果。 參考 : http://www.w3schools.com/cssref/css3_pr_transition-timing-function.asp http://devdocs.io/css/transition-timing-function Demo中的共通sass div width: 50px height: 50px background: red +transition-property(margin-left) +transition-duration(5s) .demo:hover > div margin-left: calc(100% - 50px) DEMO開始 各種transition-timing-function的效果(安安，你們會卡嗎?我好卡)，主要有以下幾種屬性。 +transition-timing-function(ease) //緩慢的開始，中間變快，又變慢慢結束。相當於cubic-bezier(0.25,0.1,0.25,1)。 +transition-timing-function(ease-in) //ease-in：緩慢的開始。相當於cubic-bezier(0.42,0,1,1)。 +transition-timing-function(ease-out) //ease-out：緩慢的結束。相當於cubic-bezier(0,0,0.58,1)。 +transition-timing-function(ease-in-out) //ease-in-out：緩慢的開始和結束。相當於cubic-bezier(0.42,0,0.58,1)。 +transition-timing-function(linear) linear：表示從開始到結束的速度一致。相當於cubic-bezier(0,0,1,1)。 +transition-timing-function(cubic-bezier(0.1, 0.7, 1.0, 0.1)) cubic-bezier(n,n,n,n)：自由定義cubic-bezier函數，每個值為0到1之間的數字。 cubic-bezier +transition-timing-function(step-start) +transition-timing-function(step-end) //這兩個....是來鬧得? +transition-timing-function(steps(4, end)) //分為4個階段 Togather! ease ease-in ease-out ease-in-out linear cubic-bezier step-start step-end steps(4, end)","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Web Font的基本設定","slug":"web-font","date":"2013-08-22T16:00:00.000Z","updated":"2017-06-21T12:10:27.000Z","comments":true,"path":"css/2013/08/23/web-font/","link":"","permalink":"https://wcc723.github.io/css/2013/08/23/web-font/","excerpt":"Web Font的基本用法不會很難，如果是要用本機的方式，首先就是要先找個資料夾放字型檔，接下來參考@font-face的作法即可。","text":"Web Font的基本用法不會很難，如果是要用本機的方式，首先就是要先找個資料夾放字型檔，接下來參考@font-face的作法即可。 @font-face 參考 : http://devdocs.io/css/@font-face http://compass-style.org/reference/compass/css3/font_face/ CSS3的設定 @font-face { [font-family: &lt;family-name&gt;;]? [src: [ &lt;uri&gt; [format(&lt;string&gt;#)]? | &lt;font-face-name&gt; ]#;]? [unicode-range: &lt;urange&gt;#;]? [font-variant: &lt;font-variant&gt;;]? [font-feature-settings: normal|&lt;feature-tag-value&gt;#;]? [font-stretch: &lt;font-stretch&gt;;]? [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;]; } sass 的設定 +font-face($name, $font-files, $eot, $weight, $style) //font-face(自訂義名稱，檔案路徑，IE專用!?，文字粗，樣式(might be also italic)) This is Kavoon-Regular. 20130823 google Web fonts Google 有提供線上的版本，按照他們的方式操作並不會很難，只要先搜尋到想要的字體就可以開始了~ 參考 : http://www.google.com/fonts/ CSS版 //插入 link &lt;link href='http://fonts.googleapis.com/css?family=The+Girl+Next+Door' rel='stylesheet' type='text/css'&gt; //或是import @import url(&quot;http://fonts.googleapis.com/css?family=The+Girl+Next+Door&quot;) //本地CSS設定 font-family: 'The Girl Next Door', cursive; This is The Girl Next Door. javascript版 google會提供，只要插入在網頁裡即可，font-family也是依提供的設定即可。 This is Frijole. 現實的來了 捉雞 Feature Firefox (Gecko) Chrome Internet Explorer Opera Safari Basic support 3.5 (1.9.1) 4.0 4.0 10.0 3.1 WOFF 3.5 (1.9.1) 6.0 9.0 11.10 5.1 SVG Font Not&nbsp;supported Unimplemented (see bug&nbsp;119490) yes Not&nbsp;supported yes yes unicode-range yes&nbsp;(bug&nbsp;443976) yes 9.0 (Yes) (Yes) 手機 Feature Android Firefox Mobile (Gecko) IE Mobile Opera Mini Opera Mobile Safari Mobile Basic support (Yes) 1.0 (1.9.1) ? Not&nbsp;supported 10.0 (Yes) WOFF Not&nbsp;supported 5.0 (5.0) ? Not&nbsp;supported 11.0 Not&nbsp;supported SVG fonts Not&nbsp;supported Not&nbsp;supported Unimplemented (see bug&nbsp;119490) ? Not&nbsp;supported 10.0 (Yes) unicode-range &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Yes)","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"html meta基本語法","slug":"html-meta","date":"2013-08-21T16:00:00.000Z","updated":"2016-10-11T09:48:48.000Z","comments":true,"path":"html/2013/08/22/html-meta/","link":"","permalink":"https://wcc723.github.io/html/2013/08/22/html-meta/","excerpt":"傳說中meta只要能夠使用的好，可以帶來許多意想不到的效果，甚至是連用了都不知道有什麼功能...。 參考文章：http://www.cnblogs.com/sniper007/p/3258389.html 延伸閱讀：http://code.lancepollard.com/complete-list-of-html-meta-tags/","text":"傳說中meta只要能夠使用的好，可以帶來許多意想不到的效果，甚至是連用了都不知道有什麼功能...。 參考文章：http://www.cnblogs.com/sniper007/p/3258389.html 延伸閱讀：http://code.lancepollard.com/complete-list-of-html-meta-tags/ meta的組成 相傳meat的是分別由http-equiv和name而組成，以下就依據該網頁介紹各種用法。 1.name屬性 &lt;meta name=&quot;參數&quot; content=&quot;具體的參數值&quot;&gt; 功能是描述網頁，對應的屬性為content，主要的屬性有以下參數。 a.Keywords(關鍵字) 描述網頁的關鍵字 &lt;meta name=&quot;keywords&quot; content=&quot;a day a share&quot;&gt; b.​​description(網站內容描述) 描述網站的內容 &lt;meta name=&quot;description&quot; content=&quot;利用純靜態網頁，來分享Web技術，並透過每日的分享，來逐步提升自己的能力。&quot;&gt; c.robots(機器人嚮導) 用來告訴機器人那些頁面需要索引，而那些不需要。 &lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; //參數有all,none,index,noindex,follow,nofollow d.author(作者) 怎麼看都知道是作者。 &lt;meta name=&quot;author&quot; content=&quot;Casper&quot;&gt; 2.http-equiv屬性 name主要作為描述，http-equiv則會與瀏覽器產生作用。 a.Expires(期限) 設定網頁的到期時間，只要過期，就必須重新傳輸。 &lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt; ​​b.Pragma(cache模式) 禁止使用cache。 &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; c.Refresh(刷新) 重新整理，並導向目標頁面。 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2；URL=http://ashareaday.wcc.tw&quot;&gt; //2秒後重新導向... d.Set-Cookie(cookie設定) 如果網頁過期，cookie將被刪除。 &lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt; e.content-Type(顯示字編碼的設定) 就...設定編碼 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; f.Window-target(顯示窗口的設定) 強制頁面在當前窗口以獨立頁面顯示。(這段不是很了解，似乎是不能被當成iframe?) &lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; 在html5之後meta屬性越來越多樣，還有許多目前沒提到，之後會依序補充。","categories":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"}]},{"title":"image 與 SVG","slug":"jpg-and-svg","date":"2013-08-20T16:00:00.000Z","updated":"2016-10-11T09:48:48.000Z","comments":true,"path":"html/2013/08/21/jpg-and-svg/","link":"","permalink":"https://wcc723.github.io/html/2013/08/21/jpg-and-svg/","excerpt":"image與SVG的運用","text":"image與SVG的運用 來源 : http://lynn.ru/examples/svg/en.html image image和img是非常相似的，大部分瀏覽器都可以用image取代img replace 以上的原始碼 &lt;svg&gt; &lt;image xlink:href=&quot;images/20130821.svg&quot; src=&quot;images/20130821.png&quot; width=&quot;75&quot; height=&quot;75&quot;/&gt; &lt;/svg&gt; 如果在支持SVG的瀏覽器會看到這樣 &lt;image xlink:href=&quot;images/20130821.svg&quot; width=&quot;75&quot; height=&quot;75&quot;/&gt; 如果是不支持SVG的瀏覽器會顯示如下 &lt;image src=&quot;images/20130821.png&quot; width=&quot;75&quot; height=&quot;75&quot;/&gt; 對於有些很簡單的圖像，她可能不需要獨立的SVG檔案，可以寫成這樣。 &lt;svg height=&quot;16&quot; width=&quot;16&quot;&gt; &lt;path d=&quot;M5 1v14l9-7&quot;&gt; //SVG code &lt;image src=&quot;next.png&quot;&gt; //替代PNG &lt;/svg&gt; 如果用img會得到以下結果... 好像不可以啊?","categories":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"CSS3 文字陰影範例","slug":"text-shadow-demo","date":"2013-08-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/08/20/text-shadow-demo/","link":"","permalink":"https://wcc723.github.io/css/2013/08/20/text-shadow-demo/","excerpt":"本篇會介紹許多CSS3文字陰影範例，而text-shadow在瀏覽器的支援度還算高，有興趣的朋友都可以試試。 來源參考：http://www.w3cplus.com/blog/52.html","text":"本篇會介紹許多CSS3文字陰影範例，而text-shadow在瀏覽器的支援度還算高，有興趣的朋友都可以試試。 來源參考：http://www.w3cplus.com/blog/52.html 最普通的版本 text-shadow: 1px 1px 5px black //text: x-offect y-offect Blur Color NORMAL Text-shadow 很常用的版本 陰刻與陽刻 text-shadow: 1px 1px 0 black text-shadow: -1px -1px 0 black Text-shadow Text-shadow 光輝的效果 利用模糊的半徑做出類似光輝的效果。 text-shadow: 0 0 20px orange GLOW AND EXTRA GLOW EFFECT 利用不同的模糊建立多層次的光輝，這個效果我還挺喜歡的，畢竟設計就是矯情~。 text-shadow: 0 0 5px white,0 0 10px white,0 0 15px white,0 0 40px #ff00de,0 0 70px #ff00de NEON EFFECT Photoshop 浮雕效果 利用上面所說的陰刻、陽刻的混和體。 text-shadow: -1px -1px 0 white, 1px 1px 0 #333,1px 1px 0 #444 PHOTOSHOP EMBOSS EFFECT 模糊文字效果 將原本的文字透明後，再將陰影模糊化做出模糊文字的效果。 color: transparent text-shadow: 0 0 5px red BLUR TEXT EFFECT 外框文字 如果有這種需求...，加減用也是不錯的 text-shadow: 1px 1px 0 red, -1px -1px 0 red STROKE TEXT 3D文字效果 利用一層一層堆疊的方式做出血尿般的3D效果。 text-shadow: 1px 1px rgba(220,220,220,.8),2px 2px rgba(220,220,220,.8),3px 3px rgba(220,220,220,.8),4px 4px rgba(220,220,220,.8),5px 5px rgba(220,220,220,.8) 3D TEXT EFFECT 反過來疊就會變這樣... 3D TEXT EFFECT 復古文字效果 這效果我也很喜歡，是利用兩個陰影堆疊出來的，可惜的是第一個陰影必須與背景相同顏色。 VINTAGE RETRO EFFECT 立體影像效果 將原本的文字及陰影都用rgba的方式製作半透明，相信有心的話，可以做出3D眼鏡都可以看的版本。 ANAGLYPHIC TEXT EFFECT","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]}]}