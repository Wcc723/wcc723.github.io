{"meta":{"title":"卡斯伯 Blog - 前端，沒有極限","subtitle":null,"description":null,"author":"Wang Casper","url":"https://wcc723.github.io"},"pages":[{"title":"關於卡斯伯","date":"2019-11-12T07:28:32.000Z","updated":"2019-11-12T07:29:03.877Z","comments":true,"path":"about/index.html","permalink":"https://wcc723.github.io/about/index.html","excerpt":"","text":"六角學院共同創辦人 個人粉絲專頁：https://www.facebook.com/WccCasper 本科技能為視覺設計，後來轉為前端工程師 學習經歷參考：https://wcc723.github.io/ironman/2019/09/19/became-a-webdesigner/ 專長為 Bootstrap、Sass、JavaScript、Vue.js … 相關線上課程可參考：https://www.hexschool.com/"},{"title":"tags","date":"2016-10-11T08:21:43.000Z","updated":"2016-10-11T08:22:23.000Z","comments":true,"path":"tags/index.html","permalink":"https://wcc723.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"CSS Border 運用技巧（手繪框線、三角形、空間運用）","slug":"css-border","date":"2020-02-20T16:00:00.000Z","updated":"2020-02-23T03:27:20.055Z","comments":true,"path":"css/2020/02/21/css-border/","link":"","permalink":"https://wcc723.github.io/css/2020/02/21/css-border/","excerpt":"","text":"CSS Border 大部份來說是用在裝飾上，卡片的邊線、hover 的視覺效果、物件之間的間隔等等，這些視覺效果除了 Border 以外亦有其它方式可以達到；雖然如此，Border 的使用率還是比較高，因為相對來說更為簡單方便，不過也別這樣小看它，透過一些小技巧時，Border 還有很多靈活運用的方式。 基本觀念介紹先了解 Border 基本的觀念，有助於接下來的靈活運用。 Border 具有空間這是很多新手常遇到的問題，border 本身是具有空間的，因此元素如果增加了 border 以後會導致整體元素空間增大。因此元素如果要維持原有的尺寸，則必須將 border 所增加的空間給扣除。 以下範例來說，左方的方框增加了額外 border 時，就導致元素尺寸大於右方的方框。 .d-flex { display: flex; flex-wrap: wrap; align-items: center; justify-content: center; } .box { height: 80px; width: 80px; margin: 3px; display: flex; justify-content: center; align-items: center; } .bg-gray { background-color: #ccc; } .border-2 { border: 2px solid #00cc99; } Border 可以搭配圓角CSS 中的圓角 border-radius 是一個偉大的發明，他並不會使元素的邊緣被裁切，而是能夠產生滑順的圓角。除此之外，雖然名稱為 border-radius 但運用上並不只限於 border，在大部分的元素上都可以運用 border-radius，而 border-radius 運用上具有以下的技巧： 不需要所有角都使用等距空間，每個角可自訂獨立的數值（左二範例） 當圓角數值超過元素空間時，將會以 較短的邊線距離產生正圓角，這樣的特性下可以在元素的邊緣套用正圓形（左三範例） 當圓角數值採用百分比且超過 50% 時，將會以 邊線距離的一半產生圓角，此特性在非正方形的情況下可能會變成橢圓形。 大多數情況來說，我都會將圓角數值設為極大值，來產生更好看圓邊，避免會出現橢圓形的狀況。 .radius { border-radius: 24px } .radius-6-12-24-48 { border-radius: 6px 12px 24px 48px; } .radius-circle { border-radius: 200px; } .radius-oval { border-radius: 50%; } 不同的樣式大部分來說 border 運用都是以 solid 為大宗，其次為 dashed 及 dotted，以下列出所有的 border 樣式，除此之外 border 的樣式還可以混合使用喔。 dotted dashed solid double groove ridge inset outset 混合 .border-4 { border: 4px solid #00cc99; } .border-dotted {border-style: dotted;} .border-dashed {border-style: dashed;} .border-solid {border-style: solid;} .border-double {border-style: double;} .border-groove {border-style: groove;} .border-ridge {border-style: ridge;} .border-inset {border-style: inset;} .border-outset {border-style: outset;} .border-mix {border-style: dotted dashed solid double;} 技巧空間運用Border 很常運用在選單的 hover 或 active 的視覺效果，但如果沒有注意到就可能因為 border 的空間讓選單產生位移，如以下範例來說，滑鼠移入選單時就會造成選單位移。 關鍵程式碼：123a.demo-item:hover &#123; border-bottom: 3px solid #00cc99;&#125; 選單 1 選單 2 .demo-navbar { background-color: #fff; box-shadow: 0 3px 3px rgba(0, 0, 0, .16); padding: 0 30px; justify-content: center; } a.demo-item { display: block; padding: 10px 15px; } a.demo-item:hover { border-bottom: 3px solid #00cc99; text-decoration: none; } 會造成這樣的原因在於「Border 本身是具有空間的」，因此直接在 hover 上新增 border 時就會發生此問題，其中一種解決方法則是預先加入 “透明的 border 空間”，在 hover 或其它的行為時再來切換 border 的色彩。 關鍵程式碼：12345678.demo-navbar &#123; /* 將部分的空間先扣除 */ padding: 0 27px;&#125;.demo-navbar .demo-item &#123; /* 加入下方透明的 Border */ border-bottom: 3px solid transparent;&#125; 選單 1 選單 2 .demo-navbar-update { padding: 0 27px; } .demo-navbar-update .demo-item { border-bottom: 3px solid transparent; } 由於 Border 本身是佔有空間的，所以也可以使用其它不含空間的視覺效果來達到此效果，以下範例則是使用 box-shadow 做到類似的效果。 關鍵程式碼：123a.demo-item:hover &#123; box-shadow: 0 -3px #00cc99 inset; &#125; 選單 1 選單 2 .demo-navbar-update2 a.demo-item:hover { border-bottom: 0; box-shadow: 0 -3px #00cc99 inset; } 三角形接續一開始所提到 border 本身是佔有空間的，當有兩個邊線的 border 重疊的部分就會產生 “實體的交疊”，這個實體的交疊就會產生三角形的視覺效果。 下方的範例來說，上者是下邊、右邊的 border 產生，下者則是四邊的 border 產生。 .left-border { width: 0; height: 0; margin: 0 auto; border-right: orange 20px solid; border-bottom: blue 20px solid; } .arrow { width: 0; height: 0; margin: 0 auto; border-top: red 20px solid; border-right: orange 20px solid; border-bottom: blue 20px solid; border-left: green 20px solid; } 當四邊均為 border 時，就能產生四個三角形，當如果僅需要一個方向的三角時，就可以使用到前一個段落所提到的技巧 “透明 border”。 關鍵程式碼：1234567.message-box:after &#123; content: \"\"; /* 四邊透明的 border */ border: transparent 10px solid; /* 將其中一補上色彩 */ border-top-color: #00cc99;&#125; 透過此方法就能做到類似訊息框的視覺效果。 歐拉歐拉歐拉歐拉歐拉！ .message-box { background: #00cc99; color: white; padding: 10px; border-radius: 5px; position: relative; } .message-box:after { content: \"\"; width: 0; height: 0; position: absolute; left: 10px; bottom: -20px; border: transparent 10px solid; border-top-color: #00cc99; } 多層次除了 Border 以外，有很多方法可以做到類似的視覺效果，而其中一個很常利用的就是 box-shadow，與 border 最大不同之處就是 box-shadow 不佔有任何空間\b\b。兩者在此也可以作為好朋友產生多層次的邊框效果。 123456789.border-multi &#123; border: 5px solid red; box-shadow: 0 0 0 5px orange, 0 0 0 10px yellow, 0 0 0 15px green, 0 0 0 20px blue; margin: 25px &#125; .border-multi { border: 5px solid red; box-shadow: 0 0 0 5px orange, 0 0 0 10px yellow, 0 0 0 15px green, 0 0 0 20px blue; margin: 25px } 手繪邊框最後，展示比較特別的視覺風格 “手繪邊框”，前幾個範例都是圍繞在 border-radius 上，這個也不例外，最重要的關鍵點在於 border-radius 可以在同一個角設定兩個以上的參數。 如以兩個範例 範例一：設定左上的圓角，前者的數值是左上圓角靠上方邊線的圓半徑，後者的數值則是左上圓角靠左方邊線的圓半徑，原始碼 如下： 範例二：縮寫方法，可以一次設定四個圓角不同的形式。 12345678/* 範例一 */.border-top-left-radius &#123; border-top-left-radius: 10px 100px;&#125;/* 範例二 */.border-2-size &#123; border-radius: 15px / 100px;&#125; .border-top-left-radius { border-top-left-radius: 10px 100px; } .border-2-size { border-radius: 15px / 100px; } 最後也補充此風格的技巧說明： border-width：可設定不同的粗細變化，做出手繪過程中的不同粗細變化 transform：手繪過程中通常不會過於水平或垂直，所以外層都可以補上 transform 製作出傾斜的效果 內層也同樣需要補上 transform 將文字內容給予補正 border-style：也可試著加入不同樣式的邊線，做出不同的手繪視覺效果 關鍵程式碼：12345678910111213.ink-box &#123; border-width: 2px 3px 2px 5px; border-radius: 90% 6% 93% 5% / 5% 94% 7% 95%; /* 做出傾斜的視覺感 */ transform: rotate(2deg);&#125;.ink-box-double &#123; border: dashed black 2px;&#125;.box-inner &#123; /* 將傾斜的部分修正 */ transform: rotate(-2deg);&#125; Handwriting style Handwriting style @import url('https://fonts.googleapis.com/css?family=Caveat&display=swap'); .ink-box { width: 150px; height: 150px; background:#fff; border: solid black 1px; display: flex; justify-content: center; align-items: center; /* 紙風格 */ border-width: 2px 3px 2px 5px; border-radius: 90% 6% 93% 5% / 5% 94% 7% 95%; font-family: 'Caveat'; transform: rotate(2deg); } .ink-box-double { border: dashed black 2px; } .box-inner { transform: rotate(-2deg); } 參考文件： https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius https://code.tutsplus.com/tutorials/css-refreshers-borders--net-24655 https://freefrontend.com/css-border-examples/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"border","slug":"border","permalink":"https://wcc723.github.io/tags/border/"}]},{"title":"JavaScript Promise 全介紹","slug":"all-new-promise","date":"2020-02-15T16:00:00.000Z","updated":"2020-02-23T03:27:10.405Z","comments":true,"path":"development/2020/02/16/all-new-promise/","link":"","permalink":"https://wcc723.github.io/development/2020/02/16/all-new-promise/","excerpt":"","text":"最近直播介紹如何串接開源資料，也剛好許多朋友詢問到 Ajax、Promise 相關的問題，因此重新撰寫一篇文來介紹 Promise，這篇文章也與過去形勢不太一樣，試著先將常見的問題放在前頭，接下來才開始介紹 Promise。 另外本文的內容較多，Promise 想看簡易版可參考：/javascript/2017/12/29/javascript-proimse/。 使用 Vuejs 結合 Open Street Map 製作口罩地圖 關於 Promise 常見問題Q: Promise 跟 Ajax 有什麼關係？ 關於 Ajax 可以先參考這份：https://zh.wikipedia.org/wiki/AJAX 以目前來說，Ajax 可以向伺服器傳送及取得資料，並且不需要重新整理瀏覽器畫面，這樣可以大幅提升使用者體驗並且減少伺服器負擔（僅處理資料，畫面由前端處理）。 Ajax 是屬於一個透過 JavaScript 技術名稱，用於取得遠端資料；而 Promise 則是一個語法，專門用來處理非同步行為，並不是專門用來處理 Ajax 使用，所以兩者是不同的。 Q: Promise 與 Async、Await 有什麼關係？ Promise 是用來優化非同步的語法，而 Async、Await 可以基於 Promise 讓非同步的語法的結構類似於 “同步語言”，更易讀且好管理。 Async、Await 參考：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function Q: 請問 Promise 很常用到嗎？是否一定要學呢？ 使用頻率高，必學。 非同步的問題Promise 本身是用來改善 JavaScript 非同步的語法結構。 在過去的文章中有提到，JavaScript 是屬於同步的程式語言，因此一次僅能做一件事情，但遇到非同步的事件時，就會將非同步的事件移動到程式碼的最後方，等到所有的原始碼運行完以後才會執行非同步的事件。 以下列的程式碼來說，在 console 中依序的會出現的順序為： 開始 程式碼結束 非同步事件 &lt;- 最後執行 1234567console.log('開始');setTimeout(() =&gt; &#123; console.log('非同步事件');&#125;, 0);console.log('程式碼結束'); 雖然在上段的原始碼中，setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行。 在 Ajax 的行為中也是一樣，當需要確保擷取到遠端資料才繼續往下執行時，如果程式碼是依序撰寫的方式，就會無法正確呈現資料，以下範例我們使用 Promise base 的 Ajax 函式庫 axios 進行一下錯誤的示範： 與上述的概念是相同的，Ajax 本身也是屬於非同步的行為。在一開始先定義了一個 data 物件，中間段落使用 axios 嘗試取得遠端資料，後面的緊接的 console.log(data); 呈現的依然是一開始定義的物件，並不會是 Ajax 取得的資料。 123456789let data = &#123;&#125;console.log('開始');axios.get('https://randomuser.me/api/').then(function(response) &#123; data = response;&#125;);console.log(data); 在上述的範例中，data 正確的賦值位置在以下片段，如果預期在取得資料後進行其它的行為，了解整個 Promise 的運作將非常的重要。123then(function(response) &#123; data = response;&#125;) Promise 的結構及狀態結構Promise 本身是一個建構函式，函式也是屬於物件的一種，因此可以附加其它屬性方法在上，透過 console 的結果可以看到 Promise 可以直接使用 all、race、resolve、reject 的方法，寫法如下（後面再介紹運用方式）： Promise.all Promise.race Promise.resolve Promise.reject Promise 建構函式 new 出的物件，則可以使用其中的原型方法（在 prototype 內），其中就包含 then、catch、finally，這些方法則必須在新產生的物件下才能呼叫。 透過 new Promise() 的方式建立 p 物件，此時 p 就能使用 Promise 的原型方法：12345const p = new Promise();p.then(); // Promise 回傳正確p.catch(); // Promise 回傳失敗p.finally(); // 非同步執行完畢（無論是否正確完成） 除此之外，Promise 建構函式建立同時，必須傳入一個函式作為參數（executor function），此函式的參數包含 resolve, reject，這兩個方法分別代表成功與失敗的回傳結果，特別注意這兩個僅能回傳其中之一，回傳後表示此 Promise 事件結束。1234new Promise(function(resolve, reject) &#123; resolve(); // 正確完成的回傳方法 reject(); // 失敗的回傳方法&#125;); resolve 及 reject 的名稱可以自定義，但在開發上大多數開發者習慣維持此名稱。 狀態Promise 的關鍵在處理非同步的事件，而非同步的過程中也包含著不同的進度狀態，在 Promise 的執行過程中，可以看到以下狀態。 pending：事件已經運行中，尚未取得結果 resolved：事件已經執行完畢且成功操作，回傳 resolve 的結果（該沈諾已經被實現 fulfilled） rejected：事件已經執行完畢但操作失敗，回傳 rejected 的結果 進入 fulfilled 或 rejected 就算完成後不會再改變，Promise 中會使用 resolve 或 reject 回傳結果，並在調用時使用 then 或 catch 取得值。 如果要判斷 Promise 是否完成，可依據 Promise 事件中的 resolve 及 reject 是否有被調用，以下範例來說在沒有調用兩個方法時，Promise 的結果則會停留在 pending。12345function promise() &#123; return new Promise((resolve, reject) =&gt; &#123;&#125;);&#125;console.dir(promise()); 在 Promise 的執行函式中，可以看到以下兩個屬性： [[PromiseStatus]]: &quot;pending&quot; -&gt; 表示目前的進度狀態 [[PromiseValue]]: undefined -&gt; 表示 resolve 或 reject 回傳的值 以下範例來說，執行完函式直接 reject(&#39;失敗&#39;)，最終也能取得 rejected 的狀態及值。12345function promise() &#123; return new Promise((resolve, reject) =&gt; &#123;reject('失敗');&#125;);&#125;console.dir(promise()); 建立自己的 Promise如果要熟悉 Promise，最好的方式莫過於自己撰寫一次 Promise。 Promise 預設會帶入 resolve, reject 的參數（可自訂名稱，但大家習慣 resolve 及 reject），resolve 代表成功；reject 代表失敗，而兩者必定只能回傳其中之一，且必定只能回傳一次。 函式陳述式建立以後，直接透過 return new Promise 回傳並建立一個 Promise 物件，並且在內部加入一個執行函式且帶上 resolve, reject 的參數，到這個階段就是常見的 Promise 結構，接下來在依據執行的結果來透過 resolve, reject 回傳值即可（以下範例會隨機調用 resovle 及 reject）。123456789101112function promise() &#123; return new Promise((resolve, reject) =&gt; &#123; // 隨機取得 0 or 1 const num = Math.random() &gt; 0.5 ? 1 : 0; // 1 則執行 resolve，否則執行 reject if (num) &#123; resolve('成功'); &#125; reject('失敗') &#125;);&#125; 在呼叫前 Promise 前回顧一下 Promise 會有三個狀態： Pending -&gt; 尚未得到結果 Resolved：事件已經執行完畢且成功操作，回傳 resolve 的結果 Rejected：事件已經執行完畢但操作失敗，回傳 rejected 的結果 上列的三種狀態每次執行必定會經過 Pending，接下來進入 Fulfilled 或 Rejected 的其中之一，並且可以使用 then() 及 catch() 取得成功或失敗的結果。 在 .then(onFulfilled, onRejected)中可帶入兩個回呼函式，兩者分別又可以帶入各自的參數： onFulfilled：執行成功的函式，所帶入參數表示 Promise 函式中 resolve 所帶入的值。 onRejected：執行失敗的函式，帶入參數表示 Promise 函式中 reject 所帶入的值。 12345678// promise.then(onFulfilled, onRejected);// 前者為 resolve callback，後者則為 rejectpromise() .then((success) =&gt; &#123; console.log(success); &#125;, (fail) =&gt; &#123; console.log(fail); &#125;) 在大部分情況下，開發者習慣僅使用 .then() 來取得成功的結果，失敗的部分交由 catch(onRejected) 來處理，這兩種寫法差異很小。 12345678910// promise.then(onFulfilled);// promise.catch(onRejected)promise() .then(success =&gt; &#123; console.log(success); &#125;) // 失敗的行為一律交給了 catch .catch(fail =&gt; &#123; console.log(fail); &#125;); 鏈接為了確保非同步完成後才執行另一個方法，過去都只能不斷的透過 callback 的方式來確保下一個方法正確執行，網路上如果搜尋 callback hell 也可以看到相關的文章及程式碼波動拳的圖片。 Promise 另一個特點在於 then、catch 都可以使用鏈接的方式不斷的進行下一個任務，在此範例中我們修改 Promise 的結果，改成傳入 0 則會調用 reject，其它數值則會調用 resolve。12345function promise(num) &#123; return new Promise((resolve, reject) =&gt; &#123; num ? resolve(`$&#123;num&#125;, 成功`) : reject('失敗'); &#125;);&#125; 接下來，當我們要進行確保 Promise 任務結束後在進行下一個任務時，就可以使用 return 的方式進入下一個 then，此 return 也有以下特點： 方法不限於 promise 函式，任何表達式（expression）都可進行回傳 如果是 promise 函式，則會繼續遵循 then 及 catch 的運作 如果不是 promise 函式，在下一個 then 則可以取得結果12345678910111213141516promise(1) .then(success =&gt; &#123; console.log(success); return promise(2); &#125;) .then(success =&gt; &#123; console.log(success); return promise(0); // 這個階段會進入 catch &#125;) .then(success =&gt; &#123; // 由於上一個階段結果是 reject，所以此段不執行 console.log(success); return promise(3); &#125;) .catch(fail =&gt; &#123; console.log(fail); &#125;) Then VS Catch 的失敗回呼差異then、catch 都可以透過進行鏈接，上述也有提到 then 同時也能接收失敗的結果，在此用圖示表示兩者在執行上不同的結果。 不使用 then 接收失敗：無論在哪一個階段遇到 reject 時，接下來會直接跳到 catch，在其後的 then 都不會執行。另外提一下：catch 依然可以使用 return 繼續串接（實戰中很少這樣寫）。 使用 then 接收失敗：then 中的兩個函式必定執行其中一個（onFulfilled, onRejected），可以用此方式確保所有的鏈接都能夠被執行。 Finally 完成最後方可以使用 finally 來確認工作結束，finally 不帶有任何參數。這個方法適合用來作為 Ajax 已經讀取完成，透過 finally 來關閉讀取的效果。 123456promise(1) .then(success =&gt; &#123; console.log(success); &#125;).finally(() =&gt; &#123; console.log('done'); &#125;) 使用 Promise 改寫 XMLHttpRequestPromise 很大一部份是用來處理 Ajax 行為，此段透過改寫的形式了解使用 Promise 及傳統的寫法有哪些差異。 傳統上，需透過 XMLHttpRequest 建構式來產生可進行遠端請求的物件，並且依序定義方法(GET)及狀態(onload)並送出請求(send)，取得結果後的其它行為則需要撰寫在 onload 內，程式碼結構如下：1234567891011121314151617181920var url = 'https://jsonplaceholder.typicode.com/todos/1';// 定義 Http requestvar req = new XMLHttpRequest();// 定義方法req.open('GET', url);// 當請求完成，則進行函式的結果req.onload = function() &#123; if (req.status == 200) &#123; // 成功直接列出結果 console.log(req.response); &#125; else &#123; // 失敗的部分 &#125;&#125;;// 送出請求req.send(); 接下來將以上的行為封裝至 get 函式內，此函式包含 Promise 及上述的 XMLHttpRequest 行為，運用時只要直接使用 get(url)...，接下來的運用方式則是符合 Promise 的結構，重複運用的情況下程式碼可以大幅提高易讀性。 1234567891011121314151617181920212223242526function get(url) &#123; return new Promise((resolve, reject)=&gt; &#123; // 定義 Http request var req = new XMLHttpRequest(); req.open('GET', url); req.onload = function() &#123; if (req.status == 200) &#123; // 使用 resolve 回傳成功的結果，也可以在此直接轉換成 JSON 格式 resolve(JSON.parse(req.response)); &#125; else &#123; // 使用 reject 自訂失敗的結果 reject(new Error(req)) &#125; &#125;; req.send(); &#125;);&#125;// 往後的 HTTP 直接就能透過 get 函式取得get('https://jsonplaceholder.typicode.com/todos/1') .then((res) =&gt; &#123; console.log(res); &#125;) .catch((res) =&gt; &#123; console.error(res) &#125;) Promise 方法最後，介紹 Promise 中其它的方法，就 Promise 的物件下，展開後可以看到以下方法： Promise API all -&gt; 多個 Promise 行為同時執行，全部完成後統一回傳。 race -&gt; 多個 Promise 同時執行，但僅回傳第一個完成的。 Promise.reject, Promise.resolve -&gt; 定義 Fulfilled 或 Rejected 的 Promise 物件。 此段用下方定義的 promise 函式做說明，可以傳入兩個參數： num: 此 Promise 執行成功與否 time: 此 Promise 所執行的時間長度1234567function promise(num, time = 500) &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; num ? resolve(`$&#123;num&#125;, 成功`) : reject('失敗'); &#125;, time); &#125;);&#125; Promise.all透過陣列的形式傳入多個 promise 函式，在全部執行完成後回傳陣列結果，陣列的結果順序與一開始傳入的一致。 1234Promise.all([promise(1), promise(2), promise(3, 3000)]) .then(res =&gt; &#123; console.log(res); &#125;); 這個方法很適合用在多支 API 要一起執行，並確保全部完成後才進行其他工作時。 Promise.race透過陣列的形式傳入多個 promise 函式，在全部執行完成後回傳單一結果，結果為第一個運行完成的，以下範例來說就會回傳 promise(1) 的結果。 123Promise.race([promise(1), promise(2), promise(3, 3000)]).then(res =&gt; &#123; console.log(res);&#125;); 這個方法可以用在站點不穩定，同時發送多支同行為 API 確保可行性使用，但實作中使用率並不高。 Promise.reject, Promise.resolve這兩個方法是直接定義 Promise 物件已經完成的狀態（resolve, reject），與 new Promise 一樣會產生一個新的 Promise 物件，但其結果是已經確定的，以下提供範例說明： 使用 Promise.resolve 產生一個新的 Promise 物件，此物件可以使用 then 取得 resolve 的結果。 123456var result = Promise.resolve('result');result.then(res =&gt; &#123; console.log('resolved', res); // 成功部分可以正確接收結果&#125;, res =&gt; &#123; console.log('rejected', res); // 失敗部分不會取得結果&#125;); 改為 Promise.reject 產生 Promise 物件，此物件必定呈現 rejected 的結果。1234567var result = Promise.reject('result');result.then(res =&gt; &#123; console.log(res);&#125;, res =&gt; &#123; console.log(res); // 只有此段會出現結果&#125;);// rejected result 注意：Promise.reject、Promise.resolve 是直接定義結果，無論傳入的是否為 Promise 物件。 參考文章： Google 開發者文件：https://developers.google.com/web/fundamentals/primers/promises MDN Promise：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://wcc723.github.io/tags/promise/"}]},{"title":"單元測試 - 非同步及 Ajax","slug":"jest-async","date":"2020-02-08T16:00:00.000Z","updated":"2020-02-09T06:22:08.215Z","comments":true,"path":"development/2020/02/09/jest-async/","link":"","permalink":"https://wcc723.github.io/development/2020/02/09/jest-async/","excerpt":"","text":"本篇延續上一篇：十分鐘上手前端單元測試 - 使用 Jest JavaScript 是屬於同步，單執行緒的程式語言，因此當有非同步的事件時就會被往放到事件佇列，直到所有程式碼運行過後才會執行事件佇列內的程式，如果不熟悉這段觀念就會使程式的運行不符合預期，相關概念可以看此文章一次只能做一件事情的 JavaScript。 另外，現在的非同步大多都使用 Promise 來撰寫，包含 ES6 的 Fetch 及許多遠端請求的套件亦是使用 Promise 作為基礎。因此在撰寫 Jest 撰寫非同步測試時也會使用到相關的概念，至於 Promise 可參考 使用 Promise 處理非同步 範例函式這次的測試目標是使用 Ajax Get 取得遠端資料，並且確保遠端的資料是符合預期的。JSONPlaceholder 此服務可以供前端模擬 Ajax 行為，包含 GET、POST、PUT、DELETE 都可以練習，同時也可以使用 id 的方式取得固定的資料內容。 使用的遠端資料 API 路徑（最後一個數字則是 id，可確保取得固定資料）：https://jsonplaceholder.typicode.com/todos/1 該路徑取得的格式及值如下，本次將會驗證 title 的值是否為 “delectus aut autem”：123456&#123; userId: 1, id: 1, title: \"delectus aut autem\", completed: false&#125; 除此之外，我們還會使用 axios 此套件來取得遠端資料，這是一個基於 Promise 開發的 HTTP 請求工具，可運用於瀏覽器或 Node.js 上（axios），使用以下指令安裝 axios：1npm install axios 接下來在範例專案引入 axios，並且取得遠端資料。12345678910const axios = require('axios');const fns = &#123; fetchData: (num = 1) =&gt; &#123; return axios .get(`https://jsonplaceholder.typicode.com/todos/$&#123;num&#125;`) .then(res =&gt; res.data) .catch(err =&gt; 'error'); &#125;&#125; 如果透過 console.log() 檢視此段函式，可以發現他所回傳的是 Promise 函式，並非遠端的值。1console.log(fns.fetchData()) 如果要正確取得遠端值，則必需使用 then 這個方法。123fn.fetchData(1).then(res =&gt; &#123; console.log(res);&#125;); 錯誤範例JavaScript 特性是同步的，它會依序執行所有的程式碼，但遇到「非同步的事件」則會將事件移動到事件佇列內最後執行。因此，測試的預期結果如果是直接放到非同步的後方，則會無法正確取得資料。 以下範例來說： fn.fetchData(1) 是屬於非同步事件，因此會最後才執行。 因為 fn.fetchData(1) 是最後執行，所以 expect(data.title) 中的 data 是一開始定義的 {} 所以結果必定為 failed（fn.fetchData(1) 不可能先執行完）。1234567891011test('should 返回值必定為 \"delectus aut autem\"（沒有正確套用 Promise）', () =&gt; &#123; // 非同步必定需要加上 return，才能正確驗證結果 let data = &#123;&#125;; fn.fetchData(1).then(res =&gt; &#123; data = res; &#125;); // expect 無法正確取得值 expect(data.title).toEqual('delectus aut autem');&#125;); 非同步Promise 是常見的非同步的方法，基於 Promise 上還可以使用 Async、Await，這兩種寫法在 Node.js 中都可以運行，因此也都可以導入 Jest 中撰寫。 使用 Promise由於上述提到 fn.fetchData 會直接回傳 Promise 函式，Promise 執行完後回傳的值則必須使用 then 來取出，測試的期望及匹配也就必須寫在 then 之內，確保 Promise 已經執行完成。 所以只要將先前範例中的 expect() 移動到 then 內部基本上就能運作。1234567891011// 非同步：Promise 寫法test('should 返回值必定為 \"delectus aut autem\"', () =&gt; &#123; // 斷言，確保非同步有正確取得資料 expect.assertions(1); // 當有使用 assertions 則必需加上 return，才能正確驗證結果 // The assertion for a promise must be returned. return fn.fetchData(1).then(data =&gt; &#123; expect(data.title).toEqual('delectus aut autem'); &#125;)&#125;); 斷言在前面的範例中，如果移除 expect.assertions 還是可以正確運作，而 assertions 的目的是確保有完整取得 Promise 資料，可以將程式碼改為如下將得到不同結果：12345// 此段範例中，Promise 直接進入 Catch 則會通過驗證// 因為 catch 回傳的 'error' 與期望值一致test('assertions 驗證', () =&gt; &#123; return fn.fetchData(1).catch(e =&gt; expect(e).toMatch('error'));&#125;); 如果要確保程式碼正確取得 Promise Resolve 的結果，就可以使用 expect.assertions(num)（num 表示斷言的數量）。 當補上 expect.assertions(1) 就必須使用 resolve 的結果才能通過驗證，expect.assertions 在 async 的寫法上也會更顯得重要。12345test('assertions 驗證', () =&gt; &#123; expect.assertions(1); return fn.fetchData(1).catch(e =&gt; expect(e).toMatch('error'));&#125;); 使用 ES6 Async, AwaitJavaScript 特性是同步的，它會依序執行所有的程式碼。但在 ES6 中，只要將函式轉為 Async 函式，就可以使用 await 來接受 Promise 回傳的結果，相對於 Promise 來說，await 不需要另外使用 then 或函式的巢狀結構，並且會依序執行 Promise 的事件，也因為這個特性使非同步原始碼不需要寫得很 “巢”。 1234567test('should 回傳值必定為 \"delectus aut autem\"（async）', async () =&gt; &#123; expect.assertions(1); // async 函式下，await 會確保取得遠端資料後才繼續往下運行 const data = await fn.fetchData(1); expect(data.title).toEqual('delectus aut autem');&#125;); 驗證特定屬性是否存在除此之外，遠端資料相對於本地端是更不可預期的，因為蝴蝶效應的關係，後端改了程式碼可能沒有知會前端，導致前端程式碼發生不可預期的錯誤（但開發者可能找不到原因），測試中也可以導入特定欄位是否存在的驗證。 123456test('驗證非同步 特定屬性是否已被定義', async () =&gt; &#123; expect.assertions(1); const data = await fn.fetchData(1); expect(data.title1).toBeDefined();&#125;); 參考資料：參考： 官方文件：https://jestjs.io/en/ 影片：https://www.youtube.com/watch?v=7r4xVDI2vho","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"test","slug":"test","permalink":"https://wcc723.github.io/tags/test/"},{"name":"jest","slug":"jest","permalink":"https://wcc723.github.io/tags/jest/"}]},{"title":"十分鐘上手前端單元測試 - 使用 Jest","slug":"jest-intro","date":"2020-02-01T16:00:00.000Z","updated":"2020-02-02T13:46:18.534Z","comments":true,"path":"development/2020/02/02/jest-intro/","link":"","permalink":"https://wcc723.github.io/development/2020/02/02/jest-intro/","excerpt":"","text":"隨著應用程式越來越大，人工流程的測試也會耗去許多的時間，許多功能再開發後都必須重新進行點擊特定目標、撰寫複雜表單、送出來檢驗功能的正確性，當功能越來越複雜時，人工測試所花的時間也會越來越常，因此改用測試工具相對會節省去許多時間。尤其到了上線時才發現錯誤，那時候心中真的會吶喊 No、No、No～。 前端的測試常見的有兩大類別： Unit Test：中文稱為單元測試，是以一個行為進行測試，可驗證運行是否符合結果。 E2E Test：直接模擬使用者在瀏覽器上的行為做測試 圖片來源：Unit vs E2E Testing for Vue.js 因此 Unit Test 相對來說測試成本降低非常多，在任何時間點都可以優先導入測試（甚至在開發前 - TDD），雖然測試聽起來要另外撰寫程式碼做驗證，但撰寫並不一定會花上許多時間（思考驗證邏輯反而會花上許多），但好的測試可以帶來許多的優點： 避免修改程式碼後的錯誤：修改程式的過程中可能會發生蝴蝶效應，A 處修改的原始碼卻使看似毫無關聯的 B 處錯誤。 不需要每次修改都重新人工測試 除此之外，身為一個工程師看不慣前輩（或是過去的自己）的 Code 是很正常的，但重構同時也會帶來風險，如何確保新舊程式碼之間的結果一致是相對困難的過程。 Jest本篇會以 Jest 作為起手式介紹，後續也會另外介紹一篇 E2E 的測試框架。Jest 在 React 界有許多開發者推薦使用，Vue 的 Cli 中也是可做為預設的單元測試選項。 單元測試的基本觀念是對 function 進行測試，但許多同學可能聽到 “測試” 就會覺得些許的麻煩。接下來我們透過一個小故事來介紹單元測試中的各種行為。 小明是一間麥當當分店的店長，接下來要為新進的員工進行評鑑，因此他模擬了顧客行為要在麥當當買大麥克套餐 127 元，並且使用百元鈔票付款，因此他會拿出 200 元現金，預期讓點餐員找回正確的零錢。 因此，這段對應到單元測試會有以下流程： 測試的目標為何？ -&gt; 會使用一段文字描述做什麼、期望的結果為何 小明決定拿出 200 元，心裡想著「拿 200 元買套餐，預期會找 73 元」 導入要測試的函式 -&gt; 實際運行的過程 點餐員收走了 200 元減去大麥克套餐的 127 元，得到了 73 元找給了小明 測試的期望是什麼？ -&gt; 驗證的期望值，可以用各種方式比對結果 小明收了錢後，算了算確實是 73 元沒有錯 在這個過程中就有可能發生： 點餐員不夠專業，找錢的過程出錯 小明的預期是錯誤的，可能小明在一開始就沒規劃好，也沒算準導致錯誤 無論如何，接下來我們將透過實際的程式碼來介紹上述的過程。 驗證點餐員的行為是否符合預期接下來，我們會新增兩個檔案，一個是點餐員的行為，另一個是測試整個過程的腳本。12|- employee.js 點餐員的行為|- employee.test.js 點餐員的測試腳本 點餐員目前只有一個行為就是找零錢，他會接收兩個數值（顧客的現鈔、餐點的價格），並且回傳一個結果（找的零錢）。注意：這個檔案必需 export 才能被測試檔案接收並測試。1234567const employee = &#123; makeChange: function(bill, price) &#123; return bill - price; &#125;&#125;;module.exports = employee; 命名一個中間補上 .test. 的檔名作為測試檔（這是測試預設的檔名），接下來在此補上要測試的內容。測試的過程中會明確的標上「測試的目標描述test(...)」，並且定義「測試的結果是否符合預期expect()...」12345678910const employee = require('./employee');// 明確描述測試的目標：'拿 200 元買套餐，預期會找 73 元'test('拿 200 元買套餐，預期會找 73 元', () =&gt; &#123; const bill = 200; // 小明手中的鈔票 const price = 127; // 餐點的價格 // 期望找錢的結果是符合預期的 expect(employee.makeChange(bill, price)).toBe(73);&#125;); 準備安裝環境及測試結果，在上述過程中已經將原始碼及測試的過程都準備好，接下來只要小步驟就能將測試環境導入： 輸入 npm install jest --save-dev 安裝 Jest 打開 package.json 內將 script 內新增方法並加入 jest。 123456789&#123; \"devDependencies\": &#123; \"jest\": \"^24.9.0\" &#125;, \"scripts\": &#123; \"test\": \"jest\" // 運行 test 的方法時，會使用 jest 作為套件開始運行 &#125;, // ...&#125; 輸入 npm run test 查看結果 如果過程沒有錯誤，你應該可以在終端機下看到以下結果，我們定義了一個目標「拿 200 元買套餐，預期會找 73 元」，這個測試結果是沒有問題的。 到此，已經掌握到基礎的測試過程，提出一個目標並且使期望值通過（心中是否會聽到 Yes、Yes、Yes 的聲音呢？）。 監控測試：也可以將 scripts 中的方法改為如下，就可以不需要每次都重新輸入 npm run test12345678910&#123; \"devDependencies\": &#123; \"jest\": \"^24.9.0\" &#125;, \"scripts\": &#123; \"testwatch\": \"jest --watchAll\" // 使用 npm run testwatch 時會持續用監控的形式，而不是只有單一次報告 &#125;, // ...&#125; 藉此，相信你對於測試有基本的概念，在進入下一個階段前可以先回顧一下三個階段： 測試的目標為何？ -&gt; test(&#39;...&#39;, ()=&gt;{}) 導入要測試的函式 -&gt; employee.makeChange() 測試的期望是什麼？ -&gt; expect(...).toBe(...); 專案結構調整透過範例了解以後，我們稍微調整一下專案結構，便於後續的介紹： 資料夾目錄與上述接近，將 employee 改為 fn，用來定義多個函式。12|- fn.js 原始的測試檔案|- fn.test.js 測試的腳本 JS 檔案中，透過物件定義多個行為。12345const fns = &#123; // ...&#125;module.exports = fns; // 將函式給予匯出 fn.test.js 這個測試檔案將匯入上述的函式檔案，並且開始進行測試：12345const fn = require('./fn');test('...', ()=&gt; &#123; ...&#125;); 準備好以後，我們來繼續往下介紹吧！ 搭配 VSCode 環境除了使用終端機外，Jest 與 VSCode 也能有很好的整合，不需要每次運行都輸入 npm run test，搭配套件使用即可在每次存檔後看到測試的結果。 套件連結：https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest 接下來新增一個 jest.config.js，此測試檔案預設僅需要匯出一個空的即可運作（全部使用官方預設即可），參考如下：12module.exports = &#123;&#125;; 123|- fn.js 原始的測試檔案|- fn.test.js 測試的腳本|- jest.config.js 新增的 Jest 設定檔案 在測試的文檔右方即可看到測試成功的 v，如果是失敗狀態則會出現紅色的 x。 錯誤的狀態如下，會出現 x ，並且在 expect 行列上出現紅色下底線，游標在上時會提供預期值及實際接收值。 VSCode 片段提示每次都要重新輸入 test(&#39;....&#39;, ()=&gt; {}) 或各種驗證覺得麻煩嗎？Jest 的各種語法都很好理解，但反覆輸入真的會花上許多時間，因此可以透過 Snippets 來增快寫測試的速度。 https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets 使用方式，輸入比對方法中的首字及其後的大寫字母（建議直接從 Jest 官方文件去做聯想，可以學得更快），參考如下： tb -&gt; expect().toBe(); tblt -&gt; expect().toBeLessThan(); tblte -&gt; expect().toBeLessThanOrEqual(); 基本的起手式，也可以輸入 test + tab 即可出現以下片段：123test('should ', () =&gt; &#123; &#125;); 在測試的檔案下，輸入特定字母也會提示具有哪些片段可用。 常見的條件驗證方式 - matchers編寫測試時需要讓值符合期望，Jest 中的 expect 後方可以使用 matchers（匹配器）作為條件驗證，如先前的範例 expect(...).toBe(...); 中的 toBe 就屬於 matchers，作為各種不同條件的驗證使用。 如果是熟悉 JavaScript 的開發者，可以直接看 Jest 官方文件 expect 的部分，所有的 matchers 皆陳列於此，本段落會列出實際開發中常見的 matchers，有了基礎概念後，對於官方所提供的文件也能更快上手。 在 fn.js 中先定義多個方法，這些方法會回傳數值、null、undefined 等各種純值，另外還會回傳物件（物件的驗證概念會與純值不同）。12345678910111213// 原始碼const fns = &#123; add: (num1, num2) =&gt; num1 + num2, isNull: () =&gt; null, isUndefined: () =&gt; undefined, isNaN: () =&gt; NaN, checkValue: (val) =&gt; val, createUser: () =&gt; &#123; return &#123; name: '小明' &#125; &#125;&#125; 在純值的驗證上相對單純，除了 toBe 外，有各種直白的 matchers 可供利用。123456789101112131415// toBe：使值完全符合，判斷是使用 Object.is// 概念接近於 `===`test('測試 fn 相加是否正確', () =&gt; &#123; expect(fn.add(5, 5)).toBe(10);&#125;);// toBeNull：測試回傳值是否為 nulltest('測試 fn 是否為 Null', () =&gt; &#123; expect(fn.isNull()).toBeNull();&#125;);// toBeUndefined：測試回傳值是否為 undefinedtest('測試 fn 是否為 Undefined', () =&gt; &#123; expect(fn.isUndefined()).toBeUndefined();&#125;); 在 JavaScript 中，如果使用 NaN === NaN 則會回傳 False，官方另有提供 toBeNaN 作為驗證，但其實使用 toBe(NaN)也能通過，主要原因 toBe 是使用 Object.is 的方法，相關討論可參考 NaN check：1234// toBeNaN：測試回傳值是否為 NaNtest('測試 fn 是否為 是否為 NaN', () =&gt; &#123; expect(fn.isNaN()).toBeNaN();&#125;); 真值、假值（truthy、falsy）是判斷式中的判斷依據，並不一定完全是布林值的 true or false，所以在此就不適合使用 toBe，可以使用 toBeFalsy、toBeTruthy 進行驗證。12345678// 以下是判斷真值與test('測試 fn 是否為 是否為假值', () =&gt; &#123; expect(fn.checkValue(0)).toBeFalsy();&#125;);test('測試 fn 是否為 是否為真值', () =&gt; &#123; expect(fn.checkValue(1)).toBeTruthy();&#125;); 物件比對JavaScript 的特性之一，物件是傳參考而不是傳值（關鍵字可查詢：Javascript call by sharing）。 以下列範例來說，雖然物件內的值是相同的，但因為物件是傳參考的特性，所以最終所回傳的結果還是 false。12345const user = &#123; name: '小明'&#125;console.log(user === &#123;name: '小明'&#125;); // false 在 Jest 也是相同的概念，如果直接使用 toBe 來比對物件，就算其內部的屬性值是相同的，一樣會得到 failed 的結果。 範例：123456789101112131415// 原始碼const fns = &#123; createUser: () =&gt; &#123; return &#123; name: '小明' &#125; &#125;&#125;// test (failed)test('測試 fn 是否為 小明', () =&gt; &#123; expect(fn.createUser()).toBe(&#123; name: '小明' &#125;);&#125;); 因此在做物件比對時，必須使用另一個方法 toEqual 才能比對兩個物件內的值是否相同。 123456// test (passed)test('測試 fn 是否為 小明', () =&gt; &#123; expect(fn.createUser()).toEqual(&#123; name: '小明' &#125;);&#125;); toBe 及 toEqual 的差異toBe 及 toEqual 語意上都是很接近的，許多情況下兩者混用也會出現相同的結果，但在運作上會有所不同，以下分別列出兩者特點及差異： toBe 是使用 Object.is 作為判斷，並非使用 ===，所以在部分情況下會與 ECMAScript 有所不同。 toEqual 是屬於深度比對（deep equality），一一使用 Object.is 比對物件或陣列內的純值；也由於是深度比對，就如同在物件內將值一一取出重新比對，效能上會較差一些。 參考： https://jestjs.io/docs/en/expect#toequalvalue https://jestjs.io/docs/en/expect#tobevalue Jasmin（此段說明接近 Jest）：https://stackoverflow.com/questions/22413009/jasmine-javascript-testing-tobe-vs-toequal 數值比對數值比對中也有提供「大於、小於、大於等於、小於等於」等方法，以下直接提供範例做參考： 123456789101112131415161718// testtest('測試數值 是否小於 2000', () =&gt; &#123; const num1 = 1000; const num2 = 900; expect(num1 + num2).toBeLessThan(2000);&#125;);test('測試數值 是否小於 2000', () =&gt; &#123; const num1 = 1000; const num2 = 1000; expect(num1 + num2).toBeLessThan(2000);&#125;);test('測試數值 是否小於或等於 2000', () =&gt; &#123; const num1 = 1000; const num2 = 1000; expect(num1 + num2).toBeLessThanOrEqual(2000);&#125;); 字串符合字串除了 toBe 以外，還可以使用 toMatch 搭配正規表達式進行驗證，以下提供 mail 的驗證供參考： 1234567891011test('測試 email 格式是否正確', () =&gt; &#123; expect('gres@gmail.com').toMatch( /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z]+$/ );&#125;);test('測試 email 格式是否正確 2', () =&gt; &#123; expect('gres@gmail').toMatch( /^\\w+((-\\w+)|(\\.\\w+))*\\@[A-Za-z0-9]+((\\.|-)[A-Za-z0-9]+)*\\.[A-Za-z]+$/ );&#125;); 陣列是否包含特定值陣列比對上與物件相同，都是使用 toEqual()，另外可以使用 toContain 檢視陣列中是否有包含特定值。 1234test('陣列是否包含 Casper', () =&gt; &#123; const newArray = ['Bob', 'Someone', 'Casper']; expect(newArray).toContain('Casper');&#125;); describedescribe 的用途是提供一個群組的描述，以一開始的範例來說，我們可能會驗證點餐員以下行為是正確的： 點餐內容與顧客需求相符 結帳金額正確 找零的金額正確 那麼 describe 就可以將這些測試定義成一個群組：12345describe('僱員的行為測試', () =&gt; &#123; test('點餐內容與顧客需求相符', () =&gt; &#123;&#125;); test('結帳金額正確', () =&gt; &#123;&#125;); test('找零的金額正確', () =&gt; &#123;&#125;);&#125;); 在使用 npm run test 則可以接受到群組的測試結果。 describe 的群組定義也同樣可以使用巢狀，詳細可見官方網站：https://jestjs.io/docs/en/api#describename-fn 預告單元測試難的也並非是語法，更重要的是如何驗證函式的行為與產品邏輯一致。本篇簡單入門了 Jest 的運作方式，接下來還會繼續介紹非同步的測試及框架的實戰測試方法。 參考： 官方文件：https://jestjs.io/en/ 單元測試和整合測試的涵蓋範圍：https://ithelp.ithome.com.tw/m/articles/10229734 影片：https://www.youtube.com/watch?v=7r4xVDI2vho 神 Q 超人簡報：https://hackmd.io/@ei_7gAIeSEq2x9U-cH1WoQ/r1FoTHClL","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"test","slug":"test","permalink":"https://wcc723.github.io/tags/test/"},{"name":"jest","slug":"jest","permalink":"https://wcc723.github.io/tags/jest/"}]},{"title":"前端開發者，圖片常犯的五個粗心錯誤","slug":"image-common-mistakes","date":"2020-01-03T16:00:00.000Z","updated":"2020-01-05T23:54:19.954Z","comments":true,"path":"development/2020/01/04/image-common-mistakes/","link":"","permalink":"https://wcc723.github.io/development/2020/01/04/image-common-mistakes/","excerpt":"","text":"前端開發者是透過程式碼將資訊呈現成畫面，因此畫面的好壞也多少影響品質，在觀看許多履歷或作業的過程中，會發現許多相似的錯誤，而這些錯誤都是有跡可循，並且可以避免的；本篇先以常見的圖片問題與大家分享，看是否你也犯了這些錯誤呢？ 一、圖片變形新手錯誤率：⭐⭐⭐⭐令人感受的粗心度：👎👎👎👎 圖片變形是最明顯的錯誤，大部分的使用者都能看到這樣的問題，而這些問題會讓人感受到開發者的不細心。 要避免圖片變形，關鍵在於「避免在 比例可能會調整 的空間使用 img 標籤」 以下圖為例：該圖的原始檔案長寬為 1350px * 901px 就比例來說是張橫式的圖片，如果在網頁上的空間提供非此比例則會造成變形。 以下圖來說，左方是屬於正確呈現的圖片，維持原本的橫向矩形，如果改為右圖接近方形的情況就會產生變形。 有些時候，比例變化沒有那麼大的情況下，開發者可能會誤以為圖片沒有變形，但在用戶看來並非如此，現在人普遍美感大幅提升的情況下，越來越多人可以輕易看出這樣的問題。 避免方法： 僅限制寬 或 高，另一邊使其自由伸展 如果寬高比例是無法控制的，可以使用背景圖作替代 錯誤範例及解決辦法： See the Pen 圖片變形範例 by Wcc723 (@Wcc723) on CodePen. 範例連結：https://codepen.io/Wcc723/pen/zYxPmXR 二、圖片尺寸過大新手錯誤率：⭐⭐⭐⭐⭐令人感受的粗心度：👎👎 雖然越高的解析度會有更好的畫質呈現，但受限於裝置能夠呈現的極限及人眼的辨識度下，過於提高的解析度並不會有更高的畫質，反而會造成 1. 圖片下載速度過慢、2. 瀏覽器渲染速度變慢導致網頁操作不順暢。雖然現在的裝置普遍效能很高，但超過 2000px ~ 3000px 的圖片還是會影響顯示效能。 這個錯誤算是最常見，但卻不一定會被發現的錯誤，因為圖片顯示上是沒有問題的（只是可能慢一些），大多情況則是會透過開發者工具檢查此問題。以下圖來說就載入該空間所需十倍尺寸大的圖片 See the Pen 圖片檔案過大 by Wcc723 (@Wcc723) on CodePen. 範例連結：https://codepen.io/Wcc723/pen/NWPwOQr 避免辦法： 簡單解決辦法，釐清你的圖片的用途： 主要圖片、小圖：圖片的寬高尺寸盡量不超過顯示區域的兩倍（ex: 寬度 300px 的顯示區域則圖片寬度不超過 600px 為主），現在許多裝置都有 Retina 顯示器，此情況下 2 倍解析度已有不錯的品質。 背景圖：因為背景圖並非主要用來傳達資訊的內容，因此使用 1:1 的顯示尺寸即可。 使用 srcset 設置響應式圖像： 透過 srcset 可以在同一個 img 標籤載入不同尺寸的圖片，參考文件 範例程式碼：1&lt;img class=\"img-fluid\" srcset=\"https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=300&amp;q=80 800w, https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1200&amp;q=80 1200w\"&gt; 請另開分頁，並調整視窗尺寸後並重新整理畫面（可以取得不同尺寸的圖片）：https://codepen.io/Wcc723/full/oNgoQXm 三、SVG 內混用了點陣圖、未外框的文字新手錯誤率：⭐⭐令人感受的粗心度：👎👎 SVG 是屬於向量圖，而一般的 jpg, png 是屬於點陣圖，向量圖來說最大的特性在於沒有解析度的限制，並且是屬於數學座標，且檔案大多小於點陣圖，並且有極佳的顯示品質。因此再大的區塊，也都僅需要載入很小檔案的 svg 就有很棒的呈現。 SVG 是屬於 XML 格式的標記語言，原始碼的內容都是在標記所有節點的座標位置，因此在原始碼會看到元素標籤、座標位置的相關資訊，輸出的檔案結構如下：12345&lt;svg width=\"100px\" height=\"100px\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;g id=\"svg-outline\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"&gt; &lt;path d=\"M49.564,64.336 C45.878,64.336 41.926,62.968 39,60.27 L42.838,55.596 C44.852,57.306 47.474,58.484 49.716,58.484 C52.224,58.484 53.402,57.534 53.402,56.014 C53.402,54.38 51.844,53.848 49.412,52.822 L45.802,51.302 C42.838,50.124 40.064,47.654 40.064,43.55 C40.064,38.8 44.32,35 50.324,35 C53.592,35 57.05,36.254 59.52,38.724 L56.138,42.98 C54.276,41.574 52.528,40.814 50.324,40.814 C48.234,40.814 46.942,41.65 46.942,43.17 C46.942,44.728 48.728,45.336 51.236,46.324 L54.77,47.73 C58.266,49.136 60.356,51.492 60.356,55.482 C60.356,60.194 56.404,64.336 49.564,64.336 Z\" id=\"S\" fill=\"#000000\" fill-rule=\"nonzero\"&gt;&lt;/path&gt; &lt;/g&gt;&lt;/svg&gt; SVG 圖片範例 當 SVG 內容插入點陣圖片後，圖片就不是只存在著座標位置，還會將點陣圖片以 base64 的格式插入。記得，這個圖片會造成許多額外的檔案大小，並且無法如同 SVG 一樣自由縮放，如同喪失使用 SVG 的用意。 通常會出現這樣的錯誤是在設計稿插入了點陣圖，並誤將此圖片輸出出來，開發者如果沒有檢查通常不會主動發現這樣的錯誤。12345&lt;svg width=\"100px\" height=\"100px\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;g id=\"svg-bmp\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\"&gt; &lt;image id=\"Bitmap\" x=\"39\" y=\"35\" width=\"22\" height=\"30\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAeCAYAAAAo5+5WAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAFqADAAQAAAABAAAAHgAAAAAsUXibAAACGklEQVRIDaWVzUtWQRSHX0sjXfiBCJGErowgqFaJK10kbkUoaKFILmon2V/Qulq0yFoErowWhatEDcGFbcOVIm0EP7ACsbJU+np+rw7OnTtz517eA887M2d+58x978ycW1UKWxNTt6AHrkEL1MFn2IQP8A4W4BCipuBH8AP+5WAdzT04A0G7yMwq5EnoapaJU3zK2vBodTegyHiX+E4381yFSfUAK1BvJ+6NJP3L/Bbo734JaL/hvwQJm2AU+sva9Y6EulRqZzwGG6A4LdwPKVvCE0rcmlKfOM7S1Ql6eOJK9rYZ+hL/xt+YlOYbnTqWaTd9dhrnE6j2TebxvUHke2Lj09kehto8yWzNTQYmSVa7g+4pXLaDY/1FBFlJ3TnViiGoiSW+gkDv2k0QG38i5jZUQdCuMqOLEEvmm39FXOYm69y+BB01X4Is3xQxUVOleg55y6dZ0HsDfas14ByFvOVUt7iQaXP6YAHM04Xa5kKZLfEd+n8yFrhuacvdNn4T9dQVWOP39ENPPGBqhfR6lzPwEbogZvsZgq9mTgtMg/0EbxmnPjPHATdoDxy9idUr0he9bKqpZsJt15h7DY/hBcSu/jyasg3y6yarZNx9lPbollWSyI59ZpKadoTOT7BFRfuTxOvDkLJ2POOg3S6SVBXxLkTtPIoHMAu/wLfIIX7V4/vgPfeZNZQgfYUvwDnQNf0OOqOqwXsQtP8amWC6AXj6RwAAAABJRU5ErkJggg==\"&gt;&lt;/image&gt; &lt;/g&gt;&lt;/svg&gt; SVG 圖片範例，此範例文字在高解析的裝置下會變得模糊。 在 SVG 加入文字內容時，需要確保文字輸出是有被轉外框，如果沒有轉外框程式碼會看似如下簡短，但如果用戶沒有此字體，該文字就無法如預期顯示。 此錯誤是屬於設計稿中的文字沒有轉外框，因此開發者很難以發現。1234567&lt;svg width=\"100px\" height=\"100px\" viewBox=\"0 0 100 100\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\"&gt; &lt;g id=\"svg-font\" stroke=\"none\" stroke-width=\"1\" fill=\"none\" fill-rule=\"evenodd\" font-family=\"NotoSansCJKtc-Black, Noto Sans CJK TC\" font-size=\"38\" font-weight=\"700\"&gt; &lt;text id=\"S\" fill=\"#000000\"&gt; &lt;tspan x=\"38.359\" y=\"66\"&gt;S&lt;/tspan&gt; &lt;/text&gt; &lt;/g&gt;&lt;/svg&gt; SVG 圖片範例，此範例的文字可以圈選，且與上方的字體不一定相同（視系統內是否有該字體）。 S SVG 的錯誤與設計師有很大的關係，因此前端開發者在使用 SVG 稿件時也有義務一同檢視該檔案是否正確。而設計師也需要對此更加注意，避免輸出錯誤的圖檔給予開發者使用。 相較於其它錯誤來說，此錯誤與設計師的稿件輸出有很大關係。因此，如果你是 UI 設計師，此類型錯誤會令人感受到不專業。 四、背景圖裁切掉主體新手錯誤率：⭐⭐⭐令人感受的粗心度：👎 現在開發都會考量 RWD 的顯示，RWD 中的圖片大多會改變寬高或轉為背景圖來處理，而背景圖並非都適合運用在 RWD 中，因為在縮放的過程中會有不同比例的裁切，這些裁切如果是在主體上，對於網頁品質會有很大的扣分。 在以下的範例中有一個長形的沙發，也由於沙發長度過長，因此在行動版中左右方會有裁切。 See the Pen 圖片裁切掉主體 by Wcc723 (@Wcc723) on CodePen. 因此在選擇圖片時，可以先思考行動版、桌面版所呈現的比例，兩者比例中的重疊空間稱為「重疊安全區域」，如果主體可以完整置入此區域內就可以避免被裁切。 完整的介紹文章：網頁設計 - 響應式圖片選用技巧 五、圖片連結錯誤新手錯誤率：⭐⭐令人感受的粗心度：👎👎👎👎👎 如果圖片是屬於裝飾類型，並且由開發者所置入，就必須要多加注意。開發者也通常會反覆檢視自己輸出的頁面是很正常的，因此這類型錯誤通常不會是在開發階段時遺漏，很多是在轉換環境時沒有完整檢查出錯。大多原因在於相對路徑與絕對路徑的掌握度不足。","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"}]},{"title":"CSS 技巧：精簡語法操作暗色主題 - CSS Dark Mode","slug":"css-dark-mode","date":"2019-12-21T16:00:00.000Z","updated":"2019-12-22T13:04:00.023Z","comments":true,"path":"css/2019/12/22/css-dark-mode/","link":"","permalink":"https://wcc723.github.io/css/2019/12/22/css-dark-mode/","excerpt":"","text":"Mac 暗色主題推出後，就讓黑色控非常喜愛，而且這樣的暗色佈景使用起來更不傷眼。以我來說是比較喜歡在亮色的佈景下工作的，但暗主題的對於長期需要在電腦面前工作來說，真的相對輕鬆很多。雖然如此，也並非所有的介面都是有提供暗主題，以網頁來說就需要開發者另外定義暗主題才會進行切換（不使用任何瀏覽器插件的情況下）。 好在，暗色主題的語法相當容易，以下介紹如何作切換，並且會提供一個小技巧，只要透過短短的幾行就能操控整個網站所有元件的主題色彩。 支援度先附上大家所在意的支援度，但其實暗色主題本身就是由 Apple 先提出的，所以 Mac OS、iOS 的支援度會比較高，其它的瀏覽器也正在持續跟進中。 語法MDN 上的介紹：https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme 暗色主題的 CSS 是透過 @media 取得裝置的主題模式，就如同取得裝置的形式一樣（尺寸、橫向或垂直、是否為螢幕等等…），相信對於撰寫過響應式的開發者都不陌生。 語法上使用 prefers-color-scheme 來監測是亮色或暗色的主題，相對應的值也就是 dark or light。123@media (prefers-color-scheme: $&#123;dark or light&#125;) &#123; // ...&#125; 實際演示範例範例：1234567891011121314151617181920212223&lt;style&gt;.mode &#123; background-color: #eee; color: #333;&#125;.text-mode:after &#123; content: \"light\";&#125;@media (prefers-color-scheme: dark) &#123; .mode &#123; background-color: #333; color: #eee; &#125; .text-mode:after &#123; content: \"dark\"; &#125;&#125;&lt;/style&gt;&lt;div class=\"demo mode\"&gt; &lt;p&gt;本區塊會隨著暗色與亮色主題切換&lt;/p&gt; &lt;p&gt;您目前的是 &lt;span class=\"text-mode\"&gt;&lt;/span&gt; 主題&lt;/p&gt;&lt;/div&gt; 請透過切換你的暗色、亮色主題來改變下方的範例（暗色主題為深色背景，亮色則反之）。 .mode { background-color: #eee; color: #333; } .text-mode:after { content: \"light\"; } @media (prefers-color-scheme: dark) { .mode { background-color: #333; color: #eee; } .text-mode:after { content: \"dark\"; } } 本區塊會隨著暗色與亮色主題切換 您目前的是 主題 使用變數快速切換網頁的主題色暗色系與亮色中的色彩並不是黑白兩色互相切換，以 Material Design 來說，如果亮色的主色色彩為 #6222ee，在暗色系並不會使用相同色，而是會改變為 #bb85fc 藉此來增加辨識度，而整個網頁中所需要套用色彩的區塊非常多，從按鈕到元件都會不斷地引用，如果透過一個個的 @media 設定將會增加開發及管理的困難度。 Material Design 中的暗色、亮色切換範例，兩者的主色（紫色）在不同的主題下色彩也會改變。 因此，在開發時可以將暗色、亮色的佈景主題色彩以 CSS 變數的方式作定義，避免直接將色彩寫入 CSS 元素上，接下來在 @media 中僅需要改變 CSS 的變數就能夠完整切換所有元件的主題色彩。 1234567891011121314151617.card &#123; --theme-primary: #6222ee; --theme-background: #eee;&#125;.card &#123; /* ... */ background-color: var(--theme-background); color: var(--theme-primary);&#125;@media (prefers-color-scheme: dark) &#123; .card &#123; --theme-primary: #bb85fc; --theme-background: #111; &#125;&#125; .card { --theme-primary: #6222ee; --theme-background: #eee; } .card { margin: 0 auto; padding: 15px; text-align: center; max-width: 320px; border-radius: 3px; border: 1px solid #777; background-color: var(--theme-background); color: var(--theme-primary); } @media (prefers-color-scheme: dark) { .card { --theme-primary: #bb85fc; --theme-background: #111; } } 本卡片會隨著暗色與亮色主題切換 本文中還有利用到 CSS Variables，有興趣可參閱本篇文「原生 CSS 變數運用技巧（CSS Variables）」。 設計規範目前在 Apple 及 Material Design 中也都有針對亮色、暗色的佈景主題提供規範，在完整投入之前，也不妨先參考看看。 Material Design Material Design：https://design.google/library/material-design-dark-theme/ Apple Mac：https://developer.apple.com/design/human-interface-guidelines/macos/visual-design/dark-mode/ iOS：https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"develop","slug":"develop","permalink":"https://wcc723.github.io/tags/develop/"}]},{"title":"一分鐘切換成中文版 VSCode（完整圖文版）","slug":"vscode-chinese","date":"2019-11-30T16:00:00.000Z","updated":"2019-12-22T03:55:53.582Z","comments":true,"path":"development/2019/12/01/vscode-chinese/","link":"","permalink":"https://wcc723.github.io/development/2019/12/01/vscode-chinese/","excerpt":"","text":"雖然開發者都具有一定的英文閱讀能力，但如果在不熟悉的情況下，就比較難以快速上手一個新工具。如果要快速掌握一個完整的工具或技術，最好的方式還是先切換成熟悉的語言。 而 VSCode 雖然預設並無法直接切換語系，但官方有提供各國的語言套件，讓開發者可以自行選用。 切換成中文版如果你對於 VSCode 有興趣，別因為 VSCode 預設開啟是英文版就急著關閉，預設雖然是使用英文版，也找不到語系切換的地方，但其實官方有提供中文版的套件安裝（為了讓 VSCode 輕量化，語系需要另外安裝）。 畫面的左方功能列表中，可以找到 Extensions，點選後輸入 “Chinese” 即可搜尋到中文的相關語系，選擇中文（繁體）後頁面的右方即會出現相關介紹，此時按下 “Install” 就會安裝中文語系套件。 安裝後系統會自動跳出是否切換成該語系，按下 Yes 後就會套用成中文版囉～ 不過人生中最怕的就是那個 “But”，如果沒有自動跳出右下方的提示該如何切換呢？另外 VSCode 如果更新時，可能也會再次切換為英文版，這時候就需要手動切換語系。 手動切換流程也並不複雜，可使用以下三個步驟手動切換 按下 ctrl + shift + P（Mac 版請按下 cmd + shift + P） 輸入 display language 就會跳出 “Configure Display Language” 選擇安裝的語系 “zh-tw” 即可安裝 以下附上影片供參考","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://wcc723.github.io/tags/vscode/"},{"name":"develop","slug":"develop","permalink":"https://wcc723.github.io/tags/develop/"}]},{"title":"十分鐘快速掌握 Markdown","slug":"ten-mins-learn-markdown","date":"2019-11-22T16:00:00.000Z","updated":"2019-11-23T03:35:10.315Z","comments":true,"path":"development/2019/11/23/ten-mins-learn-markdown/","link":"","permalink":"https://wcc723.github.io/development/2019/11/23/ten-mins-learn-markdown/","excerpt":"","text":"Markdown 是目前非常普遍用來撰寫文檔的語言，一開始的目標就是使用「易讀易寫的純文字格式編寫文件」，此初衷讓使用者可以專注在文字的本身，而不需要透過其它工具來切換格式。以 Word 撰寫文檔來說，就必須透過上方的工具列來切換標題、列表、粗體、斜體等等；而 Markdown 並沒有這樣的工具列，完全都是使用標示符號來完成這些需求。 常見應用大部分情況下 Markdown 是用來撰寫程式語言相關的文檔，因為純文字的特性與程式碼一致，且可搭配標示符號來改變呈現格式，像是在 Github 的文件中使用 readme.md 的 Markdown 格式，則會預設作為該儲存庫的介紹。 除了軟體開發以外，目前也越來越多的服務加入了 Markdown 的編寫支援，與文字傳達有關聯性的都慢慢加入其中的語法，像是筆記工具、文字通訊、部落格等等都有這類影子，如 Bear note 就是完全使用 Markdown 的筆記工具、Slack 則是支援部分的文字訊息、Hexo 則是透過 Markdown 撰寫的部落格工具；除此之外，現在 Facebook 發文也可以使用此格式來撰寫文章（目前是限定社團才能使用）。 現在台灣主流的通訊工具 LINE，也可以透過部分的 Markdown 語法來傳遞程式碼或是調整文字格式（電腦版限定）。 學習 Markdown基本概念：Markdown 可以輸出成 HTML 的格式，所以各種標示也會對應 HTML 的標籤，就顯示的結構上可區分為兩大類：區塊、行內。 區塊：此類別會讓內容獨立形成一個區塊，區塊內的 全部文字都是套用同樣的格式，標題、引用、清單都是屬於此類型，而區塊可以疊加使用，如引用內可以包含標題。 行內：套用此類別的內容可插入於區塊內，如：強調文字、斜體字、文字連結等等，要特別注意插入圖片也是屬於此類別（與 HTML 特性相符合）。 以 Word 的概念來介紹，區塊元素表示文字整段都是同樣的風格、層級（洋紅色標示），而行內元素則是在區塊的文字上做修飾（綠色標示）。 除了以上兩點以外，每個 Markdown 環境所能接受的語法都略有不同，像是部分工具、環境雖然接受使用 Markdown 撰寫，但標題上只接受三個以下的層級（正確為六個層級），所以實際上還是需以運行的環境為主，而本篇介紹的則是介紹通用的使用方式。 區塊元素此類別會讓內容獨立形成一個區塊，區塊內的 全部文字都是套用同樣的格式，標題、引用、清單都是屬於此類型，而區塊可以疊加使用，如引用內可以包含標題。 標題總共分為六個層級，依據 HTML 的結構會轉為 &lt;h1&gt; ~ &lt;h6&gt;，形式上是在文字前方補上不同數量的 #，# 數量越少層級越高，反之則是越低，以下方結構來說 # 標題 1 是層級最高，且視覺上最大的標題。 1234# 標題 1## 標題 2...###### 標題 6 呈現結果（以下為 Bear note 的範例） 文字段落當沒有加上任何標示符號時，該區塊的文字就是文字段落區塊，而段落與段落之間會保留一行空白空間，在接下一段的內容。 1234## 這是標題這是一段文字段落這是第二行的文字段落，還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 實際運作範例：標題、內文 這是標題 這是一段文字段落 這是第二行的文字段落，還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 引用引用的寫法與樣式都類似於 Email 中的回文原文，只要在文章前面補上 &gt; 的符號即可。 1&gt; 這裡是一段引用文字 實際運作範例：引用文字 這裡是一段引用文字 部分文件提到：引用文字不僅可以單獨使用，也可以混用其他的區塊元素，或者透過多個 &gt; 來調整層級。但要特別注意，並非所有的 Markdown 環境都支援多個層級的寫法，許多環境僅能單獨使用 &gt;， 清單清單分為一般列表及包含數字符號的列表，兩種都包含多個層級，只要加上一個縮排或兩個空格就可以新增一個層級。 一般列表的使用彈性較高，-、+、* 等符號後方加上一個空白後都可以轉為列表，要表示下一個層級可多一個縮排或是兩個空白即可。 1234- 這是清單+ 這也是清單* 這同樣是清單 - 清單子項目 實際運作範例：一般列表 這是清單 這也是清單 這同樣是清單 清單子項目 包含數字符號的列表則是使用 數字 + .作為開頭，列表中的第一個數字是數字列表的起始序號，而後方的數字不需要按照順序，如：1. 2. 2. 結果依然會是 1. 2. 3.；另外縮排的規則與一般列表相同。 12341. 數字型清單2. 第二個數字清單2. 數字清單不需要連續數字 3. 數字清單子項目 後方的數字不需要按照順序。 122. 數字清單從 2 開始3. 第 3 實際運作範例：數字列表（數字 3 開始） 數字型清單 第二個數字清單 數字清單不需要連續數字 數字清單子項目 如果段落文字需要以數字 + . 作為開頭，可以改為 數字 + 反斜線 + .，範例如下。 12019\\. 避免 `數字.` 轉為數字型清單的方法 區塊程式碼作為許多開發者撰寫文本的工具，插入程式碼片段也是合情合理的。Markdown 中會使用三個連續的反引號（`）開頭及結尾做為區塊的程式碼，並且可以在首行的位置補上該段程式碼的語言類別，藉此輸出具有 Highlight 的程式碼。 三個連續的反引號（`）用在開頭結尾，即可作為區塊程式碼。 首行補上特定程式碼語言名稱，該段可使用特定語言的 Highlight （依據輸出的環境而定），以下圖為例則是使用 js 或 javascript。 12345for (let i = 0; i &lt; 10; i++) &#123; setTimeout(function () &#123; console.log('這執行第' + i + '次'); &#125;, 0);&#125; 當輸出為 html 時，該段落並不會被瀏覽器作為標籤渲染，而是呈現可被使用者閱讀的程式碼。 123&lt;body&gt; &lt;p&gt;這是一段 HTML 結構&lt;/p&gt;&lt;/body&gt; 分隔線分隔線，可以使用三個連續符號表示（-、*，部分環境亦可使用 _） 123---***___ 實際運作範例：分隔線 表格雖然 Markdown 有提供表格的符號，但實際運用上並不是很方便，如果環境許可我大多會直接使用 HTML 的表格標籤替代 Markdown 的表格。Markdown 的表個就像是使用符號 “畫” 一個表格，實際撰寫時對其很麻煩。 下圖為表格的範例。 123| thead 1 | thrad 2 | thread 3 ||---------|---------|----------|| td | td | td | 實際運作範例：表格 thead 1 thrad 2 thread 3 td td td 行內元素套用此類別的內容可插入於區塊內，如：強調文字、斜體字、文字連結等等，要特別注意插入圖片也是屬於此類別（與 HTML 特性相符合）。 斜體斜體字與強調文字使用上是很接近的，可以使用 * 或 _ 符號套用在文字的前後方，即可將文字改為斜體字；而將 * 或 _ 使用連續兩個加在文字的前後方則會是強調文字。 以下為斜體文字的範例，另外在 * 或 _ 的前後補上空白會維持原本的符號，就不會套用斜體效果。 1還是要*勉強自己*，笑起來處子般通紅；看人_突然好想你_，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。* 普通文字 *。 實際運作範例：斜體 還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 普通文字 。 強調以下為強調文字的範例，使用兩個 * 或 _套用在文字的前後方 。** 或 __ 的前後補上空白會維持原本的符號，一樣不會套用強調效果。 1還是要**勉強自己**，笑起來處子般通紅；看人__突然好想你__，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。** 普通文字 **。 實際運作範例：強調 還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。 普通文字 。 行內程式碼與區塊程式碼一樣使用反引號，在此改為單一個反引號加在文字的前後方即可。 1還是要勉強自己，笑起來處子般通紅；看人 `&lt;strong&gt;` 突然好想你 `&lt;/strong&gt;`，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣 `var a = 0`。 實際運作範例：行內程式碼 還是要勉強自己，笑起來處子般通紅；看人 &lt;strong&gt; 突然好想你 &lt;/strong&gt;，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣 var a = 0。 連結連結的結構略有不同，會分為前後兩個片段符號： 前者為 [ ]：中括號內需要補上連結的顯示文字。 後者為 ( )：小括號內補上的是連結路徑。 以下為連結範例：Google 1[Google](https://www.google.com.tw/) 圖片圖片要特別注意是屬於行內元素，因此圖片也可以放在文字段落之中（與 HTML 中的 img 標籤邏輯一致），不過大多情況下會將圖片作為獨立區塊使用。 圖片也與連結結構接近，只不過前方多了 !。 ![ ]：與連結結構接近，但前方緊貼著 ! 符號。中括號的內容也並非必填，其文字內容通常作為 hover 後的提示文字或作為 SEO 增強使用。 ( )：圖片連結位置。 1![unsplash 圖片](https://images.unsplash.com/photo-1573900941478-7cc800f708f3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2100&amp;q=80) 實際運作範例：圖片 參考文章： https://markdown.tw","categories":[{"name":"development","slug":"development","permalink":"https://wcc723.github.io/categories/development/"}],"tags":[{"name":"develop","slug":"develop","permalink":"https://wcc723.github.io/tags/develop/"},{"name":"markdown","slug":"markdown","permalink":"https://wcc723.github.io/tags/markdown/"}]},{"title":"鐵人賽：獲利優先，將你的資金塊狀化","slug":"block-your-money","date":"2019-09-26T16:00:00.000Z","updated":"2019-09-26T23:24:41.859Z","comments":true,"path":"ironman/2019/09/27/block-your-money/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/27/block-your-money/","excerpt":"","text":"獲利優先的概念是來自於這本書：https://www.books.com.tw/products/0010794087 此書是在介紹公司的資金管理方式，大多數新創公司管理人，容易在資金上升後喪失對金錢的敏感度，導致支出費用過高，收入不敷支出使用而使公司倒閉，這個狀況不僅會出現在公司上，家庭中大數目的資金運用時都很容易忽略掉細節。 這會導致： 跳巢加薪才 3000 ，下個月就多花 6000 高金額的費用沒有注意細向花費 月底還以為剩錢，結果在領薪水前透支了 預支未來的資金做運用 （提早透支，真正拿到資金時卻又不夠，只好再次預支 第一次投資就失敗（投入數字過高，導致恐懼心理容易認賠出場 資金塊狀化為了維持對於金錢的敏感度，書中提供了「資金塊狀化」的概念，簡單來說 10,000 數目看似很大，但如果拆成 2,000 來看就簡單很多，如果把每個花費都用 2,000 做拆分在花費上就容易更警慎，用一個小故事來介紹這個概念。 | 小朋友們參加幼稚園的活動，活動中有一塊大蛋糕，兩三個小朋友就想直接用湯匙挖來吃，想說一起吃一個大蛋糕是可以吃完的，但小朋友們其實沒有辦法掌握自己的食量，加上這麼大的蛋糕容易產生誤判。因此老師看到急忙阻止，因為很清楚這幾個小朋友是吃不完的，接下來老師將大蛋糕一一的切小，每個小朋友都分發到了切片小蛋糕，就能大概感受到這是平常爸爸媽媽切好給他的份量。 不知道大家是否有相同經驗，訂購一大份蛋糕、烤雞、合菜都曾經錯估合適的用餐人數，不是過多就是過少，但一一分盤以後，用餐人數的掌握度就會提高。 金錢的掌握也是同樣的概念，從學生時代的消費都是 50 ~ 100 做計算，長時間下來對於百元上下的費用掌握度提高，出可支配費用上升，但對於上千、上萬的金額敏感度卻沒有因此而提升，沒有足夠經驗的情況，就常常會錯估花費的金額。我們對於小數目的費用已經有數年的經驗，累積下來也有上千、上萬次，但在萬元以上的運用卻僅有數十次到數百次，所以經常容易錯估費用導致額外的花費 用盤子分裝你的存款先前的章節介紹到花費基本上可以分為 固定、生活、變動三大類，收入的分配也可以做這種方式有些銀行提供子帳戶的服務，就可將預先將錢分配到不同的帳戶上。經過每月的紀錄，也可抓出這幾個類別在通常需要花費多少；也就像是將食物分盤的概念一樣，集中、大量的食物、金錢我們難以去估算份量。 透過拆分的方式將需要花費的預先保留，以供當月使用，最後再將一部份百分比的費用預先留存（如：每個月另外留下 20% 收入），以薪資五萬為例，結構如下： 固定花費 35%：17,500 生活費 10%：10,000 變動花費 10%：10,000 保留存款 45%：22,500 每個人的收入、支出大不相同，可依據自己的帳務統計來規劃合適的盤子，使用這種方式更能控制即將花費的項目，也能藉此慢慢的增加存款以供未來投資使用。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：有土斯有財？還是緊握著負債","slug":"buy-a-house","date":"2019-09-25T16:00:00.000Z","updated":"2019-09-26T07:32:16.488Z","comments":true,"path":"ironman/2019/09/26/buy-a-house/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/26/buy-a-house/","excerpt":"","text":"傳統觀念中有土斯有財，不斷的鼓勵大家去擁有自己的土地、住宅，出社會後也會有許多長輩洗腦「該擁有屬於自己的房子」。但在臺北這樣高房價的地區，許多人買了第一間房後就長期背著負債，「窮爸爸、富爸爸」一書中提到「自用住宅即是負債」，雖然房子也是資產的一種，但資產是可以脫手轉為現金的，第一間房是否可以轉為現金呢？還是在房貸的壓力下產生難以轉移的問題。 開始工作幾年以後，到許多同輩開始擁有屬於自己房子，有些人有部分長輩資助，也有些人靠自己買了千萬豪宅，但要特別注意自己是否能夠負擔，如果你和我一樣是沒有長輩資助，全額靠自己的可聽聽以下建議。 買房的負債，以不影響生活為前提當然，每個人都會老，老人不太可能在以租屋為前提尋找住所，以目前的社會環境來說會避免租用房子給年長者，為避免額外的延伸問題，大多還是租給年輕學生、小家庭為主，所以長期下來還是需要規劃屬於自己的自住宅。而購買房子時都會有一筆不小貸款，對於貸款有以下的建議： 確保手中現金至少可維持一年的還款費用意外總是來的像龍捲風，如被資遣、家中事故、個人因傷無法工作等等…，這都會造成短期的資金不足，許多文章建議每月還款金額低於家庭收入 35%，我自己則是建議更低於此值 (看地區而定)。別忘了，自住宅就是負債，負債當無法轉正（無法脫手）就永遠是負債， 所以除了每月還款外，自己依然要有留存一定的錢財作為風險控制及投資使用，這是意外發生時無法還款，以及讓自己資產有辦法成長，並在未來能夠將當前房屋脫手使用。 每月還款避免超過租金行情租不如買，前提要是買比租還划算，以天龍國內湖的公寓輕鬆突破 1500 萬來說，每月還款約落在 42,000，但平均租金則是 30k+，目前來說台北的房價成長趨緩，如果以往後想要脫手 (或租人) 都會具有風險。 每月還款不影響生活水平上一篇有介紹分裝你的費用，頭期款 + 每月還款 將是一筆不小的數目，如果因此壓縮生活品質，會讓人的情緒進入負面的循環，無法出國玩、無法買自己想要的東西、買任何東西都要斤斤計較，加上時程長達二三十年(大概就是自己人生長度了!?)，相信大家不想過著長期被房貸綁架的日子。 也想想你住的是哪一區上面的項目列出後，是不是發現似乎沒房好買了呢？ 想要買房不是看房價，而是看自己的還款能力，天龍國自然具有高競爭力、高房價；許多買房者最終被房貸壓垮，就是選擇高房價的地區且錯估自己的還款能力，但並非全台灣都是天龍價，如果你的薪資只有雞蛋等級，就別試著去接巨石等級的房價，買房是長期的規劃，全台灣那麼大，雞蛋等級的薪資也會有適合的巢可以放置。 買房的最終目的是賣出如果要避免房子就是負債，那就需要確保手中的房子是可以脫手的，傳統觀念買房都是為了自住，出售則是次要目標；但如果將者兩者對調思維結果將會大不同，如果是為了售出優先自住為次要需求時： 地點優先而不是屋齡 具有成長性的區域，不會挑選毫無成長力的區域 會逐一挑選有價值的物件，而不會急於一時 當觀念改變後，選擇也會大不同。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：超簡易記帳 - 輕鬆規劃你的理財目標","slug":"how-to-accounting","date":"2019-09-24T16:00:00.000Z","updated":"2019-09-25T07:53:27.758Z","comments":true,"path":"ironman/2019/09/25/how-to-accounting/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/25/how-to-accounting/","excerpt":"","text":"前一篇介紹到退休所需要的資金是兩千萬，雖然這是大部分 “投資廣告” 所提出的金額，但這個金額確切是如何計算出來的呢？這個金額與每個人的花費習慣有很大的關係，兩千萬則是大部分人計算出來的結果，大家也可以用以下方法試著估算一下自己的每月花費，再用每月花費來估算 “年花費”。 目前大部分人類都可以活到 9x 歲來說，從 60 歲退休到 9x 約有 30 年時間，年花費 * 30 就是退休所需的基本金額。 經常錯估的金額沒有記帳習慣的人來說，“年花費” 是很容易低估的，因為我們總是會忘記把錢花去哪邊，翻開銀行的交易紀錄，看著上個月或上上個月，總有許多想不起來的大筆支出。因此，記帳將會是預估年花費一個很重要的方法。年花費大多來說也會逐年提高，隨著家庭人員增加、年紀的增長，透過記帳更能了解消費習慣的改變。 簡單的記帳方法雖然現在有許多記帳軟體，可以記錄到細微的花費，如早餐、交通、點心等等。但記帳最重要的是區分 “固定花費” 及 “變動花費”，每日的餐點、下午茶、點心，甚至是搭車繞了遠路不需要記得那麼細，這麼細微的紀錄會額外花費許多精力，只要錯過幾次就容易導致放棄。 在此與大家介紹一下我的記帳模式，每月可只記錄兩次（次數越少，越不會因為一次的遺漏導致放棄），紀錄上也僅要針對主要費用做紀錄即可，不需要過度細節。 固定花費我們每月都有必備需要支出的項目： 水電、房租、房貸、瓦斯費、電話費 保險費 孝親費 及其它每月落差不大的支出費用 這些費用每月都需要且數目變動不大，可預先列出固定欄位來記錄這些品項。 生活費生活費包含：吃、喝、交通等大部分用小額現金的費用。雖然每天飲食不同、交通方式略有改變，但其實每月的生活費其實差異不大，與其一一的紀錄這些花費品項，不如使用一個固定小錢包來支付這些費用，因此每次提款進入小錢包時，就可以了解生活費的使用狀況，記帳時僅需紀錄提款的時間點、額度就可算出生活費的概略值。(每月幾百元以下的誤差可忽略) 變動花費生在江湖，推坑、聚餐、出國玩樂在所難免，因此包含： 卡費（依據品項分類） 聚餐費用 玩樂費用 奢侈品 意外費用 服務訂閱費用（雲服務、iCloud、Adobe 服務…，可以使用年計算） 非固定的大金額支出 預先訂一個額度（如 2000 元），如果不是每月都需要支付的，只要超過就屬於變動花費，因此實際上需要另外紀錄的也是此項目。記帳時，翻開你的信用卡消費記錄或是另外透過工具紀錄這些消費，就可以知道實際的高額消費情況。 下圖是幾年前我實際紀錄的表格，可以算出每月最終的餘額，非固定支出部分也都有註解說明品項，每月紀錄兩次即可。 有了以上帳目之後，你可以了解到： 多少錢是你的最低需求（固定花費 + 生活費） 哪些費用是可以節省的（變動花費的特定項目檢視） 一年多少錢，你可以過的還不錯 (固定花費 + 生活費 + 變動花費) 一年兩千萬的退休金也就是大多數人的 固定花費 + 生活費 + 變動花費 總和（約每年 60 萬），乘上 30 年的結果，平均則會落在 1800 ~ 2000 萬之間。 透過記帳，可以真正認識自己的消費習慣，能夠了解每年可動用的金額是多少，預先規劃出幾年的投資計劃，並且預先推算退休所需的費用，藉此設計出屬於個人的投資方式。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：iPhone 11 Pro Max 心得文","slug":"iphone-11","date":"2019-09-23T16:00:00.000Z","updated":"2019-09-24T04:07:31.217Z","comments":true,"path":"ironman/2019/09/24/iphone-11/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/24/iphone-11/","excerpt":"","text":"參加個人挑戰的好處，就是可以隨意的歪樓！？ 最近入手了三眼神童 iPhone 11 Pro Max，在這支手機上是好幾個月前就已經打算入手，與這台本身的特性沒有什麼關係，會購買主要原因是一般的 LCD 手機螢幕只要看 5 分鐘就會開始頭暈，也因為如此，一天觀看手機的時間平均是不超過 30 分鐘的（不清楚原因，目前僅了解對於要專注細微的發光體會感到不適）；看過 OLED 後發現可以減輕看螢幕的不適，加上家中老母希望可以換一台手機，所以就適順勢換一台手機了。 我：「要 Android 的還是要我用過的 iPhone？」 老母：「iPhone」 我：「iPhone 二手的，確定？」 老母：「我要 iPhone」 所以就只好順勢換一台手機，把舊的 iPhone 給老母。另外 OLED 也並非蘋果專利，看到 Pixel 系列也是有些興趣，但不得不說蘋果近幾年除了 iPhone 以外，更重視整個生態系，例如： 蘋果系統下的 iCloud 對於相關產品的支援度很高，加上老婆手機儲存空間不足時，可以直接升級成家庭版的 iCloud，費用不高也方便。 各裝置的整合性，如 iPhone 所接到的電話可以使用 Mac 接聽，Mac 複製的連結可以直接貼到 iPhone 上（直接開啟也沒有問題）。 與其它的裝置便利性，AirDrop 可以直接丟檔案可其它人，AirPlay 可以不接線直接投影畫面等等。 而這些功能就會讓習慣 iPhone 的人在轉移上有所顧慮，綜合以上所述，反正我就是買了一台 iPhone。 我選擇的是金色的 iPhone，雖然這次主打的是新色彩夜幕綠，但我對於深色並沒有特別的愛好，所以還是從亮色系做選擇（金或銀），當然兩者都不錯，後來選擇略有些變化的金色。 11 Pro Max 的優缺點這次的 iPhone 主打特色就是三眼神童，具有超級強的相機，在官網的介紹中可以發現三眼相機介紹佔了將近 2/3 的篇幅，這幾天並沒有拍相當多的照片，但還是可以略感受到它與前幾代的差異，如： 色彩更討喜：這點我認為是最大的改動，雖然 iPhone 一直給人稱讚的是接近原色的表現，但原色不一定是討喜的色彩，這方面在韓國、中國的手機可以感到很大的優勢，而這次的 iPhone 依然與原色接近，但同時更能呈現豐富的變化色彩在其中，讓畫面更為討喜。 暗處表現更好：AI 的運算已經讓暗處不受相機感光的限制，而三眼童子結合 AI 自然能有更優的表現。 長距離拍攝依然清晰：多一個長鏡頭當然會更好 拿到手機後帶著女兒去草衙道，但是她幾乎從頭哭到尾，只有在晚上的時候才能好好的拍一張照片，雖然畫面上所提供的是室外照片，但不得不說這次在室內的日光燈下也有很好的調整，讓膚色不會像過往一樣偏綠，看起來會更討喜。 這次的相機加入了長時間曝光，這對於習慣使用單眼的拍照者來說多了更多成像手法，雖然如此，對於手抖者來說，透過 AI 的輔助夜景也依然清晰。 除了相機以外，再說說從 iPhone 8 替換成 11 Pro 的一些感想： 優點： OLED 螢幕：這是換這台手機的主因，搭配深色主題讓畫面呈現對我沒那麼刺眼，使用來說可以比以往有更長一點的時間（恩，就長一點，大概兩倍吧，所以適十分鐘）；不過官方說的螢幕可以呈現更亮這對我來說就沒什麼興趣了 ～＿～。 深色主題：結合上述優勢，自然能讓眼睛能夠更為舒適，且現在許多 APP 也開始加入深色模式，使用上也比較不會疲勞（OLED 在黑色部分是不發光的）。 刷臉：真的挺方便的，臨時 LINE 的訊息喵一眼就能看到。 三眼神童：很厲害，但沒仔細用的拍照功能，有機會會希望多些嘗試，讓我回到文青的年代（有那個年代過嗎）。 還沒看過的 Apple TV+ 這台也並非沒有缺點，其中 3D Touch 的移除是最難過也是最不爽的，在先前的版本 3D Touch 很適合用來看 LINE 的訊息，而且不會變成已讀的狀態，這就很適合用來看老婆傳來的訊息（x）；現在改了一個爛名字，找個爛藉口來取代本來的優點，更不爽的是 Macbook 的 Touchbar 更沒有用，卻不找個機會將它給移除。 現在只希望 LINE 能夠透過長點擊來開啟訊息，讓訊息不會變成已讀 :(。 另外也由於 Home 鍵的移除，許多操作就與原本略有不同，像是 Apple Pay 的啟用改為右側按鈕點擊兩下，這也讓付款的時候一時不知道怎麼使用，還好店員遇過類似問題立馬解決我的困惑。 目前入手還沒有幾天，加上使用時間並不長，有機會希望可以補上更多的介紹。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：從哪邊學習投資？","slug":"where-to-learn","date":"2019-09-22T16:00:00.000Z","updated":"2019-09-23T08:55:18.947Z","comments":true,"path":"ironman/2019/09/23/where-to-learn/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/23/where-to-learn/","excerpt":"","text":"在開始學習投資以前，我心裡是牴觸的，主要原因是不了解，認為這是高度風險的財富管理方式。身邊也有許多人對於投資不熟也會有這樣的疑惑： 聽說買股票的人都賠錢誒 &gt; 如果都賠錢怎麼會那麼多人投入 是不是要很多錢才能開始學投資啊 &gt; 是投資才有錢，不是有錢才投資 那是內線的人玩的，我們這種局外人玩不起 &gt; 真正好的股票不是少數人決定的 這些疑惑其實是來自於自身恐懼心理造成的，各種優點將會被忽略不見，而將細微的點不斷放大。 正確的投資來說，只要掌握少量的幾檔好投資標的，不斷的長期持有就可以致富，以 GoodInfo 這個網站來說可以填入股票名稱，下方就會列出這張股票 每月、每季、半年、年、三年、十年的成長紀錄，在此可以試著輸入認識的股票名稱，就可以看到這些股票的成長狀態，以近年來大家都認識的台積電來說，三年的成長幅度也有 47% (2019/9/9 的資料)，意指投入 100 萬，三年後如果賣出至少有 147 萬，另外還有每年的股利可領取。 上面僅是列出公開的數據，更重要的是如何選擇一個投資標的，無論選擇的是海內外股票、債券、基金等等，在沒有任何經驗之前，都需要一名導師來帶領我們進入這個領域，選擇導師的重點： 產生連結 選擇導師時，盡可能選擇能與其產生連結的導師，無論是家人、朋友、同事，因為投資過程中是非常漫長的，許多問題都是在操作的過程中才會出現，在遇到問題時能夠詢問「導師」會增加你持有的信心，避免在正確的機會下做出錯誤的操作。 信任 信任再投資中是非常重要的，為何選擇一檔股票都是可以用「信任」這個詞來說明，在與任何導師進行學習時，會有產生不斷的溝通對答，如果你無法信任這名導師的教導，就別繼續與這名導師學習，因為不信任也會使操作投資時的信心動搖，無法具有長期持有的信心，容易在投資目標短期下跌時就出手導致賠錢。 獲利經驗 上方我提出了持有台積電三年可成長 47%，這句話具有很大的錯誤，真正的投資獲利來自於兩個步驟，一是從購買到賣出中間的價差；二則是持有時間的利息。因此，除了股利以外，如果沒有賣出就無法賺到那個 47%，而且大多數人看到股票成長時都會繼續持有，下跌時賣出，許多老鳥也會說到：股票中最困難的判斷是「何時賣出」。所以找的導師不僅要教如何買，更要教你怎麼賣！ 哪邊可以找到投資的導師呢？每個人的背景不同，適合的方式也不同： 工作場所這是我主要學習投資的地方，也很幸運讓我有機會糾正錯誤的財務觀念，當學到一定程度以後，也從中了解到什麼是財富自由，且財富自由並沒有那麼困難。 並非所有的工作環境都會有擅長投資的同事，依據產業的不同，每個工作者所具有的次要幾能也會不同，有些擅長交際、有些則擅長交易。因此要尋找擅長投資的同事，可以從百大企業、金融體系、具規模的傳產、公教體系這些尋找，因為這些員工普遍來說收入穩定 (不太會換工作) 且具有一定資金 (有一定年資)，所以比較會投資股票。 專門的講師去除上面兩種，如果還是無緣接觸，則可以試著去尋找專門的講師，專門的講師具有一定經驗，且會為了課程專門設計教材，在學習上自然會更有成效。但要特別注意，講師相對來說難以產生連結，除了學習外一定要從過程中與人再次產生連結 (講師或其他學員)，這樣在實際操作的過程中才能解除疑惑，更能降低投資失敗的機率 (投資只要降低失敗就能穩定成長)。 家庭如果家族中有人擅長投資，尤其是自己的父母，從他們開始學習最好，因為他們是最能夠直接產生連結與信任的導師。大部分的家庭都是不斷地述說金錢的可惡，但卻沒有教導正確的理財觀念，導致窮不只窮一代，還窮了好幾代，這不僅是物質上的窮，更是心態上的貧窮(因為恐懼而不學習)。 這也是出社會以後的體悟，因此也很欣賞將理財經驗傳授給自己子女的家長，而不是避而不談相關的財務概念。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：充滿未來希望的成長公式","slug":"hope","date":"2019-09-21T16:00:00.000Z","updated":"2019-09-22T08:40:42.452Z","comments":true,"path":"ironman/2019/09/22/hope/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/22/hope/","excerpt":"","text":"當初花了大量的時間不斷充實自己能力，目的就是可以能拿到更好的收入，雖然薪資也如預期的不斷成長，但是心中還是有一個結沒有解開，以台灣來說，每個人退休所需要的資金約是兩千萬，在薪資成長的幅度下，就算不吃不喝達到目標還是非常的困難。 主計處所提供的網站來說，研究所畢業生年收入在 100 萬也算是接近中位數，而 100 萬實際要存下來的錢並不多，以一般大部分人的年支出約落在六十萬的情況下，實際能存下的約四十萬，以不買房地產的情況下至少要存 50 年，更別說要買房或者薪資未達中位數的。 https://earnings.dgbas.gov.tw/experience_sub_01.aspx 而這個問題，在我進入鴻海後有很大的轉變，還記得有一天主管問我，認為要工作到幾歲時退休呢？ 我很天真的回覆：「應該是需要工作到老吧」 他很認真的回覆：「為了錢工作一輩子這個思維是不對的」 也就持續跟我說明理財的重要性，還記得剛開始的前幾年我無法接受他這個思想，認為「不工作就有錢」是有錢人才有可能達到的，而在這個大企業下，可以認識許多對於財務管理有一定掌握的人。因此那幾年，除了眼界有很大的不同外，對於理財的觀念也有很大的增長，也對於這些觀念慢慢有所改觀，也在此學到不同的理財觀念，並整合成屬於自己的投資模式。 透過理財觀念，大幅降低難度以下說明很容易理解的概念，假設我們每年能夠存下的款項是 30 萬，如果持續 20 年不中斷則可以存到 600 萬；但如果透過股票或各種形式的投資 (每年 7% 的成長率)，一樣每年投入 30 萬約 14 年就可以達到 600 萬（到此投入才 420 萬），而 20 年後則有機會可以達到 1200 萬（投入 600 萬），這樣的數值是單純存款的兩倍（注意，這是極度理想化的數值，實際上還是依據每個人的投資選擇而定）。 公式參考：https://docs.google.com/spreadsheets/d/1YosXnSu3nguHuQEpJ9xpdVbD3V1x1pPKFSH37eeSjzM/edit#gid=1444089297 除此之外，如果是每年 7% 的成長率，每七年則會翻倍一次。 意指，上述的資金在 20 年後沒有再持續投入，則會在第 27 年到達 2400 萬（成本依然是 600 萬）。沒有學會投資理財的觀念，很難想像如何存到退休所需要的資金，而且沒有正確的理財觀念，縱使獲得了 2000 萬也很難妥善管理。 而是否是在真的有足夠收入時才思考投資呢？絕對不是，金錢投資是要在平時就要慢慢培養觀念，資金的成長不是立即性的（有，也通常輪不到大部分人），透過平時的累積觀念，才能在機會來臨時正確出手。但大多人會忽略這段期間的理財觀念培養，當有足夠資金時，想嘗試投資時又無法掌握大數字的精準度，也就因此會常聽到新手投入股市失敗，卻又不敢再次投入的故事。 https://github.com/xiaolai/regular-investing-in-box 李孝來：投资，是我能找到的唯一一个普通人可以跨越阶层的通路 跨越階層的方式非常多，創業、中樂頭、理財投資等等方法非常多。撇除中樂透的低機率以外，創業也是一種方式，但創業的成功率極低，根據經濟部中小企業處統計，公司成立一年內倒閉的機率高達 90%，相對來說投資理財是成功率更高的，但並非每個人都有機會可以接觸到合適的理財導師。因此，不斷的學習成長是非常重要的，在增加物質上資產的同時，也增加思維上的資產，讓自己更能接觸到符合自己的理財導師。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：樂觀、悲觀 - 財務的思維改變","slug":"poverty","date":"2019-09-20T16:00:00.000Z","updated":"2019-09-21T06:13:04.234Z","comments":true,"path":"ironman/2019/09/21/poverty/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/21/poverty/","excerpt":"","text":"出社會以前，因為對於市場的不理解，所以有許多「天真」的用詞，也因為這個天真過去還認為自己挺樂觀的，曾經認為窮人與富人差異沒有那麼大，許多故事都告訴我們窮人也能翻身。 但出了社會才瞭解故事只是故事，那並非容易的事情。 小故事： 舉個例子，一個不靠家中努力向上的青年，每天早出晚歸，年收入約落在 120 萬的情況下，除了生活費、卡費、孝親費等每年亦能存下 60 萬（實際上收入越高，支出也會越高），後來看收入不錯就買了台北市一間公寓價值 1500 萬，（貸款 1200 萬情況下，每月約四萬的房貸，每年的支出增加 48 萬），接下來的每年的存款剩餘 12 萬。 而另一位家境小康的朋友雖然不算挺有錢，但家中資助一間台北市公寓，雖不算認真，但吃住都在家中費用省下許多，年收入 80 的情況下，因為沒有孝親費及房貸每年存款依然有 50 萬，加上家中從小就幫小孩存上基金、股票，每年還有十幾萬可領，另外還有持續增加的資產。這樣穩健的基礎下，再不背負房貸的情況下資產輕鬆超越「努力向上的青年」，加上家中持續灌輸基本的理財觀念，所以長期下來也是不愁吃穿。 上述故事可以了解到家庭背景對於新鮮人的影響，更何況出了社會，就要認真面對 “收入” 這個問題，除了要能夠養活當前的自己外，也同時需要為了 “未來“ 以及 ”風險“ 做準備，一個人老年約需要的資金約是兩千萬，而風險更是不確定性，除了自身的風險外，更大一部份來自於長輩的風險（年紀大自然容易遇到不確定性的意外），這些風險可能會讓我們短時間內沒有收入，並且面臨許多親情與現時兩難的問題。 從自以為的樂觀到悲觀問題不斷的湧出後，每天都在思考該怎麼面對這些困境，每當越思考就會越難過、越悲觀，這是一面難以跨越的牆，並非無法做到，只是一時找不到解法，卻不曉得這個問題讓曾經自以為樂觀的自己，慢慢的散佈出悲傷的情緒到周圍的人身上，直到有人對我說到：「我認為你挺悲觀的」，才真正地認清這樣的思維對自己的打擊有多大。 貧窮分為兩個層面，一個是物質上的貧窮，另一個則是思維上的貧窮，我們大多數被物質上的貧窮限制了思維的成長，所以有句話說「貧窮限制了你的想像」，負面、悲觀的思維也是如此。因此，要達到物質的富有，也需要先讓思維富有才行。 重新振奮思而不做是沒有任何幫助的，出社會的第二年以後我投入許多技職上的改變，目的是消除這些恐懼，另一方面則試著去面對這些問題。到了現在，透過學習讓有機會進入更好的環境，更高的薪水、更優秀的人才、更豐富的環境，也因此慢慢改變我原有的想法，更知道如何改善自己及未來的生活。 接下來幾篇會寫到關於財務觀念的改變，這些觀念讓我重新規劃我的人生，並深切地相信我的女兒可以過得比我更富有。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：改變思維的三個重要技能","slug":"three-skills","date":"2019-09-19T16:00:00.000Z","updated":"2019-09-20T05:45:45.783Z","comments":true,"path":"ironman/2019/09/20/three-skills/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/20/three-skills/","excerpt":"","text":"當掌握第二個技能以後，視野自然也會更為開闊，出社會陸續掌握的技能不少，雖不一定到精通，但有些技能帶給我許多思維上的衝擊，讓我不得不思考過去的觀念是否需要調整，也慢慢地了解到為什麼能力越強的人會更為謙卑。 出社會後主要改變思維的三個技能為： 程式 理財 行銷 程式語言雖然在學生時代就開始慢慢接觸程式語言，但真正認識則是出社會以後，程式語言真正教給我的並不是單純一個技能，它同時能夠影響工作效率及思考能力，並且因為這是趨勢，它同時會帶來更為主流的工作型態及思維。以下大致列出對於我的改變： 掌握趨勢：軟體開發是趨勢，而我的切入點是前端開發，前端開發的崛起與目前的行動裝置有很大的關聯性，也因此更需要了解目前行動裝置的趨勢。~所以，買新手機絕對可以說是為了工作。~ 高速學習的技能：現在的程式語言淘汰更快，尤其是前端，因此不斷學習是必備條件，也因此開發者的學習速度相對來說是更快的。 持續學習：同上，因為我們知道技術有可能被淘汰，所以自然養成持續學習的習慣，長期下來我們更能避免在社會上被淘汰。 自動流程：軟體開發者大多都很懶惰，步驟能越少越好，如果是同一件事情需要無腦的反覆執行時，開發者就會將它給自動化，藉此能夠釋放出更多的時間，做更有價值的事情。 工作模組化：開發中很重視相同的程式碼 “不要” 寫兩次，因此會習慣將類似的片段給模組化，這對於工作管理及效率有很大的幫助。 更能掌握價值的核心：作為開發者，工作很容易就進入核心（當沒有工程師時，也代表產品無法完成），很容易清楚自己的定位，也能夠從中獲得許多成就感（~不過也容易從中迷失~）。 邏輯能力：開發的過程中自然會不斷的訓練邏輯能力，這會讓理解事情的速度加快，並且與不同領域之間具有更有效率的溝通（無法溝通的人也就無需溝通）。 分享：能夠獨佔就代表自己優於其他人，這是許多傳統技能的邏輯，但在軟體開發上不一定是好事，許多企業也慢慢將專有技術開源化，因此「開源已是常態，分享更能造福更多人」（包括未來的自己）正是軟體開發的生態。 社群：由於新技術不斷出現，自學的速度有限，必須透過各種形式來加快「認識新技術」，而社群也因此孕育而生，率先掌握技能者可以從分享加強對新技能的概念，而後進者也能從中認識新的技能，開發者們也能透過社群增加彼此的連結，形成互助的環境。 在這個社會上，更能看到許多具有軟體技能的成功者，無論是在原有或另一個領域都能有不錯的表現。 理財對於財務方面長期沒有安全感，不僅是對於當下，更對未來感到無力，而在鴻海工作的那幾年與同事之間學習與討論許多相關的觀念，並且糾正長期對於理財的錯誤觀念，也讓我從對於財務沒有安全感並漸漸地對於此充滿希望。 本系列文章會有許多關於理財的主題介紹，讓大家慢慢地了解為何我會從缺乏安全感到對未來感到希望（絕對可以開場就讓大部分人感到絕望），相關內容會有大量的篇幅作介紹，在此就不多述。 行銷這段標題是 “行銷”，更精確地來說是 Growth Hacker。開發、設計的過程中都是用 “我” 的思維在執行，例如： 我認為這個色彩比較好 我認為流程應該是這樣 我認為用戶喜歡這樣做 我認為 XX 廠商這麼做廣告效果不會好 我認為主管的意見不專業 我覺得老闆這麼做一定會虧錢 我覺得工程師沒有站在用戶端的思維 我覺得賈伯斯在世一定會這麼想 強者我朋友的意見是 … … 這樣的思維具有強烈的自我意識，這些意見容易造成與其他人的衝突，更重要的是 無法證明是否正確。以 UX 來說，我們都清楚站在用戶端思考是正確的，但如何真正的站在用戶端呢？難道是去詢問用戶？（透過直接詢問時，此流程已經有所預期性，參考性將大幅降低） 幾年前接觸到 Growth Hacker 時，慢慢地了解到大多數人所認為的與用戶具有非常大的差異，因為我們的生活環境不同，無法真正認識其他背景的人們，所以許多猜想都是無意義且錯誤的，更有效的方式是直接透過數據來分析用戶行為，透過學習這個技能也知道自己的思維不代表他人，也知曉應從另一個觀點觀察這個社會。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：放棄十年本科經歷，投入網頁開發領域","slug":"became-a-webdesigner","date":"2019-09-18T16:00:00.000Z","updated":"2019-09-19T07:25:20.266Z","comments":true,"path":"ironman/2019/09/19/became-a-webdesigner/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/19/became-a-webdesigner/","excerpt":"","text":"當完兵投入社會的時候，家裡也剛好出了些事情，心中最大的希望就是找份工作。當時，Flash 因為 iPhone 的出現而沒落，所以當下選擇可以是回到設計的本業、網頁設計師或者是繼續找 Flash 工作試試看（沒落，但它還是存在的）。 而無論哪一種，其實我當下的選擇是 “看哪個薪水多，就選哪個！”；打開求職網站後「設計的工作基本上可以移除了」，普遍的薪資是低於網頁設計、Flash 的工作，所以就以網頁設計師、Flash 的選擇為主。 我投的履歷並不多，可是有投的履歷只要有回應，基本上都是錄取的，主要是在研究所的 Flash 作品非常搶眼，加上學歷及經歷（得獎）的優勢，面試上很容易就能打動人，其中一間主要製作 Flash 教學的公司也坦言：「如果到他們公司，很快就能升上主管」。但也是考慮長久的發展性，我又再次放棄修練許久的專長，投入另一個不熟悉的領域。 除此之外，雖然我是台北人，但後來都在高雄工作，許多人會因此詢問為何在高雄工作？而不是在機會豐富的台北，相關的內容將會有獨立篇幅作介紹。 放棄原有技能，有時能獲得更多進入第一間公司是以接案為主，起初壓力挺大的，原因在於我是使用平面設計觀念在製作網頁設計，主管並不滿意我的設計作品，但由於主管並未具有設計背景，所以給予的建議也不一定能精準到重點： 我覺得你的顏色這樣不行 你不能用平面設計的思維做網頁 你可以多參考前輩們的作品 就這樣反反覆覆也花了不少時間摸索什麼是 “網頁設計”，幾周的時間下來也好不容易交出勉強被接受的作品，但也深知自己能力上的不足。 後來自己當老闆，在給予新進的平面設計師員工建議時，也一直會想到這段過去，但也好在自己是設計底，給予的建議也能夠更精確 接下來空閒的時間就不斷投入網頁設計的研究，會去不斷的翻找當時主流的開發模式，如： 響應式網頁 → 行動版剛開始盛行，由於是屬於新技術，投入後就是跟著浪頭走，許多優勢很明顯。但也由於是新技術，所有的觀念都要自己想辦法摸索。 文字編輯器 → 當時公司是 Dreamweaver 為主，後來改用 Sublime Text 戒除所見即所得的開發模式（WYSIWYG）。 Sass → 一開始我還以為是一種軟體，可以直接外掛於 Dreamweaver 或其它文字編輯器下，研究後才知道需要 Ruby 環境。 CSS3 → 雖然當時 CSS3 並沒有被許多瀏覽器所支援，但提前掌握這些技術在往後可被支援時，可以優先並精準的使用在網頁上。 社群是什麼？不斷的尋找新的技術、資源，自然也會搜尋到相關的資源，當時洧杰正好創立「高雄前端社群」，好奇心的驅使下也就去參加了，也由於「前端」這個技術正在發展中，也會思考如何強迫自己加快成長速度，當下決定站上講台與他人介紹來加速成長，因此與 洧杰 毛吹自薦介紹幾場不同的技術，這帶給我了： 更快速的成長 除了學一次，還要懂的如何介紹 認識許多比我更厲害的人 知道自己還有哪些需要進步 我也不是擅長在講台上分享的人，一開始很會很緊張面對數十人介紹一個主題，不過當時的想法是「提早犯錯總比未來犯錯成本更低」，透過幾次的介紹也會越來越熟悉該如何面對多人的舞台，其實也不會有人在意犯的哪幾個小錯誤，也因此認識許多前端的高手，讓自己接下來遇到問題也能有人可以討論。 鐵人的開始接下來，除了在台上介紹技術外，我更希望能有平時的學習計畫，如果希望一個持續性目標可以達成，就試著與周遭朋友或更多人說（立下 flag），因此我立下一個百日貼文的 flag，也順勢的被洧杰推坑參加了 IT 邦幫忙的鐵人賽，至今還是維持每年有 30 天的學習習慣…。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：初入程式語言，沒想到是 JavaScript 的親戚啊","slug":"start-to-learn-program","date":"2019-09-17T16:00:00.000Z","updated":"2019-09-18T08:07:52.662Z","comments":true,"path":"ironman/2019/09/18/start-to-learn-program/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/18/start-to-learn-program/","excerpt":"","text":"由於家境的關係，對於金錢一直都沒有安全感，雖然視覺設計、繪畫等等是興趣，但很清楚趨勢不是如此，研究所期間可感受到：「平面設計是夕陽產業，網頁等多媒體會是趨勢」。許多面向都証明如此，如果對金錢沒有安全感，就勢必需要做一些改變。 當時，網路上很紅的技術是 Flash，臉書在台灣也才剛崛起，那時候大家最常玩的遊戲就是開心農場，開心農場就是 Flash 的遊戲之一。而 Flash 當時是搭配 ActionScript 3.0 （簡稱 AS），這也是基於 ECMAScript 規範開發的語言，因此與 JavaScript 本是同根生，當時我也不會任何的程式語言，只是想著：「我要是可以做出類似的遊戲，相信以後會有更好的收入」，運氣也是挺好的，在當時都不懂的情況下居然選到目前主流的 ECMAScript 的同規範語言。 接下來為了一股腦的投入學習 AS 之中，為了可以全心全意學習該語言，當時也跟指導教授請求說希望以此做遊戲（藝術學院說要寫程式做論文的概念），搭配著經過 “設計” 的圖像，硬是在最後一年的期間做出一款小遊戲。 遊戲畫面的一景，目前遊戲忘記丟在哪了（遮臉），要是當年就認識 Github 有多好。 學習的經驗分享在一開始也是抱著天真的想法：「什麼程式語言的，了不起一個多月我就能學會」，預估學習程式及撰寫的時間也沒有很長，但實際上我學到差點放棄想休學 :(，這段我們就放到後面再說。 以學生來說，最便宜的學習方式莫過於買書，那時買了數本 AS 的書籍，包含： 基礎教學 字典類型的 AS 書籍 特效範例等等 如果從零開始學來說，基礎教學是最有效果的，因為可以從中瞭解程式碼運作的概念，記得很清楚當時為了搞清楚什麼是 var a = 1; 這句話其實就花了不少時間，更別說後來還要練習寫陣列、函式等等（其實我到作品完成後，還是沒有搞懂什麼是陣列）。所以在初學的時候最重要的是從範例中獲得一些些成就，別急著了解整個來龍去脈的觀念，讓它動起來再來思考細節。 字典類型的書籍是次要的，因為當時的文字編輯器（也就是 Flash 本身）的提示並不完整，所以當有語法上的需求時都是直接從字典中查找。最少用到的書籍則是範例特效，這些酷炫的效果並不一定適合放在作品內。 放棄的心態確實，我也是曾經想放棄這條路，學生時代缺錢加上獨立學習上的挫折感，在資源匱乏的情況下不知道可以從哪詢問，且日子一天一天過去，作品離完成還有很大一條路，也曾經跟家裡提到：「想要放棄研究所的學歷」。家裡的人後來也說給一些錢來讓我完成這個學業（後來我沒有拿），希望我可以再撐下去，也因為那多一點點的堅持，讓現在有機會可以投入前端開發這條路。 影響後來出社會的時候，拖賈伯斯的福 Flash 瞬間沒落，學了許久的 AS 馬上就派不上用場（雖然拿著個作品去面試時，基本上是不會被打槍的）。不過一個沒落也意味著另一個崛起，此時前端開發是正流行起來的時間點（預先準備，機會才會有可能來臨），也正好 AS 與 JS 本是一家親，所以再轉學習時的成本是比較低的。 除此之外，雖然早期資源沒有現在那麼多，那麼也會相對越早投入的人，越容易取得領先優勢並搶得先機；而現在的資源豐富讓更多人可以快速掌握技術，讓這些技術也並非只有少數人所掌握，大家不斷的成長情況下，業界審視這些人才時的標準自然會提高。以 JS 來說，過去僅需要掌握 jQuery 就足夠了，但現在除了函式庫、框架需要有基本的了解外，對於 JS 核心運作也需要有一定的掌握度。因此無論過去與現在，其實學習都需要花上大量的時間與精力，只是前者著重於探索，後者更需要專精。 雖然我花了一年左右的時間從無到有學會了 AS，在還沒派上用場的時他就已經沒落，但可以證明的是「學習」本身就是讓自己更容易接近機會的方法，我們無法確認學習到的技術是一定可以當下派上用場，但學習是可以不斷累積，並且造成良性的結果。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：從設計轉開發者的思維改變","slug":"design-to-developer","date":"2019-09-16T16:00:00.000Z","updated":"2019-09-17T06:04:24.097Z","comments":true,"path":"ironman/2019/09/17/design-to-developer/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/17/design-to-developer/","excerpt":"","text":"在學期間我的主力是「美術及平面設計」，從國中開始一直到研究所都是屬於相關領域，軟體開發是一個很大的轉變，這個轉變不僅影響我的生活更影響我的思維。也因為如此，我會向許多設計師推薦學習軟體開發， 設計小時候很喜歡看動漫，也因此認為自己喜歡畫畫，家中也認為我應該對此是有興趣的（我也真切的這麼認為），後來從國中在美術才藝班（算補習班吧!?）&gt; 復興商工美工科 &gt; 台南大學美術系 &gt; 高雄師範大學 視覺設計研究所 都是屬於美術、設計相關體系。 而學習的過程中，才慢慢的發掘自己比較想要什麼，但這個路程也是非常漫長的。以復興後期來說，認為自己對於美術的喜愛度或許沒那麼高，更希望能夠做出具有「價值」的作品，所以在高三時就選擇「視覺傳達組」，希望自己的作品並非只有用在升學或是自己觀賞，而是真正的可以賺錢。當然，以高職那時候還是太嫩惹，但至少已經慢慢往「價值」這個目標邁進。 當時那組不僅是全校分組第一，也是當時代表學校參與新一代設計展的組別，而新一代設計展是大學設計科系為主的展覽，高職當時僅有復興參加。 升大學時，因為高職功課普遍都很爛，我還是其中更爛的那種，所以重考了一年多，拼了命考上了公立台南大學美術系。美術系前幾年還是乖乖地畫畫，只不過會接些案子以及參加競賽來當生活費，在大四的時候，半學期的獎金加上案子的費用約有 15 萬～ 18 萬(實際數值忘記了)，那時候也是可以完全靠自己的方式賺錢，而主力就是在高職打好的設計底。 當時參加競賽都是有技巧的，用特定的風格就很容易得獎（水墨 + 向量風格，可參考北京奧運的設計），當時還有得過「高雄世運會 Logo 徵選」優選，也是用此方式得獎。 大學時轉到了高雄師範大學，案源及獎金沒有像過去那麼的高，當時也會思考「我接下來真的是要當設計師嗎？」，也會因此不斷的搜尋關於設計師的工作想像。而我的專長是平面設計，當時會認為平面設計的限制很大，設計本質就是傳達，而平面的傳達是受到限制的（當然也有屬於它的優勢）；相對於平面設計來說，多媒體網頁的傳達力更強，因此就開始了 ECMAScript 的學習之旅!?（這段故事在後面會另外補完）。 另外，近幾年我也不斷審思設計的價值是什麼？ 來自於案主或老闆的費用？ 比賽得獎的獎金？（我認為設計系學生真的是很好賺，又直接） 設計因為曝光而有價值？ （設計費其中一種計價模式是用印刷品數量計算） 還是設計可以為產品曝光加分？ 這個答案，一直到出社會後我才能慢慢體會，尤其是將許多技能整合後才能更清楚什麼是「設計的價值」。 從設計轉工程師在學期間無論是高職、大學、研究所我們都是獨立學習，美術設計的體系下，每個人都是獨立的個體，很少有經驗分享或技術分享的思維，而為什麼會有這個現象我認為是： 台灣設計領域的封閉：老師、業界、評審者都是固定的一群人，導致整個生態與思維是封閉的。 技術很固定：掌握工具後剩下的就是個人的美感培養，所以不太需要類似開發者的成長社群 每個人都是競爭的心態：案子、薪水要比別人多，就是要證明比別人強 不久前遇到了一個文化工作人士，也指出了藝術領域一個很大的問題點：「藝術領域的人都是個人主義，不太會有分享及社群的概念。」在美術設計長期的訓練下，自然也會有很強烈的自我主義，所以接觸到軟體領域後會發現這個環境與過去有很大的不同，奉獻的能量更有助於自我發展（鐵人賽也是一個例子）。除此之外，軟體開發者在成長的過程中，也會不斷的創造出更多社群，如：前後端開發者社群、行銷社群、創業家社群，這些群體中都很容易找到開發者們。 長期下來思維也慢慢的從全部自己來（過去，我是盡可能不使用任何圖庫、圖示或第三方的資源），慢慢轉變為分享、共享、共有的思維模式，不僅更有效率也更能接近價值的核心。","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：你的願景是什麼？","slug":"what-is-your-vision","date":"2019-09-15T16:00:00.000Z","updated":"2019-09-16T07:01:51.974Z","comments":true,"path":"ironman/2019/09/16/what-is-your-vision/","link":"","permalink":"https://wcc723.github.io/ironman/2019/09/16/what-is-your-vision/","excerpt":"","text":"當兵的後期，有一位和我很好的義務役也即將退伍，他在退伍的時候發表感謝內容表示：「特別感謝我給他的希望的感覺」，平常的時候我常會找他閒聊，也許是談話的內容讓他更具有信心，也讓他想要去追求屬於自己的夢想（印象中是機場塔台相關的工作）。現在想起，也許是那時比較天真吧，認為什麼事情拼一下就有機會了。 天真的夢想與真誠的願景小時候各位應該都有自己的夢想，當超人、當總統、假面騎士、鋼彈駕駛員等等，但到了成年以後我們了解這些是有困難的（或者不可能!?），在這樣的情況下，是否還有夢想呢？還是夢想只存在天真的情況下才能擁有？ 在「你怎麼看待時間，決定你成為哪種人」這本書提到(精簡版：https://www.youtube.com/watch?v=pI0O_Oepay4)，目標是短期的，而願景是長期的，成功人士及企業都會擁有願景，並且以這個願景為使命來訂定目標，在訂定願景時和小時候的夢想來說都是接近遙不可及的目標(在怎麼說，小時候的我也是真誠地相信能夠成為假面騎士呢！)。 離開學校從軍中退伍，並進入社會職場的那幾年，過得並不是很如意，學貸、低薪、家庭不如意等種種的壓力不斷的接連而來，這些不愉快的情緒逐漸的影響生活，當時還真正能體會到無知就是一種幸福，承擔則是一種壓力，對於自己的過去具有許多不滿卻又無能為力。當然，這種情緒對於生活是會產生負面的影響，因此立下一個短期的願景「35 歲要過著讓人羨慕，而不是我忌妒人的生活」(說實話，當時看著許多富二代的生活真的很讓我忌妒)，而這個願景也深深的改變我接下來的生活。 今年過了 35 歲有了些許的成就，或許不一定讓所有人羨慕，但至少我不再忌妒他人的生活，並且很喜歡現在的自己(就以被討厭的「被討厭的勇氣」一書所提到，至少我已經達到滿意的階段，羨不羨慕我則是他人的課題)。這段時間也忙於小孩的出生、新課程的準備、公司的營運讓我沒有再去思考接下來的願景，這樣的日子過了一段時間，心靈上看似清閒卻又有些空虛，就好像是遊戲中拿到最想要的神裝，滿足的情緒下卻帶有一些空虛，主要原因是沒有訂定接下來的願景，讓自己似乎不斷的完成短期目標，卻不清楚自己該面向何處。而願景應該是難以達到的目標，而當初雖然我是設立難以達到的目標，但是具有一個時間點，所以時間後該願景也會結束。 接下來而在最近看到 洧杰 螢幕上的願景（他將願景直接秀在瀏覽器的新頁面上），第一個是「改善台灣的軟體就業環境」，第二則是「和太太長命百歲」。當下立刻思考到那我的呢？自從 35 歲的門檻度過之後，一時還想不到接下來的願景是什麼。 目前的工作是六角學院負責人，除了在公司內部打雜以外，更重要的是輔導學員們從零開始慢慢投入網頁開發的未來，剛開始的目標是教導學生掌握一個特定技能，隨著時間的累積越來越多的學員不僅掌握關鍵技能，還從這些技能轉職成功。從一開始大多成功投入的學員都是具有基本的背景，而許多非本科的學員對自己並沒有任何信心，但現在很多案例是從 0 開始學習並完成所有挑戰進入前端領域。 讓許多人成功邁向自己的目標時，也發現自己並非僅是傳遞一項技能的講師，而是輔導他們邁向自己目標的導師。因此，現在想回到以前過去的思維，相信這個世界並沒有那麼困難，像讓同儕士兵退伍後去追求自己目標一樣，慢慢引導更多人迎向自己的目標。 接下來我也會有兩個願景，一個請讓我作為秘密為家人付出，另一個將會是希望「讓更多人充滿希望，並真誠地相信自己能夠達到目標」 強化身心，破除無意義的恐懼 讓人了解如何安排挑戰計畫 協助最後的一哩路，讓他們找到對的人 身體力行，自己也要一同成長 真心期望大家都發大財 而這一系列文章也將會分享我的成長經歷，以及許多成長過程中的思維改變，經歷過小公司、百大企業員工並成為老闆的各種體驗分享，從一個不可能更差的人生，到改變思維看到各種希望的過程!?","categories":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/categories/ironman/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"自建 Name Server","slug":"custom_name_server","date":"2019-04-24T16:00:00.000Z","updated":"2019-04-24T07:13:59.984Z","comments":true,"path":"dns/2019/04/25/custom_name_server/","link":"","permalink":"https://wcc723.github.io/dns/2019/04/25/custom_name_server/","excerpt":"","text":"本篇教學是延續「大神來六角」的 “網址管理與 DNS 託管全攻略”，目的是讓參與的學員更了解 DNS 在轉址的過程觀念。 對於 Name Serve 的概念可以參考 AWS 提供的架構圖： 擁有一個網域後，只要網域的供應商可以設定 NS Record，都可以用來自行建立 Name Server，並且可以自行代管該網域下的所有子網域。 本篇中的環境在教學結束後被釋放，所以無法再次連接。 參考文章： http://linux.vbird.org/linux_server/0350dns.php#DNS_Zones https://eric0806.blogspot.com/2014/06/ubuntu-bind9-dns-server.html 建立環境 購買一個網域，並且該網域可以自訂 NameServer 的 本次服務購買 GoDaddy 準備一台主機，本次使用 Digital Ocean 的 Ubuntu 16 上層 Name Server 設定首先，必須先將給予自訂的 Name Server 一個網址，如果僅有 IP 的情況下將無法自訂 Name Server，在此先給予我的主機 dns 這個名稱： 接下來將 customdns 這個名稱交給予 dns.casper.tw 這個 Name Server 代管，因此： dns.casper.tw 這是 Name Server 主機 customdns.casper.tw 這是 Name Server 主機所代管的網域，接下來可以自訂 .customdns.casper.tw 的網址在這個網域下。 Name Server 設定在此，會使用 Bind 這一個 Name Server 工具，本工具有許多觀念需要理解，會在接下來的流程中一一的說明： 安裝 Bind 工具：1sudo apt-get install bind9 bind9-doc dnsutils 安裝完成後進入 /etc/bind 的套件下，輸入 ll 可以看到以下的資料結構： 1$ ll 主要調整檔案： named.conf.options：主要的 DNS 工具的選項。 named.conf.local：設定管理的 IP、正反解的對應檔案路徑、次要 Name Server 的設定等等。 自訂檔案： /zones/.tw 正解檔 /zones/ 反解檔 其它 /etc/default/bind9：修正 ipv4、ipv6 的問題 Bind 設定檔撰寫的過程中，會不斷的重啟、除錯，以下列出重要的語法： /etc/init.d/bind9 restart：重啟。 /etc/init.d/bind9 status：目前機器的狀態，必須要調整到沒有錯誤訊息為止。 設定 named.conf.options透過編輯器設定 named.conf.options，這是 bind 工具的主要項目，按照預設也不會有太大關係，但本次是以 ipv4 為主，所以 v6 的功能可以先關閉，另外 Name Server 預設是 53 port，當上層網域指定過來後就會自動用 53 的接口，所以不要隨意調整。 1234567891011121314acl intra &#123; xx.xx.xx.xx; &#125;;// 自訂義變數 intra，可查詢的 DNS 主機，不設定也沒關係options &#123; directory &quot;/var/cache/bind&quot;; dnssec-validation auto; auth-nxdomain no; # conform to RFC1035 listen-on port 53 &#123; any; &#125;; allow-query &#123; any; &#125;; allow-query-cache &#123; none; &#125;; recursion no; // allow-recursion &#123; intra; &#125;; also-notify &#123; &#125;;&#125;; 設定 named.conf.local這是與配置檔案連接的檔案，算是主要的進入點，透過這個檔案與正解、反解配置檔案產生關聯。 另外 Name Server 可以設定超過一台主要的為 Master，其它次要的為 Slave，在這個範例中僅設定一個主要，實作中會建議另外設定 Slave，避免主要的機器無法連接導致所有網址失聯。 123456789101112131415161718192021222324acl allow-trans-ip &#123; 138.68.229.69; &#125;;// 定義允許取得配置的 ip ，如果有多個 ip 可以使用分號隔開// --- 正解的區域 ---// 定義掌管的 Domainzone \"customdns.casper.tw\" &#123; type master; // 定義 master 或 slave file \"/etc/bind/zones/customdns.casper.tw.fwd\"; // 自訂義正解檔案的路徑，名稱可自訂 // 定義可以從主要機器取得配置的 ip，在此不設定也沒關係，但實作中建議加上 allow-transfer &#123; allow-trans-ip; // 上方定義的變數 &#125;;&#125; // --- 反解的區域 ---zone \"229.68.138.in-addr.arpa\" &#123; type master; // 對應 master file \"/etc/bind/zones/138.68.229.rev\"; // 反解配置檔案路徑 allow-transfer &#123; allow-trans-ip; &#125;; // 同上&#125;;// 反解命名規則：// ip 假設為 138.68.229.69// 反解應設定為 229.68.138.in-addr.arpa 設定正反解配置檔案上方定義了 named.conf.local，其中又連向兩個配置檔案，分別為： /etc/bind/zones/customdns.casper.tw.fwd 正解 /etc/bind/zones/138.68.229.rev 反解 而這兩個檔案名稱是可以自訂的，在此僅是依據所管理的網域及反解路徑命名，首先設定 customdns.casper.tw.fwd 正解檔案： 1234567891011121314$TTL 120;@ IN SOA customdns.casper.tw. xxx.gmail.com. ( 2014062007; 600; 900; 86400; 120);;@ IN NS dns.casper.tw.;dns.casper.tw. IN A 165.22.129.123;www.customdns.casper.tw. IN A 138.68.229.69; 分別說明以上檔案分別包含什麼內容： 定義 TTL 變數，單位是 “秒”，時間越短用戶就需要更頻繁的詢問 定義 SOA，SOA 算是 Name Server 的申明檔案，其中也包含該伺服器的管理者聯絡方式： customdns.casper.tw. Master DNS 伺服器主機名稱，後方的 . 是不能省略的 xxx.gmail.com. 負責該網域的聯絡人，gmail 前方的 @ 被轉為 . 2014062007 序號 (Serial)，在此可以思考為版本號，slave 用此來判斷 master 是否有更新 600 slave 的更新頻率 900 當 Slave 連線失敗重新嘗試時間 (Retry) 86400失效時間 (Expire)，當 Slave 重新連線到達多少時間會停止嘗試，屆時需要管理員處理。 120 TTL 預設時間 定義 Name Server NS：Name Server 縮寫 dns.casper.tw. Name Server 位置 定義 Record 參數 www.customdns.casper.tw. 自訂義網址 138.68.229.69 對應 ip 反解：一般網域查詢時是由右至左，如：.root &gt; .tw &gt; .casper &gt; .dns，而 ip 的運作是相反的，上述的 ip 中在運作時方向為 138 &gt; 68 &gt; 229 &gt; 69，用來從 ip 反向查詢到主機名稱。 定義反解檔案 138.68.229.rev，反解檔案的 SOA 與正解檔一致，不同的是 Record 內容：1234567891011121314$TTL 3600;@ IN SOA customdns.casper.tw. agito723.gmail.com. ( 2014062007; 600; 900; 86400; 120);@ IN NS dns.casper.tw.;123.129.22.165.in-addr.arpa. IN PTR dns.casper.tw. ;69 IN PTR www.customdns.casper.tw. ; 反解檔案與正解檔案設定差異不大，規則上定義為 PTR(反解 Record)，並且在 ip 需要使用反解的規則撰寫。到這個步驟基本上就算完成了，接下來就是進入測試、重啟與除錯。 重啟及除錯接下來，輸入 /etc/init.d/bind9 restart 就可以重啟測試，重啟後建議再輸入 /etc/init.d/bind9 status 來除錯，以下列出常見的錯誤： 遇到的問題： network unreachable resolving1network unreachable resolving &apos;ns39.domaincontrol.com/AAAA/IN&apos;: 2001:503:d414::30#53 解法：123456#編輯 /etc/default/bind9gedit /etc/default/bind9# 如下，加上 -4# startup options for the serverOPTIONS=&quot;-4 -u bind&quot; bad dotted quad設定檔中包含了不正常的空格，這些空格有可能在分號後方，可依據錯誤訊息尋找是否有多餘的空格。 正常的 status 運作應會出現以下訊息，並且沒有任何的紅色文字： Name Server 開張如果沒有任何錯誤，正常來說就能直接連線至你的網址。接下來再透過 dig +trace { 網址 } 也能看到自建的 Name Server 相關訊息。","categories":[{"name":"dns","slug":"dns","permalink":"https://wcc723.github.io/categories/dns/"}],"tags":[{"name":"dns","slug":"dns","permalink":"https://wcc723.github.io/tags/dns/"}]},{"title":"免費申請屬於自己的 SSL 憑證(手把手帶你加上 https 綠色鎖頭)","slug":"free-ssl","date":"2019-04-23T16:00:00.000Z","updated":"2019-04-24T06:31:44.889Z","comments":true,"path":"ssl/2019/04/24/free-ssl/","link":"","permalink":"https://wcc723.github.io/ssl/2019/04/24/free-ssl/","excerpt":"","text":"SSL For Free為了讓更多網站可以加上綠鎖頭(https)，並且提高網路的安全性，此服務免費提供網站 SSL 憑證，同時憑證不僅是免費的，還是屬於萬用憑證（包含所有子網域），雖然每次的憑證效期僅有三個月，但可以不斷的續約，對於每年需花個幾千、幾萬才能購買一個萬用憑證來說，算是節省不少。本篇將會一步一步介紹如何申請到此憑證。 開發環境說明： 主機 Digital Ocean：Ubuntu 16 後端語言：Node.js 另外，憑證的金鑰綁定是由開發者來完成，但這個服務是直接在網站上完成，開發者僅需要直接下載做好的憑證即可。 申請憑證透過以下網站申請：SSL For Free ，直接輸入要申請的網域即可。 申請後，他會要求認證網域是否由申請者管理，接下來會有以下的認證步驟(三選一)： 透過 FTP 上傳驗證檔 手動上傳驗證，本教學會使用此流程，順便說明一些細項 DNS 驗證，這是最簡單的流程，直接在 DNS TXT Record 補上驗證訊息即可 手動驗證流程選擇手動驗證會出現以下流程說明，接下來在我們的 Ubuntu 伺服器端先安裝好 node.js 及 express 環境後繼續以下動作。 開啟 express 框架中的 bin/www 將 port 改為 80 port，並且將 DNS 指向此主機（需與 SSL 申請的網址同一個）。 下載該手動驗證的檔案。 在 public 資料夾下，建立該資料夾 /.well-known/acme-challenge/ 並且把該檔案上傳上去(上傳方式可參考後方說明) 須確保網址上的這個檔案能夠被開啟 上傳驗證檔案的說明：方法 1: 可以直接透過指令上傳驗證檔案，需要在本地端輸入以下指令，並且對應遠端的路徑。1234scp &#123;&#123;檔名&#125;&#125; root@&#123;&#123;主機&#125;&#125;:~&#123;&#123;資料夾路徑&#125;&#125;// 範例：scp xxx root@12.3.45.678:~/website 方法 2: 直接手動新增 vi { 檔名 }，將下載檔案的內容貼入 按下 Download ssl確保上述流程完成後，就可以按下 Download SSL，失敗也會提供訊息，但如果發生錯誤，請重新上述的步驟。 接下來會核發 90 天的憑證，並且已經生成了憑證、私鑰等檔案。接下來下載這些檔案，其中 certificate.crt、private.key 這兩隻需要上傳到 server 上。 express with https步驟 1: 上傳 certificate.crt、private.key 到伺服器上，直接放到專案中方便存取的路徑即可。12scp certificate.crt root@0.0.0.0:~/&#123;&#123; 專案路徑 &#125;&#125;/ssl/scp private.key root@0.0.0.0:~/&#123;&#123; 專案路徑 &#125;&#125;/ssl/ 步驟 2: 透過 npm install https --save 安裝 https 套件步驟 3: 打開 bin/www，並且將檔案修改成以下（後方有完整的程式碼） 12345678910111213141516171819202122var fs = require('fs');var app = require('../app');var debug = require('debug')('website:server');var http = require('http');var https = require('https');/** * Get port from environment and store in Express. */var privateKey = fs.readFileSync(__dirname + '/../ssl/private.key');var certificate = fs.readFileSync(__dirname + '/../ssl/certificate.crt');var credentials = &#123; key: privateKey, cert: certificate &#125;;var port = normalizePort(process.env.PORT || '443');app.set('port', port);/** * Create HTTP server. */var server = https.createServer(credentials, app); 完成後就可以直接連線至該網址，加上憑證後預設也會自動連線至 443 port，所以就可以直接使用當時的網址連線即可。 簽核的認證範例：","categories":[{"name":"ssl","slug":"ssl","permalink":"https://wcc723.github.io/categories/ssl/"}],"tags":[{"name":"ssl","slug":"ssl","permalink":"https://wcc723.github.io/tags/ssl/"}]},{"title":"JavaScript This 系列文：this 為什麼指向 window","slug":"this-why-window","date":"2019-03-20T16:00:00.000Z","updated":"2019-03-21T07:29:48.399Z","comments":true,"path":"javascript/2019/03/21/this-why-window/","link":"","permalink":"https://wcc723.github.io/javascript/2019/03/21/this-why-window/","excerpt":"","text":"本篇是接續先前的：鐵人賽：JavaScript 的 this 到底是誰？，會更深入的探討 JavaScript This 的運作及觀念，這一系列的文章順序上不會從基礎開始介紹，會建議先從先前文章開始閱讀。 純粹的調用 (Simple call)直接呼叫函式的情況下，this 會指向全域，在以下範例中可以取到 name 的值，但一般來說很不推薦這樣的寫法，後面會提到這樣的寫法是怎麼造成的。12345var name = '小明';function callSomeone() &#123; console.log(this.name)&#125;;callSomeone(); // 小明 IIFE、Callback、閉包也屬於此類別嗎？上述的函式只有單一層級，為了加深大家的印象，我們透過各種改變 “函式” 作用域的方式看是否會改變 this 的結果。 IIFE立即函式，這算是直接在函式內直接在呼叫另一個函式，而這個結果下一樣與純粹的呼叫結果相同。1234567var name = '小明';(function() &#123; function callSomeone() &#123; console.log(this.name) &#125;; callSomeone(); // 小明&#125;)(); 無論我們把函式宣告放在 IIFE 內與外結果都是一致的。1234567var name = '小明';function callSomeone() &#123; console.log(this.name)&#125;(function() &#123; callSomeone(); // 小明&#125;)(); Closure這樣結果依然相同，並不會因為獨立的作用域改變造成 this 的不同。123456789101112var name = '小明'function easyCard(base = 100) &#123; var money = base return function(update = 10) &#123; money = money + update console.log(this.name, money) &#125;&#125;var MingEasyCard = easyCard(100)MingEasyCard()// '小明' 110 Callback functioncallback function 也是一樣的結果，透過以上這些範例了解到，並不會因為作用域的改變導致 This 的不同，更重要的還是在於函式是不是與物件有扯上關係，至此為止我們實驗了各種函式呼叫方式，都可以知道函式再直接呼叫的情況下，this 都是指向 window。 12345678function myEasyCard(callback) &#123; var money = 100 return callback(money); // window&#125;myEasyCard(function (money) &#123; console.log(this, money); // window&#125;) 而 callback function 會提到另一個常見的案例，就是陣列相關的處理方式，參考 MDN 的說明 forEach 的結構如下： 123arr.forEach(function callback(currentValue[, index[, array]]) &#123; //your iterator&#125;[, thisArg]); 因此 forEach 中間的 callback 一樣是屬於直接呼叫，所以會 this 會指向 window 物件。 1234var a = [1, 2, 3];a.forEach(function(item) &#123; console.log(this, item)&#125;); 嚴謹模式 觀念說明開始，為什麼 this 會指向 window 物件 這個階段我們加上 &#39;use strict&#39; 則會進入嚴謹模式，接下來直接呼叫的內容都會變成 undefined的奇特景象，可以理解這是為了避免不必要的錯誤提示，在此也建議別透過一般函式呼叫的 this 取用 window。 直接套上嚴謹模式則會出現錯誤範例：123456'use strict'var name = '小明';function callSomeone() &#123; console.log(this); // 這裡改成了 this，因為沒辦法找到 name&#125;callSomeone(); // undefined 而 undefined 與 window 有什麼關係呢？我們可以先介紹另一個觀念 call()，call 是可將物件傳入並替代函式內的 this： 1234567var Ming = &#123; name: '小明'&#125;function callSomeone(num) &#123; console.log(this.name, num);&#125;callSomeone.call(Ming, 2); // 小明, 2 透過 .call(Ming, 2) 的方式，可將 Ming 傳入並取代 this，後面帶上一個參數 2 則是函式的參數。因此 .call() 前者為套用 this 的物件，後者以後都是函式的參數。參考下圖：函式中的 this 為 call() 的第一個值，而函式參數為第二個(包含後續的值)。 接下來我們將 Ming 物件替換，直接定義一個 name 在全域之上，並且傳入 undefined 的值來替代 this，猜猜會發生什麼事!?123456var name = '全域魔王' function callSomeone(num) &#123; console.log(this.name, num);&#125;callSomeone.call(undefined, 2); 此時會發現運作上依然沒有問題，傳入 undefined 進入後 this 會直接指向全域。 這麼神奇的狀態也算是 JavaScript 的 Feature，發生的理由可以參考：MDN 的說明。 MDN：若這個函數是在非嚴苛模式( non-strict mode ),null、undefined將會被置換成全域變數。 因此，上述程式碼在嚴謹模式下將無法正確運行，因為傳入 undefined 時將會正確以 undefined 作運行。同樣概念下，在一般全域環境套用 ‘use strict’ this 作為一般調用時，將會直接套用 undefined 而不會是 window。 而上述程式碼於嚴謹模式下，將會正確的傳入 undefined。 1234567'use strict'var name = '全域魔王' function callSomeone(num) &#123; console.log(this, num);&#125;callSomeone.call(undefined, 2); 接下來，可以將本文的上方的程式碼都加上 &#39;use strict&#39; 都會得到相同的結果，this 都會指向 undefined。 延伸閱讀：This 都是物件前一篇介紹到 「this 大部分取決於 它在哪個物件下被呼叫」，所以其中改變 this 的方法之一則是透過物件下呼叫函式： 1234567891011function callName() &#123; console.log(this.name);&#125;var auntie = &#123; name: '漂亮阿姨', callName: callName // 這裡的 function 指向全域的 callName function&#125;auntie.callName() // '漂亮阿姨'，呼叫是在物件下調用，那麼 this 則是該物件 除此之外，還可以透過本文所介紹的 call 來改變 this 的值，先前範例都是傳入「物件」，此部分我們傳入數值來看看其型別： 12345function callSomeone(num) &#123; console.log(typeof(this), typeof(num));&#125;callSomeone.call(1, 2);// object number 此部分的 this 我們使用數字 1，函式參數使用數字 2，結果會發生 this 的型別變成了 object!? 重新透過 console 查看 this 會得到以下的結果，這是透過建構式產生的數值(new Number(1))，透過 call 所傳入的純值會被使用 new 建構式的方式產生，所以型別依然維持是「物件」（可參考：MDN），因此 this 終究為物件形式。 MDN：原生型態的值將會被封裝","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"JavaScript This 系列文：this 與物件的關係","slug":"JS-THIS","date":"2019-03-17T16:00:00.000Z","updated":"2019-03-18T09:17:50.296Z","comments":true,"path":"javascript/2019/03/18/JS-THIS/","link":"","permalink":"https://wcc723.github.io/javascript/2019/03/18/JS-THIS/","excerpt":"","text":"本篇是接續先前的：鐵人賽：JavaScript 的 this 到底是誰？，會更深入的探討 JavaScript This 的運作及觀念，這一系列的文章順序上不會從基礎開始介紹，會建議先從先前文章開始閱讀。 物件的方法調用 (As an object method)「物件的方法調用」是最常見改變 this 的方法，只要搞懂這一部份就能了解決大部分的 this 運作，大部分的文件介紹此部分說明為：在函式內的 this 值取決於該函式如何被呼叫。而如何被呼叫實在難以被定義，如：callback、閉包、函式內的函式等等其實都與 this 沒有關聯性。 提供另一個比較易懂的中文說明：this 大部分取決於 它在哪個物件下被呼叫，也就是本段落主要介紹的「物件的方法調用」這個觀念佔了 絕大部分 的 JavaScript 實作時的 this 運作（接下來幾篇會陸續介紹其它幾種），版頭圖則是說明這一類型的 This 運作模式，只要找到上層物件就搞定了整個觀念，下述文中產生了一個函式，透過兩個不同的方式取用則有不同的結果： 12345678910111213function callName() &#123; console.log(this.name);&#125;var name = '全域阿婆';var auntie = &#123; name: '漂亮阿姨', callName: callName // 這裡的 function 指向全域的 callName function&#125;callName() // '全域阿婆'auntie.callName() // '漂亮阿姨'，呼叫是在物件下調用，那麼 this 則是該物件 前者是稱為「純粹的呼叫」，此種情況相對單純下個段落會有完整介紹，而另一個物件呼叫 auntie.callName() 則會將 this 指向 “漂亮阿姨”，這個部分相信大家就能有基本的體會，物件下呼叫會影響 this 的指向。 概念如同下圖，在物件下的函式 this 為前者物件。 而 this 這個詞就可以思考成 這一個「物件」，它會隨著在哪一個物件下被調用而影響結果，在此情境下如果有更深層的 this 依然是當下這一個物件。 123456789101112131415function callName() &#123; console.log(this.name);&#125;var auntie = &#123; name: '漂亮阿姨', callName: callName, watch: &#123; name: 'Magic Watch', callName: callName &#125;&#125;auntie.callName() // '漂亮阿姨'auntie.watch.callName() // 'Magic Watch' 在這個概念下，每一層的函式的 this 都是上一層物件，很簡單吧，所以漂亮阿姨下的每一層物件函式 this，都是指向該上層物件。 Vue.js 下的概念使用 Vue.js 時運作的原理就與上述的接近，我們可以看到以下的程式碼運作時，物件第一層的內容均是指向 myCar 這一個物件。 12345678910var myCar = &#123; name: '長大以後要當保時捷', go: function() &#123; console.log(this); &#125;, init: function()&#123; this.go() &#125;&#125;myCar.init() 接下來看一下 Vue.js 的程式碼，你可能會思考這樣的結構比上述的多了一層，理論上 Vue 的 this 的運作會不太一樣才是。 12345678910111213var app = new Vue(&#123; data: &#123; text: '這是一段話' &#125;, methods: &#123; go() &#123; console.log(this.text) // 這是一段話 &#125; &#125;, created() &#123; console.log(this) &#125;&#125;) 不過當 Vue 實際運作時，元件內的物件、函式等等均會被向上拉，methods, computed 等等均不會存在，所以並非以原始碼而是以實際運行的狀態為主，如下圖，methods 內的 go() 及 data 內的 text 均在元件物件頂層。 接下來運行的概念如下，元件下的函式的 this 就會直接指向該元件，所以 go() 這個函式的 this 自然就能夠使用元件內的 text 資料囉。 延伸閱讀：陣列內插入函式在 JS 型別中，陣列也是屬於物件的一種，因此將函式插入陣列之中運行，this 的指向會如何呢？ 一般來說不會有人這樣寫，但我們可以從中獲得相同的結果： 12345function callSomeone() &#123; console.log('this is', this);&#125;var MingFamily = ['小明', '爸', '媽', callSomeone]MingFamily[3]() 同上所述，callSomeone 這一個函式的運作也是接在 MingFamily 陣列後方，所以 this 將會指向 MingFamily 這一個陣列喔！","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"鐵人賽：網頁設計 - 設計的過去、現在、未來","slug":"ironman-final","date":"2018-11-12T16:00:00.000Z","updated":"2018-11-13T07:42:24.579Z","comments":true,"path":"design/2018/11/13/ironman-final/","link":"","permalink":"https://wcc723.github.io/design/2018/11/13/ironman-final/","excerpt":"","text":"「這張圖幫我美工一下」，讓工作中的設計師聽在耳裡非常的不爽，當下正想立即回嘴：「你才美工，你全家都美工！」才發現說話的是老闆。 過去，許多設計師非常討厭這句話，「美工」原意應該為「美術工藝」的縮寫，在此用法則改為「美術工人」、「美術工作」之意，身為具有創意思維的設計師怎能接受這樣的說法。當然，隨著環境的變遷，會這樣說的老闆、同事也就越來越少，與其它領域合作時應互相尊重。 你是美工嗎？「工人」指從事某種職業的勞動者，多指工業生產領域，依靠出賣勞動獲取報酬的人，通常指「體力勞動者」，因為工作內容大多是重複的行為，所以大多數的人只要透過勞動就能勝任。 因此，設計師如果僅透過相同的行為從事設計，打開 Photoshop 用著相同技法、相同的習慣，將業務所需的圖文排列，沒有太大的變化及成長，其實也就與上述的「美工」無異，高度的可替代性，僅需要美術相關學院畢業都可以勝任。因此，設計師與工程師一樣是必須不斷的學習，擴增自己的視野，多了解不同領域之間的協作關係。 未來發展1111 剛過，這個節慶來自於中國的光棍節，現在則是華人電商促銷折扣的日子，每一年的今天「天貓」電商業績都會不斷的創新高，只要一天時間就可以獲得將近一兆的營業額。 這麼大的活動自然需要有大量的廣告及圖片推動產品的銷售，上千億張的廣告圖片等待產出，必然需要大量的人力來處理。但在 2017 年開始，阿里開發了「魯班」智能圖片產生器，收集資料庫內大量圖片素材中並分析其中的裝飾、配色、構圖，並搭配商品素材自動產生廣告圖，透過深度學習的變化下產生的圖片一般用戶是沒有辦法辨別是自動產出的，僅需要將廣告圖所需的圖片、文案加入，並搭配不同風格變化即可，在 2017 年有 1.7 億張廣告圖是由「魯班」產生。 衝擊在先前的文章其實也有不斷提到「設計規範」，規範本身也是限制設計師行為的工具，為了確保設計結果的可行性，但這樣的過程中設計師也慢慢地轉換回使用相同技法、放置圖文的「工人」，從設計師轉換為「繪製流程圖」的員工（工作是將流程圖依據規範排列出來），那麼也意味著這個流程是否在不久後可能會被類似「魯班」的工具所取代呢？ 當然，這個過程不可能太快，畢竟阿里巴巴的開發能夠帶來大量的利益，一般的中小企業不太可能導入人工智能的方式處理，一方面是成本太高，另一方面則是資料量不足。但可以知道的是未來會出現「通用類型」的商用圖文智能工具，專門來處理重複、簡單的行為。 那麼設計師該如何維持自身的價值呢？ 具備意涵的設計能力智能工具可以辨識畫面構圖、素材、色彩等等，但無法辨識圖片是否具有深層內涵，它可快速排列出具有美感、類似風格、多樣變化的圖片，但無法為任何一張圖賦予「意義」。所以設計師只有排的「美」是不足夠的，還必須思考怎樣讓圖片具有「意義」，讓圖片並非只有圖文的訊息傳遞，還需要帶有機械無法呈現的情感。 訓練 AI 的能力由於 AI 是透過大量資料分析做深度學習，因此「資料來源」非常重要，設計師就必須帶領 AI 創新，瞭解如何訓練 AI 並優化其結果。也如同上面所提的文章一樣，設計師的工作將轉為「學習這套系統（魯班），學習如何訓練機器，同時在美學方面做把控」 分析使用者體驗的能力除此之外，設計師也能做橫向的發展，以視覺為基礎研究使用者的行為，藉此優化人或 AI 所沒有涉及的部分。AI 雖然有極高的效率，但畢竟是由現有的資源做分析，也就是當現有資料具有盲點時 AI 不一定能夠修正，此時必須回到人本身具有的彈性思維。 所以接下來大家更不需要擔心被稱為「美工」，因為這類型的工作將被 AI 所取代。反之，設計師應不斷的學習，避免自己只有在重複的行為上工作。 結語這是第五次參加鐵人賽了！先前的鐵人賽都是撰寫技術相關主題，本次是回到設計的內容，其實撰寫的過程中才發現久沒接觸確實生疏了許多，也包含不少設計觀念其實有些修正，必須重新翻閱文件才能了解 orz。 不管如何，這次也是順利完賽，在此也獻給許多想要進步的朋友們，只要挑戰完 30 天該技能就能突飛猛進，寫文章並非是要寫給他人，更重要的是挑戰自我。最後列出本次的所有連結： 網頁設計基本概念 前端「設計」聖光之路 別使用平面繪圖軟體繪製 UI 設計 設計師思維及工程師思維 網頁設計常用格線系統(上) 網頁設計常用格線系統(下) 文件、規範參考 - Material Design 色彩運用 網頁設計色彩配置概念 你的網頁文字是否足夠清楚呢？ 連結的配色 按鈕的配色 字體 系統字體介紹 網路字體運用 文字大小、行高與空間上的關係 圖片 圖片格式的運用 圖片壓縮方法 SVG 輸出注意事項 Icon fonts 的常見資源 響應式圖片選用技巧 版面 版面視覺動線配置(1) 版面視覺動線配置(2) 規範 網頁設計規範 - 參考來源 一致性的距離（計算方法、水平、垂直） 定義不斷出現的網頁元素 通用視覺效果 其它 實際透過工具測量用戶行為 設計師與開發者的溝通工具 設計「參考」資源 設計「素材」資源 平面設計師轉設計前端的經驗分享 設計的過去、現在、未來","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 平面設計師轉設計前端的經驗分享","slug":"design-to-developer","date":"2018-11-11T16:00:00.000Z","updated":"2018-11-12T03:30:19.657Z","comments":true,"path":"design/2018/11/12/design-to-developer/","link":"","permalink":"https://wcc723.github.io/design/2018/11/12/design-to-developer/","excerpt":"","text":"平面設計師轉設計前端的經驗分享一開始的文章有提到，我原本也是從事設計，出社會以後開始轉往開發者。學習到目前也能開發到後端（還不會提到是全端工程師，畢竟術業有專攻），學開發觀念與過去學習設計有非常大的差異，也會不斷地反思過去設計思維的價值。 為何要從設計轉前端？原因很簡單，設計師的薪資普遍低於開發者。這也並非台灣特有現象，而是商業的上設計和開發本質就有很大的不同。設計主要的收入都是以專案為概念，雇主或業主提出一個設計案，設計師來完成它，這個過程中設計師是很難主導商業價值的（但並非沒有，產品設計師、漫畫家、插畫家也有很多成功的案例）；相對的，開發則不僅限於專案，開發者較能夠自行主導屬於自己的商業模式。 在學期間就已經開始轉往開發，雖然是 Flash 不過也對於程式碼有基礎的概念（雖然出社會後 Flash 就死掉了），過程中我所學習的是 ActionScript，這個語法是基於 ECMAScript 的標準開發的，因此與 JavaScript 接近許多，出社會後就持續往前端的路邁進。 這之中學到了什麼？轉往開發者的路上也是跌跌撞撞的，運氣不錯的是那幾年「前端」一詞才剛出現，進步上比較能有成就感（薪資 :D），但相對來說資源就會缺少很多，許多技術在研討會聽過，但是周遭能夠找到可詢問的人幾乎沒有，只能自己上網埋頭研究。 這個過程中，剛好廖洧杰創立了「高雄前端社群」，大家還不熟的情況下，也就硬著頭皮上台介紹了幾次，每次簡報都是先挖坑再跳入研究，反覆幾次以後大家就以為我會的不少，但其實也才剛學而已（遮臉）。因此，從中體驗到了挖坑、分享是加速學習的方式，如果要更快則是要增加頻率，後來自己挑戰了連續 100 篇發文，當時 IThome 鐵人賽也剛好開始，在那之後就陸陸續續參加了好幾屆。 這種學習方式是「設計」領域學不到的，設計領域重視創意、概念、自我，而開發領域重視執行、學習、共享。 學習上的建議由於體驗了兩個不同領域更能了解兩個領域間思維上的差異，同時能使用設計師語言與設計師聊天（你才美工、你全家都美工），也能使用資料邏輯和工程師打屁（幫我從第零個衣櫥裡拿衣服）。這段故事也分享給許多人知道，畢竟很多設計師因為現實的原因想轉行到 UI 或工程師，以下分享一些學習上的概念： 分享，是最佳途徑工程師學習時，會建議不斷的分享過程，這會有助於獲得階段性成就，並且在為了分享的過程中，會將細節觀念看得更透徹並將其轉換成文字，所以自然能夠學得更有效果。 學習並掌握一個技巧需要花上不少時間，過程中的煎熬不一定每個人都能體驗其樂趣，但透過階段性學習的分享，會較容易從中獲得成就感。 另外提到，因為寫了不少文章，每日流量也在千人上下，就順手置入廣告於部落格之中，開始做了廣告版面的一些實驗性功能…（地方開發者需要贊助 :D）。 學習不是一時的在轉行的過程中，總是會想選擇一個一勞永逸地工具或方向，比如說前端框架或語言只想挑一個學習，想使用同一個技術挑戰十幾年，但就目前開發領域的高速成長來說是不太可能的，許多技術出現兩三年則沒落。 可能會去想這樣不斷追新技術不就太累？其實不斷的學習過程中，就會不斷的累積基礎概念，接下來厚實的基礎概念就會有助於學習更新的技術，且不斷學習新技術也是開發者的優點及價值，讓開發者更容易適應新事物及學習新觀念。 結語作為設計師轉行開發者，價值觀會有明顯的變化，許多是直接顛覆過去學習設計的思維及價值觀，過程中也會不斷審思過去價值觀是否正確，而這個過程給予想轉工程師的設計師自行從中學習體驗，也歡迎私下與我分享你的過程喔。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 設計「素材」資源","slug":"design-material","date":"2018-11-10T16:00:00.000Z","updated":"2018-11-12T03:31:24.136Z","comments":true,"path":"design/2018/11/11/design-material/","link":"","permalink":"https://wcc723.github.io/design/2018/11/11/design-material/","excerpt":"","text":"做設計總少不了一些圖庫當資源，圖庫資源在網路上非常多，無論免費、付費都可以找到不少，但是設計師在執行時，通常只會挑用一些偏好使用的站點來運用，以下介紹我在開發時比較常利用的素材網站。 素材也有區分類別，先前有介紹的網頁圖示、字體重複的部分就不再列出，本篇另外介紹點陣、向量、日文字體、短影片等幾個類別。 點陣素材一直以來我都是以向量為主做設計、開發，點陣素材如果需要自己來就需要透過攝影，但這個領域已很久沒有接觸，且好的照片並不是那麼容易可以拍出來。 近期最長參考的點陣素材是 Unsplash 這個服務，它所提供的攝影圖片品質 “極高”，且圖片皆是免費並可以做商業運用，在挑選圖片時總是會先逛逛這個站點。 https://unsplash.com/ 雖然 Unsplash 非常好，但同時也變成他的缺點，當需要找一系列的圖片時，就會較難找出相同風格、相同情境的，當一些特定系列圖片就會參考其它的素材網站。 https://stocksnap.io/ https://www.photock.jp/ 以 Photock 來說，搜尋「桜」就會出現許多品質、風格相近的櫻花圖片，Unsplash 則會接近於藝術照。 向量素材大部分向量素材都是需要收費的，而向量素材更重要的是需要一系列的風格，透過付費較能一次取得大量相同風格的授權圖。目前較常使用的是 Flaticon，主要是它另外有提供應用程式，可以直接搜尋圖片並將圖片拖拉至 Illustrator 或 Sketch 等繪圖軟體（剛剛看了一下只有支援 MacOS）。https://www.flaticon.com/ 如下圖，可以直接在應用程式內搜尋圖示並直接加入到繪圖軟體內，如果需要系列圖片，也可以在 Flaticon 網站上搜尋後加入收藏，應用程式也能直接取用。 很多圖片是免費使用的，但是付費的通常都比較精細 :D。 日文字體由於中文字的開發成本高，加上繁體字的用戶只有台灣及香港，所以大多中文字都是需要付費。而「日本漢字」是從繁體中文演化而來，如果需要一些特殊的字體不妨可以參考「日本漢字字體」。 https://www.freejapanesefont.com/ https://fontbear.net/ 優點是風格特殊，但由於不是純中文字體，所以經常會有缺字的問題，此時就只能換詞或是乖乖換回中文字體使用。 影片素材網頁一進入後就展示「全螢幕影片」相對於「靜態圖片」是更吸引人的。但影片素材處理相對複雜，Coverr 就是專門提供免費全屏影片的服務，並且會附上全屏所需要的 CSS 及 JS（但 RWD 支援性還需要自行調整）。 https://www.coverr.co/ 素材網站也會隨著不同工作、經歷不斷地調整選用，過去我還會使用經典「書法字體」，並將歷代書法家的字體轉為向量圖運用，不過現在這類型網站較無維護，加上日文字體相對方便許多，所以就沒有再使用了。 以前學習設計時還有剛出社會的幾年，其實不太喜歡用素材，主要原因如下： 素材資源難以統一 素材資源不一定能夠搭配目前設計 用了素材感覺自己的設計就不是自己的 前面幾個其實是次要原因（但目前還是有此狀況），過去接受美學訓練時，都不斷強調自我的重要性；而在慢慢轉變到工程師後，這樣的思維就不會那麼強烈，因為工程師是偏向共享，這樣的理由下慢慢說服我自己去運用素材，加上後來工作需要加速完成商業運作，與程式碼品質的衡量下就選擇直接使用現有素材。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 設計「參考」資源","slug":"design-reference","date":"2018-11-09T16:00:00.000Z","updated":"2018-11-10T08:14:54.946Z","comments":true,"path":"design/2018/11/10/design-reference/","link":"","permalink":"https://wcc723.github.io/design/2018/11/10/design-reference/","excerpt":"","text":"開始執行設計時，除了要明確了解目標外，另一重點則是需要大量的想法及設計參考，假設需要製作遊戲類型的網站，那麼就需要先了解該類型的風格、配色、變化性等等，缺少這些參考也會難以動手開工。本篇列出經常搜尋的網站，以及這些網站的特性和參考點。 Behancehttps://www.behance.net/ Adobe 旗下的作品張貼網站，相當中規中矩的呈現各設計師作品，上方也可以透過搜尋的方式找尋特定類別。進入作品頁面後會以「專案」來呈現，呈現出作者、點閱人數、推薦人數、使用的工具等訊息。 也可以進入特定設計師、團隊的頁面內，參考特定作者的作品。 Dribbble基本的功能上與 Behance 很接近，近期流行的圖、火紅的設計師、團隊等等過濾方式皆有，不過 Dribbble 我喜歡的點在於它可以使用 “色彩” 作為搜尋的方式。如下圖，每個作品他會抓取部分重要的色彩，如果想看該色彩的延伸作品，點擊後就會出現該色系相關作品。 Pinteresthttps://www.pinterest.com/Pinterest 是 「pin」及 「Interest」兩個單字組成的，白話的意思是釘選有興趣的作品，因此該網站需要註冊登入才能使用，也是因為會主動推薦用戶可能感興趣的作品。 使用搜尋後，他會跳出更多的「詞彙」，試著找尋用戶有興趣的內容，當然接下來的搜尋、釘選都會有助於 Pinterest 提供正確的圖片。 Collect UIhttps://collectui.com/designs這是一個大雜燴收集的網站，圖片都是來自於 Dribbble 上被推薦的內容，在前期沒有特定想做的風格，會先來這個網站找尋想要的「靈感」，有些方向後再去其它網站逛逛。 品牌設計規範http://findguidelin.es/有些時候需要要找各大「經典」來參考時，像是 Airbnb、Facebook、Dropbox、Uber 等等，突然想參考時 Google 也不一定能搜尋到，這時候 FindGuildlin 就打開直接看吧～。 實際網頁參考最後，列出會特別收錄優良作品的網站，像是 Awwwards 及 CSSDA 就會收集國際上優秀的網頁設計作品，並頒發獎章給予該網站。 https://www.awwwards.com/ https://www.cssdesignawards.com/ Onepage 則是收集單頁類型網站，其中包含許多視差滾動的技巧。 https://onepagelove.com/ Mediaqueri 目前較無更新，但再響應式網站剛流行時就很參考這個網站，技巧都很基礎，重點是放在 RWD 的排版上。 https://mediaqueri.es/ 本篇重點在尋找靈感，這些也是常用來搜尋靈感的網站，下一篇則會介紹搜尋「素材」的資源，歡迎大家隨意收錄。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 設計師與開發者的溝通工具","slug":"communication-tools","date":"2018-11-08T16:00:00.000Z","updated":"2018-11-12T03:31:04.887Z","comments":true,"path":"design/2018/11/09/communication-tools/","link":"","permalink":"https://wcc723.github.io/design/2018/11/09/communication-tools/","excerpt":"","text":"溝通非常重要，不好的溝通不只沒有效率，也會造成不同領域間的嫌隙。如同設計師跟業者索取素材資源時，業者提供的是低解析度的 word 檔案，也很難解釋什麼叫做更高解析度的圖片！設計師對上工程師也是相同道理，如果給予的是 .ai、.psd 檔案，工程師會難以從中獲得執行所需要的資訊（需要另外學習如何操作）。 本篇就提供一些好用的工具，讓工程師與開發者可以了解設計師的規範，並且可以即時回饋讓設計師便於修改。 Markmanhttp://www.getmarkman.com/ Markman 是中國廠商開發的 UI 標示工具，可以用於「輸出後」的圖片，只要透過簡單的拖曳就能標記出色彩、距離、輔助說明等，操作上簡單易用。由於是運用在輸出後的圖檔，所以無論是哪一種繪圖軟體都可以搭配運用（另外支持 PSD）。 Sketch Zeplinhttps://zeplin.io/ Zeplin 最早是 Sketch 的擴充功能，目前還支援 Photoshop、Illustrator 等繪圖軟體，算是真正整合設計軟體、設計規範、工程師協作的工具，透過 Zeplin 設計師可以一鍵輸出所有的設計規範，且不需要另外標示尺寸、色彩等。 工程師可以透過該工具直接取得所需要的資訊，如尺寸、間距、色彩，這讓畫面不至於因為過多標示感到凌亂，也能得以呈現更多的資訊。不僅如此，開發者也可以依據所開發的平台（Web、iOS、Android）從中取得所需要的程式碼。 Zeplin 官網有詳細介紹：https://zeplin.io/why-zeplin過去寫過的相關文章：https://wcc723.github.io/tools/2015/04/09/zeplin-intro/ Adobe XD Spec範例設計稿：https://lihi.cc/LAfsC介紹說明：https://helpx.adobe.com/tw/xd/help/design-specs-for-developers.html Sketch 並沒有屬於自己的規範工具（類似 Zeplin 那種），而 Adobe XD 則是有推出 Spec 工具，只要有付費 Adobe CC 都可以直接運用，目前雖然功能並非如 Zeplin 那樣的完整，但在 Web 開發上也是相當足夠使用。 基本的間距、尺寸、色彩資訊皆有呈現。 另外也有討論工具。 SlackSlack: https://slack.com/台灣聊天使用的是 LINE 工具，除了閒聊外還有完整的表情圖片可以運用，非常適合抒發情緒。但在開發上還是建議使用工作用的通訊工具，主要是對於開發有完整的支援性，另一方面也可暫時關閉閒聊用的通訊工具，確保工作上的專注力。 與一般通訊工具一樣，基本的留言、搜尋都沒有問題，除此之外也有重點字詞標示、子討論項目等功能，且可以與各大現有的服務做整合如：Github、Google Drive 等等，使資訊更新時 Slack 都能及時收到。 整合 Adobe Creative Cloudhttps://slack.com/apps/A7P35MCT0-adobe-creative-cloud 透過 Slack 不僅可以傳遞規範網址以及預覽，也可做到設計師更新規範時，Slack 會即時收到規範已更新的訊息。 Dropbox Paper為了不讓 Sketch 專美於前，Adobe XD 不僅有類似於 Sketch 的功能，且還與各大廠商合作（如前面所提到的 Slack 服務），Dorpbox Paper 則是整合文件與 Adobe XD Spec 的功能，使匯出的規範連結貼入 Dropbox Paper 時能夠直接預覽。 詳細說明：https://blogs.dropbox.com/dropbox/2018/10/adobe-xd-dropbox-paper-integration/ 結語好的工具不僅可事半功倍，用在溝通上也可以增進感情，身為設計師不喜歡收到解析度不足的檔案，工程師也希望能夠收到標示明確的文件，本篇介紹的工具都不需要花費太多精力就可以使用（但可能需要花點＄），如果有更好用的工具也歡迎在下留言讓我知道。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 實際透過工具測量用戶行為","slug":"funnel","date":"2018-11-07T16:00:00.000Z","updated":"2018-11-09T03:03:00.494Z","comments":true,"path":"design/2018/11/08/funnel/","link":"","permalink":"https://wcc723.github.io/design/2018/11/08/funnel/","excerpt":"","text":"開發、設計時我們會盡可能站在用戶的導向做思考，當中也會腦補許多行為，如： 字要小才會顯得精緻 輪播 Banner 很吸睛，最新消息放在上面大家都會看 說明要拆很多頁，用戶不喜歡同一頁滾太久 相信以上範例在目前網頁已經少見很多，畢竟這些都是經過許多前人的研究調整而成。但身為設計師，多少都會想透過不同的視覺調整，嘗試是否能夠做出更好的使用者體驗，本篇就透過一些工具介紹，讓大家了解如何「觀察」使用者的體驗。 用嘴巴問!?一個畫面做出來，總是可以透過詢問同事、朋友的方式，了解該畫面是否好看、好用等等，但訪談本身也是極需專業及技巧，如果沒有許多事情準備很難有足夠效益，缺乏正確準備的詢問可能具有以下的問題： 對設計師的情感了解詢問大多會從週遭的人開始，周遭的人也對於設計師、開發者有基礎的認識，此時回答的內容就會受到情感的影響，比如說：友好的稱讚、習慣性的酸言酸語，而這些對於使用者體驗調查本身並沒有任何幫助。 對於詢問內容已有基本的了解接下來，詢問的過程中總是會先介紹問答的目標，也就是目標對象是在「有心理準備的情況下」接受檢測，那麼大部分的行為將不具有參考性，因為真正的用戶並不會有「被觀察」的感受來使用網站。 受眾、用戶可能並非真正網站使用者再者，詢問的對象大多是與自己生活相仿的對象，例如：都居在相同都市、年齡接近、生活習慣接近、價值觀差異小。不同背景、價值觀的人們在瀏覽網站時的目標也會不同。 如：嬰幼兒商品網站，那麼身為媽媽所觀察的點就不會是只有價錢，而是會仔細看產品本身是否能解決他的問題，相關評價是否優良等等，但如果是其它人可能會關注在價格、Banner 的媽媽很漂亮、嬰兒圖片可愛等等。 使用者體驗漏斗如果用戶是具有心理準備下接受訪查，那麼行為將不具有真實性（如：男性受訪者如果看到正妹圖，大多假正經會先跳過不去點擊）。反之，真實的行為是更有價值的。 試著想像：用戶在家中使用電腦時，因為其他人推薦的服務有興趣，不看任何文案、描述立馬按下註冊的情境，但註冊的過程擁有許多關卡，最後一關必須要填寫信用卡才算完成，立馬關閉視窗結束瀏覽… 上述的過程包含了： 進入導覽頁面 點擊註冊 註冊流程填寫資訊 填寫信用卡 註冊完成（假設這步驟有完成） 身為設計師或開發者，就必須從這個流程中尋找問題，這個流程我們會稱為 Funnel（漏斗），上層進入的人數會很多，過程中會不斷流失人，這個形狀就類似漏斗。 會先假定一個目標，接下來列出達到該目標會遭遇到哪些行為，接下來透過工具觀察每個行為的數據，是否在哪個階段有大幅的減少。 工具GAGA 是 Google 旗下的一個服務，大多開發者都會安裝用來監控流量來源、用戶裝置、用戶所在地區等等…，而他也有提供「增強型電子商務」，透過電商的成效呈現 Funnel 數據，不需要額外費用就可以導入 Funnel 的觀念。 MixpanelMixpanel 優點是可以隨著開發者自定義追蹤行為，所以也可以隨著需求調整需要用於各種成效追蹤，如：註冊、購買、填寫表單等等，對於 Google 所提供的 UTM 追蹤碼也能自動套用，所以除了能夠了解 Funnel 成效，更能透過用戶「來源」分析不同用戶的成果。 HotjarHotjar 也同於上述的行為追蹤工具，但更大的特色是可以做到「側錄」，了解每個用戶在網站上的行為軌跡，更能了解用戶操作上是否真的如預期活動。 另外，Hotjar 也能依據使用者點擊的數據產生熱圖，透過此熱圖也能測試各種「詞彙」對於用戶心裡成效的分析（究竟是 “免費” 吸引人還是 “註冊”）。 結語使用者體驗一直是受到重視的議題，好的使用者體驗能將導入的成效翻倍，但另一方面使用者體驗本身也需要大量的「數據」作為支持（沒有量，翻倍也是徒然）。因此關注使用者體驗前，也需要多重視產品本身的價值。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 通用視覺效果","slug":"styleguide-4","date":"2018-11-06T16:00:00.000Z","updated":"2018-11-07T03:24:04.182Z","comments":true,"path":"design/2018/11/07/styleguide-4/","link":"","permalink":"https://wcc723.github.io/design/2018/11/07/styleguide-4/","excerpt":"","text":"規範定義除了元件設計、空間、格線等等外，另外還有經常重複使用的樣式也能夠被預先定義，比要常見的視覺效果如下： 圓角 邊線粗細、邊線色彩 陰影 背景圖樣、裝飾 圓角圓角就有點類似於明體、黑體之間的關係，黑體與明體會有兩者截然不同的個性，明體讓人感受具有人文、藝術氣息；黑體則讓人感受具有科技、現代感，圓角亦是如此，且可以隨著不同的圓角尺寸有著不同感受。如無圓角如同黑體，具有科技、現代感，但同時讓人感受較無情感，反之大圓角則讓人感覺更易於親近。 然而選擇哪一種都應該延續相同的視覺效果，並延伸到所有的視覺元件上。 下圖：這是不好的示範，圓角沒有固定的運用，無法維持一致性的視覺體驗。 陰影陰影在 Material Design 中不斷提到，他是一個呈現「深度」的好技巧，具有相同深度的物件會讓人感受到相同的重要性。 前文所提到的深度：https://wcc723.github.io/design/2018/10/19/grid-system-2/ https://material.io/design/environment/light-shadows.html#shadows 因此，設計時也可以使用不同級距的陰影，表現出不同重要性的元件，當然這些依然要維持固定的級數。 雖然些許差異的陰影變化是難以察覺的，但會增加開發上的許多困擾。 邊線邊線是色彩、線條的延伸，套用在元件的邊緣，邊線運用上特別要注意元件與元件的接合性，因為邊線本身具有空間，所以當並排、小距離間隙邊線的呈現都要注意。究竟是要完全相合、色彩變化差異等等。 結語這些樣式經常會重複定義，且會應用在元件上或網站上的各個地方，就如同是字體一樣，這些通用視覺效果也應該需要被預先定義，避免每次運用只有些為落差，但卻沒有一致性的視覺效果。 這些效果並非是獨立的元件，並沒有實際外觀，但這樣的預先定義有助於統一樣式，以一個卡片來說如果沒有共用的邊線粗細、色彩、陰影等等，視覺感落差就會很大，而這些視覺感受同樣會延伸到其他元件上。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 定義不斷出現的網頁元素","slug":"styleguide-3","date":"2018-11-05T16:00:00.000Z","updated":"2018-11-06T02:28:09.797Z","comments":true,"path":"design/2018/11/06/styleguide-3/","link":"","permalink":"https://wcc723.github.io/design/2018/11/06/styleguide-3/","excerpt":"","text":"定義玩基本要素如文字、色彩、空間等等後，就可以開始定義常用的「元件」，而每一種應用程式、環境都具有固定會不斷出現的 UI 元件，如桌面系統的應用程式會有固定的導覽列、關閉縮小視窗的控制項及固定的外框，雖然這些也是能夠調整，但調整的同時也意味可能會影響操作體驗。 網頁設計、行動 APP 也是如此，本身都會具有固定的 UI，這些 UI 對於一般用戶來說是很容易理解使用的。 表單元件預先設定元件的目的，不外乎是在設計前預先準備完成，限制後續設計的變化，但同時增加開發速度，因此預先定義的元件樣式盡可能可以符合所有情境。當然，最重要的是能夠符合網頁開發的標準。 表單結構在 HTML 中的表單結構如下：12345678form div label Email address input(type=&quot;email&quot; placeholder=&quot;Enter email&quot;) div input(type=&quot;checkbox&quot; placeholder=&quot;Enter email&quot;) label checkbox button(type=&quot;submit&quot;) 最基本的會有一層 form 標籤，表示其內部是需要送出的表單內容（所以表單內容是被限制在 form 區域內），內部會有 label 及 input 對應，label 表示該 input 所需要輸入內容的說明，input 則是用戶實際輸入的內容，兩者會透過 id 互相對應（這屬於前端技術，在此不多介紹）。最後會再補上一個 button 作為最後送出的按鈕。 透過以上的結構可以得到以下的畫面，這也是大家所熟悉的網頁表單，以下我們就針對常被忽視的設計來與大家說明： 缺少 Label雖然網頁中沒有 label 表單依然可以正確運作，但依據網站親和性的概念（label），缺少 label 會難以讓裝置了解該欄位的名稱及用途。 checkbox 及 radio現在 Checkbox 及 Radio 的外觀都能夠客製化，但做這樣的調整時必須確保： 大部分瀏覽器看起來是一致的 不會影響到用戶的操作經驗 如果有搭配 JS，請確保在各種情境下都能運作 不同類型的 inputinput 的類型非常多元，正確地運用可以減少開發者的負擔，並且增加對於行動裝置的支援性。以 type=”date” 來說，Chrome 瀏覽器就會跳出一個行事曆，在行動裝置上用戶就會跳出日期選擇器，而跳出的行事曆是固定外觀不能做樣式的調整。如果要追求符合品牌的外觀，請務必同時兼顧行動裝置的使用體驗。 除此之外，有部分的 input 類型是可以自定義外觀的，如：type=”range”、type=”file”（嚴格說起來 file 也不太修改，但還是有方法）。因此需要先認識所有類型的 input，並預先設計可能會使用到的類型。 提示文字input 中還有一個 placeholder 的屬性可以作為用戶填入文字前的提示，這通常是利用填寫前的提示，另外也可以在 input 下方加上提示文字，這會偏向填寫時或填寫後的提示。 不管如何，請別忘了還有提示文字需要被設計。 與 Button 可以併排設計時，也盡可能與 button 一同設計，因為會有不少情境是兩者併排出現的，如果不能併排還挺尷尬的。 禁用、錯誤狀態最後提醒，設計規範是預先定義所有會利用的情境，所以禁用、錯誤雖然設計中不一定會出現，但請確保工程師執行時能夠了解該外觀為何。 結語定義規範是相當辛苦的，必須熟悉網頁基本運作流程，還要預先思考可能會運用的情境，但有了固定規範後工程師能夠先以規範定義元件庫，設計師更能快速建構頁面所需的內容。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 一致性的距離（計算方法、水平、垂直）","slug":"styleguide-2","date":"2018-11-04T16:00:00.000Z","updated":"2018-11-05T03:48:04.934Z","comments":true,"path":"design/2018/11/05/styleguide-2/","link":"","permalink":"https://wcc723.github.io/design/2018/11/05/styleguide-2/","excerpt":"","text":"一開始的文章有介紹到格線系統，主要是針對水平欄位空間的介紹，而其實垂直空間也是需要有固定的間距，當然一方面是有一致的美感，另一方面則是讓開發者設定全網站可用間距時可以統一帶入。 本篇主要會針對兩個部分做介紹，一是如何定義間距，另一則是針對運用上的介紹。 定義間距（5 的倍數、以文字大小） 統一的運用（文字段落、小元件空間、大區塊的間隔） 定義間距雖說間距需要定義固定的數值，但至於如何定義其實沒有完全固定的規範，如果定義出 2, 4, 6, 8, 10, 12… 等所有雙數數值也算定義，但這麼細的數值再運用上其實非常不便，在此列出常見的定義方式給大家參考。 整數的倍數大多設計師會有個習慣，就是會將色碼、字級等數字抓成整數，如過去使用 CMYK 時，就會習慣 5, 10, 15 的數字依序做色彩定義，字級也會使用雙數 2, 4, 6, 8, 10 等等…。 這個概念也依然可以運用在網頁設計上，可以預先定義一套固定級數的間距作為使用，如：12345675px10px15px20px30px45px60px 接下來所有的網站也都會用這些數值來設計，並且避免使用到 3, 6, 7, 8 這些未定義的數值。 文字的級數另一種常見的定義方式則是搭配 rem，在 Bootstrap 中就是依據這種級數來做定義，且目前的網頁文字大小大多都以 16px 做為預設，因此延伸的級數則會有以下定義：1234560.25rem -&gt; 4px0.5rem -&gt; 8px1rem -&gt; 16px1.5rem -&gt; 24px2rem -&gt; 32px3rem -&gt; 48px 這種定義方式對於設計師來說沒那麼好理解，但對於工程師來說卻能夠有延伸的運用，假設網站類性不需要 16px 大的文字，他可以調整成 14px，那麼整體的間距也會跟著調整成如下： 1234560.25rem -&gt; 3.5px0.5rem -&gt; 7px1rem -&gt; 14px1.5rem -&gt; 21px2rem -&gt; 28px3rem -&gt; 42px 以上兩種開發中都是很常見的，而設計師僅需選擇其中一種，並與開發者協調好即可（設計圖目前還沒有辦法透過統一設定調整畫面間距）。 統一的運用定義好的間距會視設計需求來調整，但基本上還是會維持小空間使用小間距、大空間維持大間距的概念，如按鈕與按鈕之間就會避免使用 3rem 這種尺寸，而兩個大 section 之間當然也不會只使用 1rem 來做區隔，以下就依據一些常見情境作為範例： 元件之間元件之間盡可能用小數值的間距做設定，透過此方式能夠維持相關內容依然視為一個群組；反之，過大的空間會使群組的觀念被打散。 元件與外層區塊元件與外層區塊雖為同一個群組，但外層區塊大多是背景或單色，不具有訊息內容，因此有些距離更能保持美感。 區塊與區塊區塊與區塊之間就是明確的不同訊息內容，因此要使用更大的空間將群組隔離，避免造成不同的訊息混淆。 如 Evernote 網站就透過垂直空間、背景色彩、排版的差異，將不同訊息的群組明確分離開。 Evernote: https://evernote.com/intl/zh-tw 結語好的空間定義，具有以下特點： 一致性：就算內容改變，全站依然維持相同的空間邏輯 視覺群組：適當的空間區分內容 可被開發運用：具有固定的數值，且是明確具有邏輯，使之便於開發合作 因此，建議設計師會預先定義好所需運用的間隔尺寸，接下來再設計時也便於方便取用，避免開發好幾頁後才發現空間間隔不一致。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網頁設計規範 - 參考來源","slug":"styleguide-1","date":"2018-11-03T16:00:00.000Z","updated":"2018-11-05T03:37:00.220Z","comments":true,"path":"design/2018/11/04/styleguide-1/","link":"","permalink":"https://wcc723.github.io/design/2018/11/04/styleguide-1/","excerpt":"","text":"網頁設計許多概念是受到限制的，因為除了設計外也要同時重視可行性，因此預先定義規範不僅預先了解可執行的限制，對於工程師來說更方便預先建構元件。 但設計規範並不是一件容易的事情，同時必須在意可行性、延展性、穩定性。 可行性：確保規範是可以被執行的 延展性：未來的更新是有預先規劃的 穩定性：不可隨意進行破壞性更新（break change） 本篇提供一些概念給予參考，讓還沒有想法的設計師了解可以從何取得資源，並且慢慢著手加入設計規範。 BootstrapBootstrap 官網：https://getbootstrap.com/繁中版：https://bootstrap.hexschool.com/ Bootstrap 是網頁使用的 CSS 函式庫，內建許多現成樣式可以直接運用，讓不熟 CSS 或設計的開發者都可以做出一定品質的網頁，是目前使用最為廣泛的 CSS 函式庫（沒有之一）。 雖然他預先定義的樣式不一定被設計師所喜歡，但卻是非常標準、符合網頁開發原則的。以下列的標題字來說尺寸的變化具有一定的級數變化，轉換為網站運用的尺寸也是固定的整數。 先前所介紹的固定尺寸級數，也就是從 Bootstrap 所延伸而來，如果沒有預先定義所有標題級數，後期新增時會出現間距不明顯或間距過大等問題。1234567設計師用的尺寸： 工程師所用的尺寸16px : 1rem20px : 1.25rem24px : 1.5rem28px : 1.75rem32px : 2rem40px : 2.5rem 除了標準的文字、色彩的定義外，Bootstrap 在元件設計上也是用盡心力，如下方的 Navbar 為了定義出多種色彩的變化，它則是將文字的顏色設計成具有「透明度」，使他在不同色彩下都能夠自然的呈現，這樣的概念也可運用於設計之中（變化性不只案例中的三種，而是幾乎所有色彩）。 Adobe XD UI KitsAdobe XD Resource: https://www.adobe.com/tw/products/xd/resources.html Adobe XD 目前在拓展階段，為了整合更多資源提供了 plugins、App internrations、UI Kits、Icon sets 等，不乏與各大企業合作或者整合性的服務，其中的 UI Kits 就有一份完整的網頁設計 wireframe 可作為設計規範（此份規範還不斷再更新中）。 本份文件從基礎的色彩、文字、字體開始，並提供完整的按鈕、表單、卡片的常見網頁元件，還提供大範圍的區塊元素如：頁腳、價格表、結帳頁面、資訊陳列區塊。幾乎可以算是設計軟體版本的 Bootstrap，非常值得參考。 雖然本分設計稿是以單色呈現，但是設想了許多情境非常值得參考，以下方到表單來說就包含未填寫、填寫中、離開 focus、錯誤提示等等，而這也是我們設計表單時經常會忽略的部分。 在這份設計文件中，同樣的目標會提供數種排列風格做變化，以價格表來說就提供了十種變化，下圖節選四種。 Material Design當然，最完整的設計規範還是可以參考前方不斷提到的 Material Design，不僅在應用上有完整說明，還有包含完整的設計理念，有機會可以將整份閱讀一次，對於設計規範會有很多的靈感及想法。 結語進入一個新領域時難以在短時間內就掌握所有細節，最好的方式是透過最佳範例來了解該如何運作，如 Bootstrap、Adobe XD UI Kits 都是很棒的案例，這些都具備了前人實作的經驗，並經歷上千、萬人的驗證。參考這些方式會比閉門造車有更好結果，並且增加設計規範的可行性、延展性及穩定性。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 版面視覺動線配置(2)","slug":"weblayout-2","date":"2018-11-02T16:00:00.000Z","updated":"2018-11-05T03:36:40.179Z","comments":true,"path":"design/2018/11/03/weblayout-2/","link":"","permalink":"https://wcc723.github.io/design/2018/11/03/weblayout-2/","excerpt":"","text":"上一篇介紹了版面配置的概念，其中最重要的是「群組」概念，而本篇就透過實際案例來說明各大網站如何運用這些概念，並且看看是否也有運用到交錯、韻律的手法。 這些概念要特別注意僅適合用在「登入頁」（Landing Page），適合用在產品、服務推廣使用，當然也就不適合套用在應用程式的服務上（如：Facebook、Youtube、Google…）。 首先還是要強調從這些網站中是否可以觀察到「群組」概念，並且觀察是否有相關延伸的概念： 群組交錯色彩 左右韻律排版 範例網站介紹以 Adobe 來說，就是標準運用此概念的網站，群組與群組之間均有套用不同的色彩，並且具有一定的左右韻律。 https://www.adobe.com/tw/creativecloud.html Evernote 亦是如此，也是透過群組式的視覺感來做分組，並且加入些許淺灰、白底的方式來做分類，最重要的是會使用深綠底色來做最重要的行動呼籲（Header 及接近底部的區塊使用綠底，其它部分則不會運用）。 Slack 雖沒有左右的韻律式排版，但依然維持最關鍵的「群組」分類，並且也會使用色彩上的變化區分不同的群組，主色的運用也是回顧到先前色彩介紹的章節，僅運用在最重要的「行動呼籲」之中，畫面中僅有 GET STARTED 會使用主色彩（或主色背景），其餘部分用到的色彩僅有到點綴，並不如主色上的凸顯。 結語本篇是延續上篇繼續介紹排版的技巧，讓一些非本科系的開發者，也能掌握一些基礎概念，排出具有基礎美感及正確的訊息傳遞方法。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 版面視覺動線配置(1)","slug":"weblayout","date":"2018-11-01T16:00:00.000Z","updated":"2018-11-02T03:10:32.284Z","comments":true,"path":"design/2018/11/02/weblayout/","link":"","permalink":"https://wcc723.github.io/design/2018/11/02/weblayout/","excerpt":"","text":"本篇主要是描述網頁「登入頁」（Landing Page），這個頁面是用戶一開始接觸的畫面，雖然這個頁面沒有固定的設計方法，但其實可以從各大網頁尋找到雷同的跡象，本篇就去除掉配色概念，單純就依據視覺動線來做說明。 群組首先，我們還是要提到設計本質為「傳遞訊息」，視覺動線也就是引導用戶了解網頁所需要傳達的訊息，而網頁本身需要傳達的訊息非常多，通常難以用少量文字、話語呈現。就像是業務推廣產品時並不會只問一句：「你要買嗎？」，而是會用不同角度切入說明。 這麼多的訊息內容加到網頁中就容易造成混亂，因此可以使用「群組」的方式來分類訊息；而定義成群組的方法可以運用「相同的視覺感」來做分類，如以下提供幾單的幾種類別給予大家參考（實際上可以運用的當然更多）。 左文右圖的群組（或右圖左文） 三欄式上圖下文的群組 左右圖文連續排列的群組 在不同的排列方式後，自然就會讓人感受到內容上的差異，因此將這些不同的群組排列在畫面上可以得到以下的結果。 此時，群組 2 及群組 3 由於具有「類似的視覺感」，會容易被視為同一個群組，如果兩個群組之間的訊息沒有足夠的關聯性，當缺乏連貫性就如同所謂的「跳躍性思考」，難以吸收前後文的訊息。 交錯式排列此時，我們也可透過顏色交錯的方式，將內容以群組的方式隔離，範例如下，群組 1 及 群組 3 是使用白底深色圖文，而群組 2 則是使用深色底、淺色圖文，透過此方式將內容隔離開來。 這種方式不僅可以增加畫面豐富度及有效群組話訊息，亦可強化品牌色彩。範例中的 群組 2 是使用深色背景搭配淺色文字，實作中也可以使用淺色背景搭配深色字（其它維持白底），僅需要與其它樣式有所區隔即可。 閱讀動向除了群組化，由於現在訊息量不斷地膨脹，人們會不斷增加自己的閱讀速度，因此閱讀時會增快由上而下的速度，並且不斷地左右交錯。因此也可以將此慣性加入畫面中，除了增加閱讀性外，也同時讓畫面更有「韻律感」。 如上圖，我們不僅使用「具有底色」及「無底色」的交錯方式，並且重新調整排版為左右交互的韻律方式，藉此增加圖文的閱讀性。 而網頁中也可以適時的透過少量內容（群組 2 及 群組 3 之間）來凸顯部分訊息，這類訊息通常簡短並具與行動呼籲性（call to action）。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 響應式圖片選用技巧","slug":"responsive-images","date":"2018-10-31T16:00:00.000Z","updated":"2018-11-02T03:10:29.525Z","comments":true,"path":"design/2018/11/01/responsive-images/","link":"","permalink":"https://wcc723.github.io/design/2018/11/01/responsive-images/","excerpt":"","text":"網站上總需要圖片來點綴，除了客戶提供解析度不足的圖片外，我們也看從許多素材網站找到不錯的圖片，而選用圖片除了找到合適主題外，也需要花不少時間來比對是否合適於網站。 本篇依據 CSS 的觀念來提供一些選用圖片的技巧，藉此來減少 25% 搜尋素材的時間。 技術限制響應式圖片運用上與技術限制有很大的關係，其中有兩個要點是必須要注意的： CSS 呈現圖片的方法 裝置尺寸變化 CSS 呈現圖片的方法以下圖來說是一張原始比例的圖片，長寬比約為 960:640，在 CSS 中如果需要限制為正方形的尺寸，常見手法是運用 background-size: cover 或 contain 的方式。 以下兩張圖片則是使用這兩種屬性，而前者是使用 cover，後者則是運用 contain(灰色為背景色彩)，運用上更是 cover 被許多設計師、開發者使用，這種方式盡可能在有限空間中呈現最多畫面。 contain：在有限空間中呈現完整圖片，畫面中的灰色部分則是背景。 圖片來源：https://unsplash.com 裝置寬度由於圖片顯示區域會受到裝置寬度的影響，我們將上述的圖片分別放置在不同的尺寸上呈現，會得到如下的結果。 960 * 450 桌面版畫面：由於這張圖片的配置是屬於水平，且 主體 僅有佔少量空間，在橫向畫面上呈現沒有什麼問題。 360 * 450 行動版畫面：雖然畫面偏向水平，但由於 主體 只有一張椅子，畫面縮小後椅子只要能完整呈現，依然沒有什麼問題。 接下來，我們選用另一張圖片來做介紹： 960 * 450 桌面版畫面：畫面中沙發是主體，完整地在畫面中間，在桌面版沒有什麼問題。 360 * 450 行動版畫面：但由於 主體 是橫式的，在行動版的垂直小空間中就顯得明顯不足，這樣導致了畫面左右方被裁切掉，這樣的圖片就不太合適。 快速驗證方法CSS background cover 方式會盡可能的呈現完整圖片，而呈現的空間是可以再透過 x, y 軸線做定位上的為條（通常預設為中間或固定的四個邊角）。 接下來可以先透過繪圖軟體準備好裁切空間，上面包含了桌面版空間及行動版空間，兩個空間的交疊處則是安全區域。 主體必須比重疊安全區域還要小 桌面版空間可以水平呈現 如下圖，既可以呈現完整畫面，也同時可以測試重疊區域是否有足夠空間。 接下來把裁切區域套用在畫面上即可得到以下結果。 結語視覺也有不同的邏輯，而這個邏輯並非能用程式邏輯完整的解釋，本篇直接透過實際的案例解釋圖片選擇方式，讓大家在選圖上可以節省一些時間。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - Icon fonts 的常見資源","slug":"icon-fonts","date":"2018-10-30T16:00:00.000Z","updated":"2018-10-31T05:10:58.593Z","comments":true,"path":"design/2018/10/31/icon-fonts/","link":"","permalink":"https://wcc723.github.io/design/2018/10/31/icon-fonts/","excerpt":"","text":"網站開發加入一些圖示點綴，除了可以增加網頁的豐富度外，同時可以讓用戶從圖示中了解當下的行為為何。過去圖示大多使用 png 來呈現，具有豐富的色彩及尺寸，但隨著設計的概念不斷調整，現在流行單色系的小圖示，以及為了增加圖示可運用性目前大多使用向量的方式呈現。 接續前文所介紹，SVG 是可縮放的向量圖形，作為圖示運用有一定的優勢，本篇會介紹如何取用向量圖示資源，以及 icon fonts 的運用方法。 什麼是 icon fontsIcon 是圖示，fonts 是字體，兩者混在一起就是圖示字體（被揍 簡單來說，我們平常使用的字體會有外觀上的不同，而 icon fonts 就是使用圖示修改掉特定的字體符號，讓他顯示成不同的圖形。如下圖所示，icon fonts 本質就是字體，也能夠像其它字體一樣安裝於系統中。 實際運用在網頁上時，除了圖形顯示外也同時具備文字的特性，如：可縮放、可改變色彩、可套用文字陰影，且只要載入 CSS 即可運作。技術上來說，大多是透過 修改字體 並從偽元素插入特定的 Unicode 的編碼文字來套用圖示，但也有部分的 Web fonts 是採用其它的渲染技巧。 接下來就能如圖中一樣的顯示這個 icon，並且這個 icon 依然具有文字的特性，可參考：https://fontawesome.com/v4.7.0/icon/address-book FontawesomeFontawesome 是目前使用相當廣泛的 icon fonts，目前版本為 5.4.x 版，而除了 icon fonts 以外，現在更有 SVG 動態插入的方式。 5.x 版本：https://fontawesome.com/4.x 版本：https://fontawesome.com/v4.7.0/ 如果要使用 Fontawesome 的圖示做設計，可以直接點選 For the Desktop 下載圖示，下載後就包含大量的圖示 SVG 可以直接運用。 因為有數千組圖示可以運用，下載後難以從字面上直接了解圖示外觀，建議使用時可以搭配官方的 圖示列表 來快速搜尋，開發者也能夠從中快速了解設計師所用的 icon 為何。 Fontawesome 的圖示也有分為免費與付費版，所能套用的 Web fonts 也有所不同，設計師使用時要特別注意，不過也不得不說，雖然付費版僅是粗細上的不同，但付費版的 icon 還是好看許多 :D。 給予開發者的說明雖然 fontawesome 提供兩種方式運用在 icon 上，一則是本文重點 icon fonts，另一種則是透過 js 來插入 SVG。如果你需要使用 fontawesome 做開發建議使用 icon fonts 的方式載入，如果想改用 SVG 的方式，可能會有動態切換上的問題，建議先讀過官方文件是否有合適的解決方案，並且實際測試後沒有問題再使用。 Google Fontshttps://material.io/tools/icons/ Material Design Icon 也是一種字體 icon，也與 Fontawesome 一樣具有大量的 icon 及搜尋功能，並且是完全免費，但比較特別的是使用「連字方法」來做 icon 的呈現。 連字方法(uses a typographic feature called ligatures)：https://google.github.io/material-design-icons/#using-the-icons-in-html 連字方法的特色在於 Icon 本身依然具有「詞彙意義」，它是透過一個單詞的判別轉為一個圖形，如下圖 icon 除了呈現一個臉以外還具有「face」的辭意，並且可以透過搜尋方式找到這個圖形。 自製 Web fonts雖然上述服務已經提供大量的 icon，但設計中有時還是有不夠用的時候，自行開發 icon 也是個選項，以下我有撰寫過 svg 轉 web fonts icon 的方法，給大家參考看看： 自行開發的方法：https://wcc723.github.io/css/2016/12/13/gulp-dev-env/ 結語Web icon fonts 現在網頁開發已很常見的手法，主要原因是只要一個 className 就能輕鬆運用，當然現在也有 svg icon 的運用方法，但相對於 web icon fonts 來說還沒那麼流行。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - SVG 輸出注意事項","slug":"image-svg","date":"2018-10-29T16:00:00.000Z","updated":"2018-10-30T02:40:35.766Z","comments":true,"path":"design/2018/10/30/image-svg/","link":"","permalink":"https://wcc723.github.io/design/2018/10/30/image-svg/","excerpt":"","text":"向量工具、Adobe XD、Sketch 也都能夠輸出 SVG 圖片，但在輸出時有些小地方也需要注意一下，避免在本地端看似沒有問題，但用戶卻看到的卻與預期不同。 首先瞭解一下 SVG 本身其實是 XML 格式的檔案，這是一個類似 HTML 格式的結構標記，如果要繪製一個方形，則會使用 &lt;rect&gt; 的標籤，並定義他的座標、尺寸、填色樣式等等。 12345&lt;!-- SVG tag --&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"120\"&gt; &lt;!-- 矩行 tag --&gt; &lt;rect x=\"2\" y=\"2\" width=\"100\" height=\"100\" style=\"stroke: #333; stroke-width: 3; fill: MediumTurquoise;\"/&gt;&lt;/svg&gt; 接下來就會出現如下的矩形。 SVG 一些常見的圖形原始碼可以 參考。所以 SVG 輸出後與其它的圖片有很大的不同，他依然是透過一些文字標記組成，再有了基本了解後，我們再透過這些觀念了解輸出的圖片為什麼可能出錯，以及怎麽從輸出後的原始碼發現錯誤。 文字務必轉外框我們在印刷時，給予印刷廠檔案的文字都會外框筆畫，為的就是避免印刷廠沒有特定的字體，導致字體的顯示與預期並不同。 以下圖來說，「Sweetaste」有分為上方的外框字體，下方則是純文字。上方的輸出後會以 “路徑” 的方式來繪製，從圖中可以看到文字周圍都是點與線的結合；而下方的文字則是純文字，只有一條下底線表示而已。 外框字體的原始碼如下，都是由 path 標示路徑組成（下述程式碼參考即考）：1&lt;path class=\"cls-2\" d=\"M55.48,40.91H56A6.11,6.11,0,0,0,55.48,43c0,3.28,3.49,5,6.15,5,4.22,0,6.66-2.34,6.66-5.76a5.72,5.72,0,0,0-2.16-4.46l-2.55-2.34c-2.27-2-3.56-3.93-3.56-6.55,0-3.93,4.17-7,9.32-7,3.13,0,4.68,1.3,6.3,1.3a1.28,1.28,0,0,0,1.29-.94l.54.11L75,29.25h-.43a7.21,7.21,0,0,0,.32-2.13c0-3.31-3.2-4.71-5.54-4.71-3.17,0-5.51,1.76-5.51,4.42,0,2.24,1.3,3.64,2.74,4.94l3.2,2.88c1.73,1.54,3,3.09,3,5.79,0,4.07-4,8.06-10.9,8.06-4,0-5.15-1.47-7-1.47a1.43,1.43,0,0,0-1.37,1.15l-.51-.11Z\"/&gt;&lt;path class=\"cls-2\" d=\"M90.54,48.22A3.24,3.24,0,0,0,91,46.56a4.9,4.9,0,0,0-.64-2l-.94-2c-.22-.47-.43-.94-.61-1.41-.69.65-1.4,1.23-2.09,1.77l-1.8,1.47c-1.11.94-1.73,1.48-2.45,2.2a10.23,10.23,0,0,0-1.58,1.91l-.43-.25a3.34,3.34,0,0,0,.43-1.66,4.76,4.76,0,0,0-.65-2l-.93-2a8.76,8.76,0,0,1-1-3.35c0-2.52,1.88-4.75,4.4-6.77l.72-.57.32.39a5.58,5.58,0,0,0-2.12,4.5c0,1.62,1,4,1.8,5.62a5.76,5.76,0,0,1,.68,2c3.49-2.84,4.75-4.79,4.75-7,0-1.47-.83-2.05-.83-3.49a1.86,1.86,0,0,1,2-1.8,1.92,1.92,0,0,1,1.83,1.12l.94-.8.72-.57.32.39a5.58,5.58,0,0,0-2.12,4.5c0,1.62,1,4,1.8,5.62a5.56,5.56,0,0,1,.68,2c3.5-2.84,4.54-4.79,4.54-7,0-1.47-.83-2.05-.83-3.49a1.86,1.86,0,0,1,2-1.8c1.62,0,2.19,1.44,2.19,2.81,0,3.27-2.88,6-5.32,8L95,44.36c-1.12.94-1.73,1.48-2.45,2.2A10.35,10.35,0,0,0,91,48.47Z\"/&gt;&lt;!-- 省略 --&gt; 純文字的程式碼，僅有直接標示「Sweetaste」的文字，並透過 cls-1 來替換成特定字體，這個情況下如果用戶沒有該字體，那麼就僅會用系統字體顯示，所以請特別注意，盡可能外框所有字體。1&lt;text class=\"cls-1\" transform=\"translate(54.65 130)\"&gt;Sweetaste&lt;/text&gt; 注意輸出後的原始碼是否正確先前不斷地說明使用工具的重要性，因為輸出原始碼時結果也會不同，如下原始碼是透過 Illustrator 所輸出，圖片是一個正方形，僅有透過 .cls-1 調整色彩。 1234567891011&lt;svg id=\"圖層_1\" data-name=\"圖層 1\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 73 73\"&gt; &lt;defs&gt; &lt;style&gt; .cls-1 &#123; fill: #3f5d45; &#125; &lt;/style&gt; &lt;/defs&gt; &lt;title&gt;tester&lt;/title&gt; &lt;rect class=\"cls-1\" width=\"73\" height=\"73\" /&gt;&lt;/svg&gt; 接下來透過 Illustrator 加上陰影。 然後再重新輸出一次，會出現 data:image/png;base64.... 的 base64 原始碼，也就是說整個陰影都是透過 “點陣圖” 的方式來呈現，這會導致： SVG 檔案大小會增加不少 尚失向量圖的特性（縮放、再編輯等） SVG 檔案普遍來說都非常小，如果檔案有不正常的增大時（明顯比其他同類型檔案大數倍），那麼請透過文字編輯工具打開 SVG 檔案（注意 image 那行），確實了解檔案是否有問題。12345678910111213141516171819202122232425262728293031&lt;svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" viewBox=\"0 0 73 73\"&gt; &lt;defs&gt; &lt;style&gt; .cls-1 &#123; isolation: isolate; &#125; .cls-2 &#123; mix-blend-mode: darken; &#125; .cls-3 &#123; opacity: 0.75; mix-blend-mode: multiply; &#125; .cls-4 &#123; fill: #3f5d45; &#125; &lt;/style&gt; &lt;/defs&gt; &lt;title&gt;tester&lt;/title&gt; &lt;g class=\"cls-1\"&gt; &lt;g id=\"圖層_1\" data-name=\"圖層 1\"&gt; &lt;g class=\"cls-2\"&gt; &lt;image class=\"cls-3\" width=\"103\" height=\"103\" transform=\"translate(-8 -8)\" xlink:href=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGcAAABnCAYAAAAdQVz5AAAACXBIWXMAAAsSAAALEgHS3X78AAAHIUlEQVR4Xu2dW5ebOBCEC49zmczu//+jm8wd9gGXKcotJM+QRGDVOX2EMdiiP6ol/GB1wzCgqU4dcgc0/T0dcwfk1HVdlzvmVjV8six1156fgdFAAcmEXgurGE4ARV9HUG4JVJRE3Td7vxRSERwBk2t9W7UnWKmkRUDCtgTQ4phjbukwh9El9kFa396bUjB820EMzO0SpCSchFs0DontCFD0esu6SLa0jD6xPTuv67ouBSg3W9NEH4LWwwHuEVAExqO36GS/ttwfKoQTlLMIxJ3EEij9nL3Iy1kEpAfwLkFI/ek8AkLKPRdwrJw5GAVyPMWdtA4qVeL2IC1lEZA3ad9kv4qgwvKWKmtemhTMEcAXiaO0hLR3QEtgCONV2sOp9c/QnCw7J/Eso645AviKEcZXAN/s9VEiGof2omh8eZN4wQjjBXGJ9zEKwGV5u9Y5dMt3jGDYMhQQneaftXV5YrWMEczzKfQm1XN1osCc5McczMuQu0Ydc2/x/fQenaQd0/JGbQmUJ87LGcvXyymeADxiujmB+Uytl9eMDvY9Jc5xOHTMPYAHAD8kFFDKPVtXyjUK5gumsZfnLM3gLsAAAicx3igcHXPonB8A/jnFD0wO+oapg4TDjm4ZEBPIu55JfsVYxp4w3Zi8Xp0ovGI+q724YXXcSZU1nqBlSWdpDudfjC56wARH3RN1ZEuQ9K7WcUNdQzi8KSHHsOR9OW1zBnc4vR+6Z+kXAnWOz9ZY2ljOHjAB0vLmU+stjjtL443CIRg6Rt3yLOH5SObA4fidHY07BPQV87HnAaOL6B6fGKTGnZoBRWDUOToRUDC97H/E5Sw2lY+Ze5YmBGwj9zgguojOucc07kTPPFuVT4XVGQ7mO9JgPBdhTnJlja2PPT6tZpmjkzgxuBU4DuYJ8wd05kzzuAgGSE8IdNvd4w4iJIY+nOrMZa9wHIw/67ljikoasOwcKgJ0J62DYmgHk1PHjclnaryWHvPfGnnNmqclMKFKyprvU1B3FsdE7BFOJ/v8WjVyQK4qaylpjSScqOR5+Vt86NqYCEfBvCO+9ihPwBXXn4LjH+Rg3EHepuLqDlYkQhnkdXR93npgoZ2pxDnRiSXQUqHnbVW5ayxJfjYHJXBy0i/JdTY6vnbRKZ1tX3OdH9IacEoV3VFbEPvqY81v1yF3wIJWvUt2plVy8xk4rtJOlB5Xm0r7XXpcVmvCAVbs2Ea16vWvDadpRTU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1Ox1obzR/7ZomKtev1rwintWOlxtam036XHZfUZONqJ1Tq0E62Smz/5x0Spf1+qXZ7oDyf7Wq0BJ+p8FH/t35dWUul1Rsd/SCVwoi8ZgrYktqyPXKu3qmw+UnBSHx51og9aD/2fNS1rW5NecxRRPkqghfkocQ7lgHrbjkL/3nfA5b/5bU16vbrMSgqU5wnSZrUEJ/oQd8y7xZuFgjlgf3D8enXhPIXnzlElYZU4x4GwYwpHF5HTJUh4Pv/ed09weszXZ2M4JM1XDtRMERw9KQLjd40uh8V1ZAimx/7/Lp9rFzxjngcHFZU8z/VMJWXNwTgUrgvj68f0uJ2FJp4xrvjxhAkUYSkkBwQEUKiS2ZqXM36RrlEWgXnFba2f8wTgJ4BfmHLCHEUOUueEgBzOgPkgrh1JgeGCEg7mFlee+oUR0E9MTkoBypa2XFlLdUTLGAEAExhdWO7W1mwjnF+YXMQSt+SeC6UmBDzBxxrOSFhjmXhg/FKuuHTLqx0+YoTy36l9PL2nsznNKz/3AtIZzjAMgy1H6XeI3iXqCGCC52uUKZytTwYoLUeeFy1vDMJR53hpmz68YPnj1HijSygy0Xz/FROYtsLumAsGSxudU/Jwmixr/P2rP20TDpPsD5i0dVubev54wVLn02ofdyDtWddMpQlBHaPljAtlM/zZZg9gKK8szIMC0udAvn5F7Jq8cxLjjrpH9/M9Ps8QTrR4HLA/OGy1vPkvJzqJWnLN+GEy3gB553C7x1zqpjuMX6zLf+0ZDLUEiJAU1rvE9c4BZu7hCSkwDueASzBbfa7JyW9eB+Sg3hPvn8G4awCgC/aNb4yA9M4/BG0KSGqc2QMgT5g7IAVqCFpg5FLmHNOAy5lbtC8a+PcIhooAsVVA0fbZLdKGSjoHOLvn/BLzxEcwIjB7guLS5Dkg3Y72jS8WACzCOR80Qcq1vq3aE6RU0lKwLtolKFQRHODCRUAeyJ5g5BQlMQI1vihMejEcKoA0e3vhvVtRMqGlUKir4bgysG5a18JwfRpO0+/TAU3V6n9/TR8I3kWSrAAAAABJRU5ErkJggg==\" /&gt; &lt;rect class=\"cls-4\" width=\"73\" height=\"73\" /&gt; &lt;/g&gt; &lt;/g&gt; &lt;/g&gt;&lt;/svg&gt; 結語先前就有聽過 svg 輸出時檔案居然要數 mb，仔細一問才發現是 Illustrator 輸出帶有了漸層、濾鏡等效果（目前版本漸層不會出錯，但濾鏡、陰影還是會有問題），如果 svg 輸出時發生這樣的問題時，會建議直接改用 png 不要使用有問題的 svg，因為已經失去 svg 原有的特色（檔案小、無縮放限制等）。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 圖片壓縮方法","slug":"image-opti","date":"2018-10-28T16:00:00.000Z","updated":"2018-10-29T03:28:15.530Z","comments":true,"path":"design/2018/10/29/image-opti/","link":"","permalink":"https://wcc723.github.io/design/2018/10/29/image-opti/","excerpt":"","text":"了解基本的格式後，接下來設計師還需要「正確的」輸出圖片並壓縮，網頁上輸出圖片雖然沒有印刷中那麼複雜，但依然有許多眉角需要注意，像是用什麼工具壓縮就很常被詢問到，本篇介紹我再壓縮上常用的一些技巧。 工具輸出繪圖軟體均可輸出圖片（廢話），在此還是比較推薦使用 Sketch 或 Adobe XD，這兩套的圖片輸出功能完整，且可以一鍵大量輸出所有設定的圖片及尺寸。 Sketch 可以直接設定好所有圖片（設定格式、尺寸比例、檔名、尺寸前綴詞…），並且一鍵輸出到特定資料夾。 Adobe XD 再輸出規範時，也可以提供所有圖片的下載連結，讓開發者選用後一次打包下載（Sketch 也有相同功能）。 設計稿參考： https://lihi.cc/LAfsC （請切換到 Download 頁面） 如果是使用 Photoshop、Illustrator 等平面繪圖軟體，當圖片數量多，且規格複雜時將會花去許多時間，且工程師拿到一堆圖片時，也難以對應檔案與位置上的關係。而 UI 繪圖軟體相對於傳統的平面繪圖軟體來說，它讓工程師更能了解每張圖片所在的位置、運用情境、多尺寸的選擇，設計師只需要做好合適的規範設定即可。 圖片壓縮當然，圖片輸出後檔案還能做最佳化壓縮，目前主流的繪圖軟體都無法有效的壓縮圖片，透過合適的工具壓縮可以在不破壞視覺品質的情況下，大幅降低圖片的尺寸（檔案尺寸可降低 30% ~ 50% 不等）。 TinypngTinypng: https://tinypng.com/ Tinypng 是直接上傳檔案後，該服務會自動在後端壓縮，並且打包壓縮後讓用戶下載。使用方法簡單，無需任何設定，缺點是必須 “上傳圖片” 才能壓縮，如果產品是需要隱密性，不得提前公開的將不適合使用。 不過他們也有提供 Photoshop 版本的擴充套件（我沒有使用過），可以花些費用購買工具將可以在本地端壓縮。 ImageOptimImageOptim: https://imageoptim.com/mac 這是目前使用的壓縮工具，優點是離線使用、大量壓縮、免費、簡單操作（也可調整壓縮比），但目前只有 Mac 版本，Windows 僅能使用他另外提供的 Web Service（與 Tinypng 相同）。 且這個工具的壓縮能力相當不錯，如下圖我壓縮了一張 png 原始檔案尺寸為 2.4mb，壓縮後為 1.4mb，降低了 42.1% 約 1mb 左右。 而這個工具是本地端運行的，因此壓縮時會大量用去系統資源，如果電腦的效能沒有很好，建議不要在「工作時間」壓縮大量圖片，這可能會導致你暫時無法作業。 gulp 自動化壓縮https://github.com/hexschool/gulp-demo gulp 到目前為止還是很方便的工具，可以用來處理許多小雜事，這類型的工具只要把圖片放入，部署前輸入一鍵就會全部壓縮。壓縮的效果如下（原圖約為 742kb，壓縮後為 486kb）： 這個工具看似很方便，很適合工程師使用，但其實壓縮的品質不是很穩定，有些圖片加入後甚至不會做任何壓縮，相比較而言我還是傾向使用前面所介紹的那兩款。 結語程式碼需要壓縮，而圖片當然也需要被壓縮，且圖片壓縮效益大幅超過程式碼壓縮，進而加速網頁瀏覽的速度。而設計師交付給與工程師圖片時，也可以討論這段流程因由誰負責（或由伺服器自動壓縮），並將此流程加入到開發與設計之中。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 圖片格式的運用","slug":"image-format","date":"2018-10-27T16:00:00.000Z","updated":"2018-10-28T07:07:22.599Z","comments":true,"path":"design/2018/10/28/image-format/","link":"","permalink":"https://wcc723.github.io/design/2018/10/28/image-format/","excerpt":"","text":"隨著裝置解析度越來越高，如果是以 1:1 的尺寸輸出圖示時，都會明顯地看到圖示邊緣出現鋸齒，這樣的情況下無疑是降低設計的品質，為了避免這樣問題，實作中通常會使用兩種方式來解決： 輸出更高解析度的圖片 輸出向量圖片 更高解析度需要多高？對於網路速度是否有影響？向量圖的使用情境及限制為何？本篇將依據這些概念介紹。 格式選擇參考網頁靜態圖片選擇主要有三種（還有另一種為 base64，這就不在我們討論範圍內）： jpg：是屬於破壞性的檔案壓縮方式，圖片可以大幅降低檔案尺寸，不過也會因此導致品質降低，壓縮的過程中可以依據需求調整壓縮比，藉此控制品質及檔案大小間的平衡。 png：壓縮比較低的圖片格式，相對於 JPG 來說圖片檔案會大不少，但影像品質也相對較佳，除了有更好影像外還同時具有「透明」的特性。 svg：向量的圖片格式，圖形定位皆是使用數學位置，且「沒有解析度」的限制，因此圖片無限放大都不會失真。另外 SVG 由於是一些文字標示而成，所以圖片尺寸普遍來說都很小。 使用情境圖示、商標 SVG：可縮放向量圖形，圖片來源：wiki 由於商標會使用在許多情境，如網頁頁首、頁尾以及行動版等，在不同的尺寸變化下依然要維持高品質的清晰度來維持形象，過去大多都是使用 png 的縮放調整，但在目前的裝置解析度不斷提高的情況下，使用 svg 替代 png 是相對更好的解決方案。 範例網站：甜點電商的上方 Logo 就是使用 SVG 來呈現 目前大多網站均是使用 svg 作為商標顯示的格式。圖中為 Sketch 網站 除了商標外，另一個很常使用 svg 格式則為圖示（icon），過去圖示也是同樣使用 png，但在高解析度的裝置下來說卻顯得不足。使用 svg 替代主要原因在於 icon： 圖形單純 - 不會混用真實圖案 高辨識性 - 需要高解析度 大量使用 - 檔案要小 需要可編輯性 - 依據情境重新賦予色彩 在 Github 的網站中就可以看到大部分圖示均是使用 svg，且可依據情境重新調整色彩。如下圖選擇的 “Code” 選項的 icon 接近黑色，旁邊的 “Issue” 則是顯示淡灰色。 在 Github 中的網站是透過前端工具處理，讓 svg 圖形的引用更為容易，但實戰中 svg 圖形在管理上是有些門檻的，下一個章節會介紹使用 icon fonts 來處理 svg 在圖示上的應用方法。 主要圖片好的圖片能夠增加網站的豐富度，也同時能夠增加訊息傳的效益，現在鮮少有網站是不透過任何圖片來傳達訊息。舉凡是 頁首大圖、商品圖片、輪播、說明圖片等等，這些都是為了增加訊息傳達效益的圖片，會建議使用 png 來作為顯示的格式，主要是 png 具有以下的特性： 高品質 - 確保顯示的品質 點陣 - 增加畫面的真實性 透明特性 - 可採用堆疊的方式呈現 如下圖，為了確保圖片品質及精緻甜點的口感，png 是不錯的選擇。 主要圖片除了有良好的呈現外，必要時還需要兼顧不同裝置的「顯示清晰度」，如一般的螢幕的 PPI 約落在 100 上下（PPI 說明），但到了部分裝置的 PPI 就會達到 320 甚至更高的 PPI（如 Apple 的 Retina Display），此時就會建議使用「雙倍」以上的尺寸做輸出。 以 Sketch 為例，當輸出一張長寬為 1200 * 628 圖片時，如果調整為 2 倍尺寸則會輸出一張 2400 * 1256 的圖片。 此時也要特別注意，圖片的檔案大小將可能成長為四倍，如一張 700kb 的圖片輸出成 2 倍尺寸大小時，檔案可能成長為 2.4mb。因此實際運用時會建議隨需求調整圖片輸出的大小，設計師部分可以規劃不同尺寸的輸出，而前端在此就需要依據需求調整運用的倍數。 使用 png 例外情況： 圖片過多，需要兼顧網路速度時還是會建議轉用 jpg 圖片是人工繪製，向量是更好的選項時會建議使用 svg 手繪向量圖片 svg 依然是好選擇：圖片來源 Github 背景圖另外，背景圖片的運用也是很重要的，相對於主要圖片來說背景圖片的重要性降低很多，如果畫面同時是使用真實景色的圖片，會更建議使用 jpg 來做呈現，藉此降低檔案的尺寸。 Yahoo 氣象的背景會使用當地的風景圖片，藉此來呈現符合情境的資訊，而這麼大張的圖片作為背景，如果使用 png 將會佔去不少流量，所以使用 jpg 將是一個好選項（原圖 1280 * 720，約 170kb）。 大多數來說，真實圖片的背景會使用 jpg 來呈現，這裡也介紹一個圖案類型的背景網站給大家參考，由於這個網站是使用「四方連續」的背景手法，這類型的圖片僅需要小小一張就能不斷重複使用，所以就直接使用 png 來維持背景圖的品質，網址：https://www.toptal.com/designers/subtlepatterns/ 此網站的背景風格非常多，下載可同時選用 2 倍尺寸的圖案，網站的圖案都是可以免費使用，但請注意 使用條款及 FAQ 結語現在工具輸出圖片也越來越方便，只要一鍵就可以大量輸出，因此設計師更需要了解各種圖片格式的差異，並且輸出符合需求的格式以便於工程師作為開發使用。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 文字大小、行高與空間上的關係","slug":"fonts-family","date":"2018-10-26T16:00:00.000Z","updated":"2018-10-27T06:30:33.070Z","comments":true,"path":"design/2018/10/27/fonts-family/","link":"","permalink":"https://wcc723.github.io/design/2018/10/27/fonts-family/","excerpt":"","text":"一般平面設計師再進入網頁環境時，會不清楚網頁設計所用的單位數值，造成設計稿與開發的畫面有嚴重的落差；且網頁設計本身有許多「慣用的數值」，建議一開始也能先使用大家通用的數值，待了解所有數值對於畫面、軟體、技術上等影響後再做調整。 文字樣式屬性由於網頁並沒有像繪圖軟體那麼的自由，所以才會有許多文章提到「設計師需要學程式」，因為之中有許多技術限制需要設計師去理解，這會有助於設計執行上的可行性。 文字單位文字分為絕對單位及相對單位，絕對單位與平面設計概念一致，基本上是設定多少，畫面呈現就是固定大小；而相對單位則是沒有固定大小，所設定的數值會受到外層、HTML 設定、裝置畫面大小等等而定，相對來說靈活很多，但在掌握上也困難許多。 絕對尺寸： px：最常使用的絕對單位，過去會使用略小的數值，目前是以預設的 16px 為主，請避免設定過小的字體導致閱讀上的困難。 pt：很少用到的數值，請不要用印刷的 “pt” 作為「螢幕顯示」時的單位（另一種 pt 為 iOS 上所定義的 pt，是接近於 CSS 上的 px，這段確實很容易搞混，請謹記不要使用印刷及 CSS 的 pt 單位即可）。 相對尺寸： em：1em = 一個字體大小，是相對於父層的單位，所以當父層為 32px 時， 1em 則為 32px 大，而這個數值可以不斷疊加。 rem：目前主流的單位尺寸，1rem = 一個字體大小，相對於 HTML 所定義的文字大小而定，可以在頁面呈現後調整設定值修改畫面的單位尺寸。 %：類似 em，使用上沒有太大差異，細節可參考。 vw, vh：1vw = 瀏覽器的寬度，1vh = 瀏覽器的高度，比較常用在畫面上，但也是有機會用在文字上，如：Header 的主要文字。 延伸介紹：實際展示 EM 與 REM 的差異 文字尺寸目前來說，網頁開發大多都是使用 16px 作為基準字，雖然設計訓練中都習慣將文字縮寫以增加質感，但請別忽略網頁本質是為了傳達訊息，且小字在行動版上閱讀上更為困難，盡可能維持預設值來製作網頁設計。 由於 rem 的出現，我們不再需要行動版與桌面版完全統一相同的字體大小（雖然實作上還是同一為主）。設計時我們依然會以 px 為主，但為了配合開發上的方便，通常會使用固定級數的方式作為大小字的變換，範例如下： 1234567設計師用的尺寸： 工程師所用的尺寸16px : 1rem20px : 1.25rem24px : 1.5rem28px : 1.75rem32px : 2rem40px : 2.5rem 同理，如果將預設尺寸改為 15px，相關的數值也會重新調整（15px = 1rem,30px = 2rem…）。 設計上注意事項當如果使用 rem 為單位時且預設值為 16px 時，應避免出現 17px, 21px, 25px 這種尺寸造成轉換上的困擾（就算不使用 rem 也不該如此 :D），盡可能維持相同邏輯在執行網頁設計。 行高平面設計中，我們習慣使用固定的數值，例如 12pt 的文字大小搭配 16pt 的行高，但在網頁設計中則習慣使用相對的倍數來呈現；如 line-height: 1.5 來代表 1.5 倍的行高，此時文字大小如果設定為 16px，那麼行高則為 24px。 並且行高的設定，通常會設置於網頁的 body 上，也就是全網站套用相同的預設行高，如果有例外再另外條整。 12345如果 body 行高設定為 1.5其它文字大小的相對行高16px : 24px20px : 30px24px : 36px 除此之外，行高的設計也會影響到「空間的顯示」，平面設計中的文字空間與其它圖文基本上是毫無關聯性的，但在網頁設計中除了設定成絕對定位，其餘物件的空間都會有彼此的關連性。 下方是行高 1.5 倍的文字段落，所佔用的區塊則使用橘色顯示，後方緊貼著一塊紫色方塊，這個方框並不會與文字產生空間上的交錯。 以下分別使用行高 0.6、1、1.5、3 再呈現一次，如果行高使用 0.6 的情況，文字會超出橘色的空間範圍，並且與紫色產生些微的交錯；而在行高 3 時文字距離橘色邊框距離增加許多，並且會將紫色方框推向後方。 設計上注意事項因此在設計文字時，也要注意繪圖軟體所呈現的範圍，如下圖：當設計 line-height 為 3 倍時，繪圖軟體自然會使用正確的方框尺寸，此時應避免與其它元素產生交錯。 另一個常見的錯誤習慣因為行高會影響到文字呈現的空間，因此會有不少網頁設計師透過 line-height 來製作垂直置中。這會導致文字再多行時也會使用到錯誤的行高，並且會降低 CSS 的設計彈性，因此非常不建議使用 line-height 的數值製作垂直置中。 1234.vertical-align &#123; line-height: 48px; height: 48px;&#125; 正確應使用 padding、flex 等方法來做垂直置中。 結語本篇的文字設定在畫面上很難找到問題，但會影響該設計師是否易於與工程師配合，所以追求美感的同時，依然要注意畫面的邏輯及可行性。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計 - 網路字體運用","slug":"web-fonts","date":"2018-10-25T16:00:00.000Z","updated":"2018-10-26T03:49:42.770Z","comments":true,"path":"design/2018/10/26/web-fonts/","link":"","permalink":"https://wcc723.github.io/design/2018/10/26/web-fonts/","excerpt":"","text":"字體如果沒有授權問題，是否能夠直接嵌入於網頁之中呢？（請注意：大部分中文字體都會有授權的問題） 當然是可以的，英文網站中許多都會使用自訂的字體，但中文字體可就沒有這麼容易。因為英文字體檔案小，直接寫入 CSS 即可運作，而中文字體動輒數十 MB，Noto Sans 整包甚至高達上百 MB，下載這些字體就會花去許多時間且非常消耗網路資源。 英文網頁字體英文字體運用上僅需要注意授權，而最大宗的免費字體就是 Google Fonts，包含襯線、無襯線、裝飾、等寬、手寫等等風格，而這些字體都有完整的預覽及字重選擇。 如果不是對於字體有極端要求者，這個網站已經可以滿足大部分的需求。 選用特定字體後，也能自行調整所需要的字重，避免一次載入過多的字體導致下載速度變慢。 中文網頁字體中文字的網頁字體就沒有那麼容易了，主要原因在於中文字太多導致檔案太大，另外就是中文字的廠商大多不會免費提供（畢竟字太多難以開發，很難免費授權），所以這些就要找專屬的線上字體供應商，如台灣知名的 華康、文鼎 到先前知名的金萱字體開發商 Justfont 都有提供這樣得服務。 這些服務是直接從網頁中透過 JavaScript 取得所用到的中文字體，再從伺服器重新下載這些字型，所以速度會比直接直接下載完整字體檔案快上非常多，但也因為如此這類型服務都需要另外付費才能使用。 另外Google 也有推出 Early Access 的 Noto Sans，在這之中也當然包含繁體中文的 Noto Sans。 這段也有看到 Google 不斷的在優化這段服務，最近一次測試 Noto Sans Regular（中等字重）的下載大小僅需要 1.8MB，實際體驗上速度也比先前快上許多，但畢竟是屬於測試中的服務，使用時還是多虛注意。 網頁設計的注意事項因此，我們在設計網頁時盡可能使用系統預設的字體，系統預設字在網頁上都有經過優化，所以都有很好的閱讀性（大部分系統文字在 12px 都還有不錯的辨識性）。設計時也可以依據主要用戶群（桌面、行動版）、較多人使用的系統作為設計（如微軟的正黑體）。 尤其在中文的部分，未搭配任何 Web fonts 服務時應避免使用特殊的字體，多利用系統的字體來進行設計。有搭配 Web fonts 服務時可多將字體利用在標題上以維持文字的辨識性，如果用在內文，須確保在不同的系統上辨識性依然是足夠的，如其它明體在小字時就不一定比「新細明體」辨識性還高（可參考：https://www.justfont.com/fonts）。 思源明體在 16px 左右的狀態 系統字體 16px 而在更小的字體上落差也會更為明顯，使用前可多利用該服務來做測試，並且選擇合適的字體運用。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：系統字體介紹","slug":"fonts","date":"2018-10-24T16:00:00.000Z","updated":"2018-10-25T03:23:56.674Z","comments":true,"path":"design/2018/10/25/fonts/","link":"","permalink":"https://wcc723.github.io/design/2018/10/25/fonts/","excerpt":"","text":"字體一直是設計師排版的關鍵之一，但由於網頁設計受到技術、法規、網路影響，在網頁上能夠使用的字體非常有限，本篇文章其實並非告訴大家怎麼使用字體才會「美」，而是了解字體運用上的「限制」，避免設計出執行上有困難或是效能極差的網頁。 字體分類字體因為外觀的關係而有不同的名稱，如：黑體、明體、襯線、無襯線等字體，以上或許大家都有聽過名稱，但不清楚外型（如果熟悉可以跳下一段），這裡就來解釋這些字體的分類及常見用途吧。 serif 歐文襯線字體 外觀：中文在末端會有凸起的裝飾線，英文則是在頭尾皆有額外的裝飾線 運用：帶有人文氣息，因此大多會運用在具有歷史、文學、文化的內容。 sans-serif 歐文無襯線字體 外觀：無論中英文皆沒有任何裝飾線 運用：較無個性，帶給人科技、現代、正式的感覺，使用上非常廣泛。 中文部分則是稱為黑體及明體，外觀上明體接近於「歐文襯線字體」；黑體則接近於「歐文無襯線字體」。這兩者有許多文件會視為同類別（如：黑體 == 歐文無襯線字體），但也有許多專業設計師會視為不同類別，在此特別說明。 而系統上也都有包含預設襯線與無襯線所預設的中英文字體，除了上述兩種外系統內還有 cursive、fantasy、monospace，但這些字體就並非有完全對應的中英文，實作上還是以襯線與無襯線兩種為主。 詳細文章：https://wcc723.github.io/css/2014/01/01/font-family/ 必要熟悉的系統字體目前常見的系統包含 Windows、MacOS、iOS、Android、Linux…等（本篇不介紹 Linux 家族。），每一種都還包含了中英文、襯線、無襯線等等（本篇以無襯線為主），而這些系統字體大不相同，更不會有自定的字體出現。 Windows使用人數最多的桌面作業系統（80%），無論是熬夜打電動、做作業、寫程式、畫 3D 都有不錯表現，因此所使用的系統絕對需要熟記～。 英文：在過去是使用 Arial，這款是仿造 Mac OS 的 Helvetica 字體所製作而成的，現在則是使用 Segoe UI。 中文字體：微軟正黑體，相當經典的黑體字，缺點是只有單一字重，缺乏較粗或較細的字體。 另外 Windows 系統預設的中文字體是「新細明體」，這款字體在單級數字級會有比較好的閱讀性（13px, 15px, 17px 字體顯示會較為銳利），但實作中還是以雙數字級（16px, 20px, 24px…）為主，使用上要特別注意。 Mac OS / iOS蘋果一直以來對於字體就非常要求，包含不同解析度、閱讀性、字重等等都很要求，現在的版本更提供專屬的中文字體，讓開發者、設計師、使用者都有很好的使用體驗。 英文：過去是使用 Helvetica Neue 的經典字體，現在無論是 iOS 或 Mac OS 均是使用 San Francisco，這款字體不會直接出現於繪圖軟體之中，如需可用前文連結另外安裝。 中文字體：現在是使用蘋方字體，這款是少見包含「多個字重」的中文系統字體（5 種），設計運用上自然能有更多的發揮空間。 AndroidAndroid 雖然有提供系統字體，但各家廠商製作手機時依然可以調整預設的系統字體，在此僅是提供主要的預設字體。 英文：Roboto ，這一款字體運用上也是非常靈活，擁有 6 種字體且均另有斜體（italic，共 12 種），根據 Google Fonts 的統計，這個字體已經運用在 22,000,000 個網站上。 中文字體：資料上顯示有兩款 Droidsansfallback 及 Noto Sans（我傾向是後者，有錯請指正），Noto Sans 是 Google 與 Adobe 公司共同研發的開源字體，包含 7 種常用字重並且幾乎包含所有中文字，號稱最不會缺字的字體庫，目前是設計師必備的中文字體。 另外提到，Noto Sans 是 Google 及 Adobe 合作的字體，在 Adobe 的服務中稱這套字體為「思源黑體」，在繁體中文的國家中，Noto Sans 基本上也是依據台灣官方規定的筆畫規則，是一款非常優秀的字體。 另外還有推出「思源宋體」（Noto Serif），相關的介紹可以參考 介紹頁面。 結語了解預設字體是非常重要的，原因是「系統字體」是經過系統廠商所優化，普遍來說在各種情境都有較好的閱讀性；此外，每台電腦所安裝的字體也會有所不同，不可能要求一般用戶去下載未授權的字體，或是下載 Noto Sans 來做使用。 因此，使用第三方的字體可能會造成： 可能缺乏良好的閱讀性（小字、色彩不明顯時） 用戶並未安裝該字體，導致畫面不如預期 缺字，導致字體顯示不一 但有些時候，依然會推薦使用其它字體來凸顯網頁的部分關鍵用詞，下一篇將會介紹一些網路服務來運用額外的網路字體。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：色彩運用(3) - 按鈕的配色","slug":"button-color","date":"2018-10-23T16:00:00.000Z","updated":"2018-10-24T02:37:08.379Z","comments":true,"path":"design/2018/10/24/button-color/","link":"","permalink":"https://wcc723.github.io/design/2018/10/24/button-color/","excerpt":"","text":"上一篇透過連結的狀態了解運用，本篇則是探討按鈕再運用上的色彩變化，包含了一般、行動呼籲、外框線、警告意味等常見的類型，當然這些類型介紹上別不會包含上一篇的 “狀態”，實作中依然要記得補上喔。 一般狀態一般狀態通常是最沒有特色的，但使用上也是最為普遍的，這類型的按鈕通常不會帶有太多色彩，並不會特別引人注目，目的也是讓用戶了解的要執行、連結等等。 設計：越普通越好 Call to Action宣傳網頁、登入頁等等都會有一個按鈕引導用戶到達特定目標，行為上我們稱為「Call to Action」，因此這類型的按鈕都會特別顯眼，配色上則會使用「主色」或「次要色」，並且以「填滿」的方式配置。 也因為這類型按鈕非常重要，所以相似的按鈕一個畫面中不會出現太多次，如以下範例所示，大多服務都是使用在「註冊」上（Airbnb 則是用在搜尋，所以對他們來說搜尋比註冊更為重要），必須謹慎配置這類型的按鈕，請把它用在最重要的地方。 https://github.com/ https://azure.microsoft.com/zh-tw/ https://www.airbnb.com.tw/ 設計：主色或次要色，並且填滿它 Outline幾年前開始出現的一種按鈕風格，當時有一種暱稱為 Ghost button，相對於填滿的按鈕來說它的顯眼程度沒有那麼高，但依然能夠符合網頁的主題配置，所以重要性也是介於普通按鈕及 Call to Action 之間，很適合用在宣傳網頁、登入頁的次重要性按鈕。 如下 Uber 的網頁來說，最重要的是引導人們註冊成司機，其次則是引導乘客註冊。因此這個網頁的動機是尋找引導駕駛比引導乘客更為重要。 https://www.uber.com/zh-TW/tw/ 在 Palantir 的登入頁來說，並不需要引導用戶註冊或購買，重要的是傳遞訊息、故事，因此沒有使用 Call to action 的按鈕，取而代之的是 outline 按鈕來引導用戶觀看他們的故事。 https://www.palantir.com/ 警告警告意味的按鈕是傳達此按鈕的危險性，所以與 Call to action 是相反的概念，警告是避免用戶點擊，Call to action 則是期望用戶點擊（許多電商都是使用橘色、紅色填滿作為 Call to Action。）。配色上大多會使用紅色，並且以「白底紅字」的方式避免過於顯眼，所以無論主色或是次要色選擇了紅色，都會避免使用紅底白字的方式在呈現，因為這樣的配置會吸引用戶點擊。 以 Github 的 Danger Zone 來說就是使用細紅框搭配紅字按鈕呈現，除了提醒用戶這個區域的安全性外，也避免吸引用戶目光。 避免使用紅色的按鈕，他會吸引用戶目光點擊（警告都不警告了）。 以上是常見的情境，大家可以依據這些概念看看國內外網站，是不是有很多符合這樣的情境，這些概念同時也可以運用在自己開發上並思考以下事情： 網站最重要的行為是什麼？ 當下按鈕的重要性？ 當下按鈕所傳達的情緒（警告、興奮、買買買）？ 藉此來調整網頁的行動配色喔 :D。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：色彩運用(2) - 連結的配色","slug":"link-color","date":"2018-10-22T16:00:00.000Z","updated":"2018-10-23T02:07:15.137Z","comments":true,"path":"design/2018/10/23/link-color/","link":"","permalink":"https://wcc723.github.io/design/2018/10/23/link-color/","excerpt":"","text":"除了親和性的配色外，訊息的傳遞也是很重要的，與平面設計不同的是訊息並非只有圖文的傳遞，還包含了狀態、互動、提示等等訊息，訊息也同時可以用許多不同色彩表示，增加訊息所能表示的情感、急迫性、引導性等等。 連結色彩（包含不同狀態）網頁設計中的 &lt;a&gt; 除了本身的預設樣式外，另外還包含以下幾種 “狀態” a:link - 未拜訪過的連結。 a:visited - 已拜訪過的連結。 a:hover - 滑鼠回入的連結。 a:active - 按下狀態的連結。 a:focus - 鍵盤專注的狀態。 a:link - 未拜訪過的連結及 a:visited 已拜訪過的連結，這兩種並非在所有網站都有這樣的需求，通常會運用在「需要紀錄已讀取」的網頁上，像是搜尋引擎就是很好的例子（但現在很多都改用 JavaScript 來設計）。 設計：可視專案需求來決定是否加入這個樣式。 a:hover - 滑鼠回入的連結，這個樣式普遍都會製作，主要讓用戶滑鼠滑入時了解「這是一個可互動的按鈕」，如果少了這個樣式用戶可能會誤以為沒有連結。但要特別注意，這個樣是在行動版無法正確的呈現（因為手機沒有滑鼠 hover 的事件）。 設計：在文本中的設計中大多會使用略深的主色或次要色，然後加上下底線作為呈現。 如果以按鈕呈現，也會使用略深為按鈕原色的設計 a:active - 按下狀態的連結，這是滑鼠按下的樣式，通常會與 .active 一起製作，而 .active 可以透過後端或 JavaScript 直接套用在按鈕之上，表示目前啟用中的按鍵。 設計：通常會使用略深於普通狀態的色彩，設計時可以與 .active（啟用樣式）一起設計（文本有時不會設計，或同 hover 樣式）。 a:focus - 鍵盤專注的狀態，許多用戶會使用鍵盤搭配 tab 來瀏覽網頁（也有一部分是屬於視覺障礙者），這個專注狀態可以讓用戶了解目前「專注」的按鈕，如果用戶需要按下此按鈕，則可以按下 Enter 鍵。 設計：文本中會使用瀏覽器預設的外框，主要是因為文本中不一定能調整高度，視覺上可能會干擾到其他文字的閱讀，因此不一定會另外設計。 按鈕會在原本按鈕外增加一圈類似色彩，如果沒有另外設計則會套用瀏覽器預設的樣式。 瀏覽器預設的 focus，每個瀏覽器略有不同（下圖為 Chrome 的樣式），預設樣式不會隨著網站設計改變，大多會使用藍色外框，因此會建議自行設計。 部分網頁設計師由於沒有程式開發的經驗，所以會忽略許多行為上的樣式狀態，除了 link, visited 外，其餘都是設計時必備的項目，一開始就必須加入喔。 結語按鈕互動對於使用者回饋相當重要，如果缺乏足夠回饋，用戶時常會以為該連結是否無法運作。而設計師為了追求畫面上的完美，有時會疏忽掉用戶操作的回饋，執行上則會建議一開始預先定義相關元素的互動狀態、錯誤行為等等，避免後續開發上的疏忽。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：色彩運用(1) - 你的網頁文字是否足夠清楚呢？","slug":"accessibility","date":"2018-10-21T16:00:00.000Z","updated":"2018-10-22T03:19:01.859Z","comments":true,"path":"design/2018/10/22/accessibility/","link":"","permalink":"https://wcc723.github.io/design/2018/10/22/accessibility/","excerpt":"","text":"上一篇介紹了整體色彩選擇，按造該概念完成一個網頁相信不是什麼問題，不過色彩到底怎麼選？運用上有什麼需要注意的？本篇就來介紹一下吧。 Accessibility：這個單字翻譯有很多意思，如：「無障礙」、「親和性」、「可訪問性」，其中我最喜歡的是親和性的翻譯，因此把它作為此篇文章的標題，而在 Google 的相關文件中翻譯為「可訪問性」，在本文中看到「親和性」、「可訪問性」都是指此單字喔。 網頁可訪問性分數網頁配色時除了要好看之外，色彩所造成的訊息傳遞功能依然不可降低，如黑底白字、白底黑字是普遍來說閱讀性佳的色彩組合，但這個組合並不一定適合所有的品牌配色，如果品牌顏色為綠色（#509955）那麼這樣的顏色作為文字色彩閱讀性是否足夠呢？ 網站內容親和性規範 The Web Content Accessibility Guidelines (WCAG 2.0) 將文字與背景對比度區分為不同等級，在主要的內文排版中至少要有 4.5:1 的對比度（AA 級），除了一些情境之外可以不需要達到這樣的標準： 較大的文字：超過 18px 或 14px 的粗體文字對比度可降為 3:1 附屬的文字：裝飾或者圖片一部分的文字可以不遵循此標準 品牌文字：如果文字為品牌一部分，也可不遵循此標準 Google 的 Web Fundamentals 有完整一篇文章說明該如何實踐這個概念（可訪問的樣式），下圖也演示了不同對比度的視覺關係，4.5:1 則是大部分可輕鬆閱讀的對比度，如果您的網站需要給予老年人或視力不佳的人閱讀，建議可以將標準提高到 7:1。 回到前文所說：「如果品牌顏色為綠色（#509955）那麼這樣的顏色作為文字色彩閱讀性是否足夠呢？」，以下簡單介紹該如何檢視此段文字是否符合標準。 這次透過該色彩所展示的一段文字，無論現在肉眼看起來是否足夠清晰，我們來透過工具說明是否符合標準。 接下來透過開發者工具，點選該文字 -&gt; 右鍵 -&gt; 檢查 可以看到如下的介面，然後再點選色彩就能看到以下資訊。（如果不知道如何使用開發者工具，可以參考我們的免費課程：https://www.udemy.com/chrome-devtools/） 接下來，點選 Contrast ratio 右方的箭頭 icon，展開看更多細節，接下來可以直接透過上方的色版調整色彩，色版中也給予建議的標準線，只要超過標準線就至少通過 AA 級，下方也有標示是否符合 AAA 級的對比度。 接下來我選擇一個 #458449 的色彩至少符合 AA 級（4.54:1）。 再重新查看此文字是否符合網站的標準色，我們也可以用此方法作品牌色的延伸，套用至所有的網站文字之中。 另外，這個工具也可針對不同色彩的背景做調整，如下圖我選擇另一個藍綠色作為背景色， 此時對比度也會顯示不足夠。 結語色彩的親合度使用上也必須注意不同的背景色變化，以及互動連結、按鈕等等的搭配，甚至還有針對目標群眾調整更高對比（年邁、視力不佳者），符合品牌的同時，我們還有很多的細節可以處理喔 :D。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計色彩配置概念","slug":"color","date":"2018-10-20T16:00:00.000Z","updated":"2018-10-21T06:53:51.039Z","comments":true,"path":"design/2018/10/21/color/","link":"","permalink":"https://wcc723.github.io/design/2018/10/21/color/","excerpt":"","text":"根據上一篇介紹的設計規範參考，實戰中有許多需要事先定義，而色彩是使用者打開網站最先體驗到的部分。好比說 Facebook 的深藍色、Google 的紅色、LINE 的綠色，Yahoo 的紫色，這些色彩都深深的存在我們腦海裡，所以在決定這些色彩絕不能馬乎，如果換了色彩用戶還可能會想「我進錯網站了嗎？」。 除此之外，每個色彩也帶有不同的行動意味，因此顏色要怎麼選、怎麼配才會好看、好用呢？畢竟五顏六色的網站經常讓人找不到重點且美感難以控制。 簡單的方法：選一個主色貫穿全場吧講古中…在過去，Material Design 是選擇雙色，一個主色（primary color）另一個強調色（accent color）的配置方式；主色是全畫面的主要色彩配置，這也是帶給用戶主要觀感的色彩，佔去畫面的主要區塊。而強調色只在部分的區域，目的是增強部分重點的視覺性，如：重要的互動性元件、重點文字等等。 重點：兩個顏色，一個稱為「主色」另一個為「強調色」 主色：主要是品牌色彩，除了底色為是最容易被記憶的部分，會運用在網站大多地方，除了本身的色彩外，也會依據明度的調整來做相關的延伸。 強調色：凸顯的色彩，可以使用主色的對比色，這類的色彩通常強烈、明顯如：紅色、黃色等等，大多用在互動性的元件或需要特別重要的文字。當然，除了本身的色彩外，也會依據明度的調整來做相關的延伸。 案例如下，主色為整個畫面中的核心色彩，除了底色外另一個會被使用者所關注的色彩即是「主要色」。而強調色則是運用在「互動」、「重點標示」，且要避免強調色運用在網站上過多的地方（否則就失去強調的意味）。 現在Material Design 目前則是使用一個主色（primary color）及一個次要色（secondary color），在名稱上就可以看出和過去的不同，且文件中也說明到：「如果你並沒有次要色，你的主要色同樣可以用在主要的元素上」（If you don’t have a secondary color, your primary color can also be used to accent elements.）。 而這兩個顏色作用上與過去的主色、強調色觀念一致，但在選擇上確有所不同，次要色改成「非必要」的存在。 如下圖，這個網頁中選擇一個紫色作為主色調，並且透過明度調整增加豐富性並利用在所有的地方，這個網頁也並沒有使用到次要色。 另外一個包含次要色的範例，除了剛剛的紫色外，也可以選擇一個次要色作為重點的強調，這裡的次要色類似先前版本的「強調色」。 實際案例而無論是過去或現在的選擇一組「主色、強調色」或者是僅選擇「主色」，在網頁設計上都是很常被運用。 Evernotehttps://evernote.com/intl/zh-tw 單一主色貫穿全部，僅有主色的明度調整，互動元件上也沒有額外的次要色，在畫面上也顯得乾淨一致。 Airbnbhttps://www.airbnb.com.tw/ 單一主色，僅把主色放在品牌及最重要的互動按鈕上，其餘地方則會使用不明顯的色彩來標示。 Udemyhttps://www.udemy.com/ 同樣是單一主色套用在品牌色、重要的互動按鈕上。 Shopify 電商版型https://themes.shopify.com/themes/empire/styles/supply/preview現在使用主色、強調色的配色方式已經比較少了，但還是會有電商類型的網站會用這樣的配色來增加轉換率。 Sketch APPhttps://sketchapp.com/這也算是單一主色（橘色），特別的是有搭配一個粉紫色漸層作為背景、文字配色，但整體的互動還是圍繞在橘色上。 簡單回顧一下配色的選擇方法： 選擇一個主色，盡可能用它來作為全網站的配色延伸 選用一個次要色，作為網站強調性文字、按鈕的配色，但這個選擇是非必要的。 經驗上，過去有許多雙色（主色、強調色）的案例，而在最近有趨向轉為單主色，所以這樣的觀念並非長久不變，我們可以從文件、國內外的網站觀察變化，並且依據我們製作的專案需求調整設計，而設計除了做的美，還要學會從固定的規則中尋求變化。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：文件、規範參考 - Material Design","slug":"design-guide","date":"2018-10-19T16:00:00.000Z","updated":"2018-11-13T02:41:01.221Z","comments":true,"path":"design/2018/10/20/design-guide/","link":"","permalink":"https://wcc723.github.io/design/2018/10/20/design-guide/","excerpt":"","text":"程式領域裡面非常重視文件，當然 UI 中也是如此，為了確保設計可以被執行，大型應用程式、系統都會推出屬於自己的規範，如： iOS 的 Human Interface Guidelines Google 的 Material Design 而除了上述的作業系統 / 應用程式外，網頁開發也是有相關的概念，在 Styleguide 這個網站中就可以查詢到許多相關的範例。 規範可以帶給我們什麼？簡單來說就是限制設計師的風格，一般來說設計師都會有屬於個人的個性及風格，而網站開發都並非少數人即可完成，就有可能出現同一個顏色各自表述的情況，可能會發生的狀況有： 色彩不統一：我的紅與你的紅不同 間距不同：有些設計師偏好雙數的間距，也有設計師喜歡 5 的倍數 字體、字級、字重不同：就算是相同字體、字級，設計師也可能選擇不同字重 插畫風格不同：每個設計師的手繪能力也不同，所以也會造成插畫風格上的差異 格線定義不同：這個在上一章也有提過，設計稿如果格線不同也就難以對齊 動態轉換不同：雖然在網頁中比較少演示這一段，但轉換速率、漸變函式 （ transition timing function ）不同，使用者體驗也會有不一致的問題。 就以 Material Design 來說，建立網站色表時也可以同時產生 主色、次要色、延伸色、背景色、錯誤、文字應用色等等，那麼接下來做延伸設計時也可運用相同觀念。 色彩選定後 Material Design 也會提供許多案例供設計師了解這配色該如何運用，以下圖來說錯誤訊息應使用 Secondary Color，而不是使用帶有緊告意味的色彩或是其它品牌色作為強調色 Material Design 的優點除了 iOS、Material 這兩大系統的規範外，製作網頁其實也有很多規範可以參考（Styleguide ），此時可能會思考為何要閱讀 Material 這樣的規範呢？ 除了有固定的樣式外， Material Design 提供了許多優良概念值得去思考，這部分列出一些我認爲很棒的概念給大家參考： 「紙」的風格https://material.io/design/iconography/product-icons.html#design-principles相對於目前主流的設計風格，大多強調簡潔、色塊，而 Material Design 卻在此基礎之上帶入「紙與墨」的概念，本段就以圖示來介紹是如何呈現紙的風格在內。 為了呈現出紙的風格，所以繪製 icon 時會直接製作出實體，並且觀察實體的光影變化（根本就是在畫素描水彩），透過實際觀察了解紙的切面、陰影、反光等視覺特性。 透過手工製作的 icon，這也是我們熟悉的 Gmail 雛形 打光，我們可以看到陰影的變化，除此之外也可以關注切面所產生的反光，這會讓紙的呈現包含厚度。 實際繪製及上色。 透過這樣的案例，對於圖示也定義了繪製的規範，使所產生的圖示具有一致性。如卡片的邊緣就使用如下的規範定義： 上邊緣： 高：1dp 透明度：20% 色彩：White (#FFFFFF) 下邊緣： 高：1dp 透明度：20% 色彩：參考相關色調及陰影 陰影所代表的 「深度」網頁是平面的，但內容在城線上還是會有前後的順序，如「操作中的物件」為了讓用戶了解他是正被操作的，可以使其更明顯些；而除了外框、修改色彩的方式，深度也是凸顯物件的好技法。 下圖中，拖曳的物件所產生的陰影，會讓物件感覺比較前面。 實際演示的動畫 下圖兩個物件有著不同陰影，因此會感覺深度不同。 深度的概念：下圖中 A 與 B 視覺上會感覺具有相同深度，從正面來看因為 A 具有 8dp 的陰影深度，B 與 C 各有 4dp 的深度，總合上與 A 相同，就會讓用戶感受到兩者的高度（重要性）是接近的。 結語本篇僅是概述設計規範所帶來的觀念，在此非常建議可以親自閱讀這些觀念，身為設計師會不斷的追求「創造力」及「獨特性」，Material Design 說明如何將一個實體的概念轉化為規範，其中的過程更能激發設計師的思考，除了學習符合開發的需求外，更從中了解如何創新。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計常用格線系統(下)","slug":"grid-system-2","date":"2018-10-18T16:00:00.000Z","updated":"2018-11-13T02:43:40.372Z","comments":true,"path":"design/2018/10/19/grid-system-2/","link":"","permalink":"https://wcc723.github.io/design/2018/10/19/grid-system-2/","excerpt":"","text":"上一篇介紹了格線系統的概念及計算方式，擁有了這些觀念後會如何運用在繪圖軟體上呢？無論你是使用 Sketch 或是 Adobe XD 都可以快速建立如前文所提到的格線，本篇不會著重在軟體的操作，而是網格如何運用在網頁的設計上。 實際運用 格線與響應式的搭配 實際運用假設我們的網頁內容包含了以下元素： 頂部的大 Banner（頁首） 側邊選單 主要內容區域 頁腳 我們一樣先依據下圖的數據打開格線系統，如果有必要也可用更大或更小的數值調整。 接下來可以依據這個概念將元素一個一個繪製到畫面上，所有的相對位置大約會如下圖呈現（選單佔 3 欄寬，內容佔 9 欄寬，中間保留一個 Gutter 寬）。透過格線系統的限制下，將不需要花太多精力去思考“水平空間” 及 “水平間距” 需要多大，只要貼的格線繪製都會顯得整齊。 這個概念下，如果有額外的需求也能跟著調整，假設需要增加三個廣告欄位在畫面上，那麼我們可以將三個廣告做 4 欄寬的設計（12 / 3 = 4），也可以如下圖的呈現： 雖然廣告欄位與選單、主要內容區塊的垂直線並沒有完全對應上，但因為具有固定的間隔，還是感受到它具有一定的規範。 額外問題：如果廣告欄位與欄位數不一致怎麼辦？雖然格線系統限制了思維模式，但如果同時熟悉網頁開發技巧其實可以做這樣的變化，廣告欄位維持 4 欄寬度，超過 100% 寬度後將會自動換行，並且以置中的方式來繼續做排列。 格線系統與行動版網頁現在行動版網頁盛行的情況下，網站支援手機瀏覽也是很正常的，而格線系統當然也可以應用在行動版網頁，觀念上大致上差異不大，僅需要調整一些數值即可。先假設需要預覽的寬度為 320px，那麼我們可依據公式將數值調整為如下：公式：((320 - 20) - 20 * 3) / 4Total Width: 320Number of Column: 4 -&gt; 行動版建議不要有太細的欄位數，建議以單欄為主Gutter Width: 20 -&gt; 不變Gutter on outside: 10 -&gt; 不變Column Width: 60 -&gt; 由於欄位數大幅的減少，因此欄寬度也維持在 60px 行動版網頁在瀏覽時會以單欄為主，因此會將原本的內容轉為 100% 寬度，次要的內容會轉為 50% 寬度，甚至是 25% 寬度。 轉換的結果如下圖，元件還是依然的緊貼於格線之上，主要內容佔有 100% 的寬度，保有最大的空間讓用戶可以輕鬆地閱讀。 而在這樣的格線轉換，設計師不需要花費太多心力去計算寬度的轉換，雖然僅製作了 320 寬度的版型，工程師也能從「相同的邏輯延伸出不同尺寸下的變化」，且這樣的公式也能透過 CSS 來得以實踐。 Bootstrap 框架除了設計軟體隨著網頁發展有了新工具，網頁本身在開發時也有許多現成工具可運用，如 Bootstrap 就是網頁開發中最廣泛運用的 CSS 框架，提供了許多現成的組件直接運用，當然也有網格系統在其中。 Bootstrap 的網格系統中包含了多種裝置的設計，對照它所提供的數值其實與剛剛所運用的差異不大，除了 Gutter 為 30px 並非 20px。所以本篇所介紹的內容，只要將格線間隔調整為 30px（實際上維持 20px，Bootstrap 本身也能配合執行），也可以使用 Bootstrap 來執行，並且同時包含桌面版及行動版。 實例接下來你或許會思考「這個概念是否有被廣泛運用」？其實可以從網站中的原始碼尋找一些蛛絲馬跡（因此必須要有查看原始碼的能力），最簡單的方式可以在網頁上按下右鍵 -&gt; 選擇「檢查」。 接下來使用畫面上的小工具來選擇網頁中的區塊。 範例網頁：https://events.google.com/io/畫面中我選擇到了一個區塊，上面的程式碼 grid__item--12-cols grid__item--6-cols--gt-sm中的訊息為： grid__item–12-cols：預設為 12 欄寬 grid__item–6-cols–gt-sm：在小裝置以上時，改使用 6 欄寬 接下來我們可以用相同手法在各個網站尋找，這些概念目前已被廣泛的運用。不過由於網頁技術不斷的跟進，並不一定需要像過去定義欄位數才能完成這樣的排版，甚至可依據內容數量自動排列等寬的格線，製作出類似 Grid System 概念的排版。 以上介紹的網格系統是屬於通用的概念，在熟悉這些概念依然可以做許多延伸，設計並沒有絕對不變的，而是在了解通則及可行性後再來加以變化。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：網頁設計常用格線系統(上)","slug":"grid-system","date":"2018-10-17T16:00:00.000Z","updated":"2018-10-18T02:30:51.124Z","comments":true,"path":"design/2018/10/18/grid-system/","link":"","permalink":"https://wcc723.github.io/design/2018/10/18/grid-system/","excerpt":"","text":"學習設計的時候，一定會討論到網格系統，透過網格可將圖片、文字做有條理的編排，只要有了網格做支撐，就算是複雜的圖文都會有規矩的排列。相反的，如果平面設計缺乏網格系統，就算簡單的圖文要排列整齊也並非容易的事情。 本篇分別介紹幾個部分： 960gs 名詞解釋 格線設定 及 計算方法 實例 實際運用 格線與響應式的搭配 960gs當然網頁設計也不例外，我們通常稱為 Grid System。在 RWD 盛行起來之前最著名的網格系統稱為 960 Grid System，主要是因為早期的電腦螢幕寬度約為 1024，扣除瀏覽器的捲軸及邊框，960 則是許多數值的最小公倍數，所以被廣泛的討論及使用，直到現在許多 CSS 框架也是有 960 的設定值在內。 https://960.gs/demo.html 960 Grid System 的概念是將 960 區分為 12 欄（也可設定為 16, 24，依據需求不同會有不同的欄位數），接下來網頁中的元素就依據欄位數來排列內容，在 960gs 的網頁中也有提供許多範例是依據這個概念所執行的。 雖然範例中的網頁都有些年代，在網格系統的引導下具有固定的欄寬及間隔，資訊的呈現依然整齊、清楚，並不會感受到雜亂難以閱讀。 名詞解釋介紹 Grid System 名詞時，我喜歡使用 Sketch 的工具，它列出我們在使用 Grid System 的常用設定。 Total Width: 總寬，網頁主要內容呈現的範圍Offset: 推移，這是屬於 Sketch 畫布的設定可以無視Number of Column: 總欄位數，12 是常用的數值，16、24 也是許多開發者使用，這些數值同時是許多數值的最小公倍數。Gutter Width: 間隔寬度，欄與欄的間距。Gutter on outside: 外部間距，設定的間隔寬度是否要加在外層。Column: 單一欄的寬度，總欄位數、間隔寬度及單一欄的寬度數值會有連帶的關係。 實際的結果會如下，960 是一開始設定的總寬度，但如果有加上 Gutter on outside 就會將 (間隔寬度 / 2) 加到畫面的左右外層上，Gutter on outside 的用途是避免網頁主要內容過於貼近瀏覽器邊緣，所以會預先保留一些寬度，但直接保留一個 間隔寬度 會顯得過寬。 一個欄的寬度是 60px，但兩個欄位數的寬度並非是 120px，會再加上兩者之間的欄位間隔，所以數值會是 60 + 60 + 20 = 140px。欄位寬公式：欄寬 * 欄位數 + (欄位數 - 1) 除此之外每個欄寬的數值也是受到「總欄位數、間隔寬度」的影響，實際上會建議自行繪製看看，搭配公式來了解這些產生的原理。單一欄寬公式：(總寬度 - Gutter on outside) - 欄位寬度 (欄數 - 1)) / 欄數範例：((960 - 20) - 20 11) / 12 以上都是觀念，如果了解的話其實透過工具產生即可，並不需要記憶這些公式。 接下來回到這個網頁上，相信你就能理解這些數值的設定分別包含哪些內容，試著思考：假設下方網頁為 960px、欄寬 60px、間距 20px，並且包含外部間距的情況下，請問四籃寬度的內容約佔多寬？ 到這部分相信你對於基本網格系統有基本得了解，雖然在設計時不會一格一格去數多少寬度（通常是直接拉欄位數），不過在具備以上觀念後，我們再來介紹時暫時我們會如何的運用這些觀念。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：設計師思維及工程師思維","slug":"design-vs-developer","date":"2018-10-16T16:00:00.000Z","updated":"2018-10-17T02:25:05.599Z","comments":true,"path":"design/2018/10/17/design-vs-developer/","link":"","permalink":"https://wcc723.github.io/design/2018/10/17/design-vs-developer/","excerpt":"","text":"我接觸設計的時間也非常長了，從大學、研究所到剛出社會，都是維持著設計的思維，直到開始認真學習 Sass、JavaScript 思維才慢慢偏向工程師（不得不說，Sass 真的讓我革新了許多觀念），雖然現在不敢說是完全的工程師的思維，但中間的許多轉換是很值得與大家分享，建議設計師在執行時，不妨試試幾次以工程師為導向的概念來設計網頁，會有很大觀念變化。 以下我列出幾個常見的差異，而這些差異並非全部，僅是我個人在發展中的感想，左方的詞句是設計師，右方則是工程師： 從美好中思考 - 從錯誤中思考 從情境進入畫面 - 從資料進入畫面 喜歡手工打造 - 不重複造輪子 你也這麼認為嗎？我們先繼續看下去 美好與錯誤設計師在學習的過程中，都是以「美」這個字為開頭，整齊、乾淨、沒有錯誤，所以設計稿中都是用最完美的狀態做呈現。 以下是 Azure 的聯絡表單，一般設計師會用最完美的方式呈現，但可能會忽略表單 “出錯” 的狀態。 就業後與工程師合作的過程，工程師與我反映他總是會先製作錯誤的流程；反向思考這一段，我們可以與工程師學習先將錯誤加入設計稿內，而這個樣式加入也可能會造成跑版、突兀、不對稱等問題，也可以優先藉此修正 「完美」設計稿，以配合錯誤中的流程。 範例網站：https://azure.microsoft.com/zh-tw/overview/sales-number/ 從情境進入畫面 - 從資料進入畫面在執行設計時，我們不免會上網搜尋一些素材及資訊，並且透過這些素材拼湊出所需要的網頁。因此圖片選的美、字數要正確、資訊靠拼湊就是設計師的工作了，那麼有可能拼湊出以下的網頁資訊。 對於工程師來說，這些資訊必須要有資料欄位去儲存，最常見用於網頁上的資料格式稱為 JSON，大概長得像下面這樣子。 12345678910111213141516171819202122&#123; \"Ticketinfo\": \"免費參觀\", \"Zone\": \"三民區\", \"Px\": \"120.30211\", \"Py\": \"22.63961\", \"Add\": \"高雄市三民區建國二路318號\", \"Gov\": \"397000000A\", \"Website\": \"\", \"Opentime\": \"週二至週日10:00-18:00，每週一公休\", \"Description\": \"高雄願景館的前身是日治時期興建的高雄市舊火車站，外觀是”和洋混合式建築”氣勢雄偉...。\", \"Remarks\": \"\", \"Name\": \"高雄願景館\", \"Level\": null, \"Picture1\": \"http://khh.travel/FileArtPic.ashx?id=705&amp;w=1280&amp;h=960\", \"Toldescribe\": \"高雄願景館的前身是日治時期興建的高雄市舊火車站，外觀是”和洋混合式建築”氣勢雄偉...。\", \"Changetime\": \"2015-06-10T15:40:33\", \"Tel\": \"886-7-2363357\", \"Picdescribe1\": \"高雄願景館?\", \"Travellinginfo\": \"\", \"_id\": 1, \"Id\": \"C1_397000000A_000009\"&#125; 每一個都包含了 “屬性” 及 “值”，就像是表格中的垂直、水平欄位的對應，而這些值在每一份資料中都會有些許的落差，以 Ticketinfo（票價資訊） 來說可能就包含了以下幾種可能性： 免費參觀 的文字 純數值 的價格 沒有提供這個欄位 這些就會影響到實際呈現的情境，如 免費參觀 的文字出現時，我們就附上 icon 及 免費參觀的字眼；純數值 就必須補上 icon 及 NT$ xxx 元（包含字體樣式及色彩），如果沒有提供此欄位就忽略 icon 的呈現。 所以下次執行前，也不妨先打聽看看是否有提供資料，如果有試著去閱讀每個資料中的差異，接著將所有可能性呈現出來。 喜歡手工打造 - 不重複造輪子設計師的學習過程中總是會提倡創意的重要性，盡可能自行創造且避免抄襲其它人的作法，我在剛出社會時還是從事網頁設計的工作，當時很排斥圖庫、模板、Bootstrap 的工具，會認為這些工具無疑就是抹滅了設計師的價值。 而工程師在執行時恰巧是相反的，會先搜尋是否有合適的資源、套件、案例，接著了解這個案例是否符合專案情境（當然也會注意授權），如果沒有問題就會試著加入到專案內。從他人的經驗上繼續建築，不僅可以減少開發上的時間，並且可以增加專案的可維護性。 如果是剛入門的網頁設計師，會建議多閱讀設計文件，如：Material Design、Bootstrap 這類型的規範，這些規範會限制設計師的思維，但同時會給予合適的執行概念，避免重複造輪子（且輪子每次規格都不同），慢慢的加入模組化及規範的概念，增加設計及合作上的效率。 結語如果決定踏上 UI 或網頁設計這條路，除了精進原有的設計美感外，建議多花些時間學習不同領域的思維，如工程師與設計師不同之處，用戶使用時在想什麼（後續章節也會提到使用者體驗的驗證法）等等。透過這些學習讓設計不再僅限於「美」，而是真正能夠傳達訊息的「好」設計。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：別使用平面繪圖軟體繪製 UI 設計","slug":"dont-use-graphic-design-tool","date":"2018-10-15T16:00:00.000Z","updated":"2018-10-16T02:45:47.410Z","comments":true,"path":"design/2018/10/16/dont-use-graphic-design-tool/","link":"","permalink":"https://wcc723.github.io/design/2018/10/16/dont-use-graphic-design-tool/","excerpt":"","text":"除了前端課程外，自己也是有辦一些額外的活動，而這些都會說到我是一名設計師轉職的前端工程師，除了介紹前端外，我也會介紹一些設計觀念。介紹時我大多都會使用 Sketch 來進行說明，主要原因是 Sketch 的工具非常貼近於網頁及 UI 上的開發。 而這些活動結束後，都會有些朋友詢問到：「一定要用 Sketch 來做設計嗎？Illustrator 或 Photoshop 不足夠嗎？」，我總是會不厭其煩的回答此問題，告訴這些工具可以糾正的事項，本篇也會依據這些問題來回答為何要替換工具。（除了 Sketch 外，Adobe XD 也是個好選擇） 在過去僅有 Sketch 是主要的 UI 設計工具，且該軟體只有在 Mac 上才能運行，而現在 Adobe XD 趨近成熟，且大多用戶都有使用 Adobe 工具，所以轉換上並非有太大問題。而好的工具能夠協助設計師正確學習，而不好的工具無法學習正確觀念，還同時浪費共事者的時間。 為何不使用 Illustrator 及 Photoshop首先，這兩套軟體設計上是平面設計為導向，許多設定都不是給予 UI 使用的，所以非 UI 出身的設計師（如：平面設計師）很容易將平面設計的觀念帶到網頁設計上，這導致「無法學習正確觀念」、「造成溝通上的問題」、「浪費多餘的開發時間」，也直接的影響團隊之間的協作關係，所以不太推薦設計師使用這兩套軟體做開發。 當然也有許多例外，也是有設計師能夠透過這兩套工具完成許多驚艷的 UI 設計，上述的起因在於「對於網頁開發不熟悉」所造成的，如果具有以下能力，就非必要使用 Sketch 或 Adobe XD 的繪圖軟體。 熟悉網頁設計規範者 設計與前端開發都是同一人 正確的工具能糾正觀念由於 AI 與 PS 這兩套工具是以平面設計為導向，所以這些設定與網頁中能運用的數值差異頗大，以下我列出常見的不同點： 網頁都是 RGB 模式，沒有 CMYK 的選項 不好意思舉例了，如果犯了這個錯請自行默默調整 色彩中是運用 RGBA，A 是指色彩透明度，但實際運用與 opacity （物件透明度）是不同的 請不要使用 opacity 調整顏色的透明度 網頁設計時的尺寸單位都是使用 px 部分設計師會使用 pt 來作為文字單位 陰影的設定參數並非使用角度、長度、模糊比例來計算 實際是使用：x、y 的距離及模糊尺寸來計算 現代網頁設計並非只有點陣的選項 網頁設計也很常使用向量的圖形 示意圖：Adobe XD 中的陰影就是使用 色彩、X、Y 及 模糊尺寸的參數，這樣的參數設定對於工程師來說才能執行。 除此之外，所有的介面繪圖軟體都必備網頁格線系統，無需複雜的設定就可以立即使用。 而參數的設定與網頁開發所使用的名稱是一致的，設計師不僅可以從參數中了解各項數值的意義藉此學習格線的運作，也可以透過將這些參數交付給予前端工程師執行。 以上僅是列出常見的部分，工具透過介面、參數的設定限制設計師的行為，除了可以從中學到許多實際執行的觀念外，也可減少開發上錯誤，避免豐富的設計稿卻淪落的無法執行的窘境，而這樣也容易造成開發者與設計師的溝通衝突。 無法執行的設計稿，對設計來說是一種打擊，工程師也不一定了解設計師所遭遇的問題，而透過工具的矯正是相對有效的方法。 正確的工具能減少溝通上的障礙設計後的稿件會輸出給工程師來執行，如果設計稿中可以越明確的標示訊息，工程師在執行上也會更為順利，如： 字體、文字大小 色彩、背景圖 陰影尺寸、類型（向外 or 向內） 物件之間的間距 邊線的寬度、色彩、形式… 在傳統的設計中必須輸出多張圖稿， 每一張標示不同的訊息來說明 “部分” 訊息；而實際中，設計師所標示的訊息都是不足夠的，工程師必須額外的提供需求反覆地與設計師確認設計稿。當然，也有許多時候工程師會使用通靈的方式想像設計預期表達的情境。 Sketch 就可以透過一鍵發佈以下的網頁（XD 也行），透過滑鼠就可以了解以上訊息，並且還可以了解元件之間的距離，這個介面是屬於互動式的，相對於單一的圖片能容納更多的訊息在內。 工具限制了設計師的行為，讓設計師不能隨意地使用豐富的參數、濾鏡等等來設計網頁，其實也是為了降低溝通上的成本，並且確保輸出的結果是能夠被執行的。 正確的工具能減少開發的時間這些設計工具，都是不斷的依據開發者的需求再做優化，如輸出圖片來說都有提供一鍵大量輸出成 svg、png、jpg 的服務。 除此之外，Sketch、Adobe XD 都有提供完整的設計稿輸出（範例：F2E 前端 PK 賽甜點電商），這些設計稿不僅有完整的的標示，且工程師或 PM 更新需求時，也不需要重新標示，僅需要一鍵再次輸出即可。 設計師是專案中最前方的引導者，接獲需求後，設計師會像領航員一樣率先繪製地圖來讓其它水手（工程師）了解目標，當設計師有足夠的效率來繪製地圖，自然可以加快達到目標；反之，浪費時間在不好的工具上也等同是浪費整個團隊的時間。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：前端「設計」聖光之路","slug":"frontend-design-holy-road","date":"2018-10-14T16:00:00.000Z","updated":"2018-10-15T03:22:55.313Z","comments":true,"path":"design/2018/10/15/frontend-design-holy-road/","link":"","permalink":"https://wcc723.github.io/design/2018/10/15/frontend-design-holy-road/","excerpt":"","text":"我是卡斯伯，本身是設計出身，從高職 -&gt; 大學 -&gt; 研究所都是設計相關領域，出社會後從事網頁設計後來轉職為前端工程師。雖然主要工作是前端，但還是會有不少時間接觸網頁設計，所以相信我的經驗也是能夠帶給大家許多參考，並且完整的前端經驗也會有助於這些概念的實作。 為什麼要寫這系列文？不同領域的人們在協作時都會有些許的紛爭，設計師與工程師一直以來也會有這樣的嫌隙，但其實並非所有「設計師與工程師」都有這樣的對立狀態。 這樣的對立來自於「不了解對方」所造成的，設計師可能會想：「有這麼困難嗎？」，工程師則會想：「是想搞死人嗎？以為幾個標籤就搞定！？」，其實觀念的建立是可以減少這樣的紛爭，比如說「預先定義樣式元件庫」，並具有相同的設計邏輯，那麼工程師就可以依據這樣的邏輯反覆運用，設計師產生新的頁面時也是用相同的尺寸、色彩、元件再做變化，前端工程師如果已經依據設計製作好相關元件庫，那麼接下來也就真的用幾個標籤搞定這些事情。 所以，這次的系列文會有助於具有設計相關經驗的工作者，進入此領域時可以注意到更多的細節，減少溝通上的磨擦；非相關領域者，也可以再這次的系列文章學習美感技巧，文中會介紹很多小撇步如：韻律、配色、格線等觀念，讓大家在設計上可以抓到簡單的準則。 這系列文章適合什麼人看？雖然是設計系列文章，但我會撇除理論概念（美學、什麼是美等等…），會以實際的案例說明，並且以圖文交錯的方式介紹。 平面設計轉網頁設計師：相信你們在進入職場（或者未來進入職場），都會遇到許多溝通上的問題，畢竟我身邊就有許多的案例。所以這些文章會告訴你如何快速了解平面設計與網頁設計有什麼不同，並且了解有哪些資源可以運用，哪些觀念應該拋棄。 初階 UI 設計師：如果你是專職的 UI 設計師，本篇會介紹許多前端開發者在執行上的一些要點，你可以試著將一些觀念融入你的設計之中，相信與您搭配的工程師會體會到你的貼心。 前後端工程師：本篇還會介紹許多美感上的觀念，就算沒有設計師也瞭解畫面該如何配置、圖片如何選擇、色彩的選用等等。不需要太多經驗也能做出具有基礎美感的網頁。 會介紹哪些主題？相關大綱我還不段的調整，有許多章節是不具有連貫性的，畢竟這不是一份完整的 Guideline，而是告訴大家可以怎麼做的系列文章，所以會著重在以下要點： 工具的運用及思維調整 基礎網頁設計概念（格線、色彩、響應式、互動、文字、圖形…） 使用者體驗 - 別挑戰大家的習慣 美感 - 網頁設計大家都這麼做 設計規範 - 具有邏輯的設計 資源分享 相關文章中也會帶入許多設計實例、原始碼、各種規範文件的說明。影片來自於 Material Design 官網，完整說明 以上主題，你們著重瞭解哪部分呢？歡迎留言讓我知道，我盡可能在一些章節準備更多內容喔。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"Github Pages 自訂網域免費升級 https","slug":"gh-pages-https","date":"2018-07-26T16:00:00.000Z","updated":"2018-07-27T08:12:40.782Z","comments":true,"path":"design/2018/07/27/gh-pages-https/","link":"","permalink":"https://wcc723.github.io/design/2018/07/27/gh-pages-https/","excerpt":"","text":"Chrome 在 68 版以後會將沒有 https 連線的網站標上不安全的字樣，如果使用 Github Pages 但又不想花大錢買憑證的朋友，可以參考本篇免費安裝 https 憑證。 現在 Github Pages 免費提供自訂網域核發 HTTPS 憑證，且這段流程是完全自動，不需要額外申請，雖然是全自動的，但也需要符合規範才能自動申請。 需要注意的地方憑證是 Github 代為與 Let’s Encrypt 申請，主要也是推廣 https 的使用。如上所述，申請的流程是完全自動，只要完成以下兩個條件 Github 就會自動申請，並且選擇可免費使用 https (憑證約可使用三年)。 Domain 指向的 ip 替換過去 Github pages domain 設定使用的 ip 是兩組 “192” 開頭的 ip，目前這兩組依然可以運作，但如果需要自動申請 https 則需要將 domain 指向的 ip 替換成以下四組。 1234185.199.108.153185.199.109.153185.199.110.153185.199.111.153 建議先將 ip 替換好並過一小時後再進行以下流程，稍後會說明原因。 網頁中的所有資源，都必須是 https設定完 ip，可以將網頁中的所有資源 (css、js、圖片、外部連結等等) 全部替換成 https，並且重新上傳至 Github Pages 中，至於相關的替換可以參考 Github 的說明文件 (如下所示)： Asset type HTTP HTTPS CSS &lt;link rel=\"stylesheet\" href=\"http://example.com/css/main.css\"&gt; &lt;link rel=\"stylesheet\" href=\"https://example.com/css/main.css\"&gt; JavaScript &lt;script type=\"text/javascript\" src=\"http://example.com/js/main.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"https://example.com/js/main.js\"&gt;&lt;/script&gt; Image &lt;A HREF=\"http://www.somesite.com\"&gt;&lt;IMG SRC=\"http://www.example.com/logo.jpg\" alt=\"Logo\"&gt;&lt;/a&gt; &lt;A HREF=\"https://www.somesite.com\"&gt;&lt;IMG SRC=\"https://www.example.com/logo.jpg\" alt=\"Logo\"&gt;&lt;/a&gt; 接下再到 Github 專案中如下圖的設定頁面。 圖片中的回饋訊息是已經正確完成的，目前我所知道回饋訊息有三種 (我僅記得大概意思，忘記截圖了 orz)： 網頁不符合 https 規範，所以無法開啟 https (無法 checked 核取方塊)，並且會提供連結 說明修改事項。 如果沒有先換 ip 也會一直卡在這個階段，會較難判斷是資源沒有替換完整或是 ip 沒有換，因此建議先替換 ip 再更新網站。 憑證核發中， 24 小時內即可完成 (無法 checked 核取方塊) 到這個步驟就算完成了，雖然文件是寫 24 小時，但是約 2 ~ 4 小時就可以完成。 HTTPS provides a layer of encryption that prevents others from snooping on or tampering with traffic to your site. 完成，此時可以直接使用 https:// 進入所申請的網址，並且 http 也依然可以繼續使用，如果選擇 Enforce HTTPS 進入網站會自動導向 https。 (開啟後也須等待一段時間) 下圖是最終完成的示意圖： 範例網站：https://bootstrap.hexschool.com/","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"老同學來相找，一同轉行做 UI 設計師","slug":"be-a-ui","date":"2018-05-24T16:00:00.000Z","updated":"2018-05-25T07:05:42.186Z","comments":true,"path":"design/2018/05/25/be-a-ui/","link":"","permalink":"https://wcc723.github.io/design/2018/05/25/be-a-ui/","excerpt":"","text":"最近有些高中、研究所老同學、朋友們看到我在六角學院，也會問到如何轉行 UI、前端，很高興你們來詢問，如果對於此領域有興趣的朋友都可以來聊聊。 在此我推薦一些資訊，可以協助你們(或大家)從網頁設計慢慢轉行到 UI、網頁設計師。不過首先，平面設計的觀念到這個領域不一定受用，有許多邏輯性的概念是不同的。如：單位尺寸、色彩、字體字型、資訊流觀念都還是要重新學習，許多東西簡化了，也有許多複雜化了，可以先花點時間從文件下手，將會少走冤枉路(當作睡前讀本也是不錯)，不囉唆，先列出內容給大家參考： Google Material Design(UI、網頁設計師)https://material.io/ 由 Google 所推出的設計規範，也是近幾年 UI 規範的經典，雖然主要是介紹 Andriod 的設計介面(新的文件涵蓋內容更廣泛)，但裡面許多觀念是非常直得學習的，而這些概念套用在 Web 很受用的，如色彩配置介紹了主色與次要色： 在畫面上的比重 透過次要色強調重要內容的方法 與互動之間的關係等等 圖片來自於 Material Design 官網 另外，我也很喜歡它介紹到關於圖層的部分，透過陰影的強弱來表示圖層之間的關係。陰影越強、代表兩個圖層的關係越弱(像是距離越遠)。 影片來自於 Material Design 官網，完整說明 這也是持續在更新的文件，很建議直接觀看官方所提供的英文版本。我過去也有翻譯 Material Design，不過注意，官方更新太快，所以許多內容已不適用。 Bootstrap 文件(網頁設計師)http://getbootstrap.com/ Bootstrap 是網頁開發的現成框架，裡面許多元件都可以直接拿來用，如果打算進入 Web 開發領域的話，這份文件很值得閱讀，主要原因如下： 非常優秀的格線 圖片來自於 Bootstrap 官網 無論是平面設計或是網頁設計，都會有格線在做支撐，確保我們的畫面具有一定穩定性，這份文件有提到在網頁設計中的格線設計，不過如果覺得 Bootstrap 的文件太難懂，也可以參考：https://960.gs/。 元件設計適合 Web 運用 可以避免繪製畫面的時候，天馬行空的介面讓開發者難以執行，至少這些元件具有一定的規則，能夠確保它的可行性。 我們翻譯的繁體中文文件：http://bootstrap.hexschool.com/ 工具使用(UI、網頁設計師)工具上推薦使用 Sketch 或 Adobe XD，不建議使用熟悉的 Illustrator 及 Photoshop，因為後者在設計上比較偏向印刷使用，許多參數並無法呈現給開發者運用，這也會常常造成設計師與開發者溝通上的障礙，如果堅持使用，則有許多技術上需要克服。 平面轉 UI 會有經歷一些過程，首先應該 “先確保設計能被執行”，這也是大多設計師進入時會遇到的問題。一開始可能會先把平面設計的觀念帶過來如：色彩使用 CMYK、文字尺寸設定 pt、輸出解析度選擇 300dpi…等等，再經過一些練習後，還是會有執行上的問題，工程師無法諒解設計稿的錯誤，此時就能透過 “設計規範” 學習正確的觀念。 進階的 UI 設計師，能夠在工程師執行前就先預期結果，比如：流程動向、產品概念是否正確、資訊呈現是否符合預期…。而這個階段除了上述的基礎要打得穩外，更著要是實戰經驗的累積。 以上，也很歡迎同學們一起來討論 UI、網頁設計喔。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"Github 中的 ssh、https 路徑有什麼差異？ - 如何設定 Github SSH 金鑰","slug":"github-ssh-https","date":"2018-02-11T16:00:00.000Z","updated":"2018-02-13T05:35:46.099Z","comments":true,"path":"git/2018/02/12/github-ssh-https/","link":"","permalink":"https://wcc723.github.io/git/2018/02/12/github-ssh-https/","excerpt":"","text":"再推出 Hexo 介紹影片以後，會有許多同學私下問我關於 https 與 ssh 這兩個有什麼差異？另外會不會影響部署？為什麼看老師是使用 ssh 而自己用 ssh 卻跳出權限不足？ Git 中 https 與 ssh 這兩個有什麼差異？這兩個均是 Git 儲存庫的路徑，Github 官方推薦使用 https 但同時也提供 ssh 的連線方式，兩者差異點在於： https: 在上傳時需要輸入帳密，如果不需要大多是帳密(Key Chain)已存在電腦內。 ssh: 已先在電腦內設定好金鑰，上傳時不需要輸入額外帳密。 所以這個僅是上傳的路徑，所以選擇哪一個都不會影響最終上傳的結果或是 Hexo 部署的結果喔。而我使用 ssh 也是因為有先設定好金鑰，如果沒有設定金鑰也就會跳出權限不足的字樣喔。 如何設定 Github SSH 金鑰Github: 使用 SSH 連線相關文章 本篇文章以 Mac 的為主，如果你使用的是其它作業系統，上述文章也有詳細描述，整體差異不會太大喔。金鑰本身是一對的一個公鑰及一個私鑰，流程會是在本地端產生一組公私鑰，然後將公鑰上傳到 Github 上，接下來再上傳儲存庫時 Github 就會透過公鑰與電腦中的私鑰比對驗證，藉此不需要再輸入帳密。 步驟一：產生金鑰輸入以下指令，來產生新的 SSH Key。 1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 1234567$ Enter file in which to save the key (/Users/casper/.ssh/id_rsa):# 這行只是確定存在哪$ Overwrite (y/n)?# 如果原本就有金鑰會跳出此問題，覆蓋嗎？ (是)$ Enter passphrase (empty for no passphrase):$ Enter same passphrase again:# 輸入密碼 此密碼與 Github 密碼無關，只是使用這個金鑰的密碼，為了寫這篇文章，我真的覆蓋了 Q_Q 步驟二：設定金鑰代理 (Adding your SSH key to the ssh-agent)啟用 SSH 代理伺服器，這個步驟可以讓之後使用此金鑰不需要再輸入額外的密碼(剛剛的自訂密碼)，如果跳過此步驟，之後就要輸入自訂密碼。 1$ eval \"$(ssh-agent -s)\" 將私鑰及加入到 SSH 代理上，並且同時儲存剛剛的自訂密碼： 1$ ssh-add -K ~/.ssh/id_rsa 步驟三：上傳公鑰Mac 內的個人目錄下可以找到 .ssh/ 資料夾，以下會分別有 id_rsa、id_rsa.pub 兩個檔案，也分別為私鑰及公鑰，此步驟就是將 id_rsa.pub 檔案的內容上傳到 Github 上。 請用文字編輯器打開以上檔案並複製其內容。接下來到 Github &gt; Settings &gt; SSH and GPG keys 的設定頁面，選擇 New SSH Key。 接下來會出現設定頁面，上方標題可以自訂名稱，下方則可以貼上剛剛所複製的 Key，都確定後再輸入 Github 密碼則完成綁定， 然後進行一次 git push，如果可以進行推送就完成了，在剛剛所設定頁面重新整理後也會看到 Last used within the last week 最近一週有使用的字眼。 雖然官方是推薦使用 https，但不用輸入帳密真的很方便。","categories":[{"name":"git","slug":"git","permalink":"https://wcc723.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"鐵人賽：邁向 JavaScript 的勇者","slug":"javascript-ironman-ending","date":"2018-01-01T16:00:00.000Z","updated":"2018-01-02T03:26:34.522Z","comments":true,"path":"javascript/2018/01/02/javascript-ironman-ending/","link":"","permalink":"https://wcc723.github.io/javascript/2018/01/02/javascript-ironman-ending/","excerpt":"","text":"這次是第四次參加鐵人賽，先前參加的主題分別為兩次 CSS 及一次 JavaScript (D3.js)。 因為原本是視覺設計師，在過去曾經打算專精於 CSS 就好，所以不斷專精 CSS 的表現模式以及他的開發模式，我還曾經開發過幾次的 CSS Framework (有實際運用過)，不過隨著時間發展這個概念有了改變 :D。 撇開 CSS 不說，對於多變的 JavaScript 還是有一些自己的看法，在最後一篇就寫寫我對於此的一些看法。 目前還有持續學 CSS 嗎？CSS 很重要，但如果在良好的架構下，定義好的 CSS 基本上不太需要去做調整，一個專門的前端開發者 (需要包含 CSS、JavaScript 開發)，絕大多的時間都會把開發精神放在 JavaScript 上，且 CSS 的變化性不像是 JavaScript 那麼快，學個幾招夠用好幾年，所以就現在來說只會先略為研究新的語法 CSS Grid，但目前不會使用在主要的產品網站上，等有被實際運用在主要網站上後再觀察也不遲。 以 Flex 來說，我在 4 ~ 5 年前就已經有研究了，2 ~ 3 年前已經有許多知名網站已經開始套用(我自己實際是在 2016 在產品頁面上套用 Flex，發生錯誤的回饋並不多)，但實際被接受也是近一兩年，CSS 變化挺慢的且應用變化不多，所以新語法研究一段時間後就把時間拿去研究 JavaScript 了。 先學 jQuery 還是先學 JavaScript先說，我是先學 ActionScript 的，後來開始工作後開始學 jQuery，後來才開始花更多的時間學習 JavaScript 。 這個議題也是看過很多人討論，但就目前而言我會比較推薦先學「jQuery」，除了你可以啃得下 JavaScript 基本指南 不會覺得難以閱讀(如果沒問題，可以跳過 jQuery)。會先說學習 jQuery 的原因在於它容易學習且容易有成就感，並不是所有人在學習 JavaScript 就有程式背景，而 jQuery 將許多複雜的概念用簡單的方式去執行。 雖然如此，在了解 jQuery 後，還是需要精進 Native JavaScript 能力，畢竟糖吃太多對身體不太好。學了 JavaScript 後可以再回頭看看 糖 的成分是什麼，也會有所茅塞頓開的感覺。 要不要接觸後端我主要的工作是前後端均有參與的，雖然不到專精於後端的全端工程師，但基礎的 Router、API、部署 也都沒有問題，如果對於 JavaScript 掌握度有一定的朋友，或工作上有很長時間需要接觸 JavaScript 的開發者，非常建議花時間玩玩 Node.js，原因如下： 了解前後端協作的眉角前端並不了解後端，也並非所有後端了解怎麼與前端配合，在這兩個專業領域之間就產生了一個隔閡，許多誤會、溝通成本就在此部分出現。所以身為前端如果了解後端的運作原理，自然也能夠多為對方著想。 像是一個新的開發需求產生，如果前端在等待後端的 API 過程中就只能刻刻畫面、假裝研究新技術!?但如果有些經驗後，也可以先與後端先討論 資料欄位、API 發送時機、後端需配合的額外欄位 (很多是為了配合畫面而開的)，這樣的討論下，後端甚至能在腦中勾勒出：「啊，原來這樣做就好了喔～」(情境二：靠北，怎麼這麼麻煩)，然後預先產出可用的資料結構供前端先行運作，最後等待兩人完成的介接。 更豐富的運用瀏覽器端的 JavaScript 通常稱為 “客戶端”，主要是讓使用者有更好體驗所存在的，但 Server 端就不僅僅是為了服務客戶端，除了服務公司外，也能成為自己的好幫手。 像是 好想工作室的 Howard: 爬蟲始終來自於墮性 就是一個例子，最近聽到一個學生看完他的爬蟲教學後，也嘗試來爬 PTT 表特版 (優秀)。除此之外像是金流服務、Bot，甚至到個人創業的 idea 都可以執行。好後端，不試試嗎？ 穩定的環境在瀏覽器端寫 ES6 (甚至部分 ES5) 都要不斷的注意相容性，有些語法寫得很開心，實際測試卻不能運行；不然就是要透過 Babel 來編譯，把純 JavaScript 都搞得像前置語言一樣 (CoffeeScript、TypeScript…)。在 Node.js 環境下，可以直接看 Node.js Support ES6 了解目前的伺服器可以運行哪些語法，不行直接掛點，一翻兩瞪眼毫不囉唆。 JavaScript 多面向的運用情境JavaScript 可以被運用的層面相當廣，就目前所認識的程式語言來說，他是最廣的一種(很抱歉，這裡我就不去查相關資料囉)。從前面所介紹的前端、後端，他亦可運行在許多不同的環境下，如果地球上最多人使用的是印歐語系，那麼 JavaScript 就是開發界的印歐語系，搭配不同的工具，讓同一個語言到處都能通。 桌面應用程式 代表工具：https://electronjs.org/ 應用程式：Slack、Atom、Github Desktop、VSCode Electron 是基於 Chromium 和 Node.js (簡單來說就是一個 Chrome 的應用程式)，因此只要瀏覽器做得到的事情，基本上他都能辦到，並且可以與作業系統的環境整合(最近文件、自訂選單、縮圖、提示訊息…)，也有許多官方應用程式現在都是直接使用 Electron 做開發，透過此工具可以一次開發符合 Windows、Mac OS、Linux 等平台，相對能減少許多的開發成本。 缺點：一個應用程式相當於一個 Chrome 分頁，資源相對消耗比較高。 行動應用程式 代表工具：Crodova 相關支援工具：Ionic、Adobe PhoneGap Crodova 與 Electron 類似，但亦有些不同。Electron 是基於 Chromium 上開發(運行在 Chrome 上)，而 Crodova 基於瀏覽器的 Web View(是使用裝置的瀏覽器)，另外 Electron 除了 Web 技術外，另外還包含 Node.js，而 Crodova 僅使用 Web 技術。 使用 Web 技術開發行動應用程式發展許久，但因為每家的瀏覽器都略有些不同，要做到跨裝置的呈現還是有些困難，效能、呈現上也似乎還離原生應用還有段距離， IOT 代表工具：Webduino 相關教學：https://ithelp.ithome.com.tw/users/20091306/ironman/1161 Webduino 是台灣所開發的應用服務，可以使用 Web JavaScript 呼叫雲服務的 API 控制 Arduino，也因為可以使用 Web 技術，無論是什麼框架都沒有限制(jQuery, polymer 都可使用)。先前有參加過他們活動，當第一次透過自己寫的程式碼控制燈泡亮起來是真的非常有成就感。 他們先前釋出的影片，透過 Web 操作氣球，就如同遙控飛機一樣。 鐵人賽結束當然，很開心在幾年前學到一個應用層面這麼廣的程式語言，到目前還有許多都還不斷的在學習中。除了開發以外，今年依然期許自己能夠有更多的發展(區塊鏈、智能合約等等)。 那麼，感謝大家三十天來的觀看，有機會可以來我粉絲團聊聊喔 :D 卡斯伯粉絲團：https://www.facebook.com/WccCasper","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：透過 ESLint 學習 JavaScript ES6","slug":"javascript-eslint","date":"2017-12-31T16:00:00.000Z","updated":"2018-01-01T02:38:15.845Z","comments":true,"path":"javascript/2018/01/01/javascript-eslint/","link":"","permalink":"https://wcc723.github.io/javascript/2018/01/01/javascript-eslint/","excerpt":"","text":"至於 ES6 該怎麼學比較好!?很建議安裝 ESLint 來邊學邊修正觀念。ESLint 是一個團隊統一程式碼結構的工具，如果程式碼不符合規範，則會出現相對應的提示，而其中有三大主流規範是許多開發者愛用的： Google Airbnb JavaScript Standard Style 三個都有各自的擁護者，風格上 Airbnb 較為嚴謹，每一種語法都有嚴格的規範；而 JavaScript Standard Style 感受上較為輕鬆，像是每行的最後方也不需要加上分號，也不至於強制要求每一種語法的寫法，簡單來說：整齊就好。 以下面這個範例來說是屬於 Airbnb 的錯誤，沒有符合規範的語法會出現紅色提示，裡面也有完整的描述說明該如何修正。 在此依據提示將範例修正了一下，包括： 不會再修改的請用 const 能寫單行請別寫那麼多行好嗎？ 一個參數而已，幹麻用小括號包起來 每行後面都要有分號 console.log 記得移除 修改完後當然提示文字也就會消失，而 console.log 上的提示是 Unexpected console statement. (no-console)，記得在發布前移除這個東西。 安裝 ESLintESLint 可以運行在許多文字編輯器，而 VSCode 中非常容易整合這樣的工具，這邊提供兩個方法給大家參考，不過記得兩者不能混用，使用時請擇一即可。 ESLint：比較正式的方法，有完整的文件規範，適合團隊使用 JavaScript Standard Style 插件：比較簡單的方法。 方法一：ESLint先開啟 / 安裝 VSCode 中的 ESLint 套件，記得預設的 VSCode 是有安裝此套件的，套件中也有提到如何運行。 安裝 ESLint 的 npm 套件，目的是可以使用 eslint 的指令，方便建立規範使用的。1npm install -g eslint 開啟 Terminal 後，輸入 eslint --init 接下來會出現一連串的問題，你想要怎麼建立 ESLint 的規範文件？Q: How would you like to configure ESLint? Answer questions about your style Use a popular style guide Inspect your JavaScript file(s) 建議選擇 使用主流的 Style Guide (第二個)，如果使用此選項，他會要求先建立 package.json，如果專案中沒有 package.json 可以輸入：1npm init 其中的問題可以 Enter 到底即可，接下來再回到上一步 eslint --init 繼續選擇建立規範。 選擇 Use a popular style guide 後，會出現三個主流的規範。 Google Airbnb：如果選擇此選項，會多問一個是否使用 React Standard 接下來會選擇要哪一種格式 YAML、js、json 來儲存規範，這個規範是能夠讓其他專案使用的，只要團隊討論好即可。 安裝完後，在專案內會增加一個 eslint.js (或者其他，依據上述選擇的而定)，此時可以先關閉 VSCode 專案再重啟一次，接下來選擇 “輸出” 可以看到 ESLint server is running.，並且沒有其他錯誤訊息表示已成功運行 (如下圖)。 接下來會看到畫面上都了很多紅色提示，滑鼠移到紅底線上方會提示該如何修改。 目標就是減少畫面上的紅字 T_T，如果有未定義的變數也會跳紅字，目標當然是去除專案中的紅字來符合規範。 上圖選的是 Airbnb 的規範，相關可參考：GitHub - airbnb/javascript: JavaScript Style Guide 其它注意事項： 如果無法順利進行，可嘗試重新安裝 node_modules 試試看。 如果有替換規範，也要重新安裝 node_modules。 重開 VSCode、重裝 node_modules 都是解決問題的好方法。 方法二：JavaScript Standard Style這是使用 Standard JS 提供的 VSCode 套件，不要與 ESLint 混合使用，也可以直接在工作區關閉 ESLint 只執行 Standard JS 接下來安裝 JavaScript Standard Style 的 VSCode 套件，安裝完後直接重起就能使用了，沒有額外的設定檔。 套件路徑：https://marketplace.visualstudio.com/items?itemName=chenxsan.vscode-standardjs 啟用後再右下方一樣會出現 JavaScript Standard Style 的字樣，Standard 相對於其他規範來說寬鬆很多，最大的特點是沒有分號。 寫起來長得像這樣 (未定義或定義但未使用的仍然會跳錯)，另外還有繁體中文的文件 (standard/README-zhtw.md at master · standard/standard · GitHub)。 我自己是比較喜歡 Standard，但缺點就是沒有分號，如果用在教學中同學可能會誤以為 JavaScript 不用分號。Airbnb 比較不習慣的則是物件裡的逗號，一般物件的最後一個是沒有逗號，但在 Airbnb 則是逗號到底。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 建構式語法糖","slug":"javascript-constructor","date":"2017-12-30T16:00:00.000Z","updated":"2017-12-31T03:21:22.641Z","comments":true,"path":"javascript/2017/12/31/javascript-constructor/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/31/javascript-constructor/","excerpt":"","text":"這一段與先前介紹的建構式概念接近連結，單篇觀看可能無法理解為何 JavaScript 要加入 Class 的概念，而 Class 在 JavaScript 只是個語法糖，讓建構式及原型更容易被表現而已。 ES6 建構式這裡我們先將先前章節的程式碼整理過來，除了順序有些調換外，觀念上是沒有差異的，最後產生的值包含了物件屬性及原型的方法。 123456789101112131415161718192021function PhoneTemplate(brand, modal, withCamera) &#123; // 定義基本屬性 this.brand = brand; this.modal = modal; this.withCamera = withCamera || false;&#125;// 原型方法PhoneTemplate.prototype.takePhoto = function (someone) &#123; if (this.withCamera) &#123; console.log(this.modal + ' 照相'); &#125; else &#123; console.log(this.modal + ' 這台沒有照相功he能'); &#125;&#125;PhoneTemplate.prototype.callSomeone = function (someone) &#123; console.log('打通電話給 ' + someone)&#125;var sonyPhone = new PhoneTemplate('Sony', 'Z100', true);var nokiaPhone = new PhoneTemplate('Nokia', '3310', false); 接下來使用 class 來改寫，你可以對應著上方的原始碼與下方的一起看，僅有三個小地方要稍作修改： function PhoneTemplate 定義名稱 -&gt; class PhoneTemplate 初始化物件屬性寫在 constructor ()內，一個 class 也只能有一個 constructor。 原型方法直接寫在 class 內就可以了 123456789101112131415161718192021222324// ES6 Constructorclass PhoneTemplate &#123; // 定義基本屬性 constructor (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; // 原型方法 takePhoto () &#123; if (this.withCamera) &#123; console.log(this.modal + ' 照相'); &#125; else &#123; console.log(this.modal + ' 這台沒有照相功he能'); &#125; &#125; callSomeone (someone) &#123; console.log('打通電話給 ' + someone); &#125;&#125;;var sonyPhone = new PhoneTemplate('Sony', 'Z100', true);var nokiaPhone = new PhoneTemplate('Nokia', '3310', false); 結果： constructor 定義了原本在物件內的屬性及值，其中也包含外部傳入的參數。 原型原本是 prototype 的方法，在 Class 的類別方法是直接寫在 constructor 的後方，這樣的好處讓程式碼閱讀更為容易。 static 靜態方法靜態方法屬於原型專屬的方法，它並不會繼承到物件上。像是陣列原型中有一個 of() 的方法，但一般陣列是無法使用專屬於原型的陣列方法。 123Array.of(1,3,4,5,6); // [1, 3, 4, 5, 6][1, 3, 4, 5, 6].of();[1,3,4,5,6].of is not a function 靜態方法只能被原型使用，無法在創立的物件上使用。 123456789101112131415161718192021class PhoneTemplate &#123; // 定義基本屬性 constructor(brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; // ... // 靜態方法 static info() &#123; console.log('這是手機原型'); &#125;&#125;;var sonyPhone = new PhoneTemplate('Sony', 'Z100', true);sonyPhone.info();// sonyPhone.info is not a functionPhoneTemplate.info();// 這是手機原型 Setter, GetterGetter, Setter 顧名思義，一者是傳入、另一則是讀出，兩者可以同時對 “相同的變數” 進行操作，如以下範例來說，我們可以傳入 1，但讀出為 2。set 同時修改傳入的變數，讓 get 的資料不同。 12345678910111213141516171819202122232425262728// ES6 Constructorclass PhoneTemplate &#123; // 定義基本屬性 constructor (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this._core = 1 this.withCamera = withCamera || false; &#125; // get, set get core () &#123; return this._core &#125; set core (coreNum) &#123; let num = Number.parseInt(coreNum) this._core = num * 2 &#125; // 其它原型方法 // ...&#125;;const sonyPhone = new PhoneTemplate('Sony', 'Z100', true);console.log(sonyPhone.core); // 1，預設的 _coresonyPhone.core = 4; // 傳入 4console.log(sonyPhone.core); // 會透過 set core * 2，結果會是 8 另外特別是傳入的方式是使用 等號，而不是 function 的參數。 如果只有 getter 則不能修改 setter 則只能傳入一個參數 ES6 建構式 + extends先前已經使用一個建構式建立基本的原型，在先前我們也有提到，原型概念中還有一個是原型鍊。也就是原型可以不斷地繼承，但到目前為止的範例我們都只有創造一層原型。 手機模板是一個基本的原型，這個原型不夠使用時我們可以在上新增方法，但有些時候我們擔心會干擾到其它已建立的原型，我們可以使用 extends 來擴增新的方法。 有個品牌總是要做出最屌最潮的手機，他可以以目前手機作為基礎再加以擴增。 這裡會看到兩個新的單字 extends、super： extends: 繼承於另一個原型之下 super : 使用上層的值(屬性)1234567891011121314151617181920212223242526272829303132333435363738// 第一層class PhoneTemplate &#123; constructor (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; &#125; takePhoto () &#123; if (this.withCamera) &#123; console.log(this.modal + ' 照相'); &#125; else &#123; console.log(this.modal + ' 這台沒有照相功能'); &#125; &#125; callSomeone (someone) &#123; console.log('打通電話給 ' + someone); &#125;&#125;;// 利用上一個建構式作為延伸class ApplePhone extends PhoneTemplate &#123; constructor (brand, modal) &#123; super(brand); // 繼承原本的建構式中的變數 this.modal = 'iPhone'; // 直接賦予變數 &#125; // 直接寫入新的方法 hiSiri () &#123; console.log('hi Siri'); &#125;&#125;var iPhone = new ApplePhone('Apple');console.log(iPhone); // 這個與先前的建構式有接近的格式iPhone.takePhoto(); // 由於沒有傳入相機功能，所以沒辦法iPhone.callSomeone('小明'); // 能使用上一個建構式的方法iPhone.hiSiri(); // 能使用新建構式方法 這個概念下也能夠繼承於現有的原型，如以下範例就是將 MyPhones 繼承於 Array 之下，這種繼承方法可以讓新的建構式擁有陣列的全部方法，也可以藉此增加新的方法。 123456789101112131415class MyPhones extends Array &#123; constructor(name, ...phones) &#123; super(...phones); // 繼承原本陣列的值 this.name = name; &#125; add (phone) &#123; // 自訂的方法 this.push(phone); &#125;&#125;const JayPhones = new MyPhones('杰倫', &#123; name: 'iPhone' &#125;, &#123; name: 'Z' &#125;);console.log(JayPhones.length); // 傳入兩個值作為陣列，所以長度確實是 2JayPhones.add(&#123;name: 'G'&#125;); // 再增加一個值console.log(JayPhones.length); // 陣列長度改為 3console.log(JayPhones.name); // '杰倫'：除了陣列外，名字也在裡面，因為陣列本質就是物件 JavaScript 中許多觀念很重要，其中之一則是原型。許多時候一些語法上的錯誤或是概念一時轉不過去，打開 console 看看物件的圓形，或許就能明白。 另外…，剩兩篇了!?","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript Await 與 Async","slug":"javascript-async-await","date":"2017-12-29T16:00:00.000Z","updated":"2017-12-30T02:52:43.878Z","comments":true,"path":"javascript/2017/12/30/javascript-async-await/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/30/javascript-async-await/","excerpt":"","text":"不知道上一篇大家對於 Promise 概念如何，本篇介紹的內容與 Promise 依然有相關性，因為這兩者就是建構於 Promise 之上的，如果直接從原始碼看可能不是很好瞭解這語法怎麼使用，不過可以先直接用 Google 翻譯了解大概意思： await: 等待 async: 非同步 Await 等待Promise 中完成會透過 then 來回傳，在 await 中他則是會等待這段函式完成後在往下繼續執行，這是一個卡住的概念。 以下這段是上一個章節建立的 Promise，在這個非同步的方法下他並不會影響其他函式的運行。 小明開始跑後，並不會影響其它運行。 12345678910111213141516171819202122let runPromise = (someone, timer, success = true) =&gt; &#123; console.log(`$&#123;someone&#125; 開始跑開始`); return new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 if (success) &#123; setTimeout(function () &#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(`$&#123;someone&#125; 跑 $&#123;timer / 1000&#125; 秒時間(fulfilled)`); &#125;, timer); &#125; else &#123; // 回傳失敗 reject(`$&#123;someone&#125; 跌倒失敗(rejected)`) &#125; &#125;);&#125;// 此段函式並不會影響其它函示的執行runPromise('小明', 3000).then(someone =&gt; &#123; console.log('小明', someone)&#125;);// 以下這段 console 會在 promise 結束前就執行console.log('這裡執行了一段 console'); Await 顧名思義就是等待，在這個 Promise 結束前後面的程式碼都無法被執行。所以以下結果會出現： 立即執行：小明 開始跑開始 兩秒後：跑完了: 小明 跑 2 秒時間(fulfilled) 立即接續執行：漂亮阿姨 開始跑開始 2.5 秒後：跑完了: 漂亮阿姨 跑 2.5 秒時間(fulfilled) 12345// 此段函示會中斷其它函式的運行let mingRun = await runPromise('小明', 2000)console.log('跑完了:', mingRun);let auntieRun = await runPromise('漂亮阿姨', 2500);console.log('跑完了:', auntieRun); 以上範例並不是像 Promise 中的 race() 或 all() 的全部一起執行的方式，而是一段執行後才執行下一段。 在 await 特性下，會等 promise 任務完成後才會讓程式繼續往下執行，所以小明沒有跑完以前，漂亮阿姨都會在原地等待。 同時進行雖然 await 是逐一執行的概念，不過它也是能夠與 Promise.all() 同時使用。 123let allRun = await Promise.all([runPromise('小明', 3000), runPromise('漂亮阿姨', 2500)]);console.log(allRun);// [\"小明 跑 3 秒時間(fulfilled)\", \"漂亮阿姨 跑 2.5 秒時間(fulfilled)\"] 錯誤出錯了會怎樣？ 小明如果跌倒，漂亮阿姨會無法得知他完成，於是在原地苦苦的等待。 12345let mingRun = await runPromise('小明', 2000, false);// 小明 開始跑開始// 小明 跌倒失敗(rejected)// 以下錯誤不執行console.log('跑完了:', mingRun); 喔嗚，如果遇到錯誤就會造成停止讓後方程式碼不執行，這樣的話 await 還挺危險的 :(。但其實我們可以從許多文件發現 await/async 都是同時使用的，await 的錯誤會讓 async 拋出錯誤，而不會造成終止。 Async在解決上述問題之前，我們先來了解一下 async，它的結構非常類似 Promise，只不過他能夠將 await 包在裡面，被包在裡面的 await 就如同先前的結構一樣，他會依序地執行。 async 本身也是類似 Promise，在正確執行的情況下 return 會傳回 resolved 的狀態，也可以使用 then 來接收正確的資料。 12345678910const asyncRun = async () =&gt; &#123; let mingRun = await runPromise('小明', 2000); let auntieRun = await runPromise('漂亮阿姨', 2500); return `$&#123;mingRun&#125;, $&#123;auntieRun&#125;`&#125;asyncRun().then(string =&gt; &#123; console.log(string)&#125;).catch(response =&gt; &#123; console.log(string)&#125;) 錯誤當 async 被呼叫時他會回傳一個 Promise，如果正確的運行這個 Promise 會回傳一個 resolved (正確的運行)，如果函式無法正確地完成，則會拋出錯誤的 rejected。 1234567891011const asyncRunFail = async () =&gt; &#123; let mingRun = await runPromise('小明', 2000, false); let auntieRun = await runPromise('漂亮阿姨', 2500); return `$&#123;mingRun&#125;, $&#123;auntieRun&#125;`&#125;asyncRunFail().then(string =&gt; &#123; console.log(string);&#125;).catch(response =&gt; &#123; console.log(response); // 小明 跌倒失敗(rejected)&#125;) 這段錯誤就如同我們在使用 Promise 一樣，可以使用 catch() 得知小明跌倒了，且並不會影響到其他函式的運行，在這樣包裝下我們可以在 async 函式內做更多的 Promise 變化，並且程式碼更為精簡且容易閱讀。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：使用 Promise 處理非同步","slug":"javascript-proimse","date":"2017-12-28T16:00:00.000Z","updated":"2017-12-29T02:24:20.287Z","comments":true,"path":"javascript/2017/12/29/javascript-proimse/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/29/javascript-proimse/","excerpt":"","text":"JavaScript 中有很多非同步的事件，而這些事件我們很常使用 callback，在一層包一層後就會出現知名的 callback 地獄，而 Promise 就是為了解決此問題而生的，因此每次介紹到 Promise 都會先下以下這張圖鎮鎮樓。 上一篇所介紹到的 Fetch() 就是使用 Promise，資料接收後才會繼續跑 then() 的內容。而 fetch() 是已經包裝好的 Promise，本篇介紹如何自己運用 Promise 以及自行建立 Promise 實體。 Promise 的狀態與流程Promise 中主要有以下幾個狀態，從一進入 Promise 就進入 pending (等待事件完成)，接下來會依據事件的成功與否回傳成功或拒絕理由，通常我們會使用 resolve、reject 兩個變數來傳送成功與失敗的訊息。 pending: 等待中的初始狀態 fulfilled: 正確完成 rejected: 已拒絕，操作失敗 以下圖來說，我們可以假想跑步的過程就是 pending 的狀態，如果成功到達目的地就是成功，也就是上方那條綠色線 (fulfilled)；過程中如果失敗也會說明失敗理由(rejected: 跌倒、累了、想找媽媽…)。 回到程式碼架構如下，我們會建立 Promise 的事件，等待需要調用的時候呼叫它，而這類型的事件也有可能失敗或成功，因此會透過 resolve 及 reject 來帶入成功與否的訊息；與此相對應的會有 then() 及 catch()來接收。 製作自己的 Promise 很久沒出現的小明，今天與 杰倫、漂亮阿姨 相約一起來跑步，小明笨手笨腳常常在跑步過程中跌倒，不過如果路途順利他應該會在三秒內跑完。 在以下函式就建立了小明跑步的 Promise，如果他成功跑完就會回傳他跑了多久，失敗則會回傳他跌倒。 123456789101112131415161718192021222324let mingRunPromise = (someone) =&gt; &#123; let ran = parseInt(Math.random() * 2); // 隨機成功或失敗 console.log(`$&#123;someone&#125; 開始跑開始`); return new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 if (ran) &#123; setTimeout(function()&#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(`$&#123;someone&#125; 跑 3 秒時間(fulfilled)`); &#125;, 3000); &#125; else &#123; // 回傳失敗 reject(new Error(`$&#123;someone&#125; 跌倒失敗(rejected)`)) &#125; &#125;);&#125;mingRunPromise('小明').then((data)=&gt; &#123; // 成功訊息 (需要 3 秒) console.log(data);&#125;).catch((err)=&gt; &#123; // 失敗訊息 (立即) console.log(err)&#125;); Race 與 All 接下來小明與漂亮阿姨一起跑，在這次的比賽中只會回傳第一個到達終點的人，而另一個成功與否倒不是很重要(哭哭)。 首先先建立一個可以多人一起跑的事件，可以傳入人、時間、是否成功 等參數。 123456789101112131415let runPromise = (someone, timer, success = true) =&gt; &#123; console.log(`$&#123;someone&#125; 開始跑開始`); return new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 if (success) &#123; setTimeout(function () &#123; // 3 秒時間後，透過 resolve 來表示完成 resolve(`$&#123;someone&#125; 跑 $&#123;timer / 1000&#125; 秒時間(fulfilled)`); &#125;, timer); &#125; else &#123; // 回傳失敗 reject(new Error(`$&#123;someone&#125; 跌倒失敗(rejected)`)) &#125; &#125;);&#125; 可以使用 Promise.race 傳入多個 promise 事件，這個方法僅會回傳第一個完成的事件。 12345678// RacePromise.race([runPromise('小明', 3000), runPromise('漂亮阿姨', 2500)]).then((data) =&gt; &#123; // 僅會回傳一個最快完成的 resolve 或 reject console.log('race', data); // 漂亮阿姨 跑 2.5 秒時間(fulfilled) &lt;- 因為漂亮阿姨跑得快&#125;).catch(err =&gt; &#123; // 失敗訊息 (立即) console.log(err)&#125;); 當然，每次都跑輸的小明不希望每次都沒被記錄到，他希望就算最後一名也能一起紀錄 Promise.all() 會 同時執行 以下 Promise，在全部完成後統一回傳陣列，這個陣列的內容也是 promise 中 resolve 的內容。 12345678// AllPromise.all([runPromise('小明', 3000), runPromise('漂亮阿姨', 2500)]).then((data) =&gt; &#123; // 僅會回傳一個最快完成的 resolve 或 reject console.log('race', data); // [\"小明 跑 3 秒時間(fulfilled)\", \"漂亮阿姨 跑 2.5 秒時間(fulfilled)\"]&#125;).catch(err =&gt; &#123; // 失敗訊息 (立即) console.log(err)&#125;); 不過如果 all() 其中有事件 reject，那麼此 promise 也均視為失敗 (catch)。 Chain 鏈接方法 接下來他們三人想要依序跑，等一個人跑到定位後，下一位會接續著跑 在一開始有提到波動拳的概念，如果不斷的使用 callback 就會出現超級深的巢狀，那麼此時就可以善用 Promise 的 then()。 then() 所 turn 的資料內容會在下一個 then 接收，用此方法就可以減少 Callback 問題，也可以依序執行不同的 promise 事件。 123456789runPromise('小明', 3000).then(mingString =&gt; &#123; console.log(mingString); // 小明 跑 3 秒時間(fulfilled) return runPromise('漂亮阿姨', 2500);&#125;).then((autieString) =&gt; &#123; console.log(autieString); // 漂亮阿姨 跑 2.5 秒時間(fulfilled) return runPromise('杰倫', 2000) ;&#125;).then((jayString) =&gt; &#123; console.log(jayString); // 杰倫 跑 2 秒時間(fulfilled)&#125;); 以上就是對於 Promise 的介紹，不過非同步的主題還沒結束，明天還有喔。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 原生 Fetch 遠端資料方法","slug":"javascript-fetch","date":"2017-12-27T16:00:00.000Z","updated":"2017-12-28T02:11:52.000Z","comments":true,"path":"javascript/2017/12/28/javascript-fetch/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/28/javascript-fetch/","excerpt":"","text":"如果不透過框架，要如何寫出一個 GET 請求呢？在 JavaScript 中可以使用 XMLHttpRequest 的方法，但其實我平常也不太會這樣寫，主要原因也是難以閱讀及撰寫，我們大多都會使用框架來處理這段，如 jQuery, Axios…，以下略為介紹如何製作一個原生的 GET 請求： 本篇使用的是 https://randomuser.me/ 隨機用戶產生器，這很適合用來作為 AJAX Get 的範例。 12345678910111213141516171819function reqOnload () &#123; const data = JSON.parse(this.responseText); console.log(data)&#125;function reqError (err) &#123; console.log('錯誤', err)&#125;// 宣告一個 XHR 的物件var Req = new XMLHttpRequest(); // 定義連線方式Req.open('get', 'https://randomuser.me/api/', true);// 送出請求Req.send();// 如果成功就執行 reqOnload()Req.onload = reqOnload; // 失敗就 reqError()Req.onerror = reqError; 當然，在框架的時代我們已經習慣透過框架包裝以上的行為，讓程式碼的更為容易使用及閱讀，以 randomuser 網站所提供的範例來說，以上的行為可以寫成以下 (錯誤方法可參考 jQuery 文件)，不需要在另外自己包裝發送的物件。 12345678$.ajax(&#123; url: 'https://randomuser.me/api/', dataType: 'json', success: function(data) &#123; console.log(data); // 取得的遠端資料 &#125;&#125;); XMLHttpRequest 在製作時每次都要新建一個請求的實體，而 AJAX 的網站，通常也不會只做一次請求而已，為了讓程式碼更容易維護及開發，大多開發者都會使用框架來包裝這類行為。 FetchFetch 在使用時看似與 jQuery $.ajax 挺相近的，所以在使用上也相對容易上手，不過兩者亦有不同概念之處(可參考)。 這裡提供一個簡單的範例來取得遠端的資料，這裡與 $.ajax 不同點在於： fetch 會使用 ES6 的 Promise 作回應 then 作為下一步 catch 作為錯誤回應 (404, 500…) 回傳的為 ReadableStream 物件，需要使用不同資料類型使用對應方法，才能正確取得資料物件。 1234567891011fetch('https://randomuser.me/api/', &#123;&#125;) .then((response) =&gt; &#123; // 這裡會得到一個 ReadableStream 的物件 console.log(response); // 可以透過 blob(), json(), text() 轉成可用的資訊 return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log('錯誤:', err);&#125;); fetch 後方會接 then()，這是 Promise 的特性，資料取得後可在 then 裡面接收。return response.json(); 的資料則會傳到下一個 then()，至於詳細的 Promise 方法我們會留下一個章節介紹。 這裡如果刻意將網址打錯，會出現以下錯誤訊息。 1fetch('https://randomuserkkk.me/api/', &#123;&#125;) ReadableStreamFetch API 的 Response 物件中的 body 屬性提供了一個 ReadableStream 的實體，這個階段我們無法直接讀取資料內容，而 ReadableStream 物件中可用以下對應的方法來取得資料 (https://developer.mozilla.org/zh-TW/docs/Web/API/Body)： arrayBuffer() blob() formData() json() text() text()像是以上的範例，我們可以將 response.json() 改為 response.text()，那麼取得的資料格式將會是純字串。 blob()也可以將資料轉為 blob 物件，像是圖片就可以做這樣的轉換 (這裡的圖片並非指圖片路徑，而是圖片檔案本身)。 123456789101112// unsplash 上的圖片let url = 'https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&amp;fit=crop&amp;w=634&amp;q=80'fetch(url) .then((response) =&gt; &#123; return response.blob(); &#125;) .then((imageBlob) =&gt; &#123; let img = document.createElement('IMG') document.querySelector('.newImg').appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); &#125;) URL 也是新的 API，可以將 blob 物件轉為網址 // unsplash 上的圖片 let url = 'https://images.unsplash.com/photo-1513313778780-9ae4807465f0?auto=format&fit=crop&w=634&q=80' fetch(url) .then((response) => { return response.blob(); }) .then((imageBlob) => { let img = document.createElement('IMG') document.querySelector('.newImg').appendChild(img); // 將 blog 物件轉為 url img.src = URL.createObjectURL(imageBlob); }) 範例圖片，從 Unsplash 上所截取的圖片實體 小明眼中的漂亮阿姨 POST 方法六角的課程中有提供一個 POST 方法的練習(因為想不到哪裡可以測試 POST)，下方的程式碼就可以對測試的機器發送 POST，然後接受不同的結果 (這段 POST 並不會真的儲存帳密，只會將資料存在伺服器的記憶體，不久後會自動釋放)。 使用 fetch() 做 POST時，由於它並沒有向一些框架一樣包那麼徹底，所以有些地方還是需要做調整，其中 body 所送出的資料必須先轉純字串後才能送出，以下範例就是一個簡單的 POST行為。 12345678910111213141516171819let url = 'https://hexschool-tutorial.herokuapp.com/api/signup';fetch(url, &#123; method: 'POST', // headers 加入 json 格式 headers: &#123; 'Content-Type': 'application/json' &#125;, // body 將 json 轉字串送出 body: JSON.stringify(&#123; email: 'lovef1232e@hexschool.com', password: '12345678' &#125;)&#125;).then((response) =&gt; &#123; return response.json(); &#125;).then((jsonData) =&gt; &#123; console.log(jsonData); &#125;).catch((err) =&gt; &#123; console.log('錯誤:', err);&#125;) 所以這是第 25 篇了\b(表示庫存已用完)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：常用陣列方法","slug":"javascript-array-function","date":"2017-12-26T16:00:00.000Z","updated":"2017-12-27T03:30:01.088Z","comments":true,"path":"javascript/2017/12/27/javascript-array-function/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/27/javascript-array-function/","excerpt":"","text":"除了 forEach 外還有非常多實用的陣列方法，上一篇介紹一些注意事項，本篇要來介紹其它常用的陣列方法，這些陣列方法在大部分瀏覽器也都可以運作了，除了少數舊款的 Android Browser, ie 9 等等不能用以外。 接下來都是使用這份資料來實作一些方法： 累加 比大小 分別運算 搜尋特定值等 123456789101112131415161718let people = [ &#123; name: '小明', money: 500 &#125;, &#123; name: '漂亮阿姨', money: 3000 &#125;, &#123; name: '杰倫', money: 60000 &#125;, &#123; name: '老媽', money: Infinity &#125;]; ForEach 與其它不同之處除了 forEach 以外的幾個方法都會回傳陣列或一個值，在等號的左方如果放置一個變數，那麼此變數會是 undefined (沒有回傳任何值)。 1234var forEachLoop = people.forEach(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列)&#125;);console.log(forEachLoop); // undefined 其它的方法都會回傳一個值或陣列，以此來說就會回傳原本的陣列值。 1234var mapLoop = people.map(function(item, index, array)&#123; return item&#125;);console.log(mapLoop); // 與原本陣列資料相同 Filterfilter 可以用來過濾陣列中符合條件的物件，以下範例中搜尋符合大於 5000 元的，只要將該物件中的回傳為 true，那麼就會回傳完整的物件。 123456789// Filtervar filterEmpty = people.filter(function(item, index, array)&#123;&#125;);console.log(filterEmpty); // 沒有條件，會是一個空陣列var filterMoneyThan5000 = people.filter(function(item, index, array)&#123; return item.money &gt; 5000; // 取得大於五千元&#125;);console.log(filterMoneyThan5000); // 杰倫, 老媽 這兩個物件 findfind 是用來搜尋陣列中符合條件的物件，且僅能有一個，當回傳 true 數量超過兩者以上，那會以第一個為優先，通常會適合搜尋來搜尋特定 id。 12345678910111213var findEmpty = people.find(function(item, index, array)&#123;&#125;);console.log(findEmpty); // 沒有條件，會是 undefinedvar findMoneyThan5000 = people.find(function(item, index, array)&#123; return item.money &gt; 5000; // 取得大於五千元&#125;);console.log(findMoneyThan5000); // 雖然答案有兩個，但只會回傳 '杰倫' 這一個物件var findJay = people.find(function(item, index, array)&#123; return item.name === '杰倫'; // 找到杰倫&#125;);console.log(findJay); // '杰倫' mapmap 會回傳 return 的物件、值，功用上是用來處理陣列回傳新值產生一個新陣列，要特別注意回傳的值數量與原始陣列長度相同，所以留空的 return 則會產生 undefined。 1234567891011121314151617181920212223// 沒有 return 也會產生 undefinedvar mapEmpty = people.map(function(item, index, array)&#123;&#125;);console.log(mapEmpty); // [undefined, undefined, undefined, undefined]var everyoneAdd = people.map(function(item, index, array)&#123; item.money = item.money + 500; // 每個 money + 500 return item; // 回傳物件&#125;);console.log(everyoneAdd); // 回傳每個處理後的數值，不過記得這是傳參考特性，會影響到原始的物件// &#123;name: \"小明\", money: 1500&#125;// &#123;name: \"漂亮阿姨\", money: 3500&#125;// &#123;name: \"杰倫\", money: 60500&#125;// &#123;name: \"老媽\", money: Infinity&#125;var mapMoneyThan5000 = people.map(function(item, index, array) &#123; // 錯誤示範，長度不符合時 if (item.money &gt; 5000) &#123; return item; // 取得大於五千元 &#125;&#125;);console.log(mapMoneyThan5000);// [undefined, undefined, &#123;name: \"杰倫\", money: 60000&#125;, &#123;name: \"老媽\", money: Infinity&#125; ] every驗證全部的結果，當全部的值都為 true 時，則最終會得到 true；只要其中之一為 false，則回傳為 false。 123456789var ans = people.every(function(item, index, array)&#123; return item.money &gt; 10000;&#125;);console.log(ans); // false: 只要有部分不符合，則為 falsevar ans2 = people.every(function(item, index, array)&#123; return item.money &gt; 300;&#125;);console.log(ans2); // true: 大家錢都有超過 300 some與前者類似，但只要部分為 true，則回傳為 true；全部為 false 則才會為 false。 123456789var ans = people.some(function(item, index, array)&#123; return item.money &gt; 10000;&#125;);console.log(ans); // false: 只要有部分符合，則為 truevar ans2 = people.some(function(item, index, array)&#123; return item.money &lt; 300;&#125;);console.log(ans2); // true: 大家錢都不少於 300 reducereduce 是其中最為特別的，首先他回傳的參數與先前的不同，他會接收到前一個回傳的值供下一個物件使用，很適合用在累加與比對上，以下提供不同範例供參考。 accumulator: 前一個參數，如果是第一個陣列的話，值是以另外傳入或初始化的值 currentValue: 當前變數 currentIndex: 當前索引 array: 全部陣列 123var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123;&#125;);console.log(reduceEmpty); // 沒有條件，會是 undefined 可以透過與前一個相加的方式，累加陣列中所有的值。 1234567people.pop(); // 老媽的錢深不可測，先移除掉var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; // 分別為前一個回傳值, 目前值, 當前索引值 console.log(accumulator, currentValue, currentIndex); return accumulator + currentValue.money; // 與前一個值相加&#125;, 0); // 傳入初始化值為 0console.log(reducePlus); // 總和為 63500 也可以相互比對，取出最高的值。 12345var reduceBestOne = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log('reduce', accumulator, currentValue, currentIndex) return Math.max(accumulator, currentValue.money); // 與前一個值比較哪個大&#125;, 0);console.log(reduceBestOne); // 最大值為 60000 最近許多角色都沒機會出場，要來想點辦法了 :(。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 陣列方法","slug":"javascript-array","date":"2017-12-25T16:00:00.000Z","updated":"2018-05-29T01:52:25.465Z","comments":true,"path":"javascript/2017/12/26/javascript-array/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/26/javascript-array/","excerpt":"","text":"在過去處理陣列的方法不外乎就是使用 for 迴圈，或是使用配合框架的 forEach 像是 jQuery, angular.js 這些過去的框架都會提供 forEach；但到了 ES6 後，許多框架都不再提供 forEach 的語法，主要原因也是因為 ES6 就已經包含許多實用的陣列方法。 過去使用 forEach 的方式過去 JavaScript 並沒有 forEach 這樣的方法，如果是用原生的方式大多會使用 for...，這樣的寫法並不直覺，所以大多開發者會使用 jQuery、underscore 的框架處理 forEach 的方法。 for... 是看陣列數量有多少，就跑幾次的迴圈，程式邏輯很好理解，但在程式碼的呈現並不直覺。 12345678910111213141516171819202122let people = [ &#123; name: '小明', money: 500 &#125;, &#123; name: '漂亮阿姨', money: 3000 &#125;, &#123; name: '杰倫', money: 60000 &#125;];for (let i = 0; i &lt; people.length; i++) &#123; let person = people[i]; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`);&#125;// 小明 有 500 元// 漂亮阿姨 有 3000 元// 杰倫 有 60000 元 幾年前 jQuery 幾乎是每個 Web 頁面必備的框架，除了很好的 DOM 操作外，裡面已經包含了許多好用的 JavaScript 方法，其中之一當然就是 $.each。 1234$.each(people, (i, person) =&gt; &#123; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`);&#125;);// 結果同上 不僅 jQuery 會提供這樣的方法，同時期的框架也大多會提供，但到了現在的主流框架(React, Vue, Angular 2+)大多會搭配 ES6 編譯工具，所以就不會另外提供陣列的 Each 方法。 12345// 過去 angular 1 也有類似方法，不過參數的位置與 jQuery 有點不同angular.forEach(people, (person, i) =&gt; &#123; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`);&#125;);// 結果同上 除了以上兩個框架外，另外也有一個專門處理物件、陣列的框架 underscore，不管前後端都非常適合使用。 1234_.forEach(people, (person, i) =&gt; &#123; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`);&#125;);// 結果同上 ES6 一行解決ES6 開始提供了不同的 JavaScript 方法，並且搭配 箭頭函式、Template String 讓程式碼變得更簡短。 12people.forEach(person =&gt; console.log(`$&#123;person.name&#125; 有 $&#123;person.money&#125; 元`));// 結果同上 forEach 傳入的參數有三，大多會只使用前兩者 單一物件 及 物件索引，而最後一個則是完整的陣列本體。 123456people.forEach((person, i, array) =&gt; &#123; console.log(person, i, array); // person: 單一個陣列的值 // i: 陣列的索引值 0, 1, 2, ... // array: 傳入的陣列本體&#125;) 另外 forEach 這類型的方法無法中斷，如果想要中斷迴圈的執行會建議使用傳統的 for...loop。 12345678910111213for (let i = 0; i &lt; people.length; i++) &#123; let person = people[i] if (person.money &gt; 500) &#123; break; // 可中斷 &#125; console.log(person);&#125;people.forEach(function (person) &#123; if (person.money &gt; 500 ) &#123; break; // 會跳錯 &#125; console.log(person);&#125;) 無法使用的陣列先前提過物件原型的概念，有很多類陣列有著陣列的外觀，但其實並不是真正的陣列(如：arguments)，這些就無法直接使用 forEach。 12345678const callAll = function() &#123; console.log(arguments) // arguments.forEach is not a function arguments.forEach((arg) =&gt; &#123; console.log(arg) &#125;);&#125;callAll(people[0], people[1], people[2]) 不過可以使用前文介紹的展開語法 ... 將 array-like 轉成 array。 123456789const callAll = function() &#123; console.log(arguments); let thisPeople = [...arguments]; // arguments.forEach is not a function thisPeople.forEach((arg) =&gt; &#123; console.log(arg) &#125;);&#125;callAll(people[0], people[1], people[2]); 但也有部分的類陣列是可以使用 forEach，DOM 的就是屬於其中一種。 12345let doms = document.querySelectorAll('p');// 不會跳錯doms.forEach((ele) =&gt; &#123; console.log(ele);&#125;); 至於類陣列這麼多，怎知道哪些可以哪些不行，其實可以從原型中查找，像是上述的 dom 陣列，我們就可以從 console.log() 查看 __proto__ 找到 forEach 的方法。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 解構賦值","slug":"javascript-destructuring","date":"2017-12-24T16:00:00.000Z","updated":"2017-12-25T02:40:01.033Z","comments":true,"path":"javascript/2017/12/25/javascript-destructuring/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/25/javascript-destructuring/","excerpt":"","text":"解構賦值這是在 MDN 文件上的翻譯名詞，如果簡單來說他是個語法糖，讓我們在寫 物件、陣列 的時候可以使用縮寫來達到相同的效果，了解其中的規則再運用上最會很便利，且可以有效增加閱讀性 (程式碼短非常多)。 解構賦值可以想像是鏡子的概念，將右方的資料往左邊送，然後會一個位置對一個值 (但沒有像鏡子左右顛倒)。 陣列解構賦值就像是鏡子一樣，將值從右邊鏡射到左邊，所以左邊的陣列基本上就是從右方一個一個對映。因此右方的的五個值(字串)直接對應左方陣列的五個變數。 1234567let family = ['小明', '杰倫', '阿姨', '老媽', '老爸'];let ming = family[0];let jay = family[1];let auntie = family[2];// ... 略let [ming, jay, auntie, mom, papa] = family; 如果遇到空的變數，這些值也會跳過。 12345let family = ['小明', '杰倫', '阿姨', '老媽', '老爸'];let [ming, , , mom, papa] = family;// ming: 小明// mom: 老媽// papa: 老爸 如果左方多於右方，左方的變數會出現 undefined。 123let family = ['小明', '杰倫', '阿姨', '老媽', '老爸'];let [, , , , , who] = family;// who: undefined 至於傳值是否有順序性，在這個範例中直接將右邊的變數交換到左邊，可以看到是同時交換變數，所以在互換變數值時是非常方便的。 12345let Goku = '悟空';let Ginyu = '基紐';[Goku, Ginyu] = [Ginyu, Goku];// Goku: '基紐'// Ginyu: '悟空' 遇到字串則會將字串拆解成一個一個字元，賦予到左方的變數上。 12let str = '基紐特攻隊';[a, b, c, d, e] = str; 物件解構物件解構也是和陣列解構有著相同的概念，只不過陣列是使用順序的索引值對應，但物件則是使用物件的屬性名稱來做對應(因此沒有順序性)。在以下範例則是快速將物件值解構在變數上。 12345678910111213let family = &#123; ming: '小明', jay: '杰倫',&#125;;// 一般會這樣寫let ming = family.minglet jay = family.jay// 縮寫版let &#123; ming, jay &#125; = family// ming: 小明// jay: 杰倫 而物件的解構方法，還能重新賦予變數的名稱，如以下 Ginyu 在取得值後，將變數名稱改為 Goku，因此 Goku === &#39;基紐&#39;。 12345678let GinyuTeam = &#123; Ginyu: '基紐', Jeice: '吉斯', burter: '巴特', // ...&#125;let &#123; Ginyu: Goku &#125; = GinyuTeam;// Goku: '基紐' 混合使用相同的觀念，只要了解以上的觀念，這題也能了解到最終會產生怎樣的變數。12let &#123; ming: Goku, family: [, mom] &#125; = &#123; ming: '小明', family: ['阿姨', '老媽', '老爸'] &#125;console.log(Goku, mom); // 請問答案是什麼？ 說明： ming 取得右方的 ‘小明’ 後，將變數名稱改為 Goku family 取得家庭陣列後，再將第二個值套用在 mom (第二個變數上。) 預設值除了使用鏡射的概念外，為了避免值沒有賦予造成 undefined，可以使用預設值避免此問題。如以下左方的陣列都先賦予的預設值，當右方的陣列只有一個值時，左方的陣列剩餘內容將會採用預設值。 1234let [ming = '小明', jay = '杰倫'] = ['阿明'] // 第一個會被賦值，第二個會用預設// ming: \"阿明\"// jay: \"杰倫\" 物件的預設值也是相同的概念。 12let &#123; family: ming = '小明' &#125; = &#123;&#125;// ming: '小明' 函式除了以上的方法外，解構也能使用在函式的參數，使用方式如同將傳入的物件對應到函式參數上。這樣參數一樣能夠能夠自訂變數名稱、順序、預設值等。 12345678function callSomeone (&#123;person = '小明', person2&#125;) &#123; console.log(`$&#123;person&#125; 呼叫 $&#123;person2&#125;`)&#125;callSomeone(&#123; person: '杰倫', person2: '阿姨' &#125;); // 杰倫 呼叫 阿姨callSomeone('杰倫', '阿姨'); // 小明 呼叫 undefinedcallSomeone(&#123; person2: '阿姨' &#125;); // 小明 呼叫 阿姨callSomeone(&#123; person2: '杰倫', person: '啊罵' &#125;); // 啊罵 呼叫 杰倫callSomeone(&#123;&#125;); // 小明 呼叫 undefined","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 展開與其餘","slug":"javascript-spread-operator","date":"2017-12-23T16:00:00.000Z","updated":"2017-12-24T02:22:55.633Z","comments":true,"path":"javascript/2017/12/24/javascript-spread-operator/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/24/javascript-spread-operator/","excerpt":"","text":"這兩個分別稱為 展開運算子(spread operator) 及 其餘運算子 (rest operator，也可稱為其餘參數)，這兩個運算符有個兩個特點，就是都與陣列有關係，除此之外他都是 ...；第一次看到這樣的符號出現在 JavaScript 中，我還認為這是哪個預處理器的語法，不過在此他真的是 ES6 語法，以下內容一樣可以貼到 Chrome 運行。 預處理器：像是 CSS 的 Sass，在編譯前無法直接被讀取，需要透過編譯為 .css 或 .js 才能被瀏覽器使用，常見的 JavaScript 預處理器有 CoffeeScript、TypeScript。 展開展開非常的好用，我們先來看一個簡單的範例，這裡有兩組的陣列，我們想把他合併到同一個變數上，那麼我們可以直接用以下方法接起來。 12345let groupA = ['小明', '杰倫', '阿姨'];let groupB = ['老媽', '老爸'];const groupAll = [...groupA, ...groupB];// ['小明', '杰倫', '阿姨', '老媽', '老爸']; 誒…，看到這裡是不是有似懂非懂的感覺，看似那麼容易卻不太容易理解，... 到底做了什麼事情!? 它其實一次又一次的 return 陣列中的值。 1234console.log(...groupA); // 小明 // 杰倫 // 阿姨 順帶一提，以上的概念如果用傳統的寫法會像是這樣。 1234let groupA = ['小明', '杰倫', '阿姨'];let groupB = ['老媽', '老爸'];const groupAll = groupA.concat(groupB);// ['小明', '杰倫', '阿姨', '老媽', '老爸']; 淺層複製另外陣列與物件相同都有著傳參考的特性，所以當把陣列賦予到另一個值上時，修改其中一個另一個也會跟著變動。 123456// 由於傳參考的關係，所以將一個陣列傳到另一個上時// 兩個的值其實是一樣的let groupA = ['小明', '杰倫', '阿姨'];let groupB = groupA;groupB.push('阿明');console.log(groupA); // ['小明', '杰倫', '阿姨', '阿明']; 由於 展開運算子 它是一個一個將值寫入，所以他也有淺層的複製(shallow copy) 。 12345// 這個屬於淺拷貝，所以不會影響到另一個物件let groupA = ['小明', '杰倫', '阿姨'];let groupB = [...groupA];groupB.push('阿明');console.log(groupA); // ['小明', '杰倫', '阿姨']; 類陣列轉成純陣列JavaScript 中有許多類陣列，這類陣列有著陣列的外皮，但卻不能使用陣列的方法，相信先前有參考過原型章節的文章有發現這點，這類陣列由於原型不同，所以 “不能” 使用許多的陣列方法，如： map(), concat() 等等。 其中一種很常見的就是 DOM 陣列，這也可以透過展開運算子轉為純陣列。 12345// 可以將類陣列轉成陣列let doms = document.querySelectorAll('p');console.log(doms);let spreadDom = [...doms];console.log(spreadDom); 在先前小明儲值的故事中，悠遊卡的儲值是使用 for...in，原因也在於他不是真正的陣列，不過當他如果轉成真正的陣列後，就多了很多方法可以用了 (嘿嘿嘿)。1234567891011121314151617// 同樣道理，arguments 不是真正的陣列，也可以透過 ... 來轉成純陣列var originCash = 1000;function updateEasyCard() &#123; let arg = [...arguments] let sum = arg.reduce(function (accumulator, currentValue) &#123; // 分別為前一個回傳值, 當前值 return accumulator + currentValue; // 與前一個值相加 &#125;, 0); // 如果使用 arguments 則會出現 `arguments.reduce is not a function` console.log('我有 ' + sum + ' 元');&#125;updateEasyCard(0); // 我有 1000 元// arguments = [];updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); // 我有 718 元// arguments = [10, 50, 100, 50, 5, 1, 1, 1, 500]; 其餘參數其餘參數，顧名思義就是傳入的參數，用途類似 arguments，但不同的是： arguments 不是真的陣列，其餘參數則是 arguments 不能混用自訂傳入的參數 以下就是使用其餘參數改寫以上範例。 1234567891011121314151617let mingCard = &#123; name: '小明', value: 0&#125;;function updateEasyCard(mingCard, ...money) &#123; console.log(money); // 其餘參數的陣列 mingCard.value = money.reduce(function (accumulator, currentValue) &#123; // 分別為前一個回傳值, 當前值 return accumulator + currentValue; // 與前一個值相加 &#125;, mingCard.value); console.log(`$&#123;mingCard.name&#125; 的卡現在有 $&#123;mingCard.value&#125;`);&#125;let money = [10, 50, 100, 50, 5, 1, 1, 1, 500]updateEasyCard(mingCard, ...money); // 718updateEasyCard(mingCard, 50, 100, 50, 70, 200); // 小明 的卡現在有 1188 透過其餘參數，我們還能混用其他的變數像是 mingCard，讓這個儲值函式彈性更高，而不受 arguments 依序傳入的限制。 看到目前為止，你會跟我一樣覺得 ES6 的程式碼看起來不像 JavaScript 嗎？","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 的縮寫概念","slug":"javascript-short-hand","date":"2017-12-22T16:00:00.000Z","updated":"2017-12-23T02:44:52.972Z","comments":true,"path":"javascript/2017/12/23/javascript-short-hand/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/23/javascript-short-hand/","excerpt":"","text":"再參加過那麼多次鐵人賽，我自己習慣在週六寫比較簡短的文章，因此本篇也是屬於短文，還要介紹 ES6 偷懶的方法(O)，這讓撰寫 JavaScript 變得更簡化，熟悉這些語法也會讓閱讀性更高 (一開始會有點不習慣啦)，本篇要來介紹一些 ES6 中簡化的 JavaScript 語法。 物件縮寫在過去相同名稱的物件如果要賦予在另一個屬性上，必須寫成 屬性: 物件，這個邏輯很直覺，不過在 ES6 中如果物件名稱與屬性名稱相同時，則不需要寫兩次，可以改成寫一次即可。 12345678910111213141516171819let Frieza = '弗利沙'const GinyuTeam = &#123; Ginyu: '基紐', Jeice: '吉斯', burter: '巴特', // ...&#125;// 原本寫法const newTeam = &#123; GinyuTeam: GinyuTeam, Frieza: Frieza&#125;// 縮寫const newTeam = &#123; GinyuTeam, Frieza&#125; 這段也很常在 webpack, Node.js 引用外部套件時使用，如果有使用相關工具開發應該會常看到如以下： 123456789101112import Vue from 'vue'import App from './App'import router from './router'// 將套件由 './App' 路徑載入，並使用 App 這個變數名稱new Vue(&#123; el: '#app', router, template: '&lt;App/&gt;', components: &#123; App &#125;&#125;);// 縮寫方式載入及使用 物件函式縮寫function 這個詞彙如果使用在物件內，也可以省略 :function，省略後的語意是沒有變化的，並沒有轉而使用箭頭函式。 12345678910111213const newTeam = &#123; // ... showPosture: function () &#123; console.log('我們是 基紐特戰隊') &#125;&#125;const newTeam = &#123; // ... showPosture () &#123; console.log('我們是 基紐特戰隊') &#125;&#125; 在各大框架也推薦用此方法來撰寫物件函式，不僅可以少寫一些，也讓整體閱讀性更高，如以下是 Vue 的範例。 12345678const xxxComponent = &#123; name: 'hello', data () &#123; return &#123; msg: 'Welcome to Your Vue.js App' &#125; &#125;&#125; 變數作為物件屬性過去變數會使用 xxx. 來定義，而前者本身就是一個字串，無法再轉為變數使用，現在可以直接在宣告變數時使用 []，在 [] 內則是變數，當然也可以搭配 Template String 使用。 123456789let prop = 'Ming';let value = '小明';let teamMember = &#123; [prop]: value, [`$&#123;prop&#125;_invert`]: value.split(\"\").reverse().join(\"\")&#125;console.log(teamMember);// &#123; Ming: \"小明\", Ming_invert: \"明小\" &#125; 搭配解構使用解構 ... 也是 ES6 的新方法，可以執行以下的 const newTeam(執行完一次必須重新整理，因為 const 不能重新宣告)，會看到兩者的物件結果不太一樣。 123456789101112131415161718192021222324const GinyuTeam = &#123; Ginyu: &#123; name: '基紐' &#125;, Jeice: &#123; name: '吉斯' &#125;, burter: &#123; name: '巴特' &#125;, // ...&#125;const newTeam = &#123; GinyuTeam&#125;const newTeam = &#123; ...GinyuTeam&#125;// newTeam = &#123;// Ginyu: &#123; name: \"基紐\" &#125;,// Jeice: &#123; name: \"吉斯\" &#125;,// burter: &#123; name: \"巴特\" &#125;// &#125; 到目前介紹的 let、const、template string 及這次的縮寫，在 ES6 都屬於很好上手的部分，不妨找個時間開始試試看這些語法吧 :)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript Template String 樣板字串","slug":"javascript-template-string","date":"2017-12-21T16:00:00.000Z","updated":"2017-12-22T01:27:47.872Z","comments":true,"path":"javascript/2017/12/22/javascript-template-string/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/22/javascript-template-string/","excerpt":"","text":"在過去我們撰寫字串的時候都是使用 &quot; ，這種寫法會讓程式碼變得很攏長且難以閱讀，再多行的時候也必須插入反斜線來換行。 123456789101112131415161718192021const people = [ &#123; name: '小明', friends: 2 &#125;, &#123; name: '阿姨', friends: 999 &#125;, &#123; name: '杰倫', friends: 0 &#125;]let originString = '我叫做 ' + people[0].name; // 過去的寫法let originUl = '&lt;ul&gt;\\ &lt;li&gt;我叫做 ' + people[0].name + '&lt;/li&gt;\\ &lt;li&gt;我叫做 ' + people[1].name + '&lt;/li&gt;\\ &lt;li&gt;我叫做 ' + people[2].name + '&lt;/li&gt;\\&lt;/ul&gt;'; // 多行的寫法 ES6 借鏡了許多開發工具 (這種寫法真的很像 CoffeeScript，不過在這語言是使用 &quot; + #{} 插入變數)，可以使用 反引號 來插入一段字串，並且可以使用 ${} 來加入變數或函式，如以下範例可以直接輸入字串，並且使用 ${people[0].name} 來插入變數，省去一堆 +來做串接。 12let string = `我叫做 $&#123;people[0].name&#125;` // ES6 String Template// \"我叫做 小明\" 再多行的時候也是直接撰寫即可，不需要額外的符號。 1234567891011121314let ul = ` &lt;ul&gt; &lt;li&gt;我叫做 $&#123;people[0].name&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[1].name&#125;&lt;/li&gt; &lt;li&gt;我叫做 $&#123;people[2].name&#125;&lt;/li&gt; &lt;/ul&gt;`// \"// &lt;ul&gt;// &lt;li&gt;我叫做 小明&lt;/li&gt;// &lt;li&gt;我叫做 阿姨&lt;/li&gt;// &lt;li&gt;我叫做 杰倫&lt;/li&gt;// &lt;/ul&gt;// \" 甚至可以在 ${} 內使用函式 (函式內可在使用 Template String)。不過這裡特別注意，單行的箭頭函式會自動 return，所以在這裡是省略了 return。12345let ul2 = ` &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;我叫做 $&#123;person.name&#125;&lt;/li&gt;`).join('')&#125; &lt;/ul&gt;` 也可以在函式內增添更多的判斷式。1234567891011121314151617let ul2 = ` &lt;ul&gt; $&#123;people.map((person) =&gt; &#123; if (person.friends) &#123; return `&lt;li&gt;$&#123;person.name&#125; 有 $&#123;person.friends&#125; 朋友&lt;/li&gt;` &#125; else &#123; return `&lt;li&gt;$&#123;person.name&#125; 邊緣人&lt;/li&gt;` &#125; &#125;).join('') &#125; &lt;/ul&gt;`// \"// &lt;ul&gt;// &lt;li&gt;小明 有 2 朋友&lt;/li&gt;&lt;li&gt;阿姨 有 999 朋友&lt;/li&gt;&lt;li&gt;杰倫 邊緣人&lt;/li&gt;// &lt;/ul&gt;// \" 巢狀 String Template如同上述的方法 ${} 內可以加入函式及其更內層的 Template String，所以也可以在 ${} 插入另一組的函式的 Template String。 1234567891011121314151617181920212223242526272829303132const travelers = &#123; leader: '老媽', partner: people&#125;function renderList(people) &#123; return ` &lt;div&gt;上車名單&lt;/div&gt; &lt;ul&gt; $&#123;people.map(person =&gt; `&lt;li&gt;$&#123;person.name&#125;&lt;/li&gt;`).join('')&#125; &lt;/ul&gt; `&#125;let template = ` &lt;div class=\"template\"&gt; &lt;h2&gt;導遊：$&#123;travelers.leader&#125;&lt;/h2&gt; $&#123;renderList(travelers.partner)&#125; &lt;/div&gt;`// \"// &lt;div class=\"template\"&gt;// &lt;h2&gt;導遊：老媽&lt;/h2&gt; // &lt;div&gt;上車名單&lt;/div&gt;// &lt;ul&gt;// &lt;li&gt;小明&lt;/li&gt;&lt;li&gt;阿姨&lt;/li&gt;&lt;li&gt;杰倫&lt;/li&gt;// &lt;/ul&gt; // &lt;/div&gt;// \" 跳脫字元如果有需要插入特殊字元，一樣可以使用 \\ 反斜線來插入： 1console.log(`\\\\`); 如果要計算字元數，或是需要將字串做額外處理，跳脫字元是不佔字符數的： 1console.log(`\\\\`.length); // 1 要取得含特殊字元的字串可用 String.raw()： 1console.log(String.raw`\\\\`.length) ES6 就是加入了這些好用的功能，讓 JavaScript 在撰寫時變得更容易、快速、易讀，使得用過的人都回不去了 T_T。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：箭頭函式 (Arrow functions)","slug":"javascript-es6-arrow-function","date":"2017-12-20T16:00:00.000Z","updated":"2017-12-21T03:07:08.770Z","comments":true,"path":"javascript/2017/12/21/javascript-es6-arrow-function/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/21/javascript-es6-arrow-function/","excerpt":"","text":"Arrow function 對於它也是又愛又恨的，看似簡約的外型卻有著全新的體驗，它有著更簡短的語法以及重新定義的 this，所以先前學的 this 在此也會有不同的情境。 簡短的語法一般使用箭頭函式與 function 的用法大致一致，可以傳入參數、也有大括號包起來，除此之外箭頭函式也有更簡短的寫法如下： 1234567891011121314151617// 正常寫法var callSomeone = (someone) =&gt; &#123; return someone + '吃飯了'&#125;console.log(callSomeone('小明'))// 縮寫，單一行陳述不需要 &#123;&#125;var callSomeone = (someone) =&gt; someone + '吃飯了'console.log(callSomeone('小明'))// 只有一個參數可以不加括號var callSomeone = someone =&gt; someone + '吃飯了'console.log(callSomeone('小明'))// 沒有參數時，一定要有括號var callSomeone = () =&gt; '小明' + '吃飯了'console.log(callSomeone('小明')) 不過這個上述有個小地方也要注意一下，在大括號內的 {} 是需要自行加入 return，如果沒有傳入值則會出現 undefined。 12var callSomeone = (someone) =&gt; &#123; someone + '吃飯了' &#125;console.log(callSomeone('小明')) // undefined 沒有 arguments 參數在先前有一個小故事，小明要儲值悠遊卡，他投入不同的金額要加值，要使用 arguments 這個參數了解總共傳入了幾次並加總，但在箭頭函式內是沒有此變數的。 1234567let originCash = 1000;const updateEasyCard = () =&gt; &#123; let cash = 0; console.log(arguments); // arguments is not defined&#125;updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); 所以當需要使用 arguments 請維持使用 function。 綁定的 this 不同 傳統函式：依呼叫的方法而定 箭頭函式：綁定到其定義時所在的物件 (這個詞看似簡單，但又充滿了陷阱!?) 1234567891011121314151617181920212223var name = '全域阿婆'var auntie = &#123; name: '漂亮阿姨', callName: function () &#123; // 注意，這裡是 function，以此為基準產生一個作用域 console.log('1', this.name); // 1 漂亮阿姨 setTimeout(() =&gt; &#123; console.log('2', this.name); // 2 漂亮阿姨 console.log('3', this); // 3 auntie 這個物件 &#125;, 10); &#125;, callName2: () =&gt; &#123; // 注意，如果使用箭頭函式，this 依然指向 window console.log('4', this.name); // 4 全域阿婆 setTimeout(() =&gt; &#123; console.log('5', this.name); // 5 全域阿婆 console.log('6', this); // 6 window 物件 &#125;, 10); &#125;&#125;auntie.callName();auntie.callName2(); 綁定到其定義時所在的物件，我們要了解一般函式在建立時是在 window 下，所以在 window 下使用箭頭函式自然會指向 window，要確實將箭頭函式宣告在物件內部，這樣 this 才會指向該物件。 1234567891011121314151617var func = function () &#123; var func2 = function () &#123; setTimeout(() =&gt; &#123; console.log(this); &#125;, 10); &#125;; // 這裡才算真正的建立一個物件 // 因此要在此物件下的箭頭函式才會以此作為基準 var func3 = &#123; func: func2, var4: 4 &#125; func2(); // this = window func3.func(); // func3 Object&#125;func(); // 就算在這裡新增一個 function，也不會影響到內層的箭頭函式 這個範例稍作複雜些，但只是要解釋不同建立方式的差異，注意：如果 不是 建立在物件內的函式，並不會影響箭頭函示的 this： func() 是最外層的函式，他對於內層的箭頭不會有影響。 func2() 是包覆在內層的函式，但由於箭頭函式不是在物件內，所以沒有影響。 func3() 是呼叫在物件內的函式，因此箭頭函式會是使用它所在的物件。 縮寫的函式另外注意：物件縮寫形式的函式也是屬於 function，所以依然能夠產生作用域。 1234567891011// ==var auntie = &#123; name: '漂亮阿姨', callName () &#123; // 注意，縮寫形式的 function 屬於傳統 function setTimeout(() =&gt; &#123; console.log(this); // auntie 這個物件 &#125;, 10); &#125;&#125;auntie.callName(); 不可使用的情況apply, call, bindthis 在 Arrow function 中是被綁定的，所以套用 call 的方法時是無法修改 this。 1234567891011let family = &#123; ming: '小明'&#125;const func = () =&gt; &#123; console.log(this);&#125;const func2 = function () &#123; console.log(this);&#125;func.call(family); // 箭頭函式的情況，this 依然是 windowfunc2.call(family); // 一般函示 this 則是傳入的物件 不能用在建構式由於 this 的是在物件下建立，所以箭頭函式不能像 function 一樣作為建構式的函式，如果嘗試使用此方法則會出現錯誤 (... is not a constructor)。 12345678const PhoneTemplate = (brand, modal, withCamera) =&gt; &#123; this.brand = brand; this.modal = modal; // ...&#125;const sonyPhone = new PhoneTemplate('Sony', 'Z100', true);// 錯誤：PhoneTemplate is not a constructor DOM 事件監聽同先前說的， this 是指向所建立的物件上，如果是用在監聽 DOM 上一樣會指向 window，所以無法使用在此情境。 123456789var elements = document.getElementsByTagName('div');var changeDOM = () =&gt; &#123; console.log(this); // 指向 window Object this.style.border = '1px solid red'. // 錯誤&#125;for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener('click', changeDOM, false);&#125; Prototype 中使用 this一樣是 this 的問題，如果原型上新增一個箭頭函式，並嘗試使用 this 的話會指向全域。 12345678910111213141516function PhoneTemplate (brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; // ...&#125;PhoneTemplate.prototype.callSomeone = function (someone) &#123; console.log(this.brand + ' 打通電話給 ' + someone)&#125;PhoneTemplate.prototype.callSomeone2 = (someone) =&gt; &#123; console.log(this.brand + ' 打通電話給 ' + someone)&#125;const sonyPhone = new PhoneTemplate('Sony', 'Z100', true);sonyPhone.callSomeone('小明'); // Sony 打通電話給 小明sonyPhone.callSomeone2('杰哥'); // undefined 打通電話給 杰哥 善用的方式過去我們在寫物件內的函式時，為了確保 this 能夠正確運作會先將它賦予在另一個變數上 (that, self, vm…)。 1234567891011var auntie = &#123; name: '漂亮阿姨', callName () &#123; // 先使用另一個變數指向 this，讓內層函式可以正確使用 var that = this; setTimeout(function () &#123; console.log(that); // auntie 這個物件 &#125;, 10); &#125;&#125;auntie.callName(); 箭頭函式本就會指向他所生成的物件上，所以可以不需要另外指向另一個物件。 12345678910var auntie = &#123; name: '漂亮阿姨', callName () &#123; setTimeout(() =&gt; &#123; // 箭頭函式中會自動指向生成的物件上 console.log(this); // auntie 這個物件 &#125;, 10); &#125;&#125;auntie.callName();","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：ES6 開始的新生活 let, const","slug":"javascript-es6-let-const","date":"2017-12-19T16:00:00.000Z","updated":"2017-12-20T02:52:56.800Z","comments":true,"path":"javascript/2017/12/20/javascript-es6-let-const/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/20/javascript-es6-let-const/","excerpt":"","text":"接下來本篇開始會介紹 ES6 語法，在很久之前聽到 ES6 這個名詞時我都是保持觀望的態度，裡面有許多語法讓我感覺的不是很真實，像是 ...、=&gt;、class 等等，這些看起來與現有的 JavaScript 很不搭嘎 :(。 ES6 許多語法與現有的觀念有很大的關係，其中也很大一部分是為了改進現有的語法，就以本篇要介紹的 let、const 來說也是如此。這些語法改進目前很多問題，最大的感受在於 Promise()，他可以把非同步的語法處理得更漂亮。 至於該不該了解(或學習) ES6？當然要，這已經是可以用在伺服器端(Node.js)及瀏覽器(Chrome)，就如同 CSS 中的 Flex 是非常好用的語法，在各大主流網站都可以看到他的蹤影，與其不斷的觀望，不如實際體驗一次才能了解。 注意：目前還不是所有語法支援，詳細可參考 MDN 或 Can I use ES6 的變數：letES6 出現以後，為了潮，我自己也是想先從最容易改變的變數開始，如果不了解看文件大致可以了解： let 與 var 差不多 const 是宣告常數，不能再作修改 雖然還是有差異，但直接使用上確實感受不明顯，我們可以將先前的範例使用 let 來試試看： 1234567// 原本的範例var mom = '老媽';// 這是一個立即函式(function () &#123; console.log(mom);&#125;)(); 將以上的 var 修改成 let。 123456// 將 var 改成 letlet mom = '老媽';(function () &#123; console.log(mom);&#125;)(); 和先前沒什麼不同，這個 console.log 的結果是 老媽，如果不去探究原理，其實還真的沒什麼感覺，不過現在在實戰上已經推薦多用 let 少用 var，接下來我們來看看差在哪裡。 let 與 var先前提到 var 的重要觀念，在於變數的範圍在 function，而 let 的作用域在 block，block 意指 {} 這個符號(許多文件稱它為花括號，我自己則喜歡稱它大括號)，除了 function 以外 if、for 的 {} 都屬於 let 的作用域。 下面的範例可以看到，小明這個變數在兩者的結尾是不同的，因為 {} 所定義的空間並不同。 123456789101112131415161718function varMing () &#123; var ming = '小明'; if (true) &#123; var ming = '杰哥'; // 這裡的 ming 依然是外層的小明，所以小明即將被取代 &#125; console.log(ming); // '杰哥'&#125;function letMing () &#123; let ming = '小明'; if (true) &#123; let ming = '杰哥'; // 這裡的 ming 是不同的，只有在這個 if block 才有作用 &#125; console.log(ming); // '小明'&#125;varMing(); letMing(); let 與 for loop但我們知道，大多時候我們並不會這樣寫，常見的習慣中我們會將變數宣告放在 function 的前方，那麼我們再來看另一個情境： 123456for (var i = 0; i &lt; 10; i++) &#123; console.log(i); setTimeout(function () &#123; console.log('這執行第' + i + '次'); &#125;, 10);&#125; 如果先不講結果，你會認為以上出現什麼樣的結果呢？ 這執行第 0 次, 這執行第 1 次, 這執行第 2 次… (延續 10 次) 這執行第 10 次… (延續 10 次) 我先前跟大家一樣都會猜 1，因為 for 幾次不就是幾次嗎 :D。但實際執行時會發現答案其實會是 這執行第 10 次... (延續 10 次)，因為 var 會直接將 i 宣告成全域變數，不斷透過 for 迴圈累加，在 setTimeout 實際執行時只會拿到 10 這個數字。 所以此段要正確地執行，可以使用 let 宣告 i 這個變數，i會被緊緊的鎖在 for… 後方的 {} 內。 123456for (let i = 0; i &lt; 10; i++) &#123; console.log(i); setTimeout(function () &#123; console.log('這執行第' + i + '次'); &#125;, 10);&#125; 用此種方法，就會正確的出現，因為 let 是屬於 block 變數。 12345這執行第0次這執行第1次這執行第2次這執行第3次... 除此之外，在先前有介紹過，var 在全域下的變數會直接再 window 上，可以在這裡使用 console.log() 看看兩者之間的差異： 123456// 這段宣告擇一執行var mom = \"老媽\";let mom = \"老媽\";console.log(window.mom);// var 會出現 \"老媽\"// let 會出現 undefined 這也是 let 的一大特性，他並不會讓整個 window 物件掛上在全域環境所宣告的變數，對於愛乾淨不喜歡污染全域的開發者會是一大福音。 constconst 是宣告一個常數，簡單來說就是不可以再做修改的變數(常數)，以下面這個範例來說，小明如果使用 const 做宣告，那麼就無法再使用 let、const 做調整了。 123456const ming = '鐵錚錚男子漢';let ming = '弱雞';// 錯誤：Identifier 'ming' has already been declaredconst ming = '弱雞';// 錯誤：Identifier 'ming' has already been declared const 必須一定要有值過去可以先宣告變數 (還記得吧，宣告變數未賦予值會是 undefined)，但 const 在宣告時一定要賦予值。 12const ming;// 錯誤：Missing initializer in const declaration 物件依然是參考使用 const 宣告的物件，其內層屬性依然可以做調整，因為物件是傳參考，所以在此依然可以修改屬性。(一家人的成員依然可以更動)123456const family = &#123; mom: '老媽', me: '小明', sister: '小橙'&#125;;family.father = '爸爸'; 承上，已經被明確宣告的物件，沒有辦法再調整其參考的物件(一家人的成員並不會被另一家取代)。 123456let jayFamily = &#123; mom: '杰哥媽', me: '杰哥'&#125;;family = jayFamily // 錯誤 var 的額外問題相信上述對於 let、const都有了基本的了解，那麼不管你有沒有開始寫 ES6，請問一下下述問題如何修正： 沒有使用 let 的情況下要如何修正成可以依序執行？ 123456for (var i = 0; i &lt; 10; i++) &#123; console.log(i); setTimeout(function () &#123; console.log('這執行第' + i + '次'); &#125;, 10);&#125; 答案在下方 1234567// for (var i = 0; i &lt; 10; i++) &#123;// (function (j) &#123;// setTimeout(function () &#123;// console.log('這執行第' + j + '次');// &#125;, 10);// &#125;)(i);// &#125; 成功了嗎!?或許你能想到更棒的解法喔～","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 建構式與原型","slug":"javascript-constructor-and-prototype","date":"2017-12-18T16:00:00.000Z","updated":"2017-12-19T01:57:25.312Z","comments":true,"path":"javascript/2017/12/19/javascript-constructor-and-prototype/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/19/javascript-constructor-and-prototype/","excerpt":"","text":"還記得先前幾篇的原型鍊嗎？多個物件可以使用相同原型的那個章節，兩個不同的角色但是共用相同的原型，所以當原型增加新的功能，另一個角色一樣會獲得相同功能： 現在已經透過 JavaScript 建構式產生一個獨立的物件，我們接下來會使用原型鍊的概念來創造原型。 範例目前已經使用建構式製作一個簡單手機樣板，但我們會發現作為一個手機似乎少了一個重要的功能 打電話，這個功能是所有手機都具備個功能，無論他是何種型號。因此，這裡要透過 原型 的概念將手機賦予 打電話 這個功能，無論是哪一種型號，都能直接繼承此功能。 以下這段和上一個章節的程式碼是相同的，這裡已經透過手機範本 (PhoneTemplate)建立了兩隻手機。 123456789101112131415function PhoneTemplate(brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; this.takePhoto = function () &#123; if (this.withCamera) &#123; console.log(this.modal + ' 照相'); &#125; else &#123; console.log(this.modal + ' 這台沒有照相功能'); &#125; &#125;&#125;var sonyPhone = new PhoneTemplate('Sony', 'Z100', true);var nokiaPhone = new PhoneTemplate('Nokia', '3310', false); 接下來直接在 手機範本 上使用 prototype 的語法來加入撥打電話的功能 (callSomeone)，加入此功能後這兩隻手機都同時具有撥打電話的功能。 12345678// 加入 prototypePhoneTemplate.prototype.callSomeone = function (someone) &#123; console.log('打通電話給 ' + someone)&#125;// 兩者同時共用相同的原型sonyPhone.callSomeone('小明'); // 打通電話給 小明nokiaPhone.callSomeone('小明'); // 打通電話給 小明 發生什麼事了？可以透過 console.log() 來看看兩隻手機內有什麼樣的變化，此段的 __proto__ 是 PhoneTemplate 的原型，在 __proto__ 內可以看到 callSomeone() 的方法，我們直接在手機範本上加入就會使透過此建構式生成的物件套用這段原型。 此時我們如果查看另一支手機也會有相同的功能。 在概念上，這段的原型會如下圖顯示，兩者的上層皆是 phoneTemplate，並且共用相同的方法，這也像魂結一樣兩個連向共用的物件，當此物件新增了任何功能，兩個物件也能一起繼承。 記憶體概念除了共用的概念外，我們每次新增一個物件時，物件內的屬性、函式都會需要佔用記憶體空間。也就是一個物件內有 10 個屬性，生成 10 個則會佔用 100 單位的記憶體空間，如果適當地將 5 個屬性轉至原型內，則只會佔用 (5*10) + 5 = 55 的記憶體空間。 這點在開發 Node.js 應用程式時影響更大，由於伺服器端的記憶體不能像瀏覽器隨意關閉釋放，所以記憶體的控制更為重要。 原型觀念如果你了解此段，很容易就能看到任何物件的根本，對於看懂 JavaScript 的文件也會更為容易，就如同以下是 “陣列” 的原型，所以所有陣列都與此原型產生魂結牽連，因此可以用以下的方法。 而為什麼 DOM 方法取得的陣列為什麼不能用很多陣列方法，原因他是屬於 array-like(類陣列)，我們可以從原型中得知它與陣列不是共用的。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 建構式","slug":"javascript-constructor","date":"2017-12-17T16:00:00.000Z","updated":"2017-12-18T02:14:16.267Z","comments":true,"path":"javascript/2017/12/18/javascript-constructor/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/18/javascript-constructor/","excerpt":"","text":"了解原型繼承後，可以開始思考這個概念可以用在哪個地方，其中一個就是建構式。我們先不介紹建構式有什麼優點，先了解一下該怎麼透過 JavaScript 來寫建構式，然後再用原型的概念來介紹他的特別之處。 小明到手機行決定挑選一支手機，手機款式很多但基本上都有相同的功能，僅有少部分的規格上有差異，過去那種資料連連看的方式一定會把資料搞得一團亂 (參考先前的 Javascript 物件 “傳參考” 特性)，於是他想到一個新方法，先寫好一個樣板，有需要的格式直接從該樣板取用即可。 手機的規格樣板： 品牌： 型號： 是否能照相： 照相： 一般物件寫法的問題如果使用一般的物件製作手機規格的樣板，就會出現以下的問題，當物件賦予到另一個物件上時，兩者其實是使用相同的資料，當修改後者時前者也會跟著修改 (JavaScript 傳參考的特性)。 12345678910111213141516var phoneTemplate = &#123; brand: 'xxx', model: 'z1', withCamera: false, takePhoto: function () &#123; if (this.withCamera) &#123; console.log('照相'); &#125; else &#123; console.log('這台沒有照相功能'); &#125; &#125;&#125;var sonyPhone = phoneTemplate;sonyPhone.brand = 'Sony';console.log(phoneTemplate.brand); // \"Sony\"，原始的 Template 已經被修改到了 雖然先前有介紹到如何將值一一的取出來，但此方法也會完全與樣板斷開關聯性。 建構式使用 JavaScript 建構式寫法，可以先建立一個範本，接下來新增的物件都會依據此範本作為延伸。 JavaScript 建構式中，我們會使用 function 來建立物件樣板 (只能使用 function，亦不能使用箭頭函式)。 這個結構與前方所使用的結構接近，不同的是： this 則是代表此物件的屬性 可以透過參數來傳入數值 使用 new 來套用此樣板，且最終一樣會產生物件 123456789101112function PhoneTemplate(brand, modal, withCamera) &#123; this.brand = brand; this.modal = modal; this.withCamera = withCamera || false; this.takePhoto = function () &#123; if (this.withCamera) &#123; console.log(this.modal + ' 照相'); &#125; else &#123; console.log(this.modal + ' 這台沒有照相功能'); &#125; &#125;&#125; 使用建構式時，盡可能使用大寫開頭，讓合作的朋友也能知道他準備作為建構式之用。 而套用樣板會使用 new 這個方法，並且可以透過傳入參數的方法來改變預設值，接下來會出現兩台手機物件，包含相同的樣板套用上不同的值，但兩者並沒有任何關係。 12345678910111213141516// 建立兩隻手機，分別傳入 品牌、型號、是否有相機var sonyPhone = new PhoneTemplate('Sony', 'Z100', true);var nokiaPhone = new PhoneTemplate('Nokia', '3310', false);// 直接透過 console.log 來觀看其中的值console.log(sonyPhone);&#123; brand: 'Sony', model: 'Z100', withCamera: true, takePhoto: function () &#123; // ... &#125;&#125;console.log(sonyPhone == nokiaPhone); // false 兩者也可以獨立運行自己的方法： 12sonyPhone.takePhoto(); // Z100 照相nokiaPhone.takePhoto(); // 3310 這台沒有照相功能 我們這裡可以得知是使用相同樣板，但產生兩者毫無關係的物件，並且可以針對其中一個物件新增修改方法。 123456sonyPhone.call = function () &#123; console.log(this.modal + ' 打電話');&#125;sonyPhone.call(); // Z100 打電話nokiaPhone.call(); // nokiaPhone.call is not a function 到這裡我們可以得知這種建構式可以透過 “同一個物件樣板”，不斷地產生 “不同”的物件，每個物件彼此都是獨立的(不會有參考的問題)，只不過共用相同的原型。 其中一支手機可以看到 __proto__ 是 PhoneTemplate，這就好像是使用同一個模具產生兩個獨立的物件，我們也可以更新這個模具讓產生的物件有更多的功能，接下來我們會再介紹 原型繼承與記憶體 的關係。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的原型繼承","slug":"javascript-prototype","date":"2017-12-16T16:00:00.000Z","updated":"2017-12-17T01:58:50.542Z","comments":true,"path":"javascript/2017/12/17/javascript-prototype/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/17/javascript-prototype/","excerpt":"","text":"許多人在寫 JavaScript 應該多少都會聽過原型鍊、原型繼承…，這個觀念在寫 JavaScript 是否重要呢？實作中會不會常使用到這樣的技巧？這裡可以先回答 “會”，而且我們很常使用到原型，而且了解原型會有助於我們加速理解 JavaScript 的概念。 以下有一個物件，物件裡面只有一個 name 及一個 function run()，所以我們了解以下物件只能執行 run()，因為他沒有其他的函式可以使用。 123456789var person = &#123; name: '小明', run: function () &#123; return this.name + ' 跑向世界的另一端' &#125;&#125;person.run(); // \"小明 跑向世界的另一端\"person.hasOwnProperty('run'); // trueperson.hasOwnProperty('friend'); // false 但除此以外還有一些額外的方法可以使用，像是 hasOwnProperty()，但奇怪的事情是 hasOwnProperty() 這個方法，沒有在 person 這個物件下，為何還可以使用此 hasOwnProperty() 的方法，原因在於 “原型繼承”。 上圖中 person 這個是我們剛剛宣告的物件，它的上層是則是他的原型物件(它是半透明的喔，所以我們平常會沒注意到)，當他在使用 hasOwnProperty() 時，就是在使用它原型物件的方法。 透過錯誤範例了解原型錯誤範例：這裡提供一個觀念上的錯誤範例，實際執行時我們不會用此方法來增加原型方法。JavaScript 中所有的物件、函式都有 __proto__ 的原型屬性，這一個原形屬性會不斷的向上尋找他的上層原型。 1234var ming = &#123; name: '小明'&#125;console.log(ming); 我們在 ming 下的 __proto__ 直接掛上 run 的方法，使其產生在 __proto__ 下 注意：請不要這樣做，只是為了方便理解。123456789var ming = &#123; name: '小明'&#125;var run = function () &#123; return this.name + ' 跑向世界的另一端'&#125;ming.__proto__.run = run;console.log(ming.name); // &#123;name: \"小明\"&#125;console.log(ming.run()); // \"小明 跑向世界的另一端\" 雖然直接 console.log(ming) 並不會看到 run() 這個方法，但執行時他會不斷的向上尋找到原型內的 run() 方法來執行它。 共用原型其中原型還有個特性，我們如果在物件原型下直接建立新的方法，就會造成以下的問題，兩個看似沒有關係的物件將會共用相同的原型方法 (因為兩者的原型都是物件)，這種情況會出現管理上的問題。 12345678910111213var ming = &#123; name: '小明'&#125;var casper = &#123; name: '卡斯伯'&#125;var run = function () &#123; return this.name + ' 跑向世界的另一端'&#125;ming.__proto__.run = run;console.log(ming.run()); // \"小明 跑向世界的另一端\"console.log(casper.run()); // \"卡斯伯 跑向世界的另一端\" 這個範例中，我們強制將函式寫到了 物件 這個原型上，所以新增的物件都會 共用 此屬性。 在後面的章節我們會介紹如何正確地使用原型繼承。 原型鍊的的頂端是物件JavaScript 只有一個建構物：”物件”，如果上述程式碼以下我們繼續往下增加： 123456var mingFamily = ['ming', 'mom', '漂亮阿姨'];var casperFamily = ['卡斯伯', '媽'];// 嘗試呼叫先前物件下的原型mingFamily.run();\"undefined 跑向世界的另一端\" //雖然出現錯誤，但依然可以呼叫 這個範例中，我們新增一段陣列，並在陣列中使用先前的物件原型方法，雖然會出錯，但是是可以執行的。 1234567891011var getFirst = function () &#123; return this[0];&#125;// 對 陣列原型加入新的方法mingFamily.__proto__.getFirst = getFirst;mingFamily.getFirst(); // \"ming\"casperFamily.getFirst(); // \"卡斯伯\"ming.getFirst();// ming.getFirst is not a function 在此段，我們對任一陣列原型加入新的函式，此時兩個陣列都可以套用此函式，但對於物件來說卻不能執行此方法，因為在原型鍊上物件屬於陣列的頂端。 由於原型有不斷向上查找的特性，如果在上一層找不到可用的方法，他就會繼續往上找，這個也就稱為原型鍊，所以在 mingFamily 這個陣列才會取用到剛剛物件原型所增加的方法，本篇只是簡單介紹原型的概念，接下來幾篇則會開始讓大家了解這有什麼樣的用處。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript Function 與 Hoisting","slug":"javascript-hoisting","date":"2017-12-15T16:00:00.000Z","updated":"2017-12-16T02:23:42.388Z","comments":true,"path":"javascript/2017/12/16/javascript-hoisting/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/16/javascript-hoisting/","excerpt":"","text":"Hoisting 在 JavaScript 僅是一個觀念，主要是在說明變數、函式在宣告期間就會先建立一個記憶體空間，等到實際運行時再將值放入到該記憶體空間內。不過為了確保程式的穩定性，我們不會在實作中使用這個方法，僅了解觀念即可。 故事說明：小明的筆記本寫了每天要做的事情，但其實他並不是要做事情時，才會翻筆記本。在一早的醒來的時候小明會將全部的內容先看一次，讓腦中先有個印象。這個概念與 JavaScript Hoiting 的概念接近，先在記憶體中準備一個空間，等到執行時再將值、函式置入。 先在腦中了解有多少事情，到時執行時才比較不會忘記的小明。 在變數上如果我們對沒有宣告的變數執行 console.log()，會跳出一個錯誤表示它 “尚未” 被定義過。 1console.log(phone); // phone is not defined 如果在 var 的變數前加入 console.log()，這個時候並不會出錯，則是會跳出 undefined，這表示這個變數在記憶體中已經有一個位置，只不過目前並沒有值。 12console.log(phone); // undefinedvar phone = &apos;myphone&apos;; 但如果是直接賦予在全域物件上的屬性，因為並不是使用 “宣告”，這已經屬於定義階段，所以在記憶體中他還沒有值。會在 phone = &#39;myphone&#39; 這段直接將值寫在全域物件上。 12console.log(phone); // phone is not definedphone = &apos;myphone&apos;; 函式的 Hoisting在函式概念中也是一樣的，如果在函式之前使用 console.log() 則會出現 undefined，當然這個函式也無法被使用。這種函式宣告方法稱為：function expression 函式表達式(function 會由 var 定義)。 12345console.log(callSomeone); // undefinedcallSomeone(&apos;杰倫哥&apos;); // callSomeone is not a functionvar callSomeone = function (name) &#123; console.log(&apos;打給 &apos; + name)&#125; 比較不同的是在 function declaration 函式陳述式中(function 放在最前方的寫法)，整個函式都會被提升到最前方，所以在函式前方直接調用方法也可以運行。 1234callSomeone(&apos;杰倫哥&apos;); // 只有 function 會被提升function callSomeone(name) &#123; console.log(&apos;打給 &apos; + name)&#125; Hoisting 這個觀念主要是要了解 JavaScript 記憶體運作的觀念，實作上也會避免在 function 前方直接呼叫函式，這樣會降低對於程式碼的可維護性。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的嚴格模式 \"use strict\"","slug":"javascript-use-strict","date":"2017-12-14T16:00:00.000Z","updated":"2017-12-15T02:34:01.454Z","comments":true,"path":"javascript/2017/12/15/javascript-use-strict/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/15/javascript-use-strict/","excerpt":"","text":"JavaScript 不斷的演進下，許多不嚴謹的寫法都應該逐漸被修正，但哪些是需要修正的字詞呢!? &#39;use strict&#39; 則是新加入的標準，目的是為了讓編寫「具穩定性的 JavaScript 更容易」，在不穩定的語法或妨礙最佳化的語意都會跳出警告，讓開發者避開這些寫法。 而在傳統的瀏覽器下 &#39;use strict&#39; 僅會被視為沒有用處的字串，所以不會對舊有的瀏覽器產生影響。 使用方法&#39;use strict&#39; 直接加入在程式碼的前方就可以開始運作，特別值得注意的是它也可以單獨使用在 function 下，如果要靠 &#39;use strict&#39; 來修正目前語法上的問題，可以先針對部分的 function 來做調整。 簡單示範一個錯誤 (未定義的變數不能直接賦予值)：123'use strict';auntie = '漂亮阿姨';// Uncaught ReferenceError: auntie is not defined 嚴謹模式也能僅用在函式內，這樣將只有此函式套用。 12345(function () &#123; 'use strict'; auntie = '漂亮阿姨'; // Uncaught ReferenceError: auntie is not defined&#125;)(); 如果使用在函式的開頭，那將只會在此函式套用 “嚴謹模式”，函式的外部將不受影響。 123456(function () &#123; 'use strict';&#125;)();mom = '老媽管不到';// 不會跳錯 注意只有將 &#39;use strict&#39; 放在函式開頭才會有作用。12345(function () &#123; var aa; 'use strict'; // 無效 auntie = '漂亮阿姨';&#125;)(); 常見錯誤基本錯誤如下： 不宣告直接賦予變數 刪除已經宣告的錯誤 物件內有重複屬性 數值使用 8 進位語法 不能使用 ‘with’ 語法 arguments、eval 不能作為變數名稱 新增的保留字也不能被作為變數名稱 implements, interface, let, package, private, protected, public, static, yield，這些是為了 ES6 做得準備。 如果嘗試修改 getter 則不會默默地沒改，而是直接地跳出錯誤： 12345678(function () &#123; 'use strict'; var family = &#123; get mom() &#123; return '老媽' &#125; &#125; console.log(family.mom); // 老媽 family.mom = '老爸'; // 跳錯&#125;)(); 不可以嘗試刪除一個不可刪除的屬性(此為原型，在後面的章節會介紹到)： 1234(function () &#123; 'use strict'; delete Object.prototype;&#125;)(); ‘use strict’ 及 this在先前介紹 this 的時有介紹到不同的呼叫方法，在 ‘use strict’ 的環境下的 純粹的調用 (Simple call) 的 this 不在是全域變數。 12345678window.auntie = '漂亮阿姨';function callAuntie() &#123; 'use strict'; console.log('call:', this.auntie);&#125;callAuntie.call(&#123; auntie: '叫阿姨' &#125;); // OkcallAuntie(); // 錯誤，此呼叫會導致 this 為全域 但 this 依然可作為 window 的方式傳入。 1234567window.auntie = '漂亮阿姨';function callAuntie() &#123; 'use strict'; console.log('call:', this.auntie);&#125;callAuntie.call(this); // Ok，call: 漂亮阿姨 現在會建議寫 JavaScript 的時候加入 &#39;use strict&#39;，這可以改正一些編寫時的不良習慣，但也有可以因此導致專案無法運作，此時可以考慮將 &#39;use strict&#39; 加在函式內，避免影響過去的程式碼及相關套件。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 函式與參數","slug":"javascript-arguments","date":"2017-12-13T16:00:00.000Z","updated":"2017-12-14T02:45:58.033Z","comments":true,"path":"javascript/2017/12/14/javascript-arguments/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/14/javascript-arguments/","excerpt":"","text":"函式可以將參數傳入，使得函式的可用性提高許多，不過其中也有許多小技巧及方法可以運用，以下我們用 悠遊卡的概念 來說明此段。 小明的悠遊卡裡面有 1000 元，他要儲值一些零用錢進悠遊卡內 (真是優秀青年，這麼多錢還繼續儲)，好讓他可以繼續搭乘捷運。 傳入變數以下是一個簡單的函式，用來更新悠遊卡的金額。小明將錢 cash 投入機器內後，按下執行按鈕 updateEasyCard() 就會回傳更新後的悠遊卡金額。 1234567var originCash = 1000; // 悠遊卡內原有的現金function updateEasyCard (cash) &#123; // 傳入儲值金進入悠遊卡 var newCash = cash + originCash; console.log('我有 ' + newCash + ' 元');&#125;updateEasyCard(1000); // 我有 2000 元updateEasyCard(2000); // 我有 3000 元 但如果機器沒有設定好，小明還沒有投入任何金額就按下 updateEasyCard() 就會跳出 NaN (Not a Number) 的錯誤 。 1updateEasyCard(); // 我有 NaN 元 所以有些函式會透過 || 來加入預設值，在沒有輸入任何值的情況下會使用預設值代替，這邊就先將預設值設為 100 (佛心機器，沒投錢也會給 100)。 1234567var originCash = 1000;function updateEasyCard(cash) &#123; var money = (cash || 100) + originCash; console.log('我有 ' + money + ' 元');&#125;updateEasyCard(); // 我有 1100 元 這樣，至少不會出現錯誤了，但會出現另一個問題，假設函式中真的需要使用 0、false 這種值傳入時，他一樣會使用前者所套用的值。 1updateEasyCard(0); // 我有 1100 元 0 會被強制轉型成 false，所以兩者都會被替代。 複雜的判斷式|| 本身就是一個判斷式，如果簡單的判斷式沒辦法滿足需求，那麼就使用更複雜的判斷式來寫，以下範例：如果 cash 是 false，且 cash 不等於 0 的情況， cash = 100。 1234567891011var originCash = 1000;function updateEasyCard(cash) &#123; if (!cash &amp;&amp; cash !== 0) &#123; cash = 100; &#125; var money = cash + originCash; console.log('我有 ' + money + ' 元');&#125;updateEasyCard(); // 我有 1100 元updateEasyCard(0); // 我有 1000 元 當然，還有一種情況就是傳入的並非數值而是字串，這樣則會造成金額也自動轉換成字串。 1updateEasyCard('1000'); // 我有 10001000 元 那麼就需要先將文字轉成數值，避免原始的數值被轉換為字串。 123456789101112var originCash = 1000;function updateEasyCard(cash) &#123; cash = Number.parseInt(cash); if (!cash &amp;&amp; cash !== 0) &#123; cash = 100; &#125; var money = cash + originCash; console.log('我有 ' + money + ' 元');&#125;updateEasyCard('100'); // 我有 1100 元updateEasyCard('這不是錢'); // 我有 1000 元 (無法被轉換) ES6 預設函式變數在 ES6 中提供更簡潔的方式來解決此問題，可以直接在傳入的參數賦予預設值，此預設值也不需要額外的帶入判斷式就能達到以上效果(但文字問題依然要自己修正喔)。 12345678var originCash = 1000;function updateEasyCard(cash = 100) &#123; var money = cash + originCash; console.log('我有 ' + money + ' 元');&#125;updateEasyCard(); // 我有 1100 元updateEasyCard(0); // 我有 1000 元 arguments 假設小明零錢很多，他要一個一個投進去機器內儲值，這樣參數該如何設計？ 除此之外，JavaScript 有預設的參數 arguments 可直接帶入，這種參數不須預先設定，所有函式都內建此參數，他會將呼叫函式所帶入的參數一並透過陣列的方式傳入。 12345678910111213141516var originCash = 1000;function updateEasyCard() &#123; var cash = 0; console.log(arguments); // 這裡可以看到 arguments 的結構 for (var i = 0; i &lt; arguments.length; i++) &#123; cash += arguments[i]; &#125; var money = cash + originCash; console.log('我有 ' + money + ' 元');&#125;updateEasyCard(0); // 我有 1000 元// arguments = [];updateEasyCard(10, 50, 100, 50, 5, 1, 1, 1, 500); // 我有 1718 元// arguments = [10, 50, 100, 50, 5, 1, 1, 1, 500]; 不過 arguments 實際在使用時會有一些小問題，像是範例中為何是使用 for 迴圈，而不是使用 forEach (forEach 可以使用在陣列上)，主要原因是 arguments 並非真正的 陣列，它是 類陣列(Array-like) 的物件，因此無法使用許多陣列相關的方法。 相關文件可查閱：https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/arguments","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：另一種方式介紹 JavaScript 閉包","slug":"javascript-closure","date":"2017-12-12T16:00:00.000Z","updated":"2017-12-13T01:52:01.860Z","comments":true,"path":"javascript/2017/12/13/javascript-closure/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/13/javascript-closure/","excerpt":"","text":"閉包解釋非常多，這裡先透過幾個方式說明一下閉包是什麼： 運作原理：就是呼叫 Function 內的 Function 這樣有什麼用：內層 Function 作用域變數只會存在內層 然後勒：內層 Function 變數可以不被釋放，重複使用 卡斯伯會常用此方法嗎：沒注意，好像會不經意的使出來 那幹麻學：理解作用域 範例這個範例用花錢的概念來說明，我們每次都會傳入不同的金額，並且把剩餘的金額存在內部作用域。 直接呼叫內層函示閉包就是存取內部的函式，所以直接使用 buyItem()(100) 兩個括號就是呼叫內部的函式。 123456789function buyItem() &#123; var myMoney = 1000; return function (price) &#123; // 這裡就是一個閉包，不過目前只會使用一次 myMoney = myMoney - price; return myMoney; &#125;&#125;let balance = buyItem()(100); // 存取內部函式的變數console.log(balance); 幹麻要這樣？ 外層 myMoney 此時的變數可以被內層的 function 存取 內層的 myMoney 後來是私有的變數，外層無法讀取 運行 buyItem()(100) 時，等同於呼叫一次外層，在呼叫一次內層，最終將內層的值回傳給 balance 的變數。 這樣還沒完，目前只是一次性運作，來調整一下程式碼。 這個的行為是直接去操作內部的錢包，就像是直接花費一樣，接下來我們會用扣款的概念，不斷的使用錢包內部的金額。 將外層函式賦予到另一個變數上接下來不要直接呼叫，而是將函式賦予在另一個變數上，這樣的方式就會將 myMoney 這個變數存在內層的作用域，然後每次執行後不斷更新此值。 12345678910111213function buyItem() &#123; var myMoney = 1000; return function (price) &#123; // 這個閉包目前會被重複呼叫 myMoney = myMoney - price; // myMoney 第一次由外部傳入，接下來在這個 function 內不斷更新 return myMoney; &#125;&#125;var balance = buyItem(); // 存取內部函式的變數balance(100); // 900balance(100); // 800balance(100); // 700// 每次執行都是跑內層的函式，因此也只更新內層的函式變數 然後勒？ buyItem() 直接執行會出現 function ...，所以沒辦法直接使用。 balance 現在指向 buyItem() 使其可以不斷的反覆呼叫，且內層記憶體不會被釋放。 balance() 每次執行時，只會執行內層的函式，在內層記憶體沒有被釋放的情況下，myMoney 變數會不斷的被更新。 多個具私有變數的函式 小明拜訪完漂亮阿姨以後，接著遇到 Rich 的朋友 “杰倫哥”，杰倫哥與小明去四處揮霍，小明也想趁此機會計算一下杰倫哥的花費狀況。透過閉包的方法，小明可以用同一個公式算出兩個人剩餘多少錢。 123456789101112131415161718192021222324// 使用閉包產生兩個作用域// 這裡的 money 代表身上帶的錢function buyItem(money) &#123; var myMoney = money; console.log(this); // 趁機偷問，此地的 this 指向誰？ return function (price) &#123; console.log(this); // 趁機偷問，此地的 this 指向誰？ // myMoney 第一次由外部傳入，接下來在這個 function 內不斷更新 myMoney = myMoney - price; return myMoney; &#125;&#125;let MingCost = buyItem(1000); // 存取內部函式的變數，這個是小明錢包內的錢let JayCost = buyItem(10000); // 杰哥拿出的小錢// 小明的內層作用域變數，也就是小明剩的錢console.log(MingCost(100)); // 900console.log(MingCost(100)); // 800console.log(MingCost(100)); // 700// 杰哥的內層作用域變數，這裡是杰哥剩的錢console.log(JayCost(1000)); // 9000console.log(JayCost(1000)); // 8000console.log(JayCost(1000)); // 7000 以上片段建議分段執行，更能理解其中的過程： let MingCost = buyItem(1000); 此時 buyItem 已經執行過一次，並且 myMoney 的變數已經依傳入的變數做調整。 每次執行 MingCost(100) 時，調整的則是傳至內層的 myMoney 變數。 要了解閉包，就要多了解函式的作用域，掌握 變數 的作用域及函式的運作原理，此篇章難度就不會很高。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的 this 到底是誰？","slug":"javascript-this","date":"2017-12-11T16:00:00.000Z","updated":"2019-03-19T06:23:45.687Z","comments":true,"path":"javascript/2017/12/12/javascript-this/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/12/javascript-this/","excerpt":"","text":"This 的在 JS 使用上非常頻繁，但一個 this 每個 function 都各自表示，這裡就直接用範例說明 This 有哪些情境，不過請注意一點，影響 this 的是在於函式的呼叫方法，並非宣告的時機： 純粹的調用 (Simple call)如果直接調用函式，此函式的 this 會指向 window，以下兩個範例都是直接調用含式，所以都是指向 window。 12345678window.auntie = '漂亮阿姨';function callAuntie() &#123; console.log('call:', this.auntie); // this == window // 所以此時的 this.auntie 一樣可以取得 window 下的 auntie&#125;callAuntie(); 這裡將 function 內在包覆著 function，但只要是直接呼叫，this 都是屬於全域。 123456789101112window.auntie = '漂亮阿姨';function callAuntie () &#123; console.log('call:', this.auntie); // function 內的 function function callAgainAuntie () &#123; console.log('call again:', this.auntie); &#125; callAgainAuntie();&#125;callAuntie(); 無論在哪一層，純粹的調用方式 this 都會指向 window。 物件的方法調用 (As an object method)如果 function 是在物件下調用，那麼 this 則會指向此物件，無論 function 是在哪裡宣告。以下的範例中一個是純粹的調用，另一個則是使用物件的方法調用，物件的方法調用時 this 會指向調用的物件。 12345678910111213function callName() &#123; console.log(this.name);&#125;var name = '全域阿婆';var auntie = &#123; name: '漂亮阿姨', callName: callName // 這裡的 function 指向全域的 function，但不重要&#125;callName() // '全域阿婆'auntie.callName() // '漂亮阿姨'，呼叫是在物件下調用，那麼 this 則是該物件 相同的道理，宣告的位置不重要，重要的是呼叫的方法。如果將物件內的函式賦予在一個純粹的變數上並調用它時，這個 this 將會指向全域。 1234567891011var name = '全域阿婆';var auntie = &#123; name: '漂亮阿姨', callName: function () &#123; console.log(this.name); &#125;&#125;// 將 function 指向物件內的 function，不過不重要callThisName = auntie.callName; callThisName() // '全域阿婆' DOM 物件調用 (As a DOM event handler) 同此方法DOM 搭配 addEventListener 時，此 this 所指向的則是該 DOM。以下這段程式碼可以貼在任何網頁下的 Console，接下來點擊畫面上任何一區域，該區域則會加上紅線。 123456789var elements = document.getElementsByTagName('div');function changeDOM() &#123; console.log(this); // 指向當前的 DOM this.style.border = '1px solid red'&#125;for (var i = 0; i &lt; elements.length; i++) &#123; elements[i].addEventListener('click', changeDOM, false);&#125; 建構式的調用 (As a constructor)在建構式下會 new 一個新物件，此時的 this 會指向新的物件。建構式在後續的章節會介紹，此部分只要了解建構式的 this 也是指像物件本身即可。 123456function FamilyConstructor () &#123; this.mom = '老媽'&#125;var myFamily = new FamilyConstructor();console.log(myFamily.mom); 這一個 this 不會是全域且可以在生成的物件上重新定義 (所以他指向的是該生成的物件)。 123456789var mom = '全域老媽';function FamilyConstructor(newMom) &#123; this.mom = newMom || '老媽';&#125;var myFamily = new FamilyConstructor('希望是漂亮阿姨');var realFamily = new FamilyConstructor();console.log('我的', myFamily.mom); // 我的 希望是漂亮阿姨console.log('現實', realFamily.mom); // 現實 老媽 使用 Call 來呼叫 functioncall 調用的函式可以直接傳入新的物件，使其作為 this 所指向的物件。 1234567var name = '全域阿婆';function callName() &#123; console.log(this.name);&#125;callName(); // '全域阿婆'callName.call(&#123;name: '漂亮阿姨'&#125;); // '漂亮阿姨' call, bind, apply 這三者均可，都可以傳入新的 this 給予函式使用，三者僅是使用方法不同，可參考：Function.prototype.apply() - JavaScript | MDN。 重新指向 this在實際運作時，立即函式 (IIFE) 或是非同步的事件 (setTimeout) 大多都會指向全域，如果需調用的則是物件本身的話，可以先用一個變數指向 this，等到調用後再重新使用它。 1234567891011121314151617function callName() &#123; console.log('區域', this.name); var that = this; setTimeout(function () &#123; console.log('全域', this.name); console.log('區域', that.name); &#125;, 10);&#125;var name = '全域阿婆';var auntie = &#123; name: '漂亮阿姨', callName: callName // 這裡的 function 指向全域的 function，但不重要&#125;auntie.callName(); 這個變數名稱可以自己定義，常見有 that、vm、self 等等，可以使用自己或團隊習慣的為主即可。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 的文法學","slug":"javascript-grammar","date":"2017-12-10T16:00:00.000Z","updated":"2017-12-11T01:31:47.506Z","comments":true,"path":"javascript/2017/12/11/javascript-grammar/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/11/javascript-grammar/","excerpt":"","text":"大多數國家的語言都是由左到右、由上而下的閱讀方式，中文、拉丁語系就是屬於這類型，但也有部分國家是由右到左的，像是阿拉伯語系就是如此。而 JavaScript 是由左到右，還是由右到左呢？大多情況下我們會認為 JavaScript 是由左到右，但部份時候則會由右到左的喔。 運算子用簡單的一點的方式說明， +、=、== 都是運算子，本身這也是屬於函式的一種，是用來將它本身 前後方的值 做計算，然後回傳一個新的值。 13 + 3; // 回傳 6 所以中間的 + 即是運算子，這些運算子都屬於一個函式，但他只要寫在兩個值的中間(或是前、後的其中一方)，不需要完整函式即可運作，所以稱為運算子。運算子可以用來賦予值、數學運算、比較等等，如果想知道有哪些運算子可看：運算式與運算子 - JavaScript | MDN 方向及優先性我們在寫 JavaScript 時也是習慣由左到右撰寫，但其實 JavaScript 文法並不是只有由左到右，而是依據 結合性 (Associativity) 決定它是由左至右，還是由右至左閱讀。 一個簡單的例子： 12a = b = 5;console.log(a); 請問以上這段是從哪個方向開始閱讀!? 上述的例子，將 5 的數值賦予給 b ，再由 b 賦予給 a，所以 a 的值會得到 5。除此之外，JavaScript 還有一個優先性，高優先性 (Precedence) 的運算子會被優先執行，在看以下範例： 123 + 3 * 3 // 得到 12，因為 * 的優先值高於 +(3 + 3) * 3 // 得到 18，因為 () 內的優先計算 我們都了解先乘除後加減，所以乘號的優先值基本上是高於加的；而如果括號則是括號內的優先計算，所以很好理解。 所以下方兩個 a 分別會是什麼？哪一個運算子會先被執行？ 12a = 3 * 3a = 9 === 3 * 0 || 3 所以這段只要了解優先性就可以知道答案，MDN 有提供完整的表可以參考：運算子優先等級，表中的 Precedence 數值越高代表優先度高，也會被優先執行，而 Associativity 則是文法閱讀的順序，大家也可以直接貼到 Chrome Console 看看以上答案。 第二個 a 的說明 129 === 3 * 0 // 得到 falsefalse || 3 // 由於前者是 false，所以用 3 取代 陷阱因為綜合性 (閱讀順序)及優先性的關係，就會產生一些怪異的問題，以下兩個案例非常接近，但卻出現相反的結果，以正確來說以下兩者應該都出現 false，但卻出現一個 true，另一個 false 的結果 (正常專案盡可能不要做連續的判斷)。 121 &gt; 2 &gt; 3 // false3 &lt; 2 &lt; 1 // true 上面的後者來說，他會依據以下方式來執行： 因為文法是由左至右，所以先執行 3 &lt; 2 得到 false 接下來會執行 false &lt; 1 不過此時的 false 會被轉型成 0 0 &lt; 1 所以是 true 這段因為太燒腦，所有小明沒有出場。 延伸問題，請問以下解答是什麼？ 11 &gt; 2 == 0","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 物件的連連看!? 兩個物件的值居然會一樣","slug":"javascript-reference","date":"2017-12-09T16:00:00.000Z","updated":"2017-12-11T01:34:21.465Z","comments":true,"path":"javascript/2017/12/10/javascript-reference/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/10/javascript-reference/","excerpt":"","text":"承上集，小明現在在漂亮阿姨 (陳小美) 家裡，漂亮阿姨還有一個雙胞胎姐姐 - 陳美美，陳美美的各方面與雙胞胎妹妹都很接近，除了名字以外。因此，偷懶的小明決定將兩個人的名字畫線連再一起，然後改個名字就好了。 123456789101112var auntie = &#123; name: '陳小美', ages: 22, bwh: &#123; strength: 34, agility: 25, intelligence: 96 &#125;, single: true&#125;;var auntie2 = auntie; // 將漂亮阿姨得值 連到姊姊上 接下來，調整一下姊姊的名字 12auntie2.name = '陳美美'console.log(auntie.name); // 請問這裡會輸出什麼？ 小明將兩個人的名字，對應到相同的資料結構上，阿姨與她的姊姊都是同一份資料。因此，小明將阿姨姊姊的名字寫到阿姨的名字上了 (明天醒來就會搞不清楚是誰了!?)。 傳值與傳參考一般而言，我們在傳遞變數的時候，如果是單一的值賦予到另一個變數後，兩者是毫無關係的。 12345var a = 'a';var b = a;b = 'c';console.log(a); // a 依然是 'a'，不受影響 但就上面小明故事來說，會發現兩者的物件好像是綁定再一起的，改動其中一個，另一個物件也會跟著更動，這個因為在 JavaScript 中的物件是 “傳參考(by Reference)”，其結果就像是小明筆記本所發生的狀況。 如果使用資料表的概念在思考，可以想像資料表的 Address 就是變數，Value 就是值，一個 Address 只能對應一個值，那麼物件在組成的時候就會產生另一個表，然後透過 address 來做傳遞，所以才會兩個變數共用同一個資料表。 這樣的結果有好處也有壞處，好處是我們在操作物件時，可以輕易地用更短的變數來操作，以下面範例來說，我們可以將 DOM 物件賦予在一個更精簡名稱的變數上，然後修改其中的值。 123var input = document.getElementById('sb_ifc0');input.style.backgroundColor = \"red\";// 在 Google 首頁的 Console 套用此段程式碼，可以將 input 背景改成紅色 壞處可以參考小明所遭遇到的問題，操作資料格式時將兩份資料給搞混了，所以在處理資料時，如果他實際並非 “同一份”，而僅是相似時就要特別注意此問題。 複製物件不含參考我們來介紹不同方式來複製物件且不含參考，而以下是基礎的資料格式。 12345678910var auntie = &#123; name: '陳小美', ages: 22, bwh: &#123; strength: 34, agility: 25, intelligence: 96 &#125;, single: true&#125;; 另外複製也會有區分 深度 (Deep Copy)及淺度 (Shallow Copy)，差異在於一層傳值，還是所有層級皆傳值，在 bwh 這一層就可以做此測試。 手動賦值這是很直接的觀念，把物件的參考賦予方式改用值的方式來傳遞，此時手動傳值的部分將會完全獨立。不過注意，在內層物件還是依據參考的方式傳遞 (bwh 的物件)。 123456auntie2 = &#123; name: auntie.name, ages: auntie.ages, bwh: auntie.bwh, single: auntie.single&#125; for…in和手動賦值的方式接近，不過是使用 for...in 的語法將原本的物件屬性，傳到新的物件上，這種方式同上也是屬於淺層賦值。 1234var auntie3 = &#123;&#125;;for (var prop in auntie) &#123; auntie3[prop] = auntie[prop];&#125; 轉字串將物件轉換為一個不相干的字串，再將字串轉回物件，這種方式就會使兩個物件毫無關聯，屬於完全複製沒有深度限制。 12var str = JSON.stringify(auntie);var auntie4 = JSON.parse(str); 使用套件jQuery 套件中的 extend 可以複製物件，他也可以將加入參數使用深度複製 (deep copy)，不虧是萬年 jQuery，各種好用工具都在其中。 12var auntie5 = jQuery.extend(&#123;&#125;, auntie); // 淺複製var auntie6 = jQuery.extend(true, &#123;&#125;, auntie); // 深度複製 jQuery extend 詳細文件: jQuery.extend() | jQuery API Documentation ES6原生 ES6 中也有提供類似 jQuery 的複製方法，但此方法僅適用於淺複製，並沒有提供深度複製。 1const auntie6 = Object.assign(&#123;&#125;, auntie); By Reference, By Value 在 JavaScript Object 中一值屬於很常見的問題，不管新手老手都曾經錯在其中 T_T。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 就是一堆物件的概念","slug":"javascript-object","date":"2017-12-08T16:00:00.000Z","updated":"2017-12-09T03:08:53.410Z","comments":true,"path":"javascript/2017/12/09/javascript-object/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/09/javascript-object/","excerpt":"","text":"在 JavaScript 中，除了上一篇所介紹到的原始型別以外的都是物件，包含陣列、函式…甚至全域本身都是物件，物件本身可以一層包著一層，其內層可以是字串、數值、陣列、物件，甚至是函式。 故事說明 小明的記事本都是用物件的概念在做紀錄，他會將要做的事情、筆記分門別類的做巢狀紀錄，這樣的好處可以讓他在尋找資料時比較好處理，並且可以自由地新增屬性及值。 那麼小明筆記本資料如果使用 JavaScript 寫的話會如下，可以發現其實大家做筆記的方式也是這樣的巢狀概念： 123456789101112131415161718192021222324var note = &#123; '聯絡人資料': &#123; '阿姨': &#123; name: '陳小美', ages: 22, bwh: &#123; // 三圍 strength: 34, agility: 25, intelligence: 96 &#125;, single: true &#125;, '杰倫': &#123; name: '陳小美', ages: 19, bwh: &#123; // 三圍 strength: 87, agility: 87, intelligence: 87 &#125;, single: false &#125; &#125;&#125; 我們簡化一下資料內容，紀錄單人資料時也是用巢狀的方式在記錄，如果要尋找一個人的特定屬性時也會比較快。(ex: 漂亮阿姨的力量值在 auntie -&gt; bwh -&gt; strength 可以找到)。 12345678910var auntie = &#123; name: '陳小美', ages: 22, bwh: &#123; // 三圍 strength: 34, agility: 25, intelligence: 96 &#125;, single: true&#125;; 如何存取物件物件本身的組成是由一個 {屬性(property) / 值(value)} 組成的，可以透過 JavaScript 的規則定義一個物件的名稱，舉例來說上述的阿姨可以用以下方式定義： 12345var auntie = &#123;&#125;;auntie.name = '陳小美';auntie.ages = 22;auntie.single = true; 相同的概念，我們能夠使用一樣的方式取出物件的值，但如果是未定義的屬性則會出現 undefined，嘗試取出未定義屬性的子屬性則會出錯： 123456console.log(auntie.name); // '陳小美'console.log(auntie.name); // 22// 假設以下值位定義console.log(auntie.bwh); // undefinedconsole.log(auntie.bwh.strength); // 錯誤 另外也可以使用中括號來取用變數的值： 123456var str = 'name'auntie['name']; // 使用純字串auntie[str]; // 使用變數auntie[0]; // 使用數字，就如同存取陣列一樣 (如果有此值)auntie['some-name']; // 使用字串，就算此名稱不符合 JS 的變數命名規則 (如果有此值) 列舉物件有時候，我們無法預設了解物件內有什麼屬性，此時我們可以使用列舉 (for ... in) 來取出物件內的屬性及值。 12345678910111213var auntie = &#123; name: '陳小美', ages: 22, bwh: &#123; strength: 34, agility: 25, intelligence: 96 &#125;, single: true&#125;;for (prop in auntie) &#123; console.log(auntie[prop]); // 陳小美, 22, &#123;bwh&#125;,true&#125; 除了原始型別以外都是物件JavaScript 本身可以運行在瀏覽器、伺服器端，以瀏覽器來說全域本身就是一個大物件 (window)，裡面包含許多瀏覽器的 API、開發者定義變數、DOM 物件… 、方法等，只要在開發者工具下輸入 console.log(window) 就可以看到。 上圖可以看到剛剛宣告的物件也存在於 window 的物件下。 接下來可能會思考到為何陣列、函式都是物件？如果說陣列本身是物件可能也許好理解，他的存取方式與物件是非常相似的 (下方範例)： 1234567var auntie = ['陳小美', 22, &#123; strength: 34, agility: 25, intelligence: 96&#125;, true];auntie[0]; // '陳小美' 但偏偏他還多了許多陣列方法 (像是：push, shift, unshift)，為何還會說是陣列呢？ 這段都與原型繼承有關，我們在更後續的章節再來介紹這一段。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：動態型別的 JavaScript","slug":"javascript-typeof","date":"2017-12-07T16:00:00.000Z","updated":"2017-12-08T03:15:28.037Z","comments":true,"path":"javascript/2017/12/08/javascript-typeof/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/08/javascript-typeof/","excerpt":"","text":"JavaScript 是屬於動態型別，它定義了七種資料型別，分別為六種原始型別 (ES6 新增一種原始型別)及 Object 型別。在開始之前先用小明來說明一下型別是怎樣的東西。 故事說明： 承先前故事，小明每天早上醒來都會忘記所有事物，但會在睡覺前把要做的事情先記錄下來，筆記本上會分門別類寫出要做的事情。 小明有時會將要詢問的事情留空白，等到知道結果後再填上數值，像是某一個商品的價格如果再詢問前無法得知，就會先定義變數，等到有值後寫入： 1var porkPrice; // Undefined 1porkPrice = 200; // Number 小明也不是嚴謹的人，常常在筆記本上塗抹修改的地方，像是亂加漂亮阿姨的姓名、年齡等。 12var auntie = \"漂亮阿姨\"; // Stringauntie = &#123; name: '陳小美', ages: 22 &#125;; // Object 以上僅是說明動態型別，請不要學小明這樣做。 如果要查看型別，可以使用 typeof auntie 來驗證型別，可以透過 typeof 看看以下變數分別屬於哪些型別，其中會發現有趣的事情。 1234567891011var family = &#123; mom: '老媽', me: '小明', sister: '小橙'&#125;;var money = 100;var isEdge = true;var attributes = '邊緣';var variable;var nullVariable = null; // 猜猜這個是什麼型別 六種原始型別原始型別分別為以下六種： Boolean：僅有 true, false 兩個值 Null：僅有 null 的值 Undefined：沒有被定義的變數 String：字串型別 Number：下述說明 Symbol（於 ECMAScript 6 新定義，以後再說明） 除此之外還有一個 物件型別。 Undefined 與 Null這兩個就翻譯上會有點接近，但實際上會有一些差異，首先建議：”不要將變數手動設為 undefined，這可能會造成未預期的結果。 Undefined 是在定義了一個變數，但是沒有給值 Null 則是在一個變數上給予了 “空值” JavaScript 本身不會自動給予值 Null，這是讓開發者來設定變數沒有值的。 強制轉型 Number(undefined) -&gt; NaN、Number(null) -&gt; 0 typeof(undefined) -&gt; undefined、typeof(null) -&gt; Object null 是有效的 JSON 值，undefined 不是 為什麼 null 是 Object，自從有 JavaScript 開始就是這樣了，而這個錯誤不能修正，他會導致不可預期的錯誤 (來源：The history of “typeof null”)。 另外原本也預期在未來會給予 typeof null === &#39;null&#39; 的正確結果，但後來也被拒絕。 Number數字型別是一種 浮點數)，這種數值在極大值時會有精準度的問題，範例： 110000000000000000 - 1; // 一樣是 10000000000000000 所以有些文章會提到不要用 JavaScript 來算錢，可是也要先有這麼多錢再說啊 QQQQ。另外還有以下三種都屬於此 Number 型別。 +Infinity -Infinity NaN (not a number，但屬於數字型別，強制轉型有時會出現此錯誤) 物件型別除了上述的六種原始型別，其餘都是物件型別，包含很常使用的 “陣列”、”函式” 都屬於物件型別。 下一個章節會開始來介紹 JavaScript 的物件，了解物件的概念有助於了解整個 JavaScript 的架構及運作喔 :)","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：一次只能做一件事情的 JavaScript","slug":"javascript-event-queue","date":"2017-12-06T16:00:00.000Z","updated":"2017-12-07T03:06:33.000Z","comments":true,"path":"javascript/2017/12/07/javascript-event-queue/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/07/javascript-event-queue/","excerpt":"","text":"在 JavaScript 中，一次只會執行一段程式碼，相信看到這段大家心中都會有所疑惑，我們實作中可以大量發出許多事件，並重複執行不同的函式，這樣為何還是單執行緒 (single threaded) 的程式語言呢？ 這段如果用純文字解釋較為困難，所以本篇會加入動畫讓大家更容易了解原理。 故事說明小明故事：小明在完成早上的事情後，他會準備做以下事情： 打電話給漂亮阿姨 等待漂亮阿姨回覆 清理碗盤… 接下來他會有以下動作 打電話給漂亮阿姨 心中掛念著 漂亮阿姨 回電 (Event Queue) 去清理碗盤 接到阿姨的回電 小明並沒有再打給阿姨後就守在電話旁，而是先去做其他事情等待，並且把漂亮阿姨回電這件事情先放在心中，等待回電後再去接聽。 123456789101112131415161718192021function doWork() &#123; var auntie = \"漂亮阿姨\"; (function () &#123; console.log('打給阿姨') setTimeout(function () &#123; console.log(auntie + '回電') &#125;, 3000) &#125;)(); (function () &#123; console.log('洗碗'); &#125;)();&#125;doWork(); // 執行// 打給阿姨// 洗碗//// 漂亮阿姨回電 Event queue (事件佇列)像小明先把事情擱置在心中，等待條件觸發在 JavaScript 稱為 Event queue。像是 setTimeout, addEventListener, XMLHttpRequest 等等，這些方法在執行時會先將事件放到這地方，並將所有的事件堆疊完成後，才會開始讓 event queue 內的事件被觸發。 我們透過以下的短影片來了解一下 event queue 是怎麼樣概念 (影片下方是時間軸，用來解釋事件堆疊)。 Your browser does not support the video tag. 影片中我們可以看到 事件堆疊會逐一執行 等到執行到不會立即執行的行為，就會放到 event queue，event queue 的事件在 所有事件完成前 不會被執行。 等到所有事件堆疊完成後 event queue 內的事件才能被觸發。 這裡將 setTimeout 修改成 0 試試看，確認是不是所有事件堆疊都完成後，才會執行 event queue 的事件。 12345678910111213141516function doWork() &#123; var auntie = \"漂亮阿姨\"; (function () &#123; console.log('打給阿姨') setTimeout(function () &#123; console.log(auntie + '回電') &#125;, 0) // 修改成 0 秒 &#125;)(); // ... console.log('洗碗'); return '完成事件堆疊';&#125;doWork(); // 執行 他一樣會將所有事件完成後，再讓 setTimeout 完成，以上這段程式碼也可以貼在 Chrome 開發者工具內試試看。 1234打給阿姨洗碗// &quot;完成事件堆疊&quot;漂亮阿姨回電 在所有非同步事件如 click、setTimeout、ajax…，都不會立即執行這些行為，而是將這些行為放到 event queue 中，等待事件觸發後再回來執行。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：JavaScript 變數的宣告與他的作用域","slug":"javascript-variables","date":"2017-12-05T16:00:00.000Z","updated":"2017-12-06T03:14:15.977Z","comments":true,"path":"javascript/2017/12/06/javascript-variables/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/06/javascript-variables/","excerpt":"","text":"變數分為全域與區域變數，差異點在於宣告 (var) 的方式，就 MSDN 上的說明 在函式定義之外宣告的變數就是全域變數，其值可在整個程式中存取和修改。 所以我們可以使用函式來做兩個的分隔點，函式之內宣告的稱為區域，函式以外宣告的稱為全域。 全域性的變數在函數外宣告的變數則是具有全域性(或是包含全域物件之內)，在瀏覽器下的全域物件是 window，有以下方式所產生的變數都會在 window 內。 12345678910// 在函示外宣告var mom = '老媽';// 沒有使用 varmom = '老媽';(function () &#123; // 或是在函式內，但沒有使用 var mom = '老媽';&#125;)(); 以上方式都可以在 console.log(window); 後找到 `mom 這個變數，這個變數也屬於 全域物件，因此所有函式也都能取用此變數。 另外，也可以直接產生在 window 物件下。1window.mom = '老媽'; 這幾種方式都會在 window 物件下產生 mom，並且所有函示都能取用，但還是有些差異 (後面會介紹)，但就實際使用來說，建議無論如何都宣告你的變數。 變數與他的作用域每個變數在宣告時，都只會在執行環境內建立記憶體，這個就是他的作用域，單如果此作用域內沒有可用的變數時，他則會參照外圍的。 12345678910function doMorningWork() &#123; var mom = \"老媽\"; function sayHi() &#123; var greeting = 'hi'; return greeting + ' ' + mom; &#125; console.log(sayHi());&#125;doMorningWork(); // 執行 回到上一集的故事：小明會將每一天的要做的事情寫在記事本內，並且記錄著許多工作內容。小明在 doMorningWork() 工作下建立了 mom 變數，這個 mom 就僅屬於 doMorningWork() 內，其它外部的函式都無法取用這個函式。 (旁白：小明出門後就可以不認這個媽媽了!?) 外層 doMorningWork(); 具有 mom 的變數 內層 sayHi(); 可以使用 mom 這個變數，讓小明可以跟媽媽說早安 另一個函式就無法取用 mom 這個變數。 其中內層沒有 mom 的變數，他就會向外層尋找，找到有相同名稱的就直接拿來使用。(旁白：小明啊，你應該把媽設為全域啊!?) 變數與記憶體關係使用 var 宣告一個變數時，記憶體會先準備一個空間給予此變數，所以在實際運行前調用此變數並不會出現錯誤，只會出現 undefined (已經有記憶體空間，但沒有值)。 12console.log(mom); // undefinedvar mom = '老媽'; 故事：小明本身記性就不好，他會採取先整個看一次的方式，將整個印象存在腦中 (開啟記憶體空間)，實際開始後再把實際把當天人、事、物整個記在腦內。 宣告與不宣告MDN 文中提到 其中差異在於, 已宣告的變數是全域物件裡的一個無法變更 (non-configurable) 的屬性, 而未宣告的變數則是可變更的 (configurable) ，可以嘗試刪除產生的變數，觀察其差異。 案例：1234567891011121314var mom1 = \"老媽1\";mom2 = \"老媽2\"; (function () &#123; mom3 = \"老媽3\"; &#125;)();delete mom1;delete mom2;delete mom3;console.log(window.mom1); // 僅剩此有值console.log(window.mom2);console.log(window.mom3); 提醒如果使用 var 則會先在記憶體準備一個空間給他，所以執行以前使用這個變數還不至於跳錯。 12console.log(mom); // undefinedvar mom = '老媽'; 但如果沒有使用 var，則會跳出錯誤。12console.log(mom); // mom is not definedmom = '老媽'; 所以無論你的變數或函式是否要使用全域，都盡可能地去宣告它。至於 Let、Const 請容許我到後面 ES6 章節再來介紹它 :)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：執行環境與堆疊","slug":"ironman-2017","date":"2017-12-04T16:00:00.000Z","updated":"2017-12-05T01:49:59.820Z","comments":true,"path":"javascript/2017/12/05/ironman-2017/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/05/ironman-2017/","excerpt":"","text":"JavaScript 一次只能做一件事情，他會依據 執行環境 (Execution Context) 來一一執行工作內容，本篇系列文會用舉例的方式，讓大家用簡單的方式瞭解這些艱深詞彙。 全域執行環境與函式在一開始會登記一個函式在全域環境下(global context)，然後這個全域環境下可以登記其他函式，然後每一段執行環境下會有屬於他的變數以及物件，如果找不到該執行環境的變數或物件，則會向外層尋找。 故事說明：小明是本作的主角，早上時固定會做幾件事情，一個是與老媽說早安，另一個則是吃早餐，老媽與早餐可能會換(?)，所以他是可能會變動的，但大致上來說是說完早安，再去吃早餐。於是會在紙上紀錄下早上要做的事情。 早上要做的事情： 變數 媽：”老媽” 早餐：”麵包” 要做的事情 (function context) 吃早餐 說 ‘hi’ 12345678910111213141516171819function doMorningWork() &#123; // 從此 function 的大括號是另一個執行環境 var mom = \"老媽\"; var breakfast = \"麵包\"; function sayHi() &#123; // 說早安執行環境 return 'hi ' + mom; &#125; function eatBreakfast() &#123; // 吃早餐執行環境 return '吃 ' + breakfast; &#125; console.log('早安,' + sayHi() + ', ' + eatBreakfast());&#125;doMorningWork(); // 執行 這個地方我們得到了三個執行環境(Execution Context)，其中一個是 (global context)，另外兩個則是在 global 下的 doMorningWork 內。 故事說明：小明得了一個症狀，每天早上都是全新的一天，他會忘記先前的人事物(簡直電影故事劇情，細節不重要)，他會將每天該做的事情記錄下來，也分為主要任務及主要任務下的次要任務，並且把任務的相關人等寫下，並且一件一件事情完成它 (小明只有一個，一次只能做一件事情)。 他會依序將工作完成： 檢視一下工作任務有哪些 看完早上的任務後開始執行 doMorningWork() 接下來將會面對的人事物先存在大腦內 var ... 接下來他會面對第一個工作 sayHi() 這個工作沒有專屬的變數，於是他找主要任務的變數 mom 執行完成 做下一個任務… 他會將所有的任務完成，才會開始做下一個主要任務 (這個範例只有一個) 要做的事情往後會越來越多，小明會把要做的事情存在腦內，然後依據順序來執行。 糟糕的事情是，遇到他不知道該怎麼做下去的事情，他會卡在那邊一整天 (xxx is not defined)。 小明的筆記本與 JavaScript 有著接近的邏輯，有著一件一件要做的事情等待他去完成。 執行堆疊在這個故事中也可以說明 JavaScript 的執行堆疊，一開始會先進入 global 執行環境，接下來再進入內層的環境，執行完的堆疊就會被釋放掉 (function 內的 return 即是完成)，然後逐步地完成所有堆疊，最後將控制權交還給 Global。 每個執行堆疊都會一層一層地向內執行，等到都執行完以後才會回到外層執行下一個任務。 這段概念影響了什麼？ JavaScript 由外而內執行，執行完才會進行下一個動作 如果其中一個環境卡住，那麼 JavaScript 就會掛掉(小明想不通) 另外，變數的作用域也與此有很大的關係，我們到下一章節來繼續介紹關於作用域 :)。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"鐵人賽：邁向 JavaScript 勇者之路 - 開始","slug":"ironman-2017","date":"2017-12-03T16:00:00.000Z","updated":"2017-12-04T01:47:34.310Z","comments":true,"path":"javascript/2017/12/04/ironman-2017/","link":"","permalink":"https://wcc723.github.io/javascript/2017/12/04/ironman-2017/","excerpt":"iT邦幫忙的鐵人賽到目前是第四次參加，前幾次參加有兩次是 CSS，而本次是 JavaScript，主要原因當然是 JavaScript 即將要統治世界 (!?)，僅只有 CSS 的能力很難體會這個世界的險惡美好。 JavaScript 能做的事情非常多，Web 端的應用僅是其中的一小部分，現在包含後端、自動化、IOT、區塊鏈…許多軟體運用都可借助 JavaScript 的語言來開發，雖說不一定是最適合所有情境的，但學一個語言做更多何樂而不為呢？ 這次所介紹的 JavaScript 不限於瀏覽器上的運用，而是 JavaScript 運作上的概念，主要的文章內容包含： 執行環境 文法與陷阱 型別與物件 函式 原型 ES6 的語法說明","text":"iT邦幫忙的鐵人賽到目前是第四次參加，前幾次參加有兩次是 CSS，而本次是 JavaScript，主要原因當然是 JavaScript 即將要統治世界 (!?)，僅只有 CSS 的能力很難體會這個世界的險惡美好。 JavaScript 能做的事情非常多，Web 端的應用僅是其中的一小部分，現在包含後端、自動化、IOT、區塊鏈…許多軟體運用都可借助 JavaScript 的語言來開發，雖說不一定是最適合所有情境的，但學一個語言做更多何樂而不為呢？ 這次所介紹的 JavaScript 不限於瀏覽器上的運用，而是 JavaScript 運作上的概念，主要的文章內容包含： 執行環境 文法與陷阱 型別與物件 函式 原型 ES6 的語法說明 原型以前的章節約莫佔 15 ~ 20 篇，剩下的章節會介紹 ES6，文章內的語法都可運行在 Chrome Browser 及 Nodejs 環境(詳細需參考版本)。 系列文章適合誰我希望這篇文章適合給有基礎 JavaScript 觀念，但非相關科系的朋友。 對於具有相關背景的朋友來說，閱讀 MDN 的文件已經非常容易，但如果你和我一樣是屬於半路出家，完全不懂 Hello World 是什麼梗的話，那麼相信本系列文章能夠幫助到您。 本系列文章將會去除許多艱澀難懂的詞彙(但會盡可能附上原文)，用我們平常聊天的語彙來了解 JavaScript。 案例說明文章中的範例都可以直接貼在 Chrome Browser Console 內，所以你可以打開 Chrome 的開發者工具 &gt; Console，接下來複製以下程式碼貼上，就可以得到如註解的結果。 1234567var originCash = 1000;function updateEasyCard(cash) &#123; var money = (cash || 100) + originCash; console.log('我有 ' + money + ' 元');&#125;updateEasyCard(); // 我有 1100 元 除此之外，文章中也會用許多圖例、故事範例，舒緩閱讀上的壓力!? 歡迎交流如果對於文中有任何疑慮或有錯誤也歡迎指正，JavaScript 博大精深，是即將要統治世界的語言 (X)，透過交流我們也更能了解其中的奧妙，哪麼我們就準備開始吧～。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"}]},{"title":"在 VSCode 啟用程式碼規範工具 (ESLint)","slug":"coding-style","date":"2017-11-08T16:00:00.000Z","updated":"2017-11-10T01:06:26.656Z","comments":true,"path":"tool/2017/11/09/coding-style/","link":"","permalink":"https://wcc723.github.io/tool/2017/11/09/coding-style/","excerpt":"","text":"許多同學會詢問到程式碼怎樣寫可以比較整齊且符合規範，在 VSCode 中非常容易整合這樣的工具，這邊提供兩個方法給大家參考，不過記得兩者不能混用，使用時請擇一即可。 ESLint：比較正式的方法，有完整的文件規範，適合團隊使用 JavaScript Standard Style 插件：比較簡單的方法。 方法一：ESLint先開啟 / 安裝 VSCode 中的 ESLint 套件，記得預設的 VSCode 是有安裝此套件的，套件中也有提到如何運行。 安裝 ESlint 的 npm 套件，目的是可以使用 eslint 的指令，方便建立規範使用的。1npm install -g eslint 開啟 Terminal 後，輸入 eslint --init 接下來會出現一連串的問題，你想要怎麼建立 ESLint 的規範文件？Q: How would you like to configure ESLint? Answer questions about your style Use a popular style guide Inspect your JavaScript file(s) 建議選擇 使用主流的 Style Guide (第二個)，如果使用此選項，他會要求先建立 package.json，如果專案中沒有 package.json 可以輸入：1npm init 其中的問題可以 Enter 到底即可，接下來再回到上一步 eslint --init 繼續選擇建立規範。 選擇 Use a popular style guide 後，會出現三個主流的規範。 Google Airbnb：如果選擇此選項，會多問一個是否使用 React Standard 接下來會選擇要哪一種格式 YAML、js、json 來儲存規範，這個規範是能夠讓其他專案使用的，只要團隊討論好即可。 安裝完後，在專案內會增加一個 eslint.js (或者其他，依據上述選擇的而定)，此時可以先關閉 VSCode 專案再重啟一次，接下來選擇 “輸出” 可以看到 ESLint server is running.，並且沒有其他錯誤訊息表示已成功運行 (如下圖)。 接下來會看到畫面上都了很多紅色提示，滑鼠移到紅底線上方會提示該如何修改。 目標就是減少畫面上的紅字 T_T，如果有未定義的變數也會跳紅字，目標當然是去除專案中的紅字來符合規範。 上圖選的是 Airbnb 的規範，相關可參考：GitHub - airbnb/javascript: JavaScript Style Guide 其它注意事項： 如果無法順利進行，可嘗試重新安裝 node_modules 試試看。 如果有替換規範，也要重新安裝 node_modules。 重開 VSCode、重裝 node_modules 都是解決問題的好方法。 方法二：JavaScript Standard Style這是使用 Standard JS 提供的 VSCode 套件，不要與 ESLint 混合使用，也可以直接在工作區關閉 ESLint 只執行 Standard JS 接下來安裝 JavaScript Standard Style 的 VSCode 套件，安裝完後直接重起就能使用了，沒有額外的設定檔。 套件路徑：https://marketplace.visualstudio.com/items?itemName=chenxsan.vscode-standardjs 啟用後再右下方一樣會出現 JavaScript Standard Style 的字樣，Standard 相對於其他規範來說寬鬆很多，最大的特點是沒有分號。 寫起來長得像這樣 (未定義或定義但未使用的仍然會跳錯)，另外還有繁體中文的文件 (standard/README-zhtw.md at master · standard/standard · GitHub)。 我自己是比較喜歡 Standard，但缺點就是沒有分號，如果用在教學中同學可能會誤以為 JavaScript 不用分號。Airbnb 比較不習慣的則是物件裡的逗號，一般物件的最後一個是沒有逗號，但在 Airbnb 則是逗號到底。","categories":[{"name":"tool","slug":"tool","permalink":"https://wcc723.github.io/categories/tool/"}],"tags":[{"name":"tool","slug":"tool","permalink":"https://wcc723.github.io/tags/tool/"}]},{"title":"從設計轉職工程師的原因及過程","slug":"from-starter","date":"2017-07-26T16:00:00.000Z","updated":"2017-07-27T03:34:35.000Z","comments":true,"path":"life/2017/07/27/from-starter/","link":"","permalink":"https://wcc723.github.io/life/2017/07/27/from-starter/","excerpt":"跟很多人說過過去是 “設計師” 而現在轉職成前端工程師，這個轉換過程有兩個問題很多人長問到： 為什麼會想做工程師 設計師是怎麼轉成工程師的 先前都會一一的回答，但相關的故事其實挺多的，所以整理成一篇給大家參考囉。","text":"跟很多人說過過去是 “設計師” 而現在轉職成前端工程師，這個轉換過程有兩個問題很多人長問到： 為什麼會想做工程師 設計師是怎麼轉成工程師的 先前都會一一的回答，但相關的故事其實挺多的，所以整理成一篇給大家參考囉。 為什麼會想做工程師我在學的時候是從純美術到平面設計，過去對於相關產業有美好的憧憬，事實應該大家也略有所聞；但最終設計不能滿足我的則是以下幾點： 薪資：工作主要分為兩個層面，一則是獲得薪資，另一面則是獲得成就感，設計市場在業界普遍不會有太高的價值，這並不是台灣不重視設計，而是供需問題；開設計學院好像是每間學校洗科系數量的最快方法時，設計這種依主觀偏好定價的市場環境，加上難以用量化來評斷價值，人力資源過多的情況下自然難以提高薪資。盡早轉換一個專業來提高自己的市場價值是當時的主要想法。 成就感：以前我一直在思考一個問題，如何證明自己的價值；除了每個月發的薪資條，如何計算為了公司或是一個產品的貢獻值。這個在設計行業是很難計算的，以平面廣告來說，張貼在路邊的平面廣告如何計算出他拉了多少客人？獲得多少轉換值？無法了解就會變成用欺騙來說服自己，其實本質還是無法獲得成就感的。 恩…，不過直白點轉職後收入大幅提升，且過著更愉快的生活，你們會心動嗎？ 答案是不一定的，因為中間充滿了不確定性，以及「堅持」的毅力。 但在這樣長時間的學習後，其實對於設計也有很大不同的看法，畢竟當初的觀念是有很多不成熟的思想在內。現在有幸認識許多業界的設計高手，像是從銷售面來介紹設計、從數據分析改善 UI 流程、專注於台灣文化風格表現、將設計規範融合企業精神等等，這邊就不細說了。 設計師是怎麼轉成工程師的奇異博士的導師問奇異博士：「你是如何成為一名醫生的？」 奇異博士：「經過多年的學習和實際演練。」 要轉換一個跑道並非沒有捷徑，但還是免不了大量的學習以及實際演練，而捷徑則是「正確方向的學習」及「高密度的實際演練」；正確的方向也是新手遇到最大的問題，因為在尋找的過程中會不了解「正確的方向」在哪？ 從社群中學習：如果能遇到好導師當然是很棒的，另外還有一股很強的能量在軟體圈很盛行，那就是技術社群，找不到好導師，人多的地方或許也能找到答案，所以我從就業後沒多久就開始參加技術社群。 每天發文，持續百日：持續練習是相當有效的，而發文是在公眾下證明自己，心態上也會更重視內容，呈現決心上也不容易中斷(大多數人對於公開的承諾都會盡可能的去達到)。不過雖說如此，很建議在開始時別去思考太多細節，重點在 開始 與 堅持，如果沒有開始所有都是白說的。 A share a day：持續一百天的發文 這個網站是用當時所了解的技術完成的： 超過 100 篇文章 (約 110)，每天發文不中斷 (左邊選單有個 more 可以展開) 當初建構時只花了幾個小時，只為了快速開始 網站是使用 Ajax 呼叫其他頁面內容 網站沒有 SEO 的觀念，因為內容都是透過 Ajax 導入 前面幾乎都是 CSS，後面導入了較多 JavaScript 文章 學習成果： 更熟練的 CSS 技巧，如：animation, CSS 3D, Flexbox 對於 Canvas 有一定的概念 還拿到 ITHome 鐵人賽優選 隔年薪資提高 20%+ 自信 而後還另外再參加兩次的的 ITHome 的鐵人賽，分別是 D3.js 及 CSS 的主題，參加還多一份自己的筆記，有人問相關問題直接丟給他多棒！ 結語以上就是個人在出社會後的學習經歷，這個環境其實是不太會看一個人的過去及生長背景，出社會後的努力遠大於在學期間的課業，如果對於現階段生活不滿意，何不試試大量學習翻轉一把呢？","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"圖解：CSS Flex 屬性一點也不難","slug":"css-flex","date":"2017-07-20T16:00:00.000Z","updated":"2017-07-21T08:24:12.000Z","comments":true,"path":"css/2017/07/21/css-flex/","link":"","permalink":"https://wcc723.github.io/css/2017/07/21/css-flex/","excerpt":"前幾篇有介紹過 CSS Grid Layout 的使用方法，當我們學習排版類型的 CSS 時，最好的方式是先作分類，以 Flex 與 Grid Layout 來說都有共同的特徵，就是他們有分為外容器屬性與內元件屬性。","text":"前幾篇有介紹過 CSS Grid Layout 的使用方法，當我們學習排版類型的 CSS 時，最好的方式是先作分類，以 Flex 與 Grid Layout 來說都有共同的特徵，就是他們有分為外容器屬性與內元件屬性。 Flex 的外容器與內元件屬性放錯地方就沒有作用(廢話)，學習的過程中如果可以先了解正確的擺放位置，可以減少許多除錯的時間；Flex 中分為外容器與內元件，下方這張圖就是解釋這兩個的差異。 Flex 外容器屬性： display flex-flow flex-direction flex-wrap justify-content align-items Flex 內元件屬性： flex flex-grow flex-shrink flex-basis order align-self 類別分清楚，至少在練習的時候已經對了一半，接下來就可以開始做屬性的練習與介紹。 外容器display一開始要宣告為 flex 才能使用，如果沒有宣告為 flex，本篇大部分的屬性都無法作用，不過除了 flex 外，還有一個 inline-flex，作用類似於 inline-block + flex。 123.flex-container &#123; display: flex | inline-flex;&#125; flex-directionFlex 決定內元件排序方向的重要屬性，這也直接影響了 flex 的軸線 (主軸及交錯軸)，flex 中的對齊屬性都與此有很大的相關聯，下圖中是預設狀態的軸線方向。 flex-direction 就是來改變上圖中的軸線方向，可以將軸線做水平反轉、轉為垂直、垂直反轉等，下圖是四種軸線排列的示意圖： 123.flex-container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; 這個範例則是將主軸線設定為垂直的方向，所以 flex 的內容都是以垂直做排列。 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex-direction) by Wcc723 (@Wcc723) on CodePen. flex-wrap超出範圍時是否換行的屬性，分為換行、不換行、換行時反轉。 123.flex-container &#123; flex-wrap: nowrap | wrap | wrap-reverse;&#125; 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex-wrap) by Wcc723 (@Wcc723) on CodePen. flex-flow這僅僅是 flex-direction 與 flex-wrap 的縮寫，所以只要在這前後帶上相對應的值即可。 123.flex-container &#123; flex-flow: &lt;'flex-direction'&gt; || &lt;'flex-wrap'&gt;&#125; justify-content這個屬性和下方屬性很像，很接近水平對齊的設定，但嚴格說來是稱為主軸對齊，主軸的設定是上方的 flex-direction；所以實際是水平或垂直，要依主軸的方向而定喔。 123.flex-container &#123; justify-content: flex-start | flex-end | center | space-between | space-around;&#125; align-items相對於上一個屬性，這是交錯軸的對齊設定。 123.flex-container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex-justify) by Wcc723 (@Wcc723) on CodePen. align-content上一個屬性的多行版本，排列方式也有多一些，但注意 stretch 在高度被限制的情況下不會正常伸展。 123.flex-container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (align-content) by Wcc723 (@Wcc723) on CodePen. 內元件內元件的設定其中之一 flex 是這當中最特別的，只要搞懂 flex 的設定就了解了 flex 最困難的部分，所以我們就從這部份開始介紹喔。 flexflex 是縮寫，裡面依序包含三個屬性 flex-grow、flex-shrink 和 flex-basis，如果只設定一個則是 flex-grow。 flex-grow: 元件的伸展性，是一個數值，當空間分配還有剩餘時的當前元件的伸展性，預設值為 0，如果設置為 0 則不會縮放。 flex-shrink: 元件的收縮性: 元件的伸展性，是一個數值，當空間分配還不足時的當前元件的收縮性，預設值為 0，如果設置為 0 則不會縮放。 flex-basis: 元件的基準值，可使用不同的單位值。 以下圖為例，伸展值為 2 的空間會佔更多。 可點擊 Edit on Codepen 自己玩看看更了解： See the Pen Flex 介紹 (flex) by Wcc723 (@Wcc723) on CodePen. align-selfalign-self 可以調整內元件交錯軸的對齊設定(主軸線則不能另外做設定)，且可以個別設定單一元件的值。 See the Pen Flex 介紹 (align-self) by Wcc723 (@Wcc723) on CodePen. Order這是一個相當特別的屬性，可以重新定義元件的排列順序，順序會依據數值的大小排列。 See the Pen Flex 介紹 (order) by Wcc723 (@Wcc723) on CodePen. 和過去不同，Flex 已經是主流的 CSS 屬性，現在許多 CSS 框架也都是使用 Flex 來作網格排版。搭配著範例，動手玩玩看能夠更快速的了解 Flex 喔。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"JavaScript 陣列處理方法 [filter(), find(), forEach(), map(), every(), some(), reduce()]","slug":"es6-native-array","date":"2017-06-28T16:00:00.000Z","updated":"2017-06-29T07:40:29.000Z","comments":true,"path":"javascript/2017/06/29/es6-native-array/","link":"","permalink":"https://wcc723.github.io/javascript/2017/06/29/es6-native-array/","excerpt":"陣列處理技巧是 JavaScript 中非常重要的一塊，現在框架大亂鬥的時代，框架基本上對於 DOM 的處理都有屬於自己一套良好的方法。只要能夠對於陣列資料操作熟悉，配合框架就能夠將開發效率更上層樓。 本篇介紹到的方法有： filter() find() forEach() map() every() some() reduce()","text":"陣列處理技巧是 JavaScript 中非常重要的一塊，現在框架大亂鬥的時代，框架基本上對於 DOM 的處理都有屬於自己一套良好的方法。只要能夠對於陣列資料操作熟悉，配合框架就能夠將開發效率更上層樓。 本篇介紹到的方法有： filter() find() forEach() map() every() some() reduce() 直接點上方連結就能跳到指定區域 初始資料本篇都是使用同一份陣列資料，當然你也可以把相關的函式直接貼在 jsbin 或 codepen 上就能看到結果，因為篇幅已經很長了，所以就不在另外補上範例檔。 1234567891011121314151617181920212223// 相同的陣列var people = [ &#123; name: 'Casper', like: '鍋燒意麵', age: 18 &#125;, &#123; name: 'Wang', like: '炒麵', age: 24 &#125;, &#123; name: 'Bobo', like: '蘿蔔泥', age: 1 &#125;, &#123; name: '滷蛋', like: '蘿蔔泥', age: 3 &#125;]; Array.prototype.filter()filter() 會回傳一個陣列，其條件是 return 後方為 true 的物件，很適合用在搜尋符合條件的資料。 12345678910111213var filterEmpty = people.filter(function(item, index, array)&#123;&#125;);console.log(filterEmpty); // 沒有條件，會是一個空陣列var filterAgeThan5 = people.filter(function(item, index, array)&#123; return item.age &gt; 5; // 取得大於五歲的&#125;);console.log(filterAgeThan5); // Casper, Wang 這兩個物件var filterDouble = people.filter(function(item, index, array)&#123; return index % 2 === 1; // 取得陣列中雙數的物件&#125;);console.log(filterDouble); // Wang, 滷蛋 這兩個物件 Array.prototype.find()find() 與 filter() 很像，但 find() 只會回傳一次值，且是第一次為 true 的值。 12345678910111213var findEmpty = people.find(function(item, index, array)&#123;&#125;);console.log(findEmpty); // 沒有條件，會是 undefinedvar findAgeThan5 = people.find(function(item, index, array)&#123; return item.age &gt; 5; // 取得大於五歲的&#125;);console.log(findAgeThan5); // 雖然答案有兩個，但只會回傳 Casper 這一個物件var findLike = people.find(function(item, index, array)&#123; return item.like === '蘿蔔泥'; // 取得陣列 like === '蘿蔔泥'&#125;);console.log(findLike); // 雖然答案有兩個，但只會回傳第一個 Bobo 物件 Array.prototype.forEach()forEach 是這幾個陣列函式最單純的一個，不會額外回傳值，只單純執行每個陣列內的物件或值。 1234567891011var forEachIt = people.forEach(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列 return item; // forEach 沒在 return 的，所以這邊寫了也沒用&#125;);console.log(forEachIt); // undefinedpeople.forEach(function(item, index, array)&#123; item.age = item.age + 1; // forEach 就如同 for，不過寫法更容易&#125;);console.log(people); // 全部 age + 1 Array.prototype.map()使用 map() 時他需要回傳一個值，他會透過函式內所回傳的值組合成一個陣列。 如果不回傳則是 undefined 回傳數量等於原始陣列的長度 這很適合將原始的變數運算後重新組合一個新的陣列。 12345678910111213141516171819202122232425262728var mapEmpty = people.map(function(item, index, array)&#123;&#125;);console.log(mapEmpty); // [undefined, undefined, undefined, undefined]var mapAgeThan5 = people.map(function(item, index, array)&#123; return item.age &gt; 5; // 比較大於五歲的&#125;);console.log(mapAgeThan5); // [true, true, false, false]var mapAgeThan5_2 = people.map(function(item, index, array)&#123; // 錯誤示範 if (item.age &gt; 5) &#123; return item; // 回傳大於五歲的 &#125; return false; // 別以為空的或是 false 就不會回傳&#125;);console.log(mapAgeThan5_2); // [&#123;name: 'Casper'...&#125;, &#123;name: 'Wang'...&#125;, false, false]var mapEat = people.map(function(item, index, array)&#123; if (item.like !== '蘿蔔泥') &#123; return `$&#123;item.like&#125; 好吃`; &#125; else &#123; return `$&#123;item.like&#125; 不好吃`; &#125;&#125;);console.log(mapEat); // [\"鍋燒意麵 好吃\", \"炒麵 好吃\", \"蘿蔔泥 不好吃\", \"蘿蔔泥 不好吃\"] Array.prototype.every()every() 可以檢查所有的陣列是否符合條件，這僅會回傳一個值 true or false，可以用來檢查陣列中的內容是否符合特定條件。 123456789101112131415161718192021222324252627282930313233var array = [ &#123; name: 'Casper', like: '鍋燒意麵', age: 18 &#125;, &#123; name: 'Wang', like: '炒麵', age: 24 &#125;, &#123; name: 'Bobo', like: '蘿蔔泥', age: 1 &#125;, &#123; name: '滷蛋', like: '蘿蔔泥', age: 3 &#125;];var ans = array.every(function(item, index, array)&#123; console.log(item, index, array); // 物件, 索引, 全部陣列 return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true&#125;);console.log(ans); // false: 只要有部分不符合，則為 falsevar ans2 = array.every(function(item, index, array)&#123; return item.age &lt; 25&#125;);console.log(ans2); // true: 全部 age 都小於 25 Array.prototype.some()some() 與 every() 非常接近，都是回傳 true or false，差異僅在 every() 需完全符合，some() 僅需要部分符合。 1234567891011121314var ans = people.some(function(item, index, array)&#123; return item.age &gt; 10 // 當全部 age 大於 10 才能回傳 true&#125;);console.log(ans); // true: 只要有部分符合，則為 truevar ans2 = people.some(function(item, index, array)&#123; return item.age &lt; 25&#125;);console.log(ans2); // true: 只要有部分符合，則為 true var ans2 = people.some(function(item, index, array)&#123; return item.age &gt; 25&#125;);console.log(ans2); // false: 全部都不符合則為 false Array.prototype.reduce()reduce() 和其他幾個差異就很大了，他可以與前一個回傳的值再次作運算，參數包含以下： accumulator: 前一個參數，如果是第一個陣列的話，值是以另外傳入或初始化的值 currentValue: 當前變數 currentIndex: 當前索引 array: 全部陣列 12345678910111213141516var reduceEmpty = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123;&#125;);console.log(reduceEmpty); // 沒有條件，會是 undefinedvar reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; // 分別為前一個回傳值, 目前值, 當前索引值 console.log(accumulator, currentValue, currentIndex); return accumulator + currentValue.age; // 與前一個值相加&#125;, 0); // 傳入初始化值為 0console.log(reducePlus); // 總和為 46var reducePlus = people.reduce(function(accumulator, currentValue, currentIndex, array)&#123; console.log('reduce', accumulator, currentValue, currentIndex) return Math.max( accumulator, currentValue.age ); // 與前一個值比較哪個大&#125;, 0);console.log(reducePlus); // 最大值為 24 reduce() 的使用方法更為豐富，想認識更詳細可參考 MDN。 其它預設的陣列行為內的 this 是指向 window (本篇中除了 reduce() 是傳入初始資料)，如果要改，可以在 function 後傳入。 12345678// arr.forEach(function callback(currentValue, index, array) &#123;// your iterator// &#125;[, thisArg]);var ans3 = people.forEach(function(item, index, array)&#123; console.log(this) // 這邊的 this 就會使用後方傳入的 return item.age &lt; 25&#125;, people); // 傳入的物件，替代 this，如果無則是 window","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"JavaScript ES6 Promise","slug":"promise","date":"2017-05-24T16:00:00.000Z","updated":"2017-06-29T03:05:18.000Z","comments":true,"path":"life/2017/05/25/promise/","link":"","permalink":"https://wcc723.github.io/life/2017/05/25/promise/","excerpt":"","text":"Promise 一直都是 JavaScript 夢寐以求的功能，非同步的處理如果沒有使用 Promise 經常導致函式或資料無法正常的運作。本篇避開許多深度的詞彙，直接透過範例來瞭解怎麼運行。 簡單的 Promise 範例： 123456789101112131415161718192021222324// 宣告 promise 建構式let newPromise = new Promise((resolve, reject) =&gt; &#123; // 傳入 resolve 與 reject，表示資料成功與失敗 let ran = parseInt(Math.random() * 2); // 隨機成功或失敗 console.log('Promise 開始') if (ran) &#123; setTimeout(function()&#123; // 3 秒時間後，透過 resolve 來表示完成 resolve('3 秒時間(fulfilled)'); &#125;, 3000); &#125; else &#123; // 回傳失敗 reject('失敗中的失敗(rejected)') &#125;&#125;);newPromise.then((data)=&gt; &#123; // 成功訊息 (需要 3 秒) console.log(data);&#125;).catch((err)=&gt; &#123; // 失敗訊息 (立即) console.log(err)&#125;); 以上就是一個基本的 Promise 範例，執行 Promise 建構式時還會再帶入 resolve 與 reject 的 callback function。 resolve: 完成的 callback reject: 失敗的 callback Promise 的生命週期 pending: 等待中的初始狀態 fulfilled: 正確完成 rejected: 已拒絕，操作失敗 上圖就是一個轉化中的圖 (一開始是 Pending，等我展開的時候已經 resolved 了… )。 這個建構式另外還提供兩種調用 promise 的方法 race() 與 all()： Promise.all(): 此方法可以同時執行大量 Promise 物件，並且在 “全部” 完成後回傳陣列。 Promise.race(): 此方法執行大量 Promise 物件，但僅會回傳最快回應的結果。 範例： 123456789101112131415161718192021222324252627282930313233343536373839// 宣告 promise 建構式let newPromise1 = new Promise((resolve, reject) =&gt; &#123; let ran = parseInt(Math.random() * 5000); // 隨機成功或失敗 setTimeout(function()&#123; resolve('隨機時間完成'); &#125;, ran);&#125;);let newPromise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve('2 秒完成'); &#125;, 2000);&#125;);let newPromise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve('3 秒完成'); &#125;, 3000);&#125;);let newPromise4 = new Promise((resolve, reject) =&gt; &#123; reject('失敗');&#125;);Promise.all([newPromise1, newPromise2, newPromise3, newPromise4]).then((data)=&gt; &#123; // 一次性同時回傳成功訊息，回傳以上三個數值的陣列 console.log(data);&#125;).catch( err =&gt; &#123; // 失敗訊息 (立即) console.log(err)&#125;);Promise.race([newPromise1, newPromise2, newPromise3]).then((data)=&gt; &#123; // 僅會回傳一個最快完成的 resolve 或 reject console.log('race', data);&#125;).catch( err =&gt; &#123; // 失敗訊息 (立即) console.log(err)&#125;); 這個案例較長，前面主要是宣告幾個 Promise 建構式，差異在時間與刻意的失敗；後面介紹 Promise.all() 與 Promise.race() 的差異。 Chain 鏈接方法Promise 一個很重要的方法 then()，其實是可以不斷的做鏈接。基本的概念就是前一個 return 會是下一個 then() 傳送的變數。 1234567891011121314151617181920212223242526272829303132333435// 前面宣告的不重要let newPromise1 = new Promise((resolve, reject) =&gt; &#123; let ran = parseInt(Math.random() * 5000); // 隨機成功或失敗 setTimeout(function()&#123; resolve('隨機時間完成'); &#125;, ran);&#125;);let newPromise2 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve('2 秒完成'); &#125;, 2000);&#125;);let newPromise3 = new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve('3 秒完成'); &#125;, 3000);&#125;);// 這段以前不重要// 鏈接方法newPromise1.then((data1) =&gt; &#123; console.log('data1', data1); return newPromise2.then((data2) =&gt; &#123; return `$&#123;data2&#125; + $&#123;data1&#125;` // 回傳 Promise 內的值，讓下一個 then 可以接收 &#125;);&#125;).then((data3) =&gt; &#123; console.log('data3', data3); return newPromise3.then((data4) =&gt; &#123; return `$&#123;data4&#125; + $&#123;data3&#125;` // 回傳 Promise 內的值，讓下一個 then 可以接收 &#125;);&#125;).then((data5) =&gt; &#123; console.log(`最後的 + $&#123;data5&#125;`)&#125;); 用文字不好表達這段，直接看圖。Promise 執行時可以使用 then 做串接，串接的方法在於需要使用 return 來做下一個 then() 的傳入值，透過這個方法可以避免 JavaScript 原始碼過巢導致難以閱讀。 以上程式碼皆可直接複製貼到 Chrome 開發者工具內的 console 運行。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"}]},{"title":"CSS3 Grid Layout","slug":"css-grid","date":"2017-05-23T16:00:00.000Z","updated":"2017-05-24T02:25:30.000Z","comments":true,"path":"life/2017/05/24/css-grid/","link":"","permalink":"https://wcc723.github.io/life/2017/05/24/css-grid/","excerpt":"CSS gird layout 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，這和 Bootstrap 或是 960 Grid 沒有任何關係，而是新的 CSS 語法。","text":"CSS gird layout 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，這和 Bootstrap 或是 960 Grid 沒有任何關係，而是新的 CSS 語法。 在 5/18 與線上讀書會合作時，有針對 CSS Grid 做一個概略性的解說，並另有提供範例，以下是直播活動時的簡報內容。 直播連結：https://www.facebook.com/WccCasper/videos/377986119264284/ Css3 Grid Layout from Chih-cheng Wang 相關連結： 範例一：https://codepen.io/Wcc723/pen/jmzJWY 範例二：http://codepen.io/Wcc723/pen/bWKgPY 線上 Grid 工具：http://wcc723.github.io/WorkShop-gh-pages/cssGridDisplay/ 蒙德里安範例：https://codepen.io/Wcc723/pen/zwaZm","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"剛出社會要存錢嗎？","slug":"save-money-or-not","date":"2017-04-13T16:00:00.000Z","updated":"2017-04-14T01:24:39.000Z","comments":true,"path":"life/2017/04/14/save-money-or-not/","link":"","permalink":"https://wcc723.github.io/life/2017/04/14/save-money-or-not/","excerpt":"這個標題不是針對全聯老闆的，只是有感而發，因為我是反對靠存錢來增加存款(資產)的。","text":"這個標題不是針對全聯老闆的，只是有感而發，因為我是反對靠存錢來增加存款(資產)的。 先講一個例子： 月薪三萬跟月薪五萬花起來感覺差多少，就目測是差不到兩倍，但實際上五萬是三萬的兩倍以上。 簡單算一下必要花費： 孝親費: $5,000 水電、房租、網路: $10,000 固定生活費: $8,000 這樣同時使用五萬跟三萬去扣除 月薪三萬剩 $7000 月薪五萬剩 $27000 這樣兩者就差了近四倍，就算月薪三萬不給孝親費，月薪五萬每個月再多幾次聚餐，這差距都還是存在(公式隨便調都是差兩倍以上)。 在剛出社會的時候，不是很建議靠存錢來增加資產，建議提高學習、生活體驗的預算，這樣不僅有助於薪資的成長，身為一個人也能活得更充實。 增加學習的預算一開始我花不少時間、錢去上技術課程或書，認為上課是最乾脆的，講師將大量的知識濃縮到短時間讓學生吸收，雖然價格會比書籍貴一些，但就時間成本來說相對划算許多，到現在還是會看看有什麼有趣的課程去學習。 增加生活體驗一個人的價值並不是只有看到收入，豐富的生活體驗更能彰顯一個人的價值，生活體驗更能夠激發個人的慾望與動力，慾望自然能個轉化成目標，沒有想要發財的人怎會想去賺很多錢呢？ 薪水太少不如投資自己 以長線來說投資自己最有價值","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"CSS Grid 屬性介紹","slug":"css-grid-layout","date":"2017-03-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2017/03/22/css-grid-layout/","link":"","permalink":"https://wcc723.github.io/css/2017/03/22/css-grid-layout/","excerpt":"CSS gird 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，開始之前還是來介紹一些語法。 與 CSS Flex 一樣，CSS Grid 用兩個部分來看比較快，一個是屬於外部容器的屬性，另一個是屬於內部容器的屬性；從外開始向內看可以加快理解的速度。","text":"CSS gird 在最近 Chrome 更新已經慢慢開始支援 (就是還很久才會完全支援的意思)，開始之前還是來介紹一些語法。 與 CSS Flex 一樣，CSS Grid 用兩個部分來看比較快，一個是屬於外部容器的屬性，另一個是屬於內部容器的屬性；從外開始向內看可以加快理解的速度。 CSS Grid 可以做什麼呢？這邊提供一個簡單範例給大家看看，相同的 Grid System 如果使用 float 需要多很多層，還要注意清除浮動等等。在 CSS grid 的加持下每個 class 都僅需少量的屬性就可做到相同的效果。 See the Pen CSS Grid Layout by Wcc723 (@Wcc723) on CodePen. 本篇內容有許多參考 https://css-tricks.com/snippets/css/complete-guide-grid/ 外部容器dispaly和 Flex 一樣，需要定義容器的顯示類型。 123.container &#123; display: grid | inline-grid | subgrid;&#125; grid-template-columns, grid-template-rows看完這個屬性，對於 CSS Grid 就會有基礎的了解。 Grid 和 flex 最大不同之處，透過 grid template 來定義版型的結構，分別由 column 及 row 定義出直排與橫列的格線，內容再依隔線作安排。 圖片來源：https://css-tricks.com/snippets/css/complete-guide-grid/ 1234.container &#123; grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...;&#125; track-size: 可使用彈性的長度、百分比或分數 (分數的部分需使用 fr 單位) line-name: 可自行命名的名稱 圖片：自己畫的 12345678.wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; height: 100vh; width: 940px; margin: 0 auto;&#125; 粉紅色的部分就是 grid-template-columns，黃色部份則是 grid-template-rows，隔線排版就能靠上面一張圖了解！grid-template-columns 定義水平方向的空間，grid-template-rows 定義垂直方向的空間，且可以使用大部分的單位數值。 1234.wrap &#123; grid-template-columns: repeat(2, 1fr 2fr) 100px; /* grid-template-columns: repeat(&#123;次數&#125;, &#123;格線...&#125; | &#123;格線...&#125;) | &#123;格線...&#125;; */&#125; 這個地方在介紹兩個新東西，一個是 fr 這個單位，這個單位能夠將可用的 剩餘空間 做比例分割，以上面的 1fr 2fr 為例，空間將被分割成 1/3、2/3 兩個大小。另一個是 repeat，可以重複隔線。 grid-template-areas透過 area 定義區塊在 template 上的位置，概念就是在畫面上登記屬於該元素的空間，此部分要內外元素一起看。 內元素 grid-area：定義空間的名稱 外元素 grid-template-areas：定義空間的位置，是透過幾組字串的組合，組合方式可以參考下圖及程式碼。 假設我們需要繪製如上的空間配置，上方出現 5 * 3 那麼會透過 grid-area 來命名小空間的名稱，再透過 grid-template-areas 來表示整體空間的配置，配置的方式是透過字串的方式組合。 12345678910111213141516171819202122232425262728.wrap &#123; display: grid; grid-template-columns: 200px 50px auto 50px 200px; grid-template-rows: 25% 100px auto; grid-template-areas: \"header header header header header\" \"side main main main main\" \"side footer footer footer footer\"; height: 100vh; width: 940px; margin: 0 auto;&#125;.item-a &#123; grid-area: header; background-color: purple;&#125;.item-b &#123; grid-area: main; background-color: orange;&#125;.item-c &#123; grid-area: side; background-color: green;&#125;.item-d &#123; grid-area: footer; background-color: gray;&#125; 注意： 空間不能分離且是唯一的，錯誤範例: &quot;side main side&quot; grid-auto-columns, grid-auto-rows簡單版的 Grid，如果版型較為簡單，可以直接使用 grid-auto-{ cols or rows}。如果是簡易的 960 12欄 grid 設定如下即可。 123456789.row &#123; display: grid; grid-auto-columns: 60px; grid-auto-flow: column; grid-gap: 20px; width: 940px; min-height: 100vh; margin: 0 auto;&#125; grid-auto-flowGrid 的排列方式，以上面 12 欄排列 grid 來說，如果沒有設定 column，就會變成垂直排列。 123.row &#123; grid-auto-flow: row | column | row dense | column dense&#125; grid-gap, grid-column-gap, grid-row-gap格線的間隔包含垂直及水平，可參考如下。 123grid-column-gap: &#123; grid-column-gap &#125;;grid-row-gap: &#123; grid-row-gap &#125;;grid-gap: &#123; grid-row-gap &#125; &#123; grid-column-gap &#125;; justify-items, justify-content, align-content與 flex 的使用方法一樣，先跳過之後再補充 內部容器grid-column-start, grid-column-end, grid-row-start, grid-row-end物件所佔的空間位置，Column 及 Row 所到的起始點及終點 123456.item &#123; grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto&#125; &lt;line&gt; - 用數字表示 物件 所在的線，可參考上一段的 template span &lt;number&gt; - 物件所佔用的欄位數 span &lt;name&gt; - 物件所在的 grid 名稱 auto - 自動的啦 12345678.item &#123; grid-column-start: 2; /* 物件起始線 */ grid-column-end: span 4; /* 終點線 = 物件所佔的空間數 */ grid-row-start: 3; /* 物件起始線 */ grid-row-end: auto; /* 不設定終點線 */ background-color: red; z-index: 999; /* 欄位重疊可用 z-index 設定前後順序 */&#125; grid-column, grid-row上面那段的縮寫，使用斜線 (/) 隔開屬性。 123.item &#123; grid-column: 2 / span 4;&#125; grid-area &lt;name&gt;: 使用命名的方式，透過 grid-template-areas 來套用 &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;: 指定 grid 線數或 grid 名稱來定位 123.item-a &#123; grid-area: 2 / 2 / 4/ 4;&#125; justify-self, align-self內容器的定位模式，與 flex 使用方式一樣。 Grid 目前想到的運用方面有： 滿版的排版，適合拿來做平面設計風格的排版 輕量的 grid system，或許下次 Bootstrap 就改用 Display grid 在排版了 ~_~。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"grid","slug":"grid","permalink":"https://wcc723.github.io/tags/grid/"}]},{"title":"VSCode 快速推坑介紹文","slug":"vscode-for-mac","date":"2017-03-02T16:00:00.000Z","updated":"2017-03-03T08:47:03.000Z","comments":true,"path":"javascript/2017/03/03/vscode-for-mac/","link":"","permalink":"https://wcc723.github.io/javascript/2017/03/03/vscode-for-mac/","excerpt":"","text":"用過的 Editor 很多，常常出現新款的 Editor 都會嘗試一下，雖然主流的不一定會喜歡，但多嘗試也不是壞事，這邊稍微列出個人主觀的意見供大家參考參考： Dreamweaver這是早期在使用的 Editor，特色是所見即所得，但這個也成為 Dreamweaver 的致命傷，畢竟做網頁精準的還是瀏覽器上的呈現，過度依賴所見即所得對於學習會有所限制，後來開始精進 CSS 後就不太使用這個工具。 Sublime Text目前相當主流的 Editor，到現在偶爾會打開使用，主要原因是速度極快，搭配良好的套件可以快速完成大量的程式碼，作為一個 Editor 是非常優秀的，但在開發上總是會期待更多的功能 (嘿嘿嘿。 Atom算是 Sublime Text 的升級版，優秀的套件管理及更豐富的延伸套件，能夠達到 Sublime Text 沒有的功能，像是快速啟動 Webserver、內嵌終端機都不是問題。缺點是非常消耗硬體資源，對於較大的檔案可能會有 Crash 的問題，除此之外算是遇到 VSCode 之前的主要開發工具。 VSCode在一開始使用時對於操作不是很習慣，但隨著套件越來越多以及更新改版，也很貼近先前使用的幾套工具，開始嘗試使用開發 Node.js 專案是非常棒的，除了前幾套開發工具有的功能外，內建的 Git、debug tool 都非常的實用，且能夠與 iTerm、Gulp、Webpack 整合，算是 Node.js 開發的神器 (2017年初來說的話啦)。 VSCode 的好用功能內建 Terminal按下 Ctrl + \\` 後， VSCode 就會開啟預設的 Terminal 工具，如下圖所示，個人通常是使用 iTerm 在開發，按下之後下方會有 iTerm 分頁直接使用。如果說有需要修改預設字體，可以打開設定檔加入以下： 1&quot;terminal.integrated.fontFamily&quot;: &quot;Monaco for Powerline&quot;, Git 整合懶人使用的 Git 工具，只要勾一勾直接就可以 Commit。 在 Commit 前需要做程式碼比對也是相當容易的，點擊檔案名稱自動會出現比對，過去需要仰賴其他 GUI 工具才能做到，現在 VSCode 就內建此功能，可以大幅減少 Code Review 的時間。 Debug Mode 偵錯工具針對 Node.js 或其他後端的開發 (目前僅有測試過 Node.js)，VSCode 可以做到服務啟動、中斷點、一鍵重啟的功能，按下 cmd + shift + D 可以開始建立組態檔。 預設的組態檔其實都寫好了，存檔後就可以啟用服務。 設定中斷點，觸發時會列出當下的變數狀態，讓後端開發搞得跟用 Chrome 一個樣 (有嗎？ 啟用後畫面上會出現這樣的工具，可以暫停、重啟、停止服務。 Gulp、Webpack … 整合如果專案中有 gulpfile.js，按下 cmd + shift + P 呼叫 task run，VSCode 會自動撈出 gulpfile 內的 Task 讓開發者選擇執行。 停止方式：Terminate Running Task 尋找錯誤程式碼程式碼有錯，卻找不到在哪裡 (隱藏在茫茫 Code 海中的全行字元啊～)，按下 shift + cmd + m 就會標出目前錯誤的問題，但其實平常打錯他就會有標示囉。 程式碼提示完整的 Javascript 程式碼提示，像下面這個功能不需要多解釋，隨便按都會看起來很專業。 設定檔雖然說他沒有 Atom 那樣的 GUI 設定工具，但這樣的設計反而讓工程師更容易去搜尋想要的設定，左邊是設定的預設值，複製到右邊的個人設定檔就可以修改參數，且設定檔包含完整的中文說明，透過搜尋列可以輕鬆找到要修改得值。 VSCode 的功能相當多，相信不是一兩篇短文推坑就能摸熟，如果有興趣可以參考 Will 保哥介紹的影片，不到一個小時就能讓你從其他 Editor 轉來使用 VSCode。影片：https://www.youtube.com/watch?v=CAQdar3JGEU 圖片目前放在 Dropbox Paper 上，如有遺失會再更新。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://wcc723.github.io/tags/promise/"},{"name":"es6","slug":"es6","permalink":"https://wcc723.github.io/tags/es6/"}]},{"title":"Javascript Promise 範例","slug":"javascript-promise","date":"2017-03-01T16:00:00.000Z","updated":"2017-03-02T14:03:53.000Z","comments":true,"path":"javascript/2017/03/02/javascript-promise/","link":"","permalink":"https://wcc723.github.io/javascript/2017/03/02/javascript-promise/","excerpt":"Promise 現在已經被大部分瀏覽器所支援 (IE 以外)，在處理非同步的操作是一大助力，最近在寫 Node.js 也不需要再仰賴其它套件就能夠直接處理非同步問題，以下就提供一個範例來介紹簡單的 Promise 的操作過程。","text":"Promise 現在已經被大部分瀏覽器所支援 (IE 以外)，在處理非同步的操作是一大助力，最近在寫 Node.js 也不需要再仰賴其它套件就能夠直接處理非同步問題，以下就提供一個範例來介紹簡單的 Promise 的操作過程。 See the Pen ES6 Promise by Wcc723 (@Wcc723) on CodePen. 123456789101112131415161718192021222324252627282930313233343536373839404142(function() &#123; let epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&amp;$skip=0&amp;$top=1000&amp;format=json&amp;callback=?\"; let errorUrl = \"http://opendata.epa.gov.tw/ws/Data/UL/?$orderby=PublishAgency&amp;$skip=0&amp;$top=1000&amp;format=json&amp;callback=?\"; let _DefaultContry = '臺北市'; var getData = (url)=&gt; &#123; // 傳入的 URL return new Promise((resolve, reject) =&gt; &#123; // return promise $.getJSON( url, function()&#123; format: \"json\" &#125;).done(function(data) &#123; if (data) &#123; resolve(data); // 成功後透過 resolve 回傳值 &#125; else &#123; reject('Error'); &#125; &#125;).fail(function() &#123; reject('Error'); &#125;); &#125;); &#125; getData(epaAPI) // 傳入的 url .then((data)=&gt;&#123; // then 接受回傳的值 console.log(data); $.each( data, function( i, item ) &#123; console.log(item); let list = `&lt;li&gt;$&#123;item.SiteName&#125; $&#123;item.PublishTime&#125; $&#123;item.SiteName&#125; $&#123;item.UVI&#125;&lt;/li&gt;` //利用item.值，把每一個值取出，並寫成一個html存在list的變數內 $('.itemlist').append(list); //最後把剛剛的html放到表格內 &#125;); &#125;); getData(errorUrl) // 傳入錯誤的 url .then((data)=&gt;&#123; // then 接受回傳的值 (錯誤的狀況不會跑這段) console.log(data); &#125;) .catch((response)=&gt; &#123; // 錯誤狀態的回傳 console.log('errorUrl:', response); &#125;); &#125;)(); 說明new Promisevar getData() 裡面包含非同步的 Ajax，如果直接套用 getData() 會無法確實取得資料後再執行其他 function，所以這時候在內部加上 new Promise() 確保 Ajax 完成後再回傳資料。getData(epaAPI) 套用時可以傳入 url，在後方的 .then 表示任務完成第一段後取得 resolve() 內的值，接下來就如同 jQuery Ajax 回傳後得處理方式一樣，。 1let list = `&lt;li&gt;$&#123;item.SiteName&#125; $&#123;item.PublishTime&#125; $&#123;item.SiteName&#125; $&#123;item.UVI&#125;&lt;/li&gt;` 題外話：這一段則是 ES6 中的字串處理方式，用 符號框住整個字串，再透過類似 jQuery 的 selector (${}) 就能帶入字串中的變數，取代過去使用 &quot; &quot; + variable + &quot; &quot; 撰寫起來輕便許多。 錯誤回傳1234567getData(errorUrl) // 傳入錯誤的 url .then((data)=&gt;&#123; // then 接受回傳的值 (錯誤的狀況不會跑這段) console.log(data); &#125;) .catch((response)=&gt; &#123; // 錯誤狀態的回傳 console.log('errorUrl:', response); &#125;); 後面包含另一個 getData(errorUrl) 刻意傳入錯誤的連結使其產生錯誤，這時候的 .then 沒有辦法接受到資料，後方的 .catch 則可以接到由 reject() 回傳的訊息。 參考文件：https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise/all","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"promise","slug":"promise","permalink":"https://wcc723.github.io/tags/promise/"},{"name":"es6","slug":"es6","permalink":"https://wcc723.github.io/tags/es6/"}]},{"title":"鐵人賽 30 - CSS 鐵人賽的結束與接下來的研究","slug":"ironman-ending","date":"2016-12-29T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/30/ironman-ending/","link":"","permalink":"https://wcc723.github.io/css/2016/12/30/ironman-ending/","excerpt":"相較於 Javascript 來說，CSS 的演進速度算是非常緩慢的，主要原因當然是瀏覽器的相容性，瀏覽器不太能因為新的特色加入而毀了以前所建置的網站。 在這個相對穩定的程式語言，精通一個的手法就可以活用的相當久，像是 Sass 來說，到目前為止他還是相當流行的前置語言。","text":"相較於 Javascript 來說，CSS 的演進速度算是非常緩慢的，主要原因當然是瀏覽器的相容性，瀏覽器不太能因為新的特色加入而毀了以前所建置的網站。 在這個相對穩定的程式語言，精通一個的手法就可以活用的相當久，像是 Sass 來說，到目前為止他還是相當流行的前置語言。 就算如此，CSS 依然有許多有趣的新穎功能，以 Flex 來說就能輕鬆排出許多豐富的版型，恰巧這幾天朋友考我 flex，就將這排版獻醜給大家看看，條件如下： 用 flex 排版 navbar 固定在上方 主要內容分為三欄 中間欄內容長的時候可以 scroll ，左右不需要 scroll 右側欄分為三列 右上欄有獨立的 scroll JS Bin on jsbin.com 123456789101112131415161718192021222324252627282930313233body, html &#123; margin: 0; padding: 0;&#125;.flex-h &#123; height: 100vh;&#125;.flex &#123; display: flex;&#125;.flex-1 &#123; flex: 1;&#125;.flex-3 &#123; flex: 3;&#125;.flex-col &#123; flex-direction: column&#125;.scroll &#123; overflow-y: scroll;&#125;.navbar &#123; height: 60px; background-color: red;&#125;.bg-blue &#123; background-color: blue;&#125;.bg-gray &#123; background-color: gray;&#125; 在這些條件下，相信大家也使用過 position、float 等排版手法，而 flex 僅需要簡短的語法就能達到接近的效果。不過雖然如此 flex 目前不是大家主要排版的首選，需要上線的產品我也不會使用 flex 做為主要排版的語法(會使用在次要的內容)，主因還是 flex 在於目前相容性還不夠高，就算捨去了 IE 還是有部分的瀏覽器在呈現上略有不同(說個鬼故事，很多人的 iOS、Mac OS 都不愛更新的)。 為了讓自己可以更熟悉 Flex，我也做了一個簡單的工具，讓自己可以透過互動的方式查詢 Flex 的語法。 連結：http://wcc723.github.io/WorkShop-gh-pages/cssFlex/ CSS column和 Flex 一樣屬於排版的語法 CSS column，去年的時候也有花很多時間研究，也有製作類似的語法互動研究工具，和 flex 也遭遇相同的問題，不同瀏覽器雖然都支援，卻顯示出不同的結果，以下連結請玩～ 連結：https://wcc723.github.io/css/2015/07/23/css-column/ 據說很猛的 display: grid第一次研究 flex 是在 2013 年，至今也三年左右了… Q_Q，到現在使用上還是有所顧忌，現在對於排版有新的屬性：display: grid，依據 flex 的概念他可以等我花三年的時間慢慢研究 &gt;O&lt;。 以下為圖文參考的文件，就目前看來有許多語法與 flex 是共用的，期望 webkit 能統一瀏覽器世界，讓這些語法能夠快速進入實際運用。 https://css-tricks.com/snippets/css/complete-guide-grid/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 29 - CSS 實戰小技巧 - 不使用 important 的高優先值技巧","slug":"one-class","date":"2016-12-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/29/one-class/","link":"","permalink":"https://wcc723.github.io/css/2016/12/29/one-class/","excerpt":"在維護舊的專案很多必須放下自尊，用一些手段來維持成果的運作，但有些作法如果過於殘暴可能會影響到未來的維護，CSS !important 就是一個很好用的手段，他可以直接將 CSS 的優先值拉到最高，並且超過標籤的 style 屬性樣式，那麼在未來就變成要修正這一段樣式無法再用 style 的方式覆蓋。 這邊介紹一招只需要用 className 就能夠大幅提升優先值的手法，讓想快速結束這回合，但又怕傷了未來萌新的善良人參考。","text":"在維護舊的專案很多必須放下自尊，用一些手段來維持成果的運作，但有些作法如果過於殘暴可能會影響到未來的維護，CSS !important 就是一個很好用的手段，他可以直接將 CSS 的優先值拉到最高，並且超過標籤的 style 屬性樣式，那麼在未來就變成要修正這一段樣式無法再用 style 的方式覆蓋。 這邊介紹一招只需要用 className 就能夠大幅提升優先值的手法，讓想快速結束這回合，但又怕傷了未來萌新的善良人參考。 情境現在 CSS 的樣式如下，有一個 blue 的藍色字體，另外還有一組 ul, li，先前的開發者為了讓呈現綠色的 ul, li 中的 .blue 改成橘色，所以用很多階層的手法拉高優先值。 12345678910111213.blue &#123; color: blue;&#125;ul.green li ul li &#123; color: green&#125;ul.green li ul li.blue &#123; color: orange&#125;.demo &#123; border: 1px dashed orange; padding: 15px;&#125; 前一個開發者使用了許多巢狀的 CSS 來提高優先值，進而改變 .blue 的色彩。 12345678910111213&lt;div class=\"demo\"&gt; &lt;p class=\"blue\"&gt;這是一段藍色的話&lt;/p&gt; &lt;ul class=\"green\"&gt; &lt;li&gt; &lt;span&gt;這是一段話&lt;/span&gt; &lt;ul&gt; &lt;li class=\"blue\"&gt;&lt;span&gt;這是一段話&lt;/span&gt;&lt;/li&gt; ... &lt;/ul&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; .blue { color: blue; } ul.green li ul li { color: green } ul.green li ul li.blue { color: orange } .demo, .demo2 { border: 1px dashed orange; padding: 15px; } 這是一段藍色的話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 此時，如果身為 .blue 的藍色 (ul.green li ul li.blue)，如果想改變回藍色且不能修改原有的 CSS 程式碼情況下，這邊就提供一個小撇步來提高 CSS 權重。 .demo2 .blue.blue.blue.blue.blue.blue.blue.blue.blue.blue { color: blue; } 這是一段藍色的話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 這是一段話 只要將 .blue 這一個 className 不斷堆疊就能做到這樣的效果。 123.blue.blue.blue.blue.blue.blue.blue.blue.blue.blue &#123; color: blue;&#125; 這個手法是不斷提升堆疊單一個 className 的權重，並使它可以超過其它巢狀元素的優先值，所以並不會影響到標籤的 style 及 !important 的權重。 那麼，如果這個情況下還需要更高的權重呢？那…就慢慢加長吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 28 - 實戰小技巧 - iOS 表單的使用者體驗優化","slug":"ios-input","date":"2016-12-27T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/28/ios-input/","link":"","permalink":"https://wcc723.github.io/css/2016/12/28/ios-input/","excerpt":"最後幾篇再來額外介紹一些小技巧，這些小技巧都是非常冷門的卻是實用的手法，分享給大家參考看看。","text":"最後幾篇再來額外介紹一些小技巧，這些小技巧都是非常冷門的卻是實用的手法，分享給大家參考看看。 先前有一位朋友詢問到 iOS 表單有個小問題讓他困擾，就是用戶在點擊的時候，畫面都會略微的放大，這會讓用戶在填寫表單的時候非常的不順手，狀況如下： 這種強制放大一個不明白的尺寸，實在是非常的惱人，尤其是在畫面這麼小的情況下。於是這位朋友希望可以做一些調整，讓用戶在點擊的時候直接放到全螢幕，這樣在正常全螢幕的情況下點擊就不會有縮放的感覺；如果是放大看的用戶，也是一率拉滿全屏。成果如下： 用戶在點擊時，只會有些微的位移。 CSS 修正以上的解法，我一開始以為是使用 Javascript，透過各種方式解析，其實只要做一點點調整就可以了，就是將 input 的文字大小設定超過 16px (完)，那麼在點擊的時候就直接拉滿全屏，以下範例可用 iOS 手機點點看。 See the Pen auto fullscreen by Wcc723 (@Wcc723) on CodePen. 12345.autofullscreen &#123; input, select, textarea, button &#123; font-size: 16px; &#125;&#125; 結果如上，只要調整 CSS 就能大幅改善使用者體驗。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 27 - CSS 框架自幹心得 - 失敗三次的框架建構經驗","slug":"over-my-dead-body","date":"2016-12-26T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/27/over-my-dead-body/","link":"","permalink":"https://wcc723.github.io/css/2016/12/27/over-my-dead-body/","excerpt":"先前提到過有自幹過框架，主要的經驗是兩次，第三次就不再完全重新自幹了，每次到了最後都會發現有些概念不夠完美，然後修正前一版的錯誤再出發一次!?後來發現自幹本身就有很大的風險在…。","text":"先前提到過有自幹過框架，主要的經驗是兩次，第三次就不再完全重新自幹了，每次到了最後都會發現有些概念不夠完美，然後修正前一版的錯誤再出發一次!?後來發現自幹本身就有很大的風險在…。 第一次距今約 36 個月以前(這樣說比較久)。 剛開始接觸 Sass 時發現他的 @mixin 真的很神，發現很多樣式可以先準備好 @mixin 等到需要使用的時候在載入，所以當時就以產生 樣式庫 的概念做設計，當時還沒有參考主流的框架，單純以自己的觀念做開發，包含按鈕、表單、jQuery 套件等常見的樣式庫都有設計。 當時文件只要輸入 +divider($gap: 1.5em) 就可以引用上方的範例樣式。 且設計上都是用當時主流的漸層效果在做，只要輸入一個色彩就會運算出各種狀態的漸層，真的是好潮好潮～。當時這些都是自己在維護、使用，久而久之發現每個專案都要重新 @include 這些樣式也真的很麻煩，心想不如直接寫一款都預設 @include 的好了。 第二次距今約 24 個月以前。 已經經歷過一次的框架歷練的我，等級已經是翻倍再翻倍，這時候是以一個完整可運用的框架去執行，所以執行時也有考慮到框架的文件、運用、擴充等問題。 樣式文件，命名還要帶點叛逆。 包含延伸運用都有製作在內。 這樣的架構其實並沒有太大問題，但是發現 CSS 檔案大小上升略快 &gt;O&lt;，所以每次加入新元件都要不斷的檢查問題點在哪，後來發現 @extend 的問題以及 OOCSS 的架構。 第三次後來仔細研究了 Bootstrap 文件原始碼及 OOCSS 的概念，清楚了解到自己開發的框架問題點，所以就很乾脆的將 Bootstrap 給 fork 惹…。現在主要都是以 Bootstrap 作為基底來當作樣式框架開發的底層，並且依據自己喜愛的設計風格、專案需求去做調整。 色彩相對於當時的 Bootstrap 3 來說更為鮮豔，且圓角更小。 還有很愛的 outline button，在 Bootstrap 4 的版本也有加入，很開心的是當時很多概念在 Bootstrap 4 都有提供，如 Card、Spacing…。 還以 Material Design 為概念的 jQuery UI，當然這是選用的，預設的情況下是不需要載入的。 結語現在，許多情況下 Bootstrap 4 能滿足基礎的開發需求，再以 Sass 的特性結合需要的元件開發就能節省許多時間。除了公司專案外，我大多情況不會重頭開始寫 CSS 或是另外開發框架。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 26 - 實戰心法 - 應避免的 Sass @extend","slug":"sass-extend","date":"2016-12-25T16:00:00.000Z","updated":"2017-07-26T06:38:18.000Z","comments":true,"path":"css/2016/12/26/sass-extend/","link":"","permalink":"https://wcc723.github.io/css/2016/12/26/sass-extend/","excerpt":"Sass 的 @extend 可以將相同的樣式整理再一起，在其他語言來說是非常帥氣的技法，但在 CSS 中請警慎使用。 就如同本篇鐵人賽一開始所介紹到的 OOCSS 概念，在撰寫 CSS 時要盡可能符合兩個原則，結構與樣式分離、容器與內容分離，所以到這邊為止還是要貫徹這個概念，當使用 @extend 時如果會造成這個缺陷時，請避免使用。","text":"Sass 的 @extend 可以將相同的樣式整理再一起，在其他語言來說是非常帥氣的技法，但在 CSS 中請警慎使用。 就如同本篇鐵人賽一開始所介紹到的 OOCSS 概念，在撰寫 CSS 時要盡可能符合兩個原則，結構與樣式分離、容器與內容分離，所以到這邊為止還是要貫徹這個概念，當使用 @extend 時如果會造成這個缺陷時，請避免使用。 帥氣的 @extend@extend 能夠將重複的樣式整理再一起，以下面的範例來說，我就將 .clearfix 與 .row 中所需要的清除浮動做整理。 編譯前： 123456789101112131415%clearfix &#123; &amp;:after &#123; content: &quot; &quot;; display: table; clear: both; &#125;&#125;.clearfix &#123; @extend %clearfix;&#125;.row &#123; @extend %clearfix;&#125; 編譯後：12345.clearfix:after, .row:after &#123; content: &quot; &quot;; display: table; clear: both;&#125; See the Pen clearfix sass extend by Wcc723 (@Wcc723) on CodePen. 這手法可以有效減少散落在各處的樣式，無論他在第幾行，都會被往前統一整理。 錯誤的案例本篇繼續上一篇的範例，上一篇中我們是將 .btn 作為獨立的 Class，且此 Class 身負作為按鈕結構的重任。 在 Sass 中，我們會先新增一個 %btn 來作為 placeholder selectors，而後再 Class 的部分透過 @extend 將 %btn 合併，那麼結構的部分也會合併到每一個按鈕內。 123456789101112131415161718192021222324252627282930%btn &#123; // 結構 display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; text-align: center; vertical-align: middle; cursor: pointer; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; &amp;:hover, &amp;:focus &#123; color: #333; background-color: #e6e6e6; &#125;&#125;@each $name, $value in $btn-config &#123; $class: map-get($value, class); $color: map-get($value, color); $bg: map-get($value, bg); $border-color: map-get($value, border-color); .btn-#&#123;$class&#125;&#123; @extend %btn; @include button-variant($color, $bg, $border-color); &#125;&#125; 此作法 HTML 會看起來相當簡潔。 12345&lt;div class=\"section\"&gt; &lt;button class=\"btn-default\"&gt;這是一個按鈕&lt;/button&gt; &lt;button class=\"btn-primary\"&gt;這是一個按鈕&lt;/button&gt; &lt;button class=\"btn-accent\"&gt;這是一個按鈕&lt;/button&gt;&lt;/div&gt; See the Pen 應該避開的 @extend by Wcc723 (@Wcc723) on CodePen. 雖然說，這樣的在寫的時候看似非常簡潔，但其實所產出的 CSS 檔案非常之肥大，所有樣式結構的 Class 會被拉到前面在寫再一起，無形之中會重複大量的 Class name，如以下所產出的 disabled 的樣式。 1234.btn-primary.disabled, .btn-primary.disabled:hover, .btn-primary.disabled:focus, .btn-primary.disabled.focus, .btn-primary.disabled:active, .btn-primary.disabled.active, .btn-primary[disabled], .btn-primary[disabled]:hover, .btn-primary[disabled]:focus, .btn-primary[disabled].focus, .btn-primary[disabled]:active, .btn-primary[disabled].active, fieldset[disabled] .btn-primary, fieldset[disabled] .btn-primary:hover, fieldset[disabled] .btn-primary:focus, fieldset[disabled] .btn-primary.focus, fieldset[disabled] .btn-primary:active, fieldset[disabled] .btn-primary.active &#123; background-color: #009AFF; border-color: #009AFF;&#125; 結語其實學到現在，要安全點其實是避開 @extend 不使用，就連 Bootstrap 的原始碼中也不怎麼使用 @extend 這手法，但為什麼本篇會特別提出呢…!?因為我以前就是敗在這上的啊 Q_Q。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 25 - 實戰心法 - Sass Map 快出產出大量樣式","slug":"sass-map","date":"2016-12-24T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/25/sass-map/","link":"","permalink":"https://wcc723.github.io/css/2016/12/25/sass-map/","excerpt":"上一篇介紹了很短的程式碼產生一整組 Grid System，然後還提供變數讓 Grid 還有額外的參數可以設定，手寫的 CSS 如果要重新計算 12 組以上的計算也太苦了 T_T，這也就是 Sass 的魅力所在。 Sass 的運用上手法非常多，這次來介紹透過簡單的變數，即可大量產生相似的模組。","text":"上一篇介紹了很短的程式碼產生一整組 Grid System，然後還提供變數讓 Grid 還有額外的參數可以設定，手寫的 CSS 如果要重新計算 12 組以上的計算也太苦了 T_T，這也就是 Sass 的魅力所在。 Sass 的運用上手法非常多，這次來介紹透過簡單的變數，即可大量產生相似的模組。 Sass MapSass map 是類似 json 的一種變數，json 中包含的陣列、物件、屬性在 Sass map 都能有相似的寫法，所以首先要先使用 Sass Map 來定義基礎的元件變數。 $btn-config 裡面包覆的就是 Sass map，與 json 最大的差異是使用 () 取代 {}，這樣的手法可以大量的產生樣式的變數。 123456789101112131415161718192021222324$gray-light: #777;$brand-primary: #009AFF;$brand-accent: #D84315;$btn-config:( default:( class: &apos;default&apos;, color: $gray-light, bg: #fff, border-color: #ccc ), primary:( class: &apos;primary&apos;, color: #fff, bg: $brand-primary, border-color: $brand-primary ), accent:( class: &apos;accent&apos;, color: #fff, bg: $brand-accent, border-color: $brand-accent )); 接下來我們在製作 @mixin 與 button 的基本樣式，@mixin 可以將產出的 CSS 先寫成公式，在後續的流程在套用，這個公式我是直接抓 Bootstrap 所寫好的。 另外 .btn 則是先前提過好幾次的結構，而這個結構是不包含樣式 (色彩、大小…)，樣式的部分是在 @mixin 內。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// @mixin 運算@mixin button-variant($color, $background, $border) &#123; color: $color; background-color: $background; transition: background-color .15s; border-color: $border; &amp;:hover, &amp;:focus, &amp;.focus, &amp;:active, &amp;.active, .open &gt; &amp;.dropdown-toggle &#123; color: $color; background-color: darken($background, 6%); border-color: darken($border, 8%); &#125; &amp;:active, &amp;.active, .open &gt; &amp;.dropdown-toggle &#123; background-image: none; &#125; &amp;.disabled, &amp;[disabled], fieldset[disabled] &amp; &#123; &amp;, &amp;:hover, &amp;:focus, &amp;.focus, &amp;:active, &amp;.active &#123; background-color: $background; border-color: $border; &#125; &#125; .badge &#123; color: $background; background-color: $color; &#125;&#125;// 基本 btn 結構.btn &#123; // 結構 display: inline-block; padding: 6px 12px; margin-bottom: 0; font-size: 14px; text-align: center; vertical-align: middle; cursor: pointer; user-select: none; background-image: none; border: 1px solid transparent; border-radius: 4px; &amp;:hover, &amp;:focus &#123; color: #333; background-color: #e6e6e6; &#125;&#125; Sass @eachSass @each 也是像 javascript 中的 each，將 $btn-config 中的物件一一讀出(使用 map-get($value, value))，然後在 @include 上一段所產生的 @mixin。 這樣就能一次產生出大量的 CSS 樣式，所依據的就是先前所設定好的 Sass map，這範例僅使用三種樣式，相同的觀念下我們可以用這方法產出更多的樣式在內，只需要修改 Sass map 即可，不需要改其他部分。 12345678910@each $name, $value in $btn-config &#123; $class: map-get($value, class); $color: map-get($value, color); $bg: map-get($value, bg); $border-color: map-get($value, border-color); .btn-#&#123;$class&#125;&#123; @include button-variant($color, $bg, $border-color); &#125;&#125; 範例如下： See the Pen 透過 Sass map 製作多個樣式 by Wcc723 (@Wcc723) on CodePen. 結語現在的 CSS 大多會使用 Sass、Less、PostCSS 來做管理，使用哪一種語言倒是無所謂，但建議先從一種入門到熟悉，會發現省去許多不必要的時間，且在管理上會容易許多。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Sass","slug":"Sass","permalink":"https://wcc723.github.io/tags/Sass/"}]},{"title":"鐵人賽 24 - 實戰心法 - 自幹 Grid System","slug":"grid-system","date":"2016-12-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/24/grid-system/","link":"","permalink":"https://wcc723.github.io/css/2016/12/24/grid-system/","excerpt":"自己本身是不常自幹 Grid，但透過自幹會了解更細的運作原理，grid system 和其他元件不太一樣，他是屬於外容器型的元件，一層包覆著一層變化性相當高，如果不熟悉的情況下會容易造成跑版。","text":"自己本身是不常自幹 Grid，但透過自幹會了解更細的運作原理，grid system 和其他元件不太一樣，他是屬於外容器型的元件，一層包覆著一層變化性相當高，如果不熟悉的情況下會容易造成跑版。 Grid System 結構以下的 Grid System 是類似 Bootstrap 3 以後的結構，這結構最難以理解的部分是網格之間的 $gutter 運作，它透過反覆的 margin、 padding 補回空間，讓此 grid 的彈性發揮到最高。 灰色部分是網格中欄的區域，以下面這範例來說佔了 4 欄，為了呈現 欄 與 欄 之間的間隔，欄會左右增加 padding 讓內容保留左右的間隔。 但是 欄 所增加的 padding ，最終會影響到最外層的 .row、.container 向外擴增，所以 .row 與 .container 一則使用負值的 margin，另一則用 padding 補回這段空間。 結構分為以下 .container: 最外層的容器，作為限制最大寬度用，另外還有 padding 補回部分的寬度 .row: 包覆 欄(.col) 的容器，除了提供負值的 margin 補回間隔空間外，還有清除 欄(.col) 的浮動之功用 .col-{num}: 所有的欄位，可以從 1 ~ 12，透過 Sass 可以自訂所需的欄數。 Sass 與 Grid如果要快速產生 Grid System，建議使用 Sass 的運算，許多重複、迴圈的部分可以輕鬆很多。 技巧說明： 透過 %grid-system-col 及 @extend %grid-system-col; 可以將 col 重複的部分合併在一起 @for $i from 1 through 12 這段可以直接運算出 col 從 1 到 12 (最終的數值可以另外修改) @media (max-width: 767px) 在小於 767 的裝置下版型會做改變 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748$gird-end: 12;$gutter: 30px;%grid-system-col &#123; position: relative; min-height: 1px; padding-left: $gutter / 2; padding-right: $gutter / 2; float: left;&#125;* &#123; box-sizing: border-box;&#125;.container &#123; padding-left: $gutter / 2; padding-right: $gutter / 2; margin: 0 auto; max-width: 960px; @media (max-width: 767px) &#123; float: none; width: auto; &#125; &#125;.row &#123; margin-left: - ($gutter / 2); margin-right: - ($gutter / 2);&#125;.row:after &#123; content: \"\"; display: table; clear: both;&#125;@for $i from 1 through $gird-end &#123; .col-#&#123;$i&#125; &#123; @extend %grid-system-col; width: (100% *($i/$gird-end)); @media (max-width: 767px) &#123; float: none; width: auto; &#125; &#125;&#125;.box&#123; height: 100px; background-color: #ccc;&#125; 原始碼範例: http://codepen.io/Wcc723/pen/ENMEqY/ 結語在套用其他人開發的 grid system 之前，不妨先自己是寫看看，然候修改其中的程式碼這樣更能夠知道每個環節的用途。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 23 - 實戰心法 - 常見的垂直置中手法","slug":"vertical-align","date":"2016-12-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/23/vertical-align/","link":"","permalink":"https://wcc723.github.io/css/2016/12/23/vertical-align/","excerpt":"上一章節介紹了各種 Utilities ，唯獨垂直置中不介紹，因為在製作、使用垂直置中時要先思考 “支援的瀏覽器”，就算現在全部 IE 的使用率低於 2% 的情況下，還是會有很多小兄弟會希望網站優先支援 IE。 本篇會介紹幾種垂直置中手法(不包含舊瀏覽器)，每一種手法的寫法都不大一樣，所以使用時要特別注意使用規則。","text":"上一章節介紹了各種 Utilities ，唯獨垂直置中不介紹，因為在製作、使用垂直置中時要先思考 “支援的瀏覽器”，就算現在全部 IE 的使用率低於 2% 的情況下，還是會有很多小兄弟會希望網站優先支援 IE。 本篇會介紹幾種垂直置中手法(不包含舊瀏覽器)，每一種手法的寫法都不大一樣，所以使用時要特別注意使用規則。 條件這篇文章所介紹的垂直置中方式，都不會使用絕對值(px)，大多可以運用在各種環境，但實際上還是需要配合CSS的特性去做選用。 這次用鳴人的圖片來做介紹，這張圖片是用背景的方式載入。 123456789101112.naruto &#123; background-image: url(/images/narutoR.png?1372854973); background-color: orange; background-repeat: no-repeat; width: 107px; height: 207px; background-size: cover; margin: 0 auto;&#125;.box-wrap &#123; height: 350px;&#125; .naruto { background-image: url(/images/narutoR.png?1372854973); background-color: orange; background-repeat: no-repeat; width: 107px; height: 207px; background-size: cover; margin: 0 auto; } .box-wrap { height: 350px; border: 1px dashed red; } display table此 table 不是真 table，這是 IE8 以上才支援的 CSS 語法，將 div 的屬性轉成 table，再套用垂直置中的方式來完成。 優點：概念簡單、支援度高(IE8+) 缺點：html 結構較多層、有 table 的特性 .d0116 .table { display: table; width: 100%; } .d0116 .table-cell { display: table-cell; vertical-align: middle; } 1234567891011121314151617&lt;style&gt;.d0116 .table &#123; display: table; width: 100%;&#125;.d0116 .table-cell &#123; display: table-cell; vertical-align: middle;&#125;&lt;/style&gt;&lt;div class=\"demo d0116\"&gt; &lt;div class=\"table box-wrap\"&gt; &lt;div class=\"table-cell\"&gt; &lt;div class=\"naruto\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; translateY以前常會用一種方式做垂直置中 top: 50%; margin-top: -(元素高 / 2);，先用 top 往下推 50% 的距離，再利用 margin-top 拉回元素的一半高度，這方式雖然很好用，但是必須用在元素有明確高度上。 而這邊所介紹是相同的道理，但是是用 transform: translateY(-50%) 將元素垂直向上 50% 的距離，這 50% 則是元素的高度，且語法都集中在元素上。 優點：超簡單 缺點：並非所有情境都適用 .vertical-center { position: relative; top: 50%; margin: 0 auto; transform: translateY(-50%); } 12345678910111213&lt;style&gt;.vertical-center &#123; position: relative; top: 50%; margin: 0 auto; transform: translateY(-50%);&#125;&lt;/style&gt;&lt;div class=\"demo d0116\"&gt; &lt;div class=\"box-wrap\"&gt; &lt;div class=\"naruto vertical-center\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; flexFlex 是這幾年我經常使用的語法，這讓 CSS 排版的彈性大幅提升，不過在使用時還是有些瀏覽器的差異，像是舊版的 iOS Safari 就會略有不同，另外在實戰上的注意事項也較多。 優點：很潮 缺點：建議熟悉flex概念 .flex-center { display: flex; align-items: center; justify-content: center; } 123456789101112&lt;style&gt;.flex-center &#123; display: flex; align-items: center; justify-content: center;&#125;&lt;/style&gt;&lt;div class=\"demo d0116\"&gt; &lt;div class=\"box-wrap flex-center\"&gt; &lt;div class=\"naruto\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 結語這三種是我在實戰上比較常使用的，其中最常用的是 translate ，因為只需要一個 class 就能套用，相容性略高於 flex，相當簡單易用。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 22 - 實戰心法 - 經常使用，但卻容易被忽視的 CSS","slug":"css-utilities","date":"2016-12-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/22/css-utilities/","link":"","permalink":"https://wcc723.github.io/css/2016/12/22/css-utilities/","excerpt":"Bootstrap 3 載入以後其實就有包含大部分的元件，原本的設計概念上是希望透過一套框架就能滿足大多的需求，但實際在專案運作時有許多客製化需要微調，而很多微調的項目如下： 左邊一點、右邊一點、間格大一點 文字色彩 背景色 對齊方法 垂直置中方法 CSS 屬性：顯示屬性、背景屬性、Position … 這些雜七雜八的，通常會運用在每個元件上，但每個元件都補上重複性又高，這一個部分我們通常會用另一個元件 _utilities.scss 來管理。","text":"Bootstrap 3 載入以後其實就有包含大部分的元件，原本的設計概念上是希望透過一套框架就能滿足大多的需求，但實際在專案運作時有許多客製化需要微調，而很多微調的項目如下： 左邊一點、右邊一點、間格大一點 文字色彩 背景色 對齊方法 垂直置中方法 CSS 屬性：顯示屬性、背景屬性、Position … 這些雜七雜八的，通常會運用在每個元件上，但每個元件都補上重複性又高，這一個部分我們通常會用另一個元件 _utilities.scss 來管理。 Utilities在 Bootstrap 第四版這一兩個月的改版也有這樣的設計，而且數量多到有細項分類；就算如此，還是建議了解有哪些項目建議可以自行設計，因為這使用率非常高，就算用了第四版還是有不足的可能。 以下我就來介紹一下常用的 Utilities 分類 Spacing間格分為兩大類，一則是 margin，另一則是 padding，兩者的使用頻率都非常高，所以別想偷懶只做一種。另外依據 OOCSS 的概念，間格要避免直接使用數值命名，如： 123.mb-5 &#123; margin-bottom: 5px;&#125; 所以這部分都會用 s、m、l 或是倍數型的 1、2、3，實作範例如下 (僅列出部分的範例…)。 12345678910111213141516/* 實作範例 */.mb0 &#123; margin-bottom: 0 !important;&#125;.mbs &#123; margin-bottom: $gap-small;&#125;.mbm &#123; margin-bottom: $gap-base;&#125;....pdm &#123; padding: $gutter;&#125; 文字色彩 與 背景色文字色彩也是經常使用的，除了品牌色 (Bootstrap 中有提到) 另外經常使用的色彩就是灰階、白色，這段的問題比較小，只是建議要使用 !important 來確保色彩覆蓋(僅列出部分的範例…)。 12345678910.text-primary &#123; color: $brand-primary !important;&#125;.text-danger &#123; color: $brand-danger !important;&#125;.text-white &#123; color: white !important;&#125; 背景色如同文字色彩，但是背景色有些會有更多延伸，如： 是否包含不同明暗度 是否要額外製作漸層 在製作漸層時，如果專案維護的人不多(或者只有自己)，很建議先寫需要使用的色彩即可，不用的色彩可先不寫，因為很多色彩真的不會去用…。 12345678910.bg-primary &#123; background-color: $brand-primary&#125;.bg-primary-lighter &#123; background-color: lighten($brand-primary, 12%)&#125;.bg-primary-darken &#123; background-color: darken($brand-primary, 12%)&#125; 對齊方法這邊主要是文字的對齊，文字分為三種對齊置左、置中、置右，一般來說也是這三種即可，但是在 Bootstrap 4 之中還特別製作了不同的裝置尺寸的對齊方式。 垂直置中的部分在後面會有獨立章節介紹。 CSS 屬性CSS 很多屬性都是經常性的會運用到，這邊列出常用的： float background-size cover contain display block inline-block none position relative absolute fixed overflow overflow-y overflow-x 這些都屬於零碎的 CSS 屬性，使用頻率說高不高、說低不低，但是要用實在另外寫 CSS 也是挺麻煩的，所以我也會將它獨立出來。 12345678910111213141516.bg-cover &#123; background-size: cover&#125;.bg-contain &#123; background-size: contain&#125;.p-relative &#123; position: relative;&#125;.p-absolute &#123; position: absolute;&#125;.p-fixed &#123; position: fixed;&#125; 結語除了垂直置中以外，其他常見的雜項我都已經在本篇列出，在製作第二次框架時，我就將大量的 Utilities 加入，導致我上班不太需要寫 CSS @_@，也很高興第四版 Bootstrap 加入了大量的 Utilities 讓我寫的 CSS 更少了…。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 21 - Bootstrap 透過 Sass 新增自定義元件","slug":"bootstrap-add-component","date":"2016-12-20T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/21/bootstrap-add-component/","link":"","permalink":"https://wcc723.github.io/css/2016/12/21/bootstrap-add-component/","excerpt":"許多人在使用 Bootstrap 時，如果有需要新增、調整，都是寫在 CSS 的後方或是另開一個新檔透過 “覆蓋” 的特性來新增、調整。先前的文章已經介紹了如何調整 Bootstrap 的 CSS，透過變數的方式，我們可以調整整體的樣式設定，而 “新增” 我們也應該用相同的方法來製作，這樣的方法更有一致性，且能夠調用 Bootstrap 原有的變數及 @mixin。","text":"許多人在使用 Bootstrap 時，如果有需要新增、調整，都是寫在 CSS 的後方或是另開一個新檔透過 “覆蓋” 的特性來新增、調整。先前的文章已經介紹了如何調整 Bootstrap 的 CSS，透過變數的方式，我們可以調整整體的樣式設定，而 “新增” 我們也應該用相同的方法來製作，這樣的方法更有一致性，且能夠調用 Bootstrap 原有的變數及 @mixin。 新增一個元件範例連結https://github.com/Wcc723/ironman-gulp-sass/tree/v.0.7.component 先前的文章介紹到 Sass 的架構，所以我們的專案結構會做些許的調整，目前已經有了 all.scss 以及 helpers/_variables.scss 這兩隻 .scss 檔案，接下來新增 components 資料夾，預計新增的元件就會放在這裡。 12345678scss/|- all.scss||– helpers/| |– _variables.scss # Sass Variables||– components/| |– _card.scss # 預計新增的模組 元件來源：https://github.com/doabit/semantic-ui-sass/blob/master/app/assets/stylesheets/semantic-ui/views/_card.scss 我在 Sematic UI 上找到了一個現成的 Card 模組，這個模組所使用的變數不多，刪除後面的段落後，就可以直接加入 components/_card.scss 內。 參考加入內容：https://github.com/Wcc723/ironman-gulp-sass/blob/v.0.7.component/source/scss/components/_card.scss 1234567891011121314151617181920212223242526272829303132/*-------------- Card---------------*/.ui.cards &gt; .card,.ui.card &#123; max-width: 100%; position: relative; display: -webkit-box; display: -webkit-flex; display: -ms-flexbox; display: flex; -webkit-box-orient: vertical; -webkit-box-direction: normal; -webkit-flex-direction: column; -ms-flex-direction: column; flex-direction: column; width: 290px; min-height: 0px; background: #FFFFFF; padding: 0em; border: none; border-radius: 0.28571429rem; box-shadow: 0px 1px 3px 0px #D4D4D5, 0px 0px 0px 1px #D4D4D5; -webkit-transition: box-shadow 0.1s ease, -webkit-transform 0.1s ease; transition: box-shadow 0.1s ease, -webkit-transform 0.1s ease; transition: box-shadow 0.1s ease, transform 0.1s ease; transition: box-shadow 0.1s ease, transform 0.1s ease, -webkit-transform 0.1s ease; z-index: '';&#125;/* 略 .. */ 新增元件的心法在前面幾個章節有詳細的描述，本篇就直接運用半成品來說明，在 _card.scss 加入後，如果直接運行 gulp 是不會看到 card 加入至你的 CSS 內，所以必須要在 all.scss 補上以下內容確認載入才行。 1234@import \"helpers/variables\";@import \"bootstrap\";@import \"components/card\"; 此時，執行 gulp 沒有出錯的情況下就會看到 Card 模組已經載入了。以下範例為調整後的按鈕色彩及卡片模組。 結語透過這一段的教學，大家能夠更靈活的使用 Bootstrap，其實這段流程並沒有那麼複雜，只要稍作練習，就能夠彈性的運用這些技能，且能有效地增加工作效率。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 20 - Sass 資料夾結構","slug":"sass-folder","date":"2016-12-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/20/sass-folder/","link":"","permalink":"https://wcc723.github.io/css/2016/12/20/sass-folder/","excerpt":"對於 Bootstrap 有一定了解後，我們即將要開始新增元件，不過在新增前我在分享一下 Sass 開發時的資料結構。 Sass 資料夾結構相信大家也聽說 SMACSS 等，不過我們我們已經加入了 Bootstrap ，在開發時也要思考如何結合不同的開發概念 (自己的元件與 Bootstrap 元件的結合)，並且還有往後的 Bootstrap 框架更新、專案的樣式更新等問題。","text":"對於 Bootstrap 有一定了解後，我們即將要開始新增元件，不過在新增前我在分享一下 Sass 開發時的資料結構。 Sass 資料夾結構相信大家也聽說 SMACSS 等，不過我們我們已經加入了 Bootstrap ，在開發時也要思考如何結合不同的開發概念 (自己的元件與 Bootstrap 元件的結合)，並且還有往後的 Bootstrap 框架更新、專案的樣式更新等問題。 以元件為主的開發觀念直觀的概念下，樣式通常會是用到哪寫到哪，這樣的開發下 CSS 的可用性較低，且開發到後期，前期的樣式都不太會再次使用(甚至不敢修改)，所以如果在開發時以元件作為出發點，就可以避免樣式可用性不高的問題。 架構參考：http://www.sitepoint.com/architecture-sass-project/ 這架構是我很喜歡的 Sass 開發架構，目前開發都是以此為基礎作延伸，但由於會搭配 Bootstrap 所以還是略有調整。 這架構也並非每次都全開，會依據專案需求來做調整(用到哪開到哪)，以 layout、pages 來說，開發都是以元件為基礎，不太會使用到 layout 及 pages，所以這兩個資料夾開啟的機率不高(這兩者通常會用在活動型的網頁)。 12345678910111213141516171819202122232425262728293031323334353637383940414243sass/||– base/| |– _reset.scss # Reset/normalize| |– _typography.scss # Typography rules| ... # Etc…||– components/| |– _buttons.scss # Buttons| |– _carousel.scss # Carousel| |– _cover.scss # Cover| |– _dropdown.scss # Dropdown| |– _navigation.scss # Navigation| ... # Etc…||– helpers/| |– _variables.scss # Sass Variables| |– _functions.scss # Sass Functions| |– _mixins.scss # Sass Mixins| |– _helpers.scss # Class &amp; placeholders helpers| ... # Etc…||– layout/| |– _grid.scss # Grid system| |– _header.scss # Header| |– _footer.scss # Footer| |– _sidebar.scss # Sidebar| |– _forms.scss # Forms| ... # Etc…||– pages/| |– _home.scss # Home specific styles| |– _contact.scss # Contact specific styles| ... # Etc…||– themes/| |– _theme.scss # Default theme| |– _admin.scss # Admin theme| ... # Etc…||– vendors/| |– _jquery-ui.scss # jQuery UI| ... # Etc… 而我的開發流程就是依據以上再作為調整，開發的心法如下 all.scss 載入開發模組 (Bootstrap 或自行開發的模組庫)。 透過 helper 內的變數重新定義專案專屬的變數。 增加專案所需要的元件 (元件庫所缺乏的元件)。 增加區域性的元件如 header、footer (這部分的元件有可能再轉換成 components)。 依據頁面需求撰寫 Pages 的 css。 撰寫權限用的主題 如果有載入外部 Javascripts ，會將外部的Javascript 的 css 檔名改成 _xxxx.scss 丟到vendors。 結語大多情況下，我都是以 all.scss、/helpers/、/components/ 作為開場，如果是中小型的專案甚至從頭到尾的架構都是如此，大家也可以試試看用這個架構作為開發，可以從中思考到很多 CSS 架構管理的方法，以減少大型專案的樣式失控的問題。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 19 - Bootstrap 一次看懂元件的使用組合","slug":"bootstrap-component","date":"2016-12-18T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/19/bootstrap-component/","link":"","permalink":"https://wcc723.github.io/css/2016/12/19/bootstrap-component/","excerpt":"Bootstrap 的官方文件有完整的說明以及範例，就算是如此，還是會有許多朋友希望有快速入門的介紹，本篇就來介紹絕大部分 Bootstrap 元件的組合手法，搞懂一次後就能快速運用到其他模組上，甚至 Bootstrap 4 也是用相同的概念就能夠運用唷。","text":"Bootstrap 的官方文件有完整的說明以及範例，就算是如此，還是會有許多朋友希望有快速入門的介紹，本篇就來介紹絕大部分 Bootstrap 元件的組合手法，搞懂一次後就能快速運用到其他模組上，甚至 Bootstrap 4 也是用相同的概念就能夠運用唷。 元件組合Bootstrap 是標準的 OOCSS 概念下所設計的框架，也就如同樂高一樣可以反覆的堆疊，不過前提也是要在正確的卡楯上才能順利的接上。 以按鈕為例，一般來說會看到長長的一段說明怎麼使用，以及有哪些樣式、大小、狀態等等使用方法(除了按鈕以外，大部分的文件皆是如此)，如果是要熟悉 Bootstrap 一個一個邊看邊使用也需要很長的時間，這邊來介紹一下基本的運用： Bootstrap 在使用時，都會有個 { 模組 } 作為元件的架構，所以按鈕就會有 .btn 然而這段也會混用在其他的延伸樣式上，如配色、樣式皆是如此，不過狀態就不會帶上 .btn 囉，這段要多注意一下。 這邊我們在列出常見的按鈕表格模組，這樣是不是一目了然呢？ 模組 配色 樣式 狀態 btn btn-primary btn-sm active btn-default btn-lg disabled btn-success btn-xs btn-info btn-block … 這時候如果在製作一個流程表單，要呈現用戶尚未填寫完成，需要一個較大的下一步按鈕並且加上不能點選的按鈕，我們就可以依上表格挑選。 模組 配色 樣式 狀態 v btn btn-primary btn-sm active btn-default v btn-lg v disabled v btn-success btn-xs btn-info v btn-block … 組出來的結果會是 class=&quot;btn btn-success btn-lg disabled&quot; 這樣就能出現一個綠色，且不能點擊的大按鈕。 結構以上案例可以套用在絕大部分的 Bootstrap 元件上，另外在介紹一下 Bootstrap 的元件模組結構，絕大部分如 btn、nav、navbar、progress、pagination… 都是用模組名稱在前，後方使用 - 帶入各種延伸的配色、樣式，而第一個模組名稱其實就是 模組的結構 ，這個設計概念也是不斷的反覆出現結構與樣式分離，讓 Bootstrap 如此靈活的主要原因。 結語本篇的概念可以快速使用 Bootstrap 3 的模組，且對於往後的 Bootstrap 4 版本更是如此，這個概念會更加的明顯。當然我們在製作元件時如果能夠帶入這些觀念，也助於我們的元件開發。。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 18 - Bootstrap 元件分類概觀 (content, container)","slug":"bootstrap-component","date":"2016-12-17T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/18/bootstrap-component/","link":"","permalink":"https://wcc723.github.io/css/2016/12/18/bootstrap-component/","excerpt":"接下來我們依循著 OOCSS 與 Bootstrap 的設計模式繼續擴資、修改元件，不過在繼續下一個階段以前，我們先來了解一下 Bootstrap 的設計模式。","text":"接下來我們依循著 OOCSS 與 Bootstrap 的設計模式繼續擴資、修改元件，不過在繼續下一個階段以前，我們先來了解一下 Bootstrap 的設計模式。 Bootstrap 檔案結構還記得我們一開始所說到的 OOCSS 中結構與樣式、容器與內容這兩者的概念嗎？無論是哪一個版本，Bootstrap 所有樣式模組都是以元件為基礎作為設計，基於這個概念我們可以很快得了解 Bootstrap 3 的結構。 Bootstrap Sass 版本的檔案結構：https://github.com/twbs/bootstrap-sass/tree/master/assets/stylesheets/bootstrap 1234567/bootstrap|- /mixins/|- _variables.scss|- _buttons.scss|- ....scss|- _components.scss|- _utilities.scss 主要資料夾如上，這邊略為介紹： /mixins/ 資料夾：樣式運算的函式庫，這部分可以先忽略他 _variables.scss：變數檔案，上一篇有介紹過，大部分的 Bootstrap 樣式變數都從這檔案設定。 _button.scss ~ _components.scss：剩下這層的檔案幾乎都是元件。 _utilities.scss：雖然說是元件，但又沒有完整的形體，像是 .clearfix 清除浮動就被歸在此類。 而這篇要介紹的就是廣大的 Components 類別，從官方的文件及 OOCSS 混合來看，又可以將它作為兩大類的區分，一則是易於修改樣式的 元件 (OOCSS 的內容)，另一則是包覆個許多子元件專用的 容器；這段很熟悉吧，我們在一開始所介紹到的 OOCSS 與此部分又開始產生連結。 容器作為外層的容器，主要就是要包覆著在其內的內容及元件，在網頁上的功能偏向於排版用途，通常不會有滑鼠事件互動，所以在設計上會遵循著以下概念： 不設定高度且具有彈性 寬度以百分比為主 可以有 theme (主題) 狀態不是必須的 元件 (內容) 元件的特色在於包含許多樣式、狀態，是使用者在觀看網頁時主要互動的物件；以按鈕來說，使用者會滑過按鈕、按下按鈕，並且按鈕可能會回饋訊息給用戶了解，所以除了不同樣式上，元件所傳達得狀態訊息狀態也相同重要： 有固定的外型 有許多的樣式 設計需要包含回饋狀態 容器型 元件型 grid-system form button-group buttons panel breadcrumbs 這設計在 Bootstrap 4 更為明顯，但本篇還是以 Bootstrap 作為介紹。 結語樣式雖然不是一定為哪種容器或是元件，但我們在設計一項新的物件時，一定要去思考他是傾向于哪種類型的物件，假設我們需要新增一個容器型物件，我們就要測試他有內容物及無內容物時的差異，甚至在大量的內容時是否會造成破版的問題。反之，設計元件型的樣式時則要思考在不同情境下使用的狀態，基本上就要補上 啟用中、無法使用 的狀態，這樣的設計會影響往後樣式在套用時的靈活性，與其在後續補上，不如在初期則做到一定的彈性。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 17 - Bootstrap 自定義樣式超簡單","slug":"bootstrap-custom","date":"2016-12-16T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/17/bootstrap-custom/","link":"","permalink":"https://wcc723.github.io/css/2016/12/17/bootstrap-custom/","excerpt":"在導入框架至網站時，還要考慮框架是否符合網站風格以及往後的維護性。Bootstrap 雖然設計上是要給開發者直接運用的，但實際上他所設計的彈性非常之高，也很適合做客製化，甚至 fork 作為公司團體的 Style Guide。","text":"在導入框架至網站時，還要考慮框架是否符合網站風格以及往後的維護性。Bootstrap 雖然設計上是要給開發者直接運用的，但實際上他所設計的彈性非常之高，也很適合做客製化，甚至 fork 作為公司團體的 Style Guide。 本篇範例：https://github.com/Wcc723/ironman-gulp-sass/tree/v.0.7.component 複製 VariablesBootstrap 所有設定都是放在 _variables.scss 這隻檔案下，但要學會怎麼修改其實沒有那麼困難，最簡單的方式就是將以下路徑的 _variables.scss 複製到專案目錄下的 ./source/scss，這邊我個人是更習慣放在 helpers 資料夾內，算是寫 Sass 的習慣。 1234bower_components/bootstrap-sass/assets/stylesheets/bootstrap/_variables.scss// 複製到/source/scss 接下來我們將 ./source/scss/all.scss 打開後加入 @import &quot;helpers/variables&quot;; 再次執行 gulp ，如果沒有跳任何錯誤代表正確。 12@import \"helpers/variables\";@import \"bootstrap\"; 修改 變數打開 Bootstrap 變數稍微閱讀一下其實會發現非常好懂，以下色彩這段來說，分為灰色系列色與品牌系列色，而品牌系列色就是我們看到 Bootstrap 各個元件的主要配色。 12345678910111213141516//== Colors////## Gray and brand colors for use across Bootstrap.$gray-base: #000 !default;$gray-darker: lighten($gray-base, 13.5%) !default; // #222$gray-dark: lighten($gray-base, 20%) !default; // #333$gray: lighten($gray-base, 33.5%) !default; // #555$gray-light: lighten($gray-base, 46.7%) !default; // #777$gray-lighter: lighten($gray-base, 93.5%) !default; // #eee$brand-primary: darken(#428bca, 6.5%) !default; // #337ab7$brand-success: #5cb85c !default;$brand-info: #5bc0de !default;$brand-warning: #f0ad4e !default;$brand-danger: #d9534f !default; 然後每一個變數的後方都會接上一個 !default 在後方做為預設，所以在修改變數時需要同時將 !default 移除，請參考以下範例： 123$brand-primary: #0275d8; //darken(#428bca, 6.5%) !default; // #337ab7$brand-success: #5cb85c !default;$brand-info: #5bc0de !default; 加入一個新色彩 #0275d8 並將原本色彩註解在後方，這時候在執行 gulp 就能看到結果。 原色彩 經調整，類似於 Bootstrap 4 的色彩 像這樣的配色就比較接近於 Bootstrap 4 的色彩，用這個方法就可以輕易地修改 Bootstrap 中各個元件中的樣式變數，修改就是這麼樣的容易，只要修改一些變數就能完成。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 16 - 將 Bootstrap 導入自動化流程","slug":"bootstrap-include","date":"2016-12-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/16/bootstrap-include/","link":"","permalink":"https://wcc723.github.io/css/2016/12/16/bootstrap-include/","excerpt":"先前的流程我們將 Gulp 的基礎流程已經建立起來了，現在我們要將 Bootstrap 導入自動化流程，讓接下來的客製化更為容易。","text":"先前的流程我們將 Gulp 的基礎流程已經建立起來了，現在我們要將 Bootstrap 導入自動化流程，讓接下來的客製化更為容易。 Bower本範例是使用大家所習慣的 Bootstrap 3，如果想用 4 的朋友可以自行修改，手法是幾乎一致的。 範例：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.6.bootstrap Bower 是前端的套件管理工具，也有許多開發者會使用 NPM 來一起管理，但我個人除了使用 Webpack 以外還是習慣用 Bower 在管理前端套件。 Bower: https://bower.io/ 使用 Bower 以前要先安裝 Bower 的工具，而它分為兩個部分，全域的 Bower 指令與專案的 bower.json： 首先，先在電腦內安裝 bower (需使用先前的 npm 環境)：npm install -g bower 接下來打開本篇範例，本篇範例已經準備好了 bower.json，這時候只要下 bower install 就能夠開始安裝 bower.json 內的套件檔案。 1bower install 接下來專案內會新增對應的檔案，Bootstrap 的套件需要使用到 jQuery ，此時也會一並出現。 Gulp這時候已經將 Bootstrap 下載到本地端的資料夾，當然我們也可以用 HTML 直接 &lt;LINK&gt; CSS，不過這樣就無法自定義樣式，先打開 gulpfile.js 看看修改了什麼吧 12345678910111213141516171819var path = &#123; source: './source/', public: './public/', bower: './bower_components/' // 新增 Bower 的路徑&#125;gulp.task('sass', function () &#123; var processors = [ autoprefixer(&#123;browsers: ['last 5 version']&#125;) ]; return gulp.src(path.source + 'scss/**/*.scss') .pipe(plumber()) .pipe(sass( &#123;outputStyle: 'expanded', includePaths: [path.bower + 'bootstrap-sass/assets/stylesheets']&#125; // 新增 includePaths 將 Bootstrap 載入 ).on('error', sass.logError)) .pipe(postcss(processors)) .pipe(gulp.dest(path.public + 'stylesheets'));&#125;); includePaths 是 Sass 的功能，他可以載入其他路徑的 .sass 作為擴充載入，這部分就是將 Bower 中的 Bootstrap 載入。 完成打開 all.scss 做以下的調整，直接用 @import &quot;bootstrap&quot;; 就可以將 Bootstrap 載入。 1234567$primary-color: blue;body &#123; color: $primary-color;&#125;@import \"bootstrap\"; 最後的結果如上，一開始的 color: blue 是我們自己定義的，而後方開始就是完整的 Bootstrap，接下來我們再來了解如何去調整 Bootstrap 的樣式。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 15 - 為什麼 Boostrap","slug":"gulp-bootstrap","date":"2016-12-14T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/15/gulp-bootstrap/","link":"","permalink":"https://wcc723.github.io/css/2016/12/15/gulp-bootstrap/","excerpt":"Bootstrap 是目前主流的 CSS 框架，先前也有提到，在起初我是很不喜歡 Bootstrap 的框架，認為他搶走我大部分的工作且缺乏特色，但在研究後會發現他並非我想的那麼缺乏特色，完全看開發者的使用及熟練度。 我們也可以看到網路上有相當多的 HTML Template 都做的非常美，但其實底層都是 Bootstrap，有些已經調整得相當不像是原有的 Bootstrap 樣式。所以在熟練的情況下，Bootstrap 也是能做出超乎水平的網頁版型。","text":"Bootstrap 是目前主流的 CSS 框架，先前也有提到，在起初我是很不喜歡 Bootstrap 的框架，認為他搶走我大部分的工作且缺乏特色，但在研究後會發現他並非我想的那麼缺乏特色，完全看開發者的使用及熟練度。 我們也可以看到網路上有相當多的 HTML Template 都做的非常美，但其實底層都是 Bootstrap，有些已經調整得相當不像是原有的 Bootstrap 樣式。所以在熟練的情況下，Bootstrap 也是能做出超乎水平的網頁版型。 Bootstrap 哪裡好用通常來說，後端會比前端開發者更喜歡 Bootstrap，因為以下徵狀會是想用 Bootstrap 的起因： 覺得 float 超難搞定 希望不要花那麼多時間在美編上 不想花太多時間學習主要技術以外的內容 RWD 真心難搞 過去的經驗… 使用冷門框架找不到相依套件 自幹框架真心不如 Bootstrap (泣) 對於熟悉 CSS 的網頁設計師來說，到會覺得自己就能解決這樣的狀況，所以 Bootstrap 在起初就不認為那麼的必要，但對於大型網站、系統來說，自己寫 CSS 也會產生幾個問題： 持續性的維護：架構是否良好將影響 CSS 是否好維護 套件的使用：再引用其他第三方套件時，是否能夠依據需求調整 CSS 符合風格 (很多套件相容於 Bootstrap)。 對於 CSS 的熟練度 Bootstrap 令人喜愛的地方Bootstrap 不能算是具有特色的前端框架，但也就和 jQuery 一樣好上手，在框架裡沒有太多浮誇的效果，大多是基於 HTML 規範去做樣式的調整。也因為如此，大多略有經驗的開發者僅需看過文件就能學會如何使用。解決問題如下： 不需要重頭開始寫 降低學習曲線 開源框架，Bug 少 延伸插件多 快速自定義 本篇系列作要介紹什麼Bootstrap 本身在使用上難度並不高，就基於元件如何使用官方文件上介紹以非常完整，本篇會開始會介紹 Bootstrap 的進階使用及設計模式去介紹，讓 Bootstrap 可以依據專案需求去做調整及延伸(Bootstrap 甚至能作為大型開發專案的基底)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"Bootstrap","slug":"Bootstrap","permalink":"https://wcc723.github.io/tags/Bootstrap/"}]},{"title":"鐵人賽 14 - Gulp - Webserver","slug":"gulp-webserver","date":"2016-12-13T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/14/gulp-webserver/","link":"","permalink":"https://wcc723.github.io/css/2016/12/14/gulp-webserver/","excerpt":"Gulp 很適合搭配任何其他的前後端結構，就先前介紹的幾個章節，只要略為修改輸入及輸出的路徑即可；除了搭配其他後端結構外，Gulp 也有適合直接開發的方法，本章會在介紹 Gulp Webserver，這樣就能夠直接在 Gulp 中開啟 Webserver。","text":"Gulp 很適合搭配任何其他的前後端結構，就先前介紹的幾個章節，只要略為修改輸入及輸出的路徑即可；除了搭配其他後端結構外，Gulp 也有適合直接開發的方法，本章會在介紹 Gulp Webserver，這樣就能夠直接在 Gulp 中開啟 Webserver。 gulp webserver範例程式碼：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.4.icon-fonts Gulp webserver 能夠在 gulp 運行的期間開啟 webserver，並且包含著 Livereload 的功能，只要修改專案中的資料夾檔案，就能夠自動的更新瀏覽器上的畫面，讓開發更迅速。 package.json: 僅有新增一個 gulp-webserver。 1234567891011\"dependencies\": &#123; \"async\": \"^2.1.4\", \"autoprefixer\": \"^6.5.3\", \"gulp\": \"^3.9.1\", \"gulp-consolidate\": \"^0.2.0\", \"gulp-iconfont\": \"^8.0.1\", \"gulp-plumber\": \"^1.1.0\", \"gulp-postcss\": \"^6.2.0\", \"gulp-sass\": \"^2.3.2\", \"gulp-webserver\": \"^0.9.1\"&#125; gulpfile.js 可以依據以下的方法設定。 12345678910111213141516var webserver = require('gulp-webserver'); // 載入 webserver// webservergulp.task('webserver', function() &#123; setTimeout(function()&#123; gulp.src(path.public) // 預設開啟路徑 .pipe(webserver(&#123; // 啟動 webserver livereload: true, // Livereload 的功能 open: false, // 是否自動開啟 瀏覽器 host: '0.0.0.0', // 如果使用 0.0.0.0 的 ip，還會另外開啟 wifi 等對外網路 port: 10000, // 開放通訊埠 &#125;)); &#125;, 1000);&#125;);gulp.task('default', ['others', 'sass', 'iconfonts', 'watch', 'webserver']); 設定完成後，一樣輸入 gulp 就會依序執行先前所設定的內容，而 Webserver 放在做後是確保所有流程完成後再開啟 Webserver ，使第一次執行專案的開發者也能夠執行。 結語Gulp 介紹的目前為止，其實已經掌握大部分 Gulp 所使用的手法，接下來僅需要調整到合適的搭配環境即可；如果在開發上遇到 Gulp 不足的地方，可以到 NPM 的網站上透過 gulp 作為關鍵字，搜尋是否有其他套件可以使用。 到目前所介紹的內容，也都只要略作修改，觀念都可以運用在任何的套件上，如果遇到任何問題，也歡迎來詢問我喔～。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 13 - Gulp - 在本地端製作 Icon Fonts","slug":"gulp-dev-env","date":"2016-12-12T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/13/gulp-dev-env/","link":"","permalink":"https://wcc723.github.io/css/2016/12/13/gulp-dev-env/","excerpt":"網頁設計都會需要大量的小 icon，現在的 icon 都傾向使用 web fonts 來處理，因為 web font 所製作的 icon 有以下的好處： 載入容易，HTML 只要載入一隻 CSS 就搞定 套用容易，只要透過 Class 就能套用 可自由調整大小、色彩","text":"網頁設計都會需要大量的小 icon，現在的 icon 都傾向使用 web fonts 來處理，因為 web font 所製作的 icon 有以下的好處： 載入容易，HTML 只要載入一隻 CSS 就搞定 套用容易，只要透過 Class 就能套用 可自由調整大小、色彩 雖然只能使用單色，但在開發的便利性上還是有不少人選擇 icon font，目前大家所選擇主流 icon fonts 有以下： FontAwesome：http://fontawesome.io/ 相當完整的 web font icons 可滿足大多的開發需求 我還參與 Font Awesome 的募資 &gt;O&lt;：https://www.kickstarter.com/projects/232193852/font-awesome-5?ref=1oakzw IcoMoon：https://icomoon.io/ 可以自選 icons 可以自定義 icons 付費可以使用它們的 CDN Google Material Icon：https://material.io/icons/ 很潮，Google 出的 icon 可以被搜尋、選取 除了以上幾種不同選擇外，大家應該也會想知道 “如果想自己做呢!?”，這次就來介紹怎麼用 Gulp 來自定自己的 icon fonts。 gulp iconfont這一個套件會將 .svg 的檔案轉換成字體，接下來在轉換成 CSS 供開發者使用。 範例程式碼：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.4.icon-fonts 使用套件：https://www.npmjs.com/package/gulp-iconfont 經過這幾次的練習，相信大家應該了解 gulp 的開發順序，我們會先打開 package.json 將所需要的套件載入，這次新增的套件有 async、gulp-consolidate、gulp-iconfont。 12345678910\"dependencies\": &#123; \"async\": \"^2.1.4\", \"autoprefixer\": \"^6.5.3\", \"gulp\": \"^3.9.1\", \"gulp-consolidate\": \"^0.2.0\", \"gulp-iconfont\": \"^8.0.1\", \"gulp-plumber\": \"^1.1.0\", \"gulp-postcss\": \"^6.2.0\", \"gulp-sass\": \"^2.3.2\"&#125; 接下來打開 gulpfile.js 加入以下的 Task。 1234567891011121314151617181920212223242526// icon fontsgulp.task('iconfonts', function(done)&#123; var iconStream = gulp.src([path.source + 'icons/*.svg']) // 載入 svg .pipe(iconfont(&#123; fontName: 'icon' &#125;)); // 定義 fontName async.parallel([ function handleGlyphs (cb) &#123; iconStream.on('glyphs', function(glyphs, options) &#123; gulp.src(path.source + 'css_template/iconfonts.css') // 取用要輸出的 CSS 樣板 .pipe(consolidate('lodash', &#123; glyphs: glyphs, fontName: 'icon', fontPath: '../fonts/', // CSS 對應的字體路徑 className: 'all-my-class' // CSS Class 的前輟詞 &#125;)) .pipe(gulp.dest(path.public + 'stylesheets')) // CSS 輸出資料夾 .on('finish', cb); &#125;); &#125;, function handleFonts (cb) &#123; iconStream .pipe(gulp.dest(path.public + 'fonts/')) // 字體輸出資料夾 .on('finish', cb); &#125; ], done);&#125;); 除了 SVG 以外，在 gulpfile.js 還有列出一個 css template，這是用來產出 iconfont 所需的 CSS 檔案樣板，在我所提供的範例中已包含 template 的樣板，大家可以直接參考。 12345678|- /source # 專案資料夾 (sass 位置) |- css_template # webfont 需要的 css 樣板 |- icons # .svg 原始檔位置|- /mode_modules # node.js 套件資料夾|- /public # 專案匯出的資料夾|- .gitignore|- gulpfile.js # gulp 腳本檔案|- package.json # 套件管理 json 接下來執行 gulp iconfonts public 就會產生一個字體檔以及 CSS 檔案，接下來我們在 HTML 中載入 CSS 檔案，就可以開始使用 icon font 囉～。 結語在使用這功能時，要思考團隊中是不是有專門的設計師能繪製 icon ，以及 icon 不足時能不能有專人提供，避免用了這個功能，卻無法做良好的維護。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 12 - Gulp - 定義預設開發環境","slug":"gulp-dev-env","date":"2016-12-11T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/12/gulp-dev-env/","link":"","permalink":"https://wcc723.github.io/css/2016/12/12/gulp-dev-env/","excerpt":"今天的進度來做個小調整，讓大家在使用 Gulp 時就能相容於目前的環境，目前使用的主要套件有：gulp-sass、gulp-postcss，這次調整後會有一個主要的前端專案資料夾，可以配合各個後端語言做調整，大家也可用相同的概念加入習慣的開發環境。","text":"今天的進度來做個小調整，讓大家在使用 Gulp 時就能相容於目前的環境，目前使用的主要套件有：gulp-sass、gulp-postcss，這次調整後會有一個主要的前端專案資料夾，可以配合各個後端語言做調整，大家也可用相同的概念加入習慣的開發環境。 定義輸入及輸出範例程式碼：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.3.gulp-default 為了優化前端的效能會使用工具再將前端的內容編譯一次，如壓縮合併 Javascript、CSS；這時候會有一個原始碼以及壓縮後的程式碼，主要作業都是在原始碼，壓縮後的程式碼是用來部署使用。 在 gulpfile.js 內可以準備以下的變數： 1234var path = &#123; source: './source/', // 原始碼 public: './public/' // 輸出位置&#125; 這些變數可以依序套用在先前準備的 Task 上，開發時無論是配合什麼後端語言，只要調整原始碼、輸出位置就能夠配合各種語言。 12345gulp.task('sass', function () &#123; return gulp.src(path.source + 'scss/**/*.scss') // 輸入點 /* Task 的其他工作 */ .pipe(gulp.dest(path.public + 'stylesheets')); // 輸出點&#125;); 複製主要工作項以外的檔案原始碼之中有許多檔案是不需要編譯的，但為了方便整理，我們可以將全部原始碼先放在 source資料夾，再透過 gulp 一起輸出到另一個資料夾。 透過 ! 可以避掉特定的檔案，所以我們可以匯入全部檔案後，再排除不需要複製檔案，以下程式碼就可以直接完成以下流程。 12345678910111213// 其它不編譯的物件var objs = ['./source/**/**.*'];var others = [ '**/*.scss', '**/*.sass',]; // 不複製的檔案for (var i = 0; i &lt; others.length; i++) &#123; objs.push('!' + path.source + others[i]);&#125;gulp.task('others', function()&#123; return gulp.src(objs) .pipe(plumber()) .pipe(gulp.dest(path.public));&#125;); 這個步驟會新增一個 Task，所以我們需要使用 gulp others 來執行這段流程，此時我們也有幾個 Task，這時可以加入一個整合性的 Task 將所有的任務串接再一起。 default 是預設 gulp 會執行的 Task，後方的陣列內在加入要一起執行的 Task 即可。 1gulp.task('default', ['others', 'sass', 'watch']); 完成到這個步驟，只要執行 gulp 就會自動將以上流程一次完成，並且監聽相關的檔案是否有異動。 到目前為止，基本的 Gulp 運用已經足夠應付 CSS 在前端上的需求，在後面的章節會介紹更進階的 Gulp 套件運用。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 11 - Gulp - 透過 PostCSS 加入 CSS Prefix","slug":"gulp-postcss","date":"2016-12-10T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/11/gulp-postcss/","link":"","permalink":"https://wcc723.github.io/css/2016/12/11/gulp-postcss/","excerpt":"說到 CSS prefix 相信大家都不是很清楚當下主流版本的 prefix 有哪些是必要？又有哪些是不必要的？ 以往都是使用 Sass 的 Compass 來加入 prefix，這種增加方式就是無差別的加入，但其實現在的 CSS 有 9 成以上的 prefix 都沒有加入的必要，相信在短期內除了測試的 CSS 以外，都不需要再加入 prefix。","text":"說到 CSS prefix 相信大家都不是很清楚當下主流版本的 prefix 有哪些是必要？又有哪些是不必要的？ 以往都是使用 Sass 的 Compass 來加入 prefix，這種增加方式就是無差別的加入，但其實現在的 CSS 有 9 成以上的 prefix 都沒有加入的必要，相信在短期內除了測試的 CSS 以外，都不需要再加入 prefix。 現在寫入 prefix 以後還要移除也是個大工程，這時候推薦使用 PostCSS 的 autoPrefixer。PostCSS 類似 Sass，但是他是直接編譯 .css 檔案，另外他的套件都是用插件的方式載入，並不是像 Sass 已經有固定的寫法。這邊特別推薦他的 autoPrefixer 套件，使用上也非常容易，對於往後的維護也是無痛更新。 PostCSS範例：https://github.com/Wcc723/ironman-gulp-sass/tree/v0.2.postcss 延續前一篇的進度，這篇加入兩個新套件 gulp-postcss、autoprefixer，在 package.json 的檔案內可以找到這段： 123456\"dependencies\": &#123; \"autoprefixer\": \"^6.5.3\", \"gulp\": \"^3.9.1\", \"gulp-postcss\": \"^6.2.0\", \"gulp-sass\": \"^2.3.2\"&#125; 接下來修改 gulpfile.js 內的 sass task，直接將 PostCSS 加到原有的 Sass 流程上就能運行了。 1234567891011121314var autoprefixer = require('autoprefixer');var postcss = require('gulp-postcss');gulp.task('sass', function () &#123; var processors = [ // 定義 postCSS 所需要的元件 autoprefixer(&#123;browsers: ['last 5 version']&#125;) // 使用 autoprefixer，這邊定義最新的五個版本瀏覽器 ]; return gulp.src('./source/scss/**/*.scss') .pipe(sass( &#123;outputStyle: 'expanded'&#125; ).on('error', sass.logError)) .pipe(postcss(processors)) // 將 PostCSS 插入流程 .pipe(gulp.dest('./public/stylesheets'));&#125;); autoPrefixer 的瀏覽器版本可以自行定義，文件可參考：https://github.com/postcss/autoprefixer 這個範例是選擇 &#39;last 5 version&#39; (最新的五個版本瀏覽器)，如果是調整 &#39;last 2 version&#39; 那需要加入 prefix 的還真的沒幾個，大家也可以修改看看這段與編譯結果的差異。 編譯這時候的開發流程不會有太多的改變，一樣是在 all.scss。 1234567// 編譯前$primary-color: blue;body &#123; color: $primary-color; filter: blur(5px);&#125; 編譯後 (含 PostCSS)。 12345body &#123; color: blue; -webkit-filter: blur(5px); filter: blur(5px);&#125; 原有的 .scss 我略作些微調整，補上了 filter，這時候執行 gulp sass 就能看到 filter 加上了 -webkit- 的 prefix，如果說你看到的結果沒有加入 prefix，想必這篇文章年代已久遠，如果你堅持要使用 autoprefixer，可以參考文件，將 autoprefixer 的版本拉到 ie 7 那個年代 @_@。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 10 - Gulp 與 Sass 開發環境","slug":"gulp-init","date":"2016-12-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/10/gulp-init/","link":"","permalink":"https://wcc723.github.io/css/2016/12/10/gulp-init/","excerpt":"Gulp 是我目前最使用的自動化工具，在先前一篇也有介紹有哪些自動化工具，這篇開始會介紹 Gulp 自動化工具如何使用、有哪些推薦的工具以及一些經驗上的分享。而本次系列文都是著重在 CSS 的開發，所以不會介紹 Javascript 的自動化工具。","text":"Gulp 是我目前最使用的自動化工具，在先前一篇也有介紹有哪些自動化工具，這篇開始會介紹 Gulp 自動化工具如何使用、有哪些推薦的工具以及一些經驗上的分享。而本次系列文都是著重在 CSS 的開發，所以不會介紹 Javascript 的自動化工具。 Gulp 可以做什麼？Gulp 是一個前端任務管理工具，它可以做到如Fire.app、Prepros、Grunt等等所能做的事情，簡單內容如下： 編譯 SASS、Coffeescript 壓縮 .CSS, .JS, 甚至圖檔 web server with Livereload 享受自己動手做Task工具的快感 others.. 雖然很多工具，都能做到類似的功能，但是如果需求不足的時候，就要開另一個工具來幫忙；另外許多專案已經在執行中或者是老專案，有些工具就會顯得限制太多，那麼就可以用gulp客製化屬於該專案使用的工具。 快速建置在開始使用 Gulp 前，需要先安裝 Node.js，Node.js 是一個讓 Javascript 運行在服務端的開發平台。另外還有 npm，是由 Node.js 官方提供的第三方管理工具，並且是一種在 Node.js 應用程式中建立、分享、重複使用模組，而 npm 在目前的版本，都會隨著 Node.js 的安裝同時安裝好 npm。 簡而言之，我們使用 Node.js 的服務以及透過 npm 管理工具。 這一部分網路上有相當多的文章，本篇就不再贅述。 透過範例來了解如何運行這邊我準備了一個很簡單的 Gulp Sass 案例： https://github.com/Wcc723/ironman-gulp-sass/tree/v0.1.sass 下載後，在 Terminal 打開這個專案，並輸入以下指令： 12npm install gulp -gnpm install 這就是透過 npm 來安裝相關所需的套件，npm install gulp -g 會在全域環境下安裝 gulp，npm install 則是會安裝專案內的 package.json 所列出的需要元件。 package json 如下，這範例中只會安裝 gulp、gulp-sass。 123456789101112131415&#123; \"name\": \"gulp-sass\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": &#123; \"test\": \"echo \\\"Error: no test specified\\\" &amp;&amp; exit 1\" &#125;, \"author\": \"\", \"license\": \"ISC\", \"dependencies\": &#123; \"gulp\": \"^3.9.1\", \"gulp-sass\": \"^2.3.2\" &#125;&#125; 接下來在執行： 1gulp sass 執行後就會將 source/scss/all.scss 編譯到 public/stylesheets/all.css ，此時整個範例流程也就結束。 解說在一開始下載時檔案結構如下： 1234|- /source/scss # 專案資料夾 (sass 位置)|- .gitignore|- gulpfile.js # gulp 腳本檔案|- package.json # 套件管理 json 執行完以上步驟後，資料夾結構會如下，node_modules 是運行 gulp 的套件資料工具資料夾，public 就是前端匯出的專案資料夾，在這個範例中我們可以將 public 指定任何的資料夾名稱與後端結構配合。 123456|- /source/scss # 專案資料夾 (sass 位置)|- /mode_modules # node.js 套件資料夾|- /public # 專案匯出的資料夾|- .gitignore|- gulpfile.js # gulp 腳本檔案|- package.json # 套件管理 json gulpfile.js 是整個 gulp 的核心，相當於一齣戲的劇本，開發者可以在腳本中定義自動化的運行流程，這邊用相當簡單的 gulp-sass 來介紹怎麼撰寫一份 gulpfile。 123456789101112131415var gulp = require('gulp'); // 將 node_modules 的檔案載入var sass = require('gulp-sass');gulp.task('sass', function () &#123; // 定義 sass 的任務名稱 return gulp.src('./source/scss/**/*.scss') // sass 的來源資料夾 .pipe(sass( // 編譯 sass &#123;outputStyle: 'expanded'&#125; // sass 的輸出格式 ).on('error', sass.logError)) .pipe(gulp.dest('./public/stylesheets')); // sass 編譯完成後的匯出資料夾&#125;);gulp.task('sass:watch', function () &#123; gulp.watch('./source/scss/**/*.scss', ['sass']); // 監控資料夾，當有變化時執行 'sass' 任務&#125;); 範例中的 watch 資料夾有誤，請稍做調整如本文 所以開發者可以定義相當多的 Task，就以本範例中還有一個監控的任務可以使用 gulp sass:watch，如果不想要一直重啟 gulp 來編譯 sass 可以使用此指令。 結語接下來連續幾篇都會介紹 gulp 以及與 CSS 相關的套件給大家參考。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 9 - CSS 實戰心法 搶到決定權，開發環境自己來","slug":"css-dev","date":"2016-12-08T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/09/css-dev/","link":"","permalink":"https://wcc723.github.io/css/2016/12/09/css-dev/","excerpt":"前端工程師一般來說只要搞定 HTML、CSS、Javascript 就可以了，所以後端的環境上不用太在意，但在這幾年的體悟下，這是一個不負責任的想法。 我用過的前端自動化開發環境有： Fireapp：這用了有兩年之久，算是一個超級入門 GUI 自動化工具，但在 compass 不維護以後 Fireapp 也不再維護了。 Prepros：當時 GUI 的自動化工具另一個選擇，到現在還有持續在更新，但一直有些小問題所以沒有想用在專案上，但對於入門來說是個不錯的選擇 Middleman：為了與 Ruby on Rails 專案做整合，算是不錯的 Command line 工具，也是使用很長的一段時間，現在懶得自己開環境還是會使用。 *gulp：相當推薦的自動化工具，易學且可以與任何環境結合，缺點是肥了點。 *webpack：很潮的自動化工具，但與 gulp 觀念差異很大，適合製作 SPA(sigle page application) 的網站。","text":"前端工程師一般來說只要搞定 HTML、CSS、Javascript 就可以了，所以後端的環境上不用太在意，但在這幾年的體悟下，這是一個不負責任的想法。 我用過的前端自動化開發環境有： Fireapp：這用了有兩年之久，算是一個超級入門 GUI 自動化工具，但在 compass 不維護以後 Fireapp 也不再維護了。 Prepros：當時 GUI 的自動化工具另一個選擇，到現在還有持續在更新，但一直有些小問題所以沒有想用在專案上，但對於入門來說是個不錯的選擇 Middleman：為了與 Ruby on Rails 專案做整合，算是不錯的 Command line 工具，也是使用很長的一段時間，現在懶得自己開環境還是會使用。 *gulp：相當推薦的自動化工具，易學且可以與任何環境結合，缺點是肥了點。 *webpack：很潮的自動化工具，但與 gulp 觀念差異很大，適合製作 SPA(sigle page application) 的網站。 以下我再將開發流程分為以下三種： 後端工程師人肉整合流程：前端工程師射後不理，將 Code 交給後端工程師處理。 前後端整合的開發流程：前後端共用相同的開發環境。 前後端分離：前後端作業完全分離，後端負責資料庫、API，前端負責頁面結構、API 介接。 後端工程師人肉整合流程這是很常見的流程，網頁設計師、前端工程師將圖片切完後，交給後端的工程師做整合，後端也許是 PHP、.net、node.js。這樣的缺點在於如果版型不符合後端的需求，後端會直接用 style 的方式直接調整版型，且如果前端發現了問題，也不好修正。 前後端整合的開發流程有些框架如 Ruby on Rails，就是適合做前後端整合的框架，本身就具有編譯 Sass 的能力，並且有大量的套件可以輔助前端工作。除了 Rails 以外，Gulp 或 Grunt 這樣的自動化工具可以讓前端與後端整合在一起。 這樣的開發流程，前後端的合作會更為密切，大多前端在接觸後也會更深入的了解後端架構，甚至能夠依據需求略為調整資料結構。 前後端分離自從 Ajax 越來越普遍的情況下，前後端分離漸為許多公司開發的架構，同一個專案會在拆分成前端與後端，這樣完全的分離可以讓職責分得更清楚，但也同時需要更重視 “溝通”。 結語雖然 CSS 與後端看似關係不大，如果對於開發環境有一定掌控度，也更能掌握元件的細節。最常見的就是設計的結構與資料結構不合需要調整，前端如果對於開發環境掌控度不足，整個在修改所花的時間成本就會相當大。 經常會有前後端或者設計師抱怨其他不同領域的開發者，很多時候在於不夠了解對方，也許會思考 “我時間都不夠了” ，為什麼還要花時間去學對方的領域呢？ 換個層面思考，如果了解對方的領域(對方領域的基礎運作即可)，是不是能夠減少更多的溝通成本，進而節省時間。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"鐵人賽 8 - CSS 框架架構參考 Bootstrap","slug":"framework-bootstrap","date":"2016-12-07T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/08/framework-bootstrap/","link":"","permalink":"https://wcc723.github.io/css/2016/12/08/framework-bootstrap/","excerpt":"Bootstrap 是目前我最喜歡的 CSS 框架。 雖說如此，我以往可是很討厭 Bootstrap 的，身為一名設計師希望能夠有更多自己發揮的空間，所以早期一直在避免使用 Bootstrap 這樣的框架，總認為這些框架做出來的設計都很像，還因此自己寫一個 CSS 框架。 經歷過了一段自幹的歷程，從新再研究了 Bootstrap 的框架才發現自己很多觀念上的不足如： 過度的 sass @extend (良好的 CSS 架構，不太需要使用 @extend) OOCSS 觀念不夠強 (結構與樣式並未良好的分離) 框架可用套件不足 (自幹的怎會有套件 @_@) Bug 發現慢 (多人開發的框架 bug 自然少)","text":"Bootstrap 是目前我最喜歡的 CSS 框架。 雖說如此，我以往可是很討厭 Bootstrap 的，身為一名設計師希望能夠有更多自己發揮的空間，所以早期一直在避免使用 Bootstrap 這樣的框架，總認為這些框架做出來的設計都很像，還因此自己寫一個 CSS 框架。 經歷過了一段自幹的歷程，從新再研究了 Bootstrap 的框架才發現自己很多觀念上的不足如： 過度的 sass @extend (良好的 CSS 架構，不太需要使用 @extend) OOCSS 觀念不夠強 (結構與樣式並未良好的分離) 框架可用套件不足 (自幹的怎會有套件 @_@) Bug 發現慢 (多人開發的框架 bug 自然少) Sass 架構簡介Bootstrap 第三版是使用 LESS，到了第四版改用 SASS，但不管用哪一個開發工具，其實整個架構的差異都不大，只要了解其中一種觀念，就可以套用在每個版本上。 Bootstrap 的架構其實並不複雜，整個核心都圍繞在 “模組” 上，我們可以視 Bootstrap 每一個部件都是一個模組： 123456789101112|- bootstrap.scss # 主檔案，負責載入所有模組|- _variables.scss # 變數，如果要修改整體樣式可從這裡調整|- _buttons.scss # 從這以下都是模組|- _tables.scss|- _alert.scss|- _utilities.scss|- ...|- /mixins # 樣式運算函式庫 |- _buttons.scss |- _forms.scss |- _grid.scss |- ... bootstrap.scss這隻檔案相當的單純，主要是載入全部的樣式表，除了這隻以外還有以下幾個分支： bootstrap-flex.scssbootstrap-grid.scssbootstrap-reboot.scss 這些的功能都是一樣的，只是差異在載入的檔案不同，如果第一次想了解 Bootstrap 的同學，可以先看看這隻檔案 “依序” 載入了哪些的檔案。 _variables.scss在 scss 中，前方帶有下底線的代表該檔案不會被輸出(所以上一段落的 bootstrap.scss 會被轉成 css)，Bootstrap 主要的樣式也都是在這隻檔案做設定。 以色彩來說，檔案裡面可以看到以下的設定，開發者可以修改以下變數，在編譯時自然會套用到所有的模組上。 123456$brand-primary: #0275d8 !default;$brand-success: #5cb85c !default;$brand-info: #5bc0de !default;$brand-warning: #f0ad4e !default;$brand-danger: #d9534f !default;$brand-inverse: $gray-dark !default; _buttons.scss, _tables.scss, _utilities.scss …這個部分就是整個 Bootstrap 的結構重點了，除了以上的 bootstrap.scss、_variables.scss 及稍後提到的 _mixins 資料夾，其他都是屬於 “模組”。 Bootstrap 將模組檔案拆分得相當細，官方的文件也是依據這個架構所呈現： Bootstrap 的說明文件 每個元件拆離以後有以下優點： 元件各自獨立，互不影響 (僅少部分有相依關係 如：buttons, button-group) 易讀性高：開發者可以輕易地找出元件檔案，並且在開發新元件不影響其他元件 開發者可以依據 bootstrap.scss 自行決定載入哪些元件 元件之間影響變小了，全部是由 bootstrap.scss 串接，由 _variables.scss 決定樣式。 元件的設計除了有 Pure CSS 的結構與樣式分離外，Bootstrap 在容器與內容分離也是做得相當徹底，加上 Bootstrap 有大量的元件，彼此之間的組合變化也相當多元，就 Bootstrap 現有的架構下其實我們可以將元件分為兩大類型： 一則是在外的容器，另外則是在內的元件(內容)；像是 grid-system 就是屬於在外的容器，在外側的容器並不會影響內部的元件樣式，按鈕來說他就是屬於在內部的元件，他可以依附在任何的容器內。 以下是簡單的 Bootstrap 容器與元件分類： Bootstrap 就如同前文 OOCSS 所介紹的包含結構與樣式分離、容器與內容分離，在這架構下 Bootstrap 的可用性就會相當高，而且在後續的新增元件也會更為容易。 說句坦白話，拆解 Bootstrap 讓我更能了解 OOCSS。 _mixins 資料夾_mixins 資料夾是元件的運算函式，在大部分的情況下不需要做調整，只要修改 _variables.scss，就能運算出新的樣式表，本篇就不細說了。 結語一般來說閱讀 Bootstrap 的結構方法如下： 找出 bootstrap.scss (了解整體架構) 找出變數檔案 _variables.scss 尋找、閱讀 各元件 了解整體架構後，如果需要自行修改或自幹(?)也會相對容易很多。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 7 - CSS 框架架構參考 PURE CSS","slug":"framework-pure-css","date":"2016-12-06T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/07/framework-pure-css/","link":"","permalink":"https://wcc723.github.io/css/2016/12/07/framework-pure-css/","excerpt":"在瞭解完 OOCSS 後，可以看看主流框架是不是有帶入其中之概念，接下來會介紹兩篇 PureCSS 與 Bootstrap，這兩者的簡單架構概念讓大家參考參考。 Pure CSS 算是很老牌的 CSS 框架，到目前使用者已少了許多，但架構到現在都很是非常直得學習，不需倚靠太多的工具，就能夠將 CSS 可用性發揮到最高，如果有朋友說要參考 CSS 的架構，相當值得學習的就是 PureCSS 及 Bootstrap。","text":"在瞭解完 OOCSS 後，可以看看主流框架是不是有帶入其中之概念，接下來會介紹兩篇 PureCSS 與 Bootstrap，這兩者的簡單架構概念讓大家參考參考。 Pure CSS 算是很老牌的 CSS 框架，到目前使用者已少了許多，但架構到現在都很是非常直得學習，不需倚靠太多的工具，就能夠將 CSS 可用性發揮到最高，如果有朋友說要參考 CSS 的架構，相當值得學習的就是 PureCSS 及 Bootstrap。 架構簡介Pure CSS 分為以下模組，每個模組都是獨立的 CSS 檔案，並沒有透過 Sass 或 Less 進行編譯，所以可以依據自己需求載入需要的模組。 Base Buttons Forms (Responsive) Forms (Non-Responsive) Grids (Responsive) Menus (Responsive) Menus (Non-Responsive) Tables 除此之外，他只有透過 grunt 這個工具將檔案串接在一起，並沒有做額外的編譯；如果需要做修改，由於沒有太複雜的編譯流程，對不熟悉編譯工具的開發者來說也是相當容易的。 另外還有 COMBO 版本，是已經合併以上全部的模組，官方有提供兩種 COMBO，分為有 RWD 、無 RWD 兩個版本。 樣式架構Pure CSS 的樣式架構是我最喜歡的部份，他用相當精簡的 CSS Code 來呈現一個模組，到底有多神就使用 Button 模組來做介紹。 Button 原始碼連結：https://unpkg.com/purecss@0.6.0/build/buttons.css 這是非壓縮版的原始碼，全部的按鈕行數不到 100 行(不壓縮，且包含註解)，在這些行數下也包含了不同的狀態。 一般載入的狀態： See the Pen Pure CSS Button by Wcc723 (@Wcc723) on CodePen. 範例中，我們在載入 CSS 後，只要參考文件就能夠將樣式呈現出來，所以就以上的兩個按鈕，只要各一行 HTML 就能解決了。 12&lt;a class=\"pure-button\" href=\"#\"&gt;A Pure Button&lt;/a&gt;&lt;a class=\"pure-button pure-button-primary\" href=\"#\"&gt;A Primary Button&lt;/a&gt; Pure CSS 自訂樣式 - Pure CSS 巧妙地使用 透明度 在處理元件的樣式，就以按鈕來說可以用以下方法來調整： 複寫原有的樣式 設定元件色彩，透過原有的透明度樣式來呈現按鈕狀態 See the Pen Pure CSS Button by Wcc723 (@Wcc723) on CodePen. Pure CSS 修改樣式、新增樣式的範例如上，每個樣式都僅需一個 CSS selector 就能搞定，而且不需要編譯。 1234567891011/* 複寫樣式 */.pure-button &#123; border-radius: 4px; box-shadow: 0 1px 2px rgba(0, 0, 0, 0.16);&#125;/* 設定元件色彩來自定義樣式 */.pure-button-accent &#123; color: white; background: #FF5E45;&#125; 這種透過透明度的方法在切換樣式能將 CSS 所需的程式碼降低非常多，而這也是 結構與樣式 分離的最佳案例。在最新版的 Bootstrap v4 中的 Navbar 也有用相同的技巧在切換色彩，有興趣的朋友可以參考以下連結。 Bootstrap Navbar color theme: http://v4-alpha.getbootstrap.com/components/navbar/#color-schemes 結語在現在 Sass、PostCSS 盛行的情況下，在製作多種樣式時都是透過工具去做運算，Pure CSS 僅提供 CSS 並運用 CSS 的特性讓其他開發者也能輕易自訂樣式，這也是我喜歡 Pure CSS 的部分。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 6 - CSS 的元件狀態","slug":"css-status","date":"2016-12-05T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/06/css-status/","link":"","permalink":"https://wcc723.github.io/css/2016/12/06/css-status/","excerpt":"CSS 元件狀態重點可以分為兩部分，一個是原生的 CSS 偽類(Pseudo-classes)，另一則是配合 Javascript 所提供的 Class，在這部分相當在元件的初始時，就同時完成兩個部分。","text":"CSS 元件狀態重點可以分為兩部分，一個是原生的 CSS 偽類(Pseudo-classes)，另一則是配合 Javascript 所提供的 Class，在這部分相當在元件的初始時，就同時完成兩個部分。 元件狀態的套用方式狀態再套用時，有兩種常見的手法，一則是使用 CSS 偽類(Pseudo-classes)，另一則是提供 Class 供 javascript 作切換。 一般在撰寫 CSS 時，就會將偽類規劃進去，最常見的就是 連結，其常用的偽類有： :active 滑鼠按下的樣式 :focus 鍵盤聚焦的樣式 :hover 滑鼠滑過的樣式 :link 還沒被訪問的樣式 :visited 被訪問過的樣式 假設是 a:hover 有製作以下的狀態，那麼用戶在滑鼠滑過後就能改變色彩。 123a:hover &#123; color: blue;&#125; 但有時在呈現狀態時，並不是需要與用戶互動，而是回饋一個狀態讓用戶理解目前發生了什麼事。 如按鈕要表達已經被按下了，用戶不需要再按下一次，那麼我們可以用 .active 來說明這個狀態。或者用戶並沒有滿足按下按鈕的條件，我們可以用 .disabled 來呈現。 123456.btn:active, .btn.active &#123; color: blue;&#125;.btn:disabled, .disabled &#123; cursor: not-allowed;&#125; 一次做足元件狀態元件狀態是初學網頁設計師經常忽略的內容，就以 input 來說就有以下常見的狀態 一般狀態 focus 用戶選取的狀態 disabled 無法選取的狀態 feedback 輸入錯誤或正確的回饋狀態 如果在設計時，僅有提供 input 的一般狀態及 Focus 的狀態，那麼在開發時就會因為元素狀態不足，需要不斷的增加，如果增加時又沒有依據原有邏輯新增，就容易讓程式碼變得難以維護。 12345678910111213/* 125 行 */.input &#123; /* input style*/&#125;.input:focus &#123; border-color: blue;&#125;/* 800 行 */.input:disabled, .input.disabled&#123; cursor: not-allowed;&#125; 所以建議在一開始時，就將常見的狀態先一次補足： 12345678910111213141516171819/* 125 行 */.input &#123; /* input style*/&#125;.input:focus &#123; border-color: blue;&#125;.input:disabled, .input.disabled &#123; cursor: not-allowed;&#125;/* success feedback */.input.success &#123; border-color: green;&#125;/* error feedback */.input.success &#123; border-color: red;&#125; 結論 在寫偽類的時候別浪費，順便補上 .class 的樣式 在一開始寫的時候請順便規劃各種狀態","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 5 - CSS 的命名技巧","slug":"css-naming","date":"2016-12-04T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/05/css-naming/","link":"","permalink":"https://wcc723.github.io/css/2016/12/05/css-naming/","excerpt":"程式語言的命名一直是個麻煩課題，除了要有良好邏輯外，還必須有大量的英文詞彙能力。CSS 雖然不需要有太深的邏輯，但由於上手容易，團隊合作的命名就容易被其他小夥伴所影響。 本篇透過圖文及小故事來介紹 CSS 命名概念，讓你與小夥伴的命名協作能力更順暢。","text":"程式語言的命名一直是個麻煩課題，除了要有良好邏輯外，還必須有大量的英文詞彙能力。CSS 雖然不需要有太深的邏輯，但由於上手容易，團隊合作的命名就容易被其他小夥伴所影響。 本篇透過圖文及小故事來介紹 CSS 命名概念，讓你與小夥伴的命名協作能力更順暢。 除了不需要維護的網站以外， CSS 命名都是前端工程師的痛，因為很容易踩到先前所寫的坑，久而久之就會發生權重的問題。 案例：12345678910111213141516171819/* 100 行 */.tab &#123; color: red;&#125;/* 300 行 */a.tab &#123; color: blue;&#125;/* 600 行 */.card a.tab &#123; color: green;&#125;/* 1200 行 Joe 1203 修正錯誤 */a.tab &#123; color: red !important;&#125; 相信在維護過去的專案時，不少人有遇過這樣的經驗，當下的網站樣式是正常的，新的需求要調整目前的樣式，前一個離職同事用巧妙的手法安裝了未爆彈，為了證明你的實力只好再多一層 !important。 前人的債我們只能補，新的路我們可以自己鋪，除了前面所提到的兩個 CSS 分離方法，這邊要介紹好的 CSS 命名，讓 Class 複用性更高，這邊介紹幾個基本原則： 抽象化命名 (避免使用具體的色彩、單位尺寸等) 用元件形體命名 (不使用頁面上的功能做命名) 抽象化命名一般來說，品牌會定義色彩，網站也是一樣會定義色彩，比如說網站會定義主要色、次要色、強調色、警告色等。 主要色：藍色 強調色：紅色 網站上可以依據這樣的色彩直接命名，就如同下方這個範例，將色彩直接作為名稱 12345678/* 避免 */.text-blue&#123; color: blue;&#125;.text-red &#123; color: red;&#125; 但是，好景不常，設計師和老闆總是能夠合力起來做 “微調”，先前的藍色想改成綠色，紅色想改成橘色，畢竟這樣比較有質感。為了避免新人不知道紅為什麼是橘，還要跟他說一篇故事來介紹，其實我們可以將名稱做以下的調整。 12345678/* 建議 */.text-primary &#123; color: blue;&#125;.text-accent &#123; color: red;&#125; 除此之外，還有許多會使用單位尺寸做名稱，如： 12345678910/* 避免 */.m-t-50 &#123; margin-top: 50px;&#125;.m-t-30 &#123; margin-top: 30px;&#125;.m-t-10 &#123; margin-top: 10px;&#125; 為了避免發生 “50px 太大了，改 44px 可以嗎？”。 (小劇場等以下略)所以也是避免直接用數值來命名，我們可以用抽象畫的尺寸來做調整。 12345678910/* 建議 */.m-t-l &#123; margin-top: 50px;&#125;.m-t-m &#123; margin-top: 30px;&#125;.m-t-s &#123; margin-top: 10px;&#125; 如果這時候他需要在兩個數值中間再插入一個值呢？我也不知道，因為這真的太欠揍了。 用元件形體命名一般來說命名都會很直白，像是 左側的選單 就叫做 left-menu，產品列表稱為 .product-list。 這樣的以後選單只能放在左邊，如果放到右邊去又是一個小劇場了；產品列表也是相同道理，誰知道哪天會不會放產品以外的內容呢!? 這邊用一個範例來介紹命名的方法： 這是一個排版的範例，左側是選單，右側比較大的空間是主要文章，一開始可能直接會用他所在的位置或功能性來命名，如 .menu、.article。 實際上呢，側面欄不會只有放選單；右方的主要內容可能也不是文章，可能會有產品、廣告、文件等其他內容，所以我們可以將命名做一些調整，用頁面上所在的位置命名，例如側面叫做 .side，主要內容區域叫做 .content 。 接下來，下方增加了 .ad 的區塊，寬度佔 1/3 和 .side 相同，由於是後來新增的區塊，直接稱為 .side 不太適合，所以就直接命名為 .ad。 這個時候，如果直接用 12欄的命名方法來命名，這樣網格的可用性就會變得更高。 所以我們在命名的時候，如果只能用在當下，沒有思考到未來的發展就可能會有大量相同的模組，或者是命名與實際運用的不搭，在這邊提供幾個命名概念給大家參考： 元件的外型命名 避免限制性的命名：.product-list 建議：.list 色彩的命名 避免直接用色名：.text-blue 建議：.text-primary Layout 的命名 避免直接用位置命名：.left-menu 建議：col-4 這篇嘗試使用小劇場的方式來介紹 CSS，自我感覺良好，但需要花雙倍的時間啊啊啊啊～。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 4 - OOCSS 容器與內容分離 (最佳實踐)","slug":"oocss-three","date":"2016-12-03T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/04/oocss-three/","link":"","permalink":"https://wcc723.github.io/css/2016/12/04/oocss-three/","excerpt":"結構與樣式分離，對於網頁的樣式設計是一種解放，所有元件的樣式組合搭配及擴增變得更自由。 這篇要介紹的是容器與內容分離，簡單來說我們可以把元件分為兩大類型： 容器型元件：如 grid、card、form 內容型元件：如 button、input、progress-bar 而不同類型的元件設計上應當分離，避免混寫限制元件的搭配。","text":"結構與樣式分離，對於網頁的樣式設計是一種解放，所有元件的樣式組合搭配及擴增變得更自由。 這篇要介紹的是容器與內容分離，簡單來說我們可以把元件分為兩大類型： 容器型元件：如 grid、card、form 內容型元件：如 button、input、progress-bar 而不同類型的元件設計上應當分離，避免混寫限制元件的搭配。 容器：白話文來說是盛裝物品的器具，在這邊我們可以思考成可以裝其它元素的外元件。內容：這裡解釋在容器內的元素。 以下圖來說，我們就區分為三個模組 容器 A 與 元件 A：這兩者是一體的，元件 A 無法獨自在 容器 A 以外的環境單獨出現，他是 容器 A 的繼承。 容器 B：這是一個單獨的容器，沒有額外的設定 元件 B：這是一個單獨的元件(內容)，可以在任何容器下。 在這個範例下，我們可以了解到 元件 B 不受到任何限制，可以自由的組裝在其他容器下，這也是 OOCSS 提到的元件就像是樂高一樣，可以依據任何需求做組裝，元件 B 正好符合這個概念。 Bootstrap 的容器與內容Bootstrap 是相當好的案例可以來說明容器與內容。以下圖來說按鈕與頁籤都是屬於 內容，而卡片是屬於容器，在 Bootstrap 的設計中都是屬於個別的元件，這些元件不會互相干擾，而且可以依據需求去組合。 接下來這張範例圖就是將按鈕、頁籤放到卡片這個容器內。 所以在設計元素的時候，如果是用以下的方式繼承就會限定元件的可用性，就以 OOCSS 的概念是需要避免這樣的設計，盡可能不要讓元件被限制在特定的容器下。 123456789101112131415/* 盡量不要這麼做 */.card &#123; …&#125;.card .btn &#123; …&#125;/* 好的作法 */.card &#123; …&#125;.btn &#123; …&#125; 案例上一回我們用結構與樣式分離的概念製作出一組按鈕，接下來在製作另一組模組 card ，按鈕模組除了可以獨立使用外，在 Card 內也是可正常運用。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. 1234567891011121314151617181920212223/* card */.card &#123; padding: 2rem; border: 1px solid #ccc; border-radius: 2px; box-shadow: 3px 3px 3px rgba(black, .16); .card-head &#123; font-size: 2rem; margin-bottom: 1rem; &#125; .card-body ul &#123; margin-left: 1em; margin-right: 1em; list-style: disc; &#125; .card-body img &#123; max-width: 100%; &#125; .card-footer &#123; margin-top: 15px; text-align: right; &#125;&#125; 不過其中 .card-body ul 這個 ul 就被限制住了，只有卡片內才能這樣顯示，此時就要思考是不是只有卡片內才需要這樣的 ul 顯示？或者將它拉出來更好？ 就當下這個設計，我們其實可以略作調整，將 ul 及 img 拉出來製作，然元件的容器與內容分離。 這樣就學會了兩大 OOCSS 的觀念，而這兩個觀念下還有些細節可以注意，等到看完這幾天的介紹，就能掌握整個 CSS 模組的核心概念。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 3 - OOCSS 結構與樣式、容器與內容(實際範例)","slug":"oocss-two","date":"2016-12-02T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/03/oocss-two/","link":"","permalink":"https://wcc723.github.io/css/2016/12/03/oocss-two/","excerpt":"結構與樣式在執行的概念上就是這樣的白話，目標即是將這兩者分離，上一篇我們用建築物的結構與外觀樣式做分離，再依不同的需求去做組合。 CSS 上也是相同的道理，比如說我們可以做這樣的分類： 結構：margin、padding、display、vertical-align 樣式： 色彩樣式：color、background-color、border-color 尺寸樣式：font-size、height","text":"結構與樣式在執行的概念上就是這樣的白話，目標即是將這兩者分離，上一篇我們用建築物的結構與外觀樣式做分離，再依不同的需求去做組合。 CSS 上也是相同的道理，比如說我們可以做這樣的分類： 結構：margin、padding、display、vertical-align 樣式： 色彩樣式：color、background-color、border-color 尺寸樣式：font-size、height 案例說明我們透過一個簡單的小故事作為範例，讓大家了解 OOCSS 在實作上是如何運作。 Step1我們接到一個工作要設計一組按鈕的 CSS，由於這組按鈕是作為銷售頁面的用途，在設計上我們有以下規劃： 按鈕有三個，依據顯眼程度的順序是 購買、註冊、說明。 網站的主色是藍色，強調色彩是紅色 (這邊不特別定義色碼)。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. 就以需求來說，我們可以依據需求做出三個按鈕，名稱分別命名為 .button-resgister、.button-purchase、.button-info，顏色也分別為 藍色、紅色、白色。 就以這個範例來說，我刻意很明確地將相同的部分寫在上方，其實這也就是結構與樣式混合的範例。 1234567891011121314151617181920.button-resgister &#123; /* 重複的部分 */ display: inline-block; padding: .375rem 1rem; font-size: 1rem; font-weight: 400; line-height: 1.5; text-align: center; white-space: nowrap; vertical-align: middle; cursor: pointer; user-select: none; border: 1px solid transparent; border-radius: .25rem; /* 樣式 */ color: #fff; background-color: #0275d8; border-color: #0275d8;&#125; 結構與樣式的混合的結果，就是有大量重複的程式碼，這個案例中我們可以先將重複的程式碼抓出來，來達到結構與樣式分離。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. Step2由於需要更多的按鈕樣式，目前提供的三個按鈕並不足夠，在規劃上需要做以下調整： 按鈕有三個，依據顯眼程度的順序是 購買(主色)、註冊(強調色)、說明。 網站的主色是藍色，強調色彩是紅色 (這邊不特別定義色碼)。 說明按鈕還要做登入的功能，註冊按鈕還要兼著做訂閱電子報。 所以命名的部分，建議不要直接使用按鈕的功能性直接命名，而是可以按鈕的樣式特性來命名，比如說： 結構：btn 色彩 主次要：primary, accent 依據這樣的調整，樣式的設計就不會被原本的功能限制，使用更為靈活。 See the Pen OOCSS (Demo 1) by Wcc723 (@Wcc723) on CodePen. 12345678910111213141516171819202122232425262728293031.btn &#123; display: inline-block; padding: .375rem 1rem; font-size: 1rem; font-weight: 400; line-height: 1.5; text-align: center; white-space: nowrap; vertical-align: middle; cursor: pointer; user-select: none; border: 1px solid transparent; border-radius: .25rem;&#125;.btn-primary &#123; color: #fff; background-color: #0275d8; border-color: #0275d8;&#125;.btn-accent &#123; color: #fff; background-color: #d9534f; border-color: #d9534f;&#125;.btn-secondary &#123; color: #373a3c; background-color: #fff; border-color: #ccc;&#125; 最後，按鈕的結構就會有很大的調整，結構與樣式分離後，面對更多的挑戰(? 時可以減少修改的幅度，如果要再調整按鈕大小，相信大家也能夠用相同的概念去調整。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 2 - OOCSS 結構與樣式、容器與內容","slug":"oocss-one","date":"2016-12-01T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/02/oocss-one/","link":"","permalink":"https://wcc723.github.io/css/2016/12/02/oocss-one/","excerpt":"以前剛進入這行，掌握了 CSS2 的大部分關鍵之後，對於製作網頁非常有成就感，因為當時寫一個站不需要太多時間(整個網站約落在 800 ~ 1200 行 CSS)，而且 CSS2 語法數量也不多，查找時間也不需要太長，自然覺得世界美好(!?) 這樣快速入門時會有一些難以發現的問題，網站是否易於維護、CSS 可複用性是否夠高、命名是否一致，當時也會思考這些問題，但在沒有統整性的觀念引導下，許多嘗試都是不斷的在碰壁。","text":"以前剛進入這行，掌握了 CSS2 的大部分關鍵之後，對於製作網頁非常有成就感，因為當時寫一個站不需要太多時間(整個網站約落在 800 ~ 1200 行 CSS)，而且 CSS2 語法數量也不多，查找時間也不需要太長，自然覺得世界美好(!?) 這樣快速入門時會有一些難以發現的問題，網站是否易於維護、CSS 可複用性是否夠高、命名是否一致，當時也會思考這些問題，但在沒有統整性的觀念引導下，許多嘗試都是不斷的在碰壁。 OOCSSOOCSS 是 CSS 的架構方法，在這基本原則下 CSS 具有以下特點： 結構與樣式的分離 內容與容器的分離 在這兩個特點下，大大的強化 CSS 的可複用性 與 CSS 的擴展能力，讓原本的 CSS 從 1000 行到 5000 行都不會難以維護，以下就用建築的樣式來介紹什麼是 結構與樣式 及 容器與內容 吧。 結構與樣式原本的樣式表，就像是拿著油漆桶幫每個物件塗上色彩，在 OOCSS 的概念裡面，我們可以用樂高的觀念來思考，我們先準備好很多的模組，在需要的地方再組合。 就以下面的範例來說，我們可以將建築物模型分為 “建築物結構”、”建築物樣式”。 圖片來源：http://www.iconninja.com/building-icon-696433 在需要使用的地方，我們再將者兩個部分接在一起，結構與樣式接合以後，就會成為一棟建築物。 這樣的用意，就是可以將樣式套用至不同的結構上，結構本身的可利用性也提高了許多。是想，如果我們要建構三種不同樣式的建築物，如果都從結構開始建置，是不是麻煩許多!?但如果只要更新樣式，結構不更新，就不需要重新打造，這樣就是結構與樣式分離的概念。 到目前為止，我們其實已經學會了 OOCSS 的其中一大觀念 “結構與樣式”，而其實 OOCSS 就是以下兩個大概念而已喔： 結構與樣式 容器與內容 容器與內容另一個觀念，我們一樣用建築物模型來說明，假設建築物是外容器、窗戶是內容，那麼作為內容的窗戶應該要能裝在各個建築上。 以下是作為容器的建築物 以下是作為內容的外容器，這外容器的重點在於不限制只能安裝在特定的建築物上。 接下來窗戶裝在建築物上了，然而這兩個建築上的窗戶應當能夠做交換 接下來，我們還能夠交換兩邊的窗戶。 在這個設計下，作為內容的物件不會被限制只能在哪個外容器下。 除了結構與樣式分離外，身為外容器的物件與內容的物件也應當需要分離，避免元件只能在原有的容器上使用；容器與內容分離的情況下，元件再重新組裝時能夠更為容易，可擴增元件的再使用率。 但這些概念如果套用在網頁該如何解釋呢？別著急～，我們在後續的章節會用實際的範例來說明。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"oocss","slug":"oocss","permalink":"https://wcc723.github.io/tags/oocss/"}]},{"title":"鐵人賽 1 - 前言，CSS 最重要的事？","slug":"css-most-important","date":"2016-11-30T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/12/01/css-most-important/","link":"","permalink":"https://wcc723.github.io/css/2016/12/01/css-most-important/","excerpt":"鐵人賽系列文又開始囉，這次的主題是 CSS 你覺得 CSS 最重要的是什麼勒？ 如果換個方式思考，寫 CSS 最 痛苦 的事情是什麼呢？ 載入速度緩慢 遇到不會解的問題 接別人寫的 CSS 接別人寫的 CSS，然後還看不懂在寫什麼 兩個月後維護自己寫的 CSS ，然後還看不懂在寫什麼 稍有資歷的工程師，其實最後幾點也遇過不少次 🙈。","text":"鐵人賽系列文又開始囉，這次的主題是 CSS 你覺得 CSS 最重要的是什麼勒？ 如果換個方式思考，寫 CSS 最 痛苦 的事情是什麼呢？ 載入速度緩慢 遇到不會解的問題 接別人寫的 CSS 接別人寫的 CSS，然後還看不懂在寫什麼 兩個月後維護自己寫的 CSS ，然後還看不懂在寫什麼 稍有資歷的工程師，其實最後幾點也遇過不少次 🙈。 很多時候產品有時限性的，在撰寫程式碼的時候就不會那麼的要求，尤其是 CSS 濫用優先值、important 也是很常見的事情，接下來就會遇到： 奇怪，樣式怎麼寫不上去 頁面上的色彩與整體設計不相同 啃，字體怎麼無法調整 不同的框架相互影響 這麼低能的解法絕對不是我寫的 身為一名前端工程師，寫好 CSS 也是必須的，還記得以前在寫 CSS 的時候，為了寫出好的 CSS 經歷過很多階段的磨練，像是苦練基本功、學好 sass、自幹框架、熟悉各種架構、配合各種環境等，到現在已經衍伸出屬於自己的心法，接下來會介紹業界常用的技巧，來解決所遇到的問題：包含避免捅自己的方法。 一、CSS 架構說到看不懂自己寫什麼，通常是沒有規矩在寫 CSS，這個篇幅會放在最前方，而整個架構概念會貫通各段文章。 二、開發環境身為一名前端工程師，在自己的領土上插旗也是很重要的，無論搭配任何的後端語言，最好對於自己工作範疇有一定的掌握度，所以透過一些工具來打理良好開發環境是很重要的，也會開始了解怎麼建置 Sass 環境。 三、Sass 開發心法這邊不會介紹到 Sass 的基礎語法，而是透過先前的 CSS 架構來了解 Sass 開發中的坑，並且讓 Sass 的可用性更加翻倍！ 四、實戰架構在了解整個技術基礎概念後，還會分享我在實作上的方法，如果後面篇幅許可，再加入更多框架運用，如： Bootstrap 4 !? 在整個觀念釐清以後，除了踩到自己腳外的問題也會一一有了答案，比如說效能問題，在良好的架構下，我們可以簡單地抽離不必要的 CSS 模組，並且不會對其他的畫面產生影響。 驚險刺激的鐵人賽又開始囉，這次能不能順利達成呢!?","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Yarn - Node.js 的套件管理工具","slug":"yarn","date":"2016-10-17T16:00:00.000Z","updated":"2016-10-18T07:07:19.000Z","comments":true,"path":"nodejs/2016/10/18/yarn/","link":"","permalink":"https://wcc723.github.io/nodejs/2016/10/18/yarn/","excerpt":"NPM 每次在安裝的時候，都會安裝很久很久，就算是好幾個類似的專案，每次在執行 npm install 時都需要花費大量的時間，而且在網路不穩定的環境下還可能造成中斷。Yarn 可以讓這些問題好轉些，在實測時，安裝一次以上的套件時間將只需要原本的 20% 時間(甚至更短)，將大幅減少逛 FB 的機會。","text":"NPM 每次在安裝的時候，都會安裝很久很久，就算是好幾個類似的專案，每次在執行 npm install 時都需要花費大量的時間，而且在網路不穩定的環境下還可能造成中斷。Yarn 可以讓這些問題好轉些，在實測時，安裝一次以上的套件時間將只需要原本的 20% 時間(甚至更短)，將大幅減少逛 FB 的機會。 安裝 YarnMac 用戶需要先安裝 Homebrew，安裝方法可以參考 http://brew.sh/，這邊我也順便更新了 homebrew ，目前版本如下。 接下來再安裝的時候跳出一個錯誤 (brew install yarn) 這貌似新版的 OS Sierra 的問題，有兩個方法，一種是更新 Xcode，另一種是刪除 Xcode 原本是想採用更新 Xcode 的方式，但是 Xcode 壞了打不開(-.-)，另外就是下載的大小佔 4.4 G…，無奈的情況下，只好把 Xcode 丟進垃圾桶了。 好了，在下一次 brew install yarn，將會開使正長的安裝 Yarn (我以為 Xcode 是必備的勒…)。 下載完後檢查版本 yarn --version 。 10.15.1 使用 Yarn這邊使用兩個專案來測試，測試 安裝時間 以及所需的 磁碟空間。 專案一在當下的資料夾中，我先把原始的 node_modules (28.1 mb)移除，以下是 package.json 的部分內容。 123456789&quot;devDependencies&quot;: &#123; &quot;autoprefixer&quot;: &quot;^6.5.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-autoprefixer&quot;: &quot;^3.1.1&quot;, &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, &quot;gulp-postcss&quot;: &quot;^6.2.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot;&#125; npm install 版本所佔的磁碟空間大小 輸入 yarn install 就會開始安裝，安裝時會先檢查本地端有沒有，如果沒有才會線上拉。 第一次安裝 37.03秒，第二次安裝 6.9秒。 yarn install 版本所佔的磁碟空間大小 專案二好像是一個 express 範例…，在插入一些 gulp 教學。 1234567891011121314151617&quot;dependencies&quot;: &#123; &quot;express&quot;: &quot;~4.10.6&quot;, &quot;body-parser&quot;: &quot;~1.10.1&quot;, &quot;cookie-parser&quot;: &quot;~1.3.3&quot;, &quot;morgan&quot;: &quot;~1.5.1&quot;, &quot;serve-favicon&quot;: &quot;~2.2.0&quot;, &quot;debug&quot;: &quot;~2.1.1&quot;, &quot;jade&quot;: &quot;~1.8.2&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;gulp-gh-pages&quot;: &quot;^0.5.4&quot;, &quot;gulp-webserver&quot;: &quot;^0.9.1&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-concat&quot;: &quot;^2.6.0&quot;, &quot;gulp-sass&quot;: &quot;^2.3.2&quot;, &quot;gulp-uglify&quot;: &quot;^2.0.0&quot; &#125; 使用 npm install 安裝時，所佔的磁碟空間為 38mb。 用 yarn 所佔的磁碟空間為 26.7mb，且第一次安裝時間約 27 秒，第二次 約 8 秒。 加速安裝的秘密，就在於根目錄下的 .yarn-cache 資料夾，這個資料夾會將每次安裝的套件先安裝一份到這來，往後如果需要相同套件，就會從這邊拉。 NPM 與 Yarn 指令比較大多數的指令用法和原本並無差異，只要將 npm 換成 yarn 即可，特別要注意的是 npm install [package] 安裝少數套件在 yarn 是不支援的，yarn 的套件都是必須儲存 (--save)。 NPM Yarn 說明 npm install yarn install - npm install [package] X 不支援直接安裝套件 npm install --save [package] yarn add [paakage] 僅是將 --save 改成 add npm install --save-dev [package] yarn add [paakage] --dev npm install --global [package] yarn global add [package] 這段還沒測過 global 的差異 npm uninstall [package] x npm uninstall --save [package] yarn remove [package] rm -rf node_modules && npm install yarn upgrade 移除再安裝 變 直接升級套件 更多的語法：https://yarnpkg.com/en/docs/migrating-from-npm 目前 Yarn 個人還沒完全測試過，但就一開始的體驗確實不錯，入門也不太需要太多改變 (除了砍掉了 Xcode 而已!?)，算是一個值得入手的好工具。 開發團隊包含了 Facebook、Google 等，而且相容目前的 NPM 註冊表，有興趣的可以放心使用 http://www.ithome.com.tw/news/108974。","categories":[{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/categories/nodejs/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"},{"name":"npm","slug":"npm","permalink":"https://wcc723.github.io/tags/npm/"}]},{"title":"CSS 失控的 Margin top","slug":"css-margin-collapsing","date":"2016-06-07T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/06/08/css-margin-collapsing/","link":"","permalink":"https://wcc723.github.io/css/2016/06/08/css-margin-collapsing/","excerpt":"失控的 margin-top 是指在使用 margin 時常出現的問題，內元素的 margin 被外層所吸收，導致無法正確的顯示，這我們稱為 Collapsing margins，本篇來教大家怎麼應對這個問題。","text":"失控的 margin-top 是指在使用 margin 時常出現的問題，內元素的 margin 被外層所吸收，導致無法正確的顯示，這我們稱為 Collapsing margins，本篇來教大家怎麼應對這個問題。 情境在製作 Banner 的時候，通常需要一個 Logo 在畫面的左上，於是乎我們就會準備一個 div 把美美的 logo 往裡面塞。 如圖所示，我們的 Logo 還希望離上方有些為的距離，依邏輯來說物件離邊緣要有距離，我們就會幫他補上 margin，於是乎就會出現如下的問題。 See the Pen Collapsing margins (for blog) by Wcc723 (@Wcc723) on CodePen. 仔細看看上面所發生的問題，內元素的 margin 沒有起了作用，而是被外層所吸收。 失控的 Margin top 在遇到這個問題時，如果不熟的情況下就會說：「Bug 啦！」，通常只能用各種拋開羞恥心其它的方式去解決這個問題，但只要拿抓住發生的原因，就能輕易的去克服它。 這個問題在 w3c 有提到這問題稱為「Collapsing margins」，我將這部分縮減為以下幾點： 內外層均為 “塊狀” 元素。 外層塊狀元素沒有 border、padding、overflow。 內層第一個塊狀元素(空元素不算)，不包含 float、absolute。 所以如果要避開發生這個問題，就是避免存在以上這些問題，比如說不使用塊狀元素、外層加入padding、內層加入 float 等等，以下就列出一些解決方案。 See the Pen Collapsing margins (resolve for blog) by Wcc723 (@Wcc723) on CodePen. 這也是我們在與學員之間的問答中常遇到的，這次找個機會寫個文章跟大家分享分享。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass 基礎教學 - CSS 讀書會","slug":"css-clud","date":"2016-05-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/05/26/css-clud/","link":"","permalink":"https://wcc723.github.io/css/2016/05/26/css-clud/","excerpt":"先前的讀書會難度都有點過高，所以有時候聽的人會有點母煞煞，所以這次決定先介紹基礎的部分，以後再來介紹延伸的內容。","text":"先前的讀書會難度都有點過高，所以有時候聽的人會有點母煞煞，所以這次決定先介紹基礎的部分，以後再來介紹延伸的內容。 活動網址KKtix 活動網址：http://gonsakon-7655f2.kktix.cc/events/css-book-club-003-55ae43 這次活動在高雄醫學大學，高醫本身是教育單位，有許多資源很適合辦這樣的活動，像是強力 Wifi、強力投影機、強力空調…，缺點是這個空間在地下二樓，要從學校那麼多大樓中找到這地下室還真的頗有難度。 活動簡報 專業前端 都如何管理 Sass 基礎教學 - 高雄前端社群(CSS 讀書會) from Chih-cheng Wang 簡報連結：http://www.slideshare.net/chihchengwang3/03-sass 這次的筆記也換到了 HackMD ，感謝大家一起來協作筆記。 共筆文件：https://hackmd.io/EwDgbAJghmCcIFoAsKDGySoOwIEZIFYAzBYWIgpMJWKARjoGYg== 這次的活動自認為講授的內容進步了很多，時間上我是控制在 1hr，主要原因是如果講滿了 1.5hr，會缺乏許多和到場的人互動，所以時間上就比以往在短一些。 下次的活動下次的活動預計訂在六月中旬以後，我們會拉更多的人入坑，讓 CSS 讀書會的豐富度提升。而直播也會視入坑的開發者是否願意，主要還是供到場的朋友吸收好的內容。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"workshop","slug":"workshop","permalink":"https://wcc723.github.io/tags/workshop/"}]},{"title":"讓使用者愛上你的表單，提升客戶轉換率","slug":"best-choose-input-type","date":"2016-04-21T16:00:00.000Z","updated":"2016-10-13T06:31:39.000Z","comments":true,"path":"study/2016/04/22/best-choose-input-type/","link":"","permalink":"https://wcc723.github.io/study/2016/04/22/best-choose-input-type/","excerpt":"不知道你們在使用手機填寫表單的時候，會發現這樣的狀況，填寫地址跳出中文、填寫 E-mail 表單跳出中文、填寫電話也是跳出中文，甚至是日期欄位也是跳出中文，這樣其實對於使用者來說是很不便利的。如果這個狀況發生在結帳前，很高的機率導致使用者失去耐心，甚至離開網站，如果在表單上多花點小心思，就可以讓使用者快速地填完表單，讓雙方都滿意這次的交易。","text":"不知道你們在使用手機填寫表單的時候，會發現這樣的狀況，填寫地址跳出中文、填寫 E-mail 表單跳出中文、填寫電話也是跳出中文，甚至是日期欄位也是跳出中文，這樣其實對於使用者來說是很不便利的。如果這個狀況發生在結帳前，很高的機率導致使用者失去耐心，甚至離開網站，如果在表單上多花點小心思，就可以讓使用者快速地填完表單，讓雙方都滿意這次的交易。 如這一個範例來說，當下所點擊的是電話號碼這個欄位，但跳出的是英文鍵盤，必須在切換後才能顯示數字鍵，好在這個表單的欄位並不多，只要切換一兩次就填完表單了。但如果這個狀況發生在電子商務類型的網站上後果可不僅於此，每個不順暢的流程都會造成用戶的猶豫、不耐煩，在大量的表單需要填寫的情況下，就可能使用戶離開。 為了避免用戶不愉快造成訂單的遺失，正確的表單類型是很重要的，所以在不同需求的欄位，就必須給予正確的類型，如以下範例來說，欄位中的需求是填入電話號碼，將 &lt;input&gt; 內的 type=&quot;text&quot; 修改成 type=&quot;tel&quot;，在行動版所跳出的迷你鍵盤也就會以數字的格式呈現，並且是符合電話撥打的鍵盤。 電話號碼僅是其中一項，電子郵件、密碼、日期、時間都有相對應的類型，在不同格式下所顯示的螢幕小鍵盤都不同，大家不妨透過以下範例試試看在您的手機會提供什麼樣的小鍵盤。 See the Pen http://codepen.io/Wcc723/pen/MyBbex/“&gt;Input (http://codepen.io/Wcc723/pen/MyBbex/) type by Wcc723 (@Wcc723) on CodePen. 如果你是在行動版上觀看此原始碼，可以點選 result 來顯示範例 有發現吧，有些欄位所提供的都是英文小鍵盤，但其實細節卻不大一樣，如果是 E-mail 類型的欄位就會提供 ‘@’，在 Url 類型的欄位則會提供 ‘.com’。 Google 表單類型說明文件至於什麼樣的內容要用什麼樣的輸入類型呢？ Google 提供了一份文件，讓網頁的開發者可以輕鬆的了解什麼樣的類型是最佳的選擇，Google文件：選擇最佳輸入類型 但同時我們也必須注意，並非所有的瀏覽器、手機均支援以上的類型，如 color (顏色類型)就不是所有瀏覽器均支援，在開發時需要經過測試，確認表單的類型是否能提供該網頁最好的瀏覽體驗。 背景圖片來源：https://unsplash.com/photos/VGOiY1gZZYg 歡迎分享 Facebook：https://www.facebook.com/hexschool/ 六角學院網站：http://www.hexschool.com/","categories":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/categories/study/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"轉行工程師必須克服的三大痛點","slug":"engineer-3-point","date":"2016-04-18T16:00:00.000Z","updated":"2016-10-13T06:31:39.000Z","comments":true,"path":"study/2016/04/19/engineer-3-point/","link":"","permalink":"https://wcc723.github.io/study/2016/04/19/engineer-3-point/","excerpt":"本篇是以設計師轉工程師為主要觀點 在研究所那年，我投入大量的時間學程式，由於當時的 Flash 相當火紅，所以決定從 Actionscript 3.0 開始入手，那時也遇到相當多的挫折，印象很深的是在床上看著短短的程式碼 (手打沒問題，重點是我想了解原理，才會在床上看書…)，那段寫著什麼是 “變數”，就現在看來這是很簡單的觀念，但我也是花了好幾天才能理解是什麼意思。 現在有機會從事教育推廣，從與許多設計師想轉行工程師中的對談中，認為有以下三個原因阻擾著設計師，如果可以克服，在學習上會更為順利：","text":"本篇是以設計師轉工程師為主要觀點 在研究所那年，我投入大量的時間學程式，由於當時的 Flash 相當火紅，所以決定從 Actionscript 3.0 開始入手，那時也遇到相當多的挫折，印象很深的是在床上看著短短的程式碼 (手打沒問題，重點是我想了解原理，才會在床上看書…)，那段寫著什麼是 “變數”，就現在看來這是很簡單的觀念，但我也是花了好幾天才能理解是什麼意思。 現在有機會從事教育推廣，從與許多設計師想轉行工程師中的對談中，認為有以下三個原因阻擾著設計師，如果可以克服，在學習上會更為順利： 不知道如何開始隔行如隔山，這畢竟是要進入另一個產業，尤其是程式的領域這麼廣，一開始要投入的也不知是否正確，像是我投入 Flash Actionscript 3.0 當完兵就突然沒落了 …。現在行動裝置相當火紅，如果投入 Android 或是 iOS 的開發似乎是不錯的點，但也有可能不久後的開發會改語言(如 Android 改用 Swift) !? 在不斷猶豫之中，就失去許多學習的時間。 就學習上，我是推幾種選擇方式： 選擇有興趣的 選擇當下最主流的：使用者多不易退流行，替代方案容易出現 選擇有需求的：有需求可以強迫學習 就個人經驗來說不太需要擔心學錯語言，因為這不像是線上遊戲練錯就要砍掉重練，已經學會的技能會加速其他相關技能的學習，如同當時學了 Actionscript 3.0 後再接觸 Javascript 是相當類似的，就算是當兵一年沒有接觸，透過肌肉(?)也可以快速喚醒當年的記憶。 不了解怎麼問問題設計、藝術就像是玄學，許多設計師練就了一項特殊才能：圖像化，設計師們在溝通時可以將語言轉換為圖像，甚至在與他人介紹時可以再將圖像用語言描述出來，但可惜的是程式語言無法用這個技能去描述…。 工程師需要看到程式碼、結果、錯誤訊息才能理解問題點，所以在詢問程式上的問題時有許多眉眉角角要注意，這也是設計師在詢問時經常碰壁的點，如：我想畫一個圓，但不知道為什麼都是方的 ( xxx 傳送一張截圖)。 工程師表示：… 有耐心的工程師會導引你說出他要的答案，但也有可能被工程師白眼後酸一兩句，同時也打擊了學習的慾望。這畢竟不是一個好的方式，所以在問問題時可提供以下的訊息： 原始碼：是用什麼語言寫這個方形的 (ex: html, css 的原始碼) 環境：是用什麼環境開發或預覽的 (ex: IE 預覽的唷～) 是否有錯誤訊息：盡可能提供錯誤訊息，以開發 Web 來說會經常使用到開發者工具，試著去了解錯誤訊息在哪出現吧～。 惰性這是最大的個人問題，只能說換行不是一件容易的事情，沒有人鞭策的的情況下容易落入明日復明日的狀態，就算是說很有興趣的人，回到家看到沙發還不是先躺個一兩小時再說，有些時候需要採取一些手段來強迫自己學習，這部分我用過一些方法可以參考看看： 付費課程：這當然是最有效的，錢都付了哪有沒認真上的道理…，而且付費學習效率高，短時間內就可以到達一定的水準。 每日作業：我有一年強迫自己每天寫 CSS 文章持續 100 天，包含假日我都沒有中斷過，平台也是隨意自己架的。 破釜沈舟：如果說該技能沒學完就會影響一件大事(失業、案子無法完成等等)，透過這種方式強迫學習，ActionScript 我把它當畢業論文在研究，如果沒學會就無法畢業…。 如果說你是一位設計師，正想轉職做工程師這些問題你也正好存在，這篇文章還沒有完全解決你的問題，你可以來問我們看看，我們很樂意跟你聊聊這方面的問題。 歡迎分享 Facebook：https://www.facebook.com/hexschool/ 六角學院網站：http://www.hexschool.com/","categories":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/categories/study/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"專業前端都如何管理 CSS - CSS 讀書會","slug":"css-clud","date":"2016-04-11T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/04/12/css-clud/","link":"","permalink":"https://wcc723.github.io/css/2016/04/12/css-clud/","excerpt":"CSS 讀書會原本打算兩週辦一次，但在各種原因下已經自動發展成每月一次的活動了 Orz…(下次估計也要到五月才會有了T_T)。","text":"CSS 讀書會原本打算兩週辦一次，但在各種原因下已經自動發展成每月一次的活動了 Orz…(下次估計也要到五月才會有了T_T)。 活動網址KKtix 活動網址：http://gonsakon-7655f2.kktix.cc/events/css-book-club-003 這次活動改到 作伙，是在後驛站附近的一棟透天厝裝潢成共同工作空間，一樓及頂樓有場地出租，場地另有提供迷你的投影機及布幕；我們是租用一樓的場地，雖負責人說可以容納 20 人，但我認為 15 人左右是比較舒適的。 作伙的門口，是一間透天厝，前方有個小庭院，蕃薯(貓名)常在這邊出現。 一樓的場地，如果租用的話，負責人會調整成合適的空間，比如說這次場地我們需要投影機。 上次 Javascript 讀書會的情景 (這次我忘了拍了)… 活動簡報 專業前端 都如何管理 CSS from Chih-cheng Wang 簡報連結：http://www.slideshare.net/chihchengwang3/css-60646381 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 共筆文件：https://csscollege.hackpad.com/CSS-3-CSS-fkE5HXwHeID 問卷問卷平均分數 4.46 (滿分 5 分)。 這次的主題分為前後兩段，前半段是介紹 OOCSS ，後半段是透過 OOCSS 分析其他主流框架以及 Sass 架構分享，在難度的分配上前半段較為簡單，後半段與 Sass 有很大關係，參與者並不一定皆了解 Sass ，所以這段可能會造成出神的狀況。 另外在下次活動主要三個較多人選擇(票數接近)，這部分還在猶豫要介紹什麼 ＠＿＠： CSS 技法 Sass 基本運用 Sass 與 bootstrap 意外之外這次活動參與者大部分人給予正面的回應，但和過去不同的是有一位給了過往最低分(2分)，對於主題的建議也提出希望是 正反雙方辯論。 嗯…，就這主題上我還沒想到該如何經營及主持…，或許提出這個意見的可以私下敲我聊看看怎麼進行。 結語雖然參與的人數有再上升，但隨著人數上升也是要多注意許多細節，不可能滿足所有人的需求，辦這些活動其實就要知道有人會喜歡、有人會討厭，如果因此感到挫折與無力時，就代表自己正在進步中。 這個月的 Javascript 、 CSS 讀書會都應該會暫停，因為主辦人都中了教召….。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"workshop","slug":"workshop","permalink":"https://wcc723.github.io/tags/workshop/"}]},{"title":"響應式網站設計實作坊 - 高雄前端社群","slug":"rwd-workshop","date":"2016-04-10T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/04/11/rwd-workshop/","link":"","permalink":"https://wcc723.github.io/css/2016/04/11/rwd-workshop/","excerpt":"本篇拖了很久很久才寫，主要原因是因為最近實在很忙，加上一直想跳到 Wordpress 平台上去寫作…(Server 都準備好了)，但 Wordpress的 Server 可能還會被我拿去做其他用途，所以又回來寫了，哈哈哈哈。 這是高雄前端社群久久難得一次的 Responsive 課程，也很難得出現秒級的時間內票券完售 (當然可能是免費的關係啦 :))。","text":"本篇拖了很久很久才寫，主要原因是因為最近實在很忙，加上一直想跳到 Wordpress 平台上去寫作…(Server 都準備好了)，但 Wordpress的 Server 可能還會被我拿去做其他用途，所以又回來寫了，哈哈哈哈。 這是高雄前端社群久久難得一次的 Responsive 課程，也很難得出現秒級的時間內票券完售 (當然可能是免費的關係啦 :))。 活動網址 KKtix 報名網址：http://gonsakon-7655f2.kktix.cc/events/a5791ac5-f60f9c-cc9dec-eb381d-6b57e9-3a5710-61e623-17b85b 這次也感謝很多助教的協助，許多人就經常地在高雄前端社群幫忙，包括各大小廠的活動都有他們的蹤影，這次還特別感謝從台南來的成員，讓我們的活動更加完善。 講師列表： 廖洧杰 Maple Jackson Norman 林怡萱 IKEA Till 活動簡報 響應式網頁實作坊 from Chih-cheng Wang 簡報連結：http://www.slideshare.net/chihchengwang3/ss-60067482 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 共筆文件：https://csscollege.hackpad.com/327-RWD–orIWGAfGPvb 問卷問卷分數也還不錯，平均分數 4.78 (滿分 5 分)，其中 5 分佔 84%。 而這次活動本來是想給設計師、初學者學習的，但參與的後端工程師佔不少，參與者職業組合： UI 設計師 12.5% 平面設計師 12.5% 前端工程師 43.8% 後端工程師 40.6% PM 3.1% 學生 3.1% 其他 25% (iOS 工程師也佔不少) 這次最困難的部分其實是前半段的 Grid 介紹，這也花了大半的時間在講解，嗯…這個難度設計應該是有讓不少人有感受到收穫。 0 太簡單了 秒懂 3.1% 1 稍微思考一下，但沒太多問題 53.1% 2 有遭遇一些問題，但後來都克服了 40.6% 3 遇到了問題，但不知道怎麼解決 3.1% 結語這次活動比較沒拿捏好的部分是進度，我花很多時間在前半部，但在後半段的時間就略顯不足，有很多想在特別介紹的，卻沒有控制好時間，這在往後的活動都要特別注意。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"workshop","slug":"workshop","permalink":"https://wcc723.github.io/tags/workshop/"}]},{"title":"第二次 CSS 讀書會 - Sass 環境建置","slug":"css-book-clud-2-sass-and-gulp","date":"2016-02-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/02/29/css-book-clud-2-sass-and-gulp/","link":"","permalink":"https://wcc723.github.io/css/2016/02/29/css-book-clud-2-sass-and-gulp/","excerpt":"這次是第二次的 CSS 讀書會，目標是要教大家 Sass 的環境建立，也算是比較大的挑戰，因為要在線上及現場教大家怎麼運行 Sass 的編譯環境，且主要的目標族群包含了設計師、網頁設計師，甚至是沒有碰過 command line 的開發者…。","text":"這次是第二次的 CSS 讀書會，目標是要教大家 Sass 的環境建立，也算是比較大的挑戰，因為要在線上及現場教大家怎麼運行 Sass 的編譯環境，且主要的目標族群包含了設計師、網頁設計師，甚至是沒有碰過 command line 的開發者…。 活動簡報範例：https://github.com/Wcc723/gulp-web-designers 這次活動的簡報是用 Keynote 做的，有些部分是講解上為了呈現動態效果，所以在 slideshare 無法呈現的很完整。 建立 Sass 環境，透過 Node sass from Chih-cheng Wang 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 View CSS 讀書會 2 (Sass 編譯環境) on Hackpad. 其他問題這次有許多問題是 Hackpad 上沒有提到，是在問卷內提出的問題，這邊我就一一回覆： 問題：Sass 與 Scss在一開始寫 Sass 就是使用 .sass 的格式，前前後後也有一年多的時間，雖然看到許多開發者都是使用 .scss，大多數的文件及範例也都是使用 .scss ，但當時是想說只要有愛，就可以堅持下去 !? 直到出現一個問題用 .sass 很難解決(讓我轉跳 .scss 的原因)，那就是 Sass Maps (範例：http://www.sitepoint.com/using-sass-maps/)，當時也正好在學 Susy， Susy 一定要使用 Sass Maps，用 .sass 格式寫 Sass Maps 簡直地獄…。 // scss $map: ( key: value, other-key: other-value ); Sass 格式中，Sass Maps不能換行 = =(實際上的 Maps 會更長)，當下花了很長的時間找解法，但一直找不到替代方式，就默默地轉向 .scss。 // sass $map: (key: value, other-key: other-value) 另外一個原因是在寫教學文時 .sass 對於一般使用者較為陌生，如果不熟悉的讀者看到 .sass 應該不知道在寫什麼…。 問題：為何不再用 Susy關於 Susy 這個工具我用過 Susyone、Susy 2，後來確實有些偏見 (這部分是我該反省的點Q_Q，不該用自己的主觀來勸大家別用)，這邊還是要和大家分享為何我不再使用這樣的 Grid 工具。 第一階段這幾張圖我們就看有色彩的地方，假設需求是左邊有選單(4欄寬度)，右方的區域是文章內容(8欄寬度)，總共為 12 欄寬，一開始我們可能會使用 .menu 及 .article 來規劃 CSS 。 123456.menu &#123; // 4 欄寬&#125;.article &#123; // 8 欄寬&#125; 第二階段但這兩個區域的實際內容可能不會只放文章，左邊也有可能是放廣告，所以就把側邊改成 .side，中間也改成了 .content，以符合以後的運用。 123456.side &#123; // 4 欄寬&#125;.content &#123; // 8 欄寬&#125; 第三階段後來新增了一個區域 .ad，那個區域的寬度與 .side也都相同，但稱為 .side 的區域也不便直接套在 .ad，所有就新增一個 .ad 寬度也一樣是 4 欄寬。 123456789.side &#123; // 4 欄寬&#125;.content &#123; // 8 欄寬&#125;.ad &#123; // 4 欄寬&#125; 第四階段我們會發現其實 .side、.ad 兩者 CSS 屬性差異不大，所以可以改用欄寬的方式來定義這個 class 名稱，於是乎就出現了 .col-4、.col-8，m…到了這步驟，是不是發現和 Bootstrap 2 有點像呢!?這樣的 CSS 設計模式是將網格系統模組化，增加了Class 的可複用性。 Susy 的優點在於快速建立格線系統，但如果是 col-size 的 Grid-system 就失去了快速建立格線系統的特色，模組化的優點是增加了 Class 的可複用性，但換個方向去思考，其實它也限制了創意的發想(畢竟 grid 都已經規劃好)，不同的方法與技巧也建議去嘗試看看，這樣才能了解何者適合目前的專案。 問題：為何需要用 Scss 與 CSS 如何跟後端的結合為何需要用 Scss？理由挺多的，就個人這段時間的學習來說，有以下幾個理由： 節省時間：當初學習 CSS 時，每一行都是純手工寫出來的，雖然很有成就感，但久而久之都花時間在重複的地方，透過 Sass 的技術，不僅在重複的地方花更少的時間，還可以投資更多時間在新的技法上。 管理 CSS：就純 CSS 來說，由於所有的程式碼都集中在同一個檔案上(當然也可以用@import，但就效能上有許多建議說別這麼做)，透過 Sass 可以將 CSS “模組”拆分成不同檔案，之後再編譯成同一隻檔案。 進階的 CSS：Sass 在開發上多了變數、運算，可以去思考怎樣用簡單的方式做出豐富的效果，不過這也需要投資一定的時間去研究。 如何與後端語言結合？ 其實我在專案上都是透過 Gulp 與後端結合，但這次的讀書會主要是讓新手可以入門 Sass 環境，所以沒仔細提到這段，如果是後端的開發者，可以參考範例中的 gulpfile.js，抽離掉 webserver 模組後，就可以用來編譯給後端用的 Sass (也可以依據需求調整編譯路徑等)，或者私下敲我，我們再來討論討論。 前端的工具還相當多，這樣的一次性介紹還缺乏很多，以後我再多研究研究其他前端工具再與大家分享(近期內應該還會介紹 Bower)。 建議：講者說話太快嗯…，這部分是我該多注意的，往後的課程也會更著重在單一的主題上介紹，不過大家有問題還是盡量可以在 Hackpad 或直播頻道發問，上面有許多高手會一起交流解答～。 就票數上來說，下次會介紹 CSS 架構，希望這個連假可以準備差不多 Orz 。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"第一次 CSS 讀書會","slug":"css-book-clud-1-grid-system","date":"2016-01-29T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/30/css-book-clud-1-grid-system/","link":"","permalink":"https://wcc723.github.io/css/2016/01/30/css-book-clud-1-grid-system/","excerpt":"這次在高雄舉辦了 CSS 讀書會 (Grid syetem)，主要是之前參加了 javascript 讀書會，認為CSS 也能辦相同的聚會，在第一次試辦時有許多測試水溫的方式： 想先瞭解受眾類型 估計參與人數 直播的方式是否可行 未來讀書會的方向","text":"這次在高雄舉辦了 CSS 讀書會 (Grid syetem)，主要是之前參加了 javascript 讀書會，認為CSS 也能辦相同的聚會，在第一次試辦時有許多測試水溫的方式： 想先瞭解受眾類型 估計參與人數 直播的方式是否可行 未來讀書會的方向 活動簡報這次活動的簡報是用 Keynote 做的，有些部分是講解上為了呈現動態效果，所以在 slideshare 無法呈現的很完整。 CSS 讀書會 - 1 (Grid system) from Chih-cheng Wang 也有準備了 Hackpad 提供共筆，很感謝前端朋友們熱情協助寫共筆文件。 View CSS 讀書會 1 (grid system) on Hackpad. 現場參與照片!?(用直播用到忘記拍照了 =口=) 回饋這次活動是先透過 KKtix 報名，主要是想知道如果辦這樣的讀書會有沒有人要參加，還有達到基本的宣傳，結果…，13秒內搶完10張票！！！另外 Youtube 同時在線約 45 人上下，這次到前一天不到 24 小時的時間才公佈有線上直播 Q_Q(而且我到前幾分鐘才成功連上 Youtube…)。 而 Youtube 數據到今天我還不能看 -.-…. 問卷從問卷上得知大部分的參與者都有從事前端工程，其次在設計師及學生的數量也是不少，另外在最後也希望大家填寫想了解的 CSS 主題，選擇如下： CSS 架構 (12 人選擇) 實作 (10 人) 技法 (3 人) 往後主題因為 CSS 架構以及實作的選擇數量差距較小，以後再主題的規劃上就會兩者並重，且在內容的安排上，會持續貼近設計師與前端工程師的組合，也感謝本次參與者提供意見，希望在以後能夠透過這樣的方式互相交流成長。 另外，自己意外的喜歡這個副標 『擺脫 They 的問題，完全掌控 You 的 CSS』。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"動手玩 CSS 3d","slug":"css-3d","date":"2016-01-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/24/css-3d/","link":"","permalink":"https://wcc723.github.io/css/2016/01/24/css-3d/","excerpt":"一開始接觸 CSS3 時，常常會不了解每個 CSS 屬性的意思，就需要花些時間去查詢及嘗試，就算到了現在，對於不熟悉的語法，我還是經常回我的 Blog 查詢，如先前的 動手玩 CSS，快速學會Flex，我就經常會回去查 Flex 的使用方法 Orz…，這次趁寒流來襲，不想出門的時間在家裡做簡單的 CSS 3d 範例。","text":"一開始接觸 CSS3 時，常常會不了解每個 CSS 屬性的意思，就需要花些時間去查詢及嘗試，就算到了現在，對於不熟悉的語法，我還是經常回我的 Blog 查詢，如先前的 動手玩 CSS，快速學會Flex，我就經常會回去查 Flex 的使用方法 Orz…，這次趁寒流來襲，不想出門的時間在家裡做簡單的 CSS 3d 範例。 CSS 3D當要做 CSS 3D 的效果時，可以先假想兩層的元素。外層是視角，是用第三人稱的方向在看著內層；內層就是物件的本身，可以有不同的 3D 屬性(旋轉、位移等等)。 HTML 結構如下： 1234&lt;div class=\"perspective\"&gt; &lt;!-- 外層視角 --&gt; &lt;div class=\"box\"&gt; &lt;!-- 物件本身 --&gt; &lt;div&gt;&lt;/div&gt; 在CSS 的屬性上，外層會提供 perspective 的透視屬性，這是從第三人稱看物件的距離，值可以先使用 500px ~ 1000px (不負責研究，通常這個起手式效果不太差)；在內層的屬性則必須包含 transform-style: preserve-3d，讓物件本身已 3D 的模式呈現，並加入 transform 的變形屬性，就可以完成基本的 CSS 3D 。 CSS 結構如下： 1234567.perspective &#123; perspective: 500px;&#125;.box &#123; transform-style: preserve-3d; transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg);&#125; 接下來透過動手玩的方式，調整看看外層與內層得屬性值，了解他們彼此 perspective 與 transform 之間的效果。 可以發現，如果 perspective 值如果是非常小時，內層物件就會像衝出螢幕一樣，如同我們在看物體時，通常會保持一定的距離，並非貼的很近在觀看。 2016年的冬天…到底是怎樣的溫度會不想出門呢…，在高雄很少低於 10 度，如果低於 8 度就要拿出羽絨衣，在更低一點就只想要躲在棉被裡…。 這個體感問度是…，讓我回想到馬祖的冬天。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"跟 Javascript 相比，CSS 還是友善多了 @@","slug":"I-love-css","date":"2016-01-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/16/I-love-css/","link":"","permalink":"https://wcc723.github.io/css/2016/01/16/I-love-css/","excerpt":"本週參加了高雄 Javascript 讀書會，所選擇的書籍是 JavaScript設計模式與開發實踐，這本雖然原本是簡體書，但內容真的不錯(不過我只有看一兩章似乎沒什麼說服力 &gt;O&lt;)，也多虧這次的讀書會，讓我對於技術有更深層的看法。 JavaScript 什麼的太難了…，直接請人教比較快 了解設計模式對於大部分 JavaScript 的了解很有幫助 (如 Angular 的 Service 本身就具有 Closure 的觀念) 參加讀書會這樣的活動，對於技術的學習相當迅速，等於是直接吸別人的經驗值 工作上雖然會寫 Javascript，但這次讀書會光是 this 就可以玩死我 Orz，更別說 Closure、ES6 等等…，雖然最後還是有學到一兩招，但真的很累…。","text":"本週參加了高雄 Javascript 讀書會，所選擇的書籍是 JavaScript設計模式與開發實踐，這本雖然原本是簡體書，但內容真的不錯(不過我只有看一兩章似乎沒什麼說服力 &gt;O&lt;)，也多虧這次的讀書會，讓我對於技術有更深層的看法。 JavaScript 什麼的太難了…，直接請人教比較快 了解設計模式對於大部分 JavaScript 的了解很有幫助 (如 Angular 的 Service 本身就具有 Closure 的觀念) 參加讀書會這樣的活動，對於技術的學習相當迅速，等於是直接吸別人的經驗值 工作上雖然會寫 Javascript，但這次讀書會光是 this 就可以玩死我 Orz，更別說 Closure、ES6 等等…，雖然最後還是有學到一兩招，但真的很累…。 CSS 讀書會由於 JavaScript 對於設計師來說稍微不友善!? 所以在讀書會中有人就隨口提出了 CSS 讀書會(~其實想辦的是CSS Girls吧!!)。雖然我對於 CSS 掌握有一定的信心，但要挑什麼樣的書籍就沒什麼概念，目前有想到幾個方案： CSS Secrets :本書有相當多的奇淫巧計，堪稱CSS 界的神書，究竟有多神，可以先參考本作者先前的 簡報。 Bootstrap:方案是研究目前在市面上較為普及的 CSS Framework，藉此來了解主流框架的架構以及他們的 CSS 設計模式。 目前還在與其他同好討論是否有更適合的方案，也希望能有更多同好一同參與啊～。 100 Day UI100 Day Ui是一個相當好的活動，可以看到很多很棒的作品 . ，這個網站有些作品也被其他網友做成了網頁版本，我也就偷偷地摸了一部份漂亮的 CSS 囉～。 http://wcc723.github.io/WorkShop-gh-pages/glowButton/ 我很喜歡這樣的按鈕表現模式，雖然說之前我不喜歡大圓角，但這樣的光暈及漸層表現方式真的很棒，而且也擺脫目前許多 Style Guide 的扁平化思維。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"動手玩 CSS Blend Mode - 根本 Photoshop 的圖層效果","slug":"css-blend-mode","date":"2016-01-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2016/01/10/css-blend-mode/","link":"","permalink":"https://wcc723.github.io/css/2016/01/10/css-blend-mode/","excerpt":"現在的 CSS 變化比過去還多，原本的 CSS 主要用於排版，在 CSS3 除了排版還會包含許多效果，本篇介紹的 Blend Mode 就是混合模式的效果，讓 CSS 像 Photoshop 一樣有圖層混合。","text":"現在的 CSS 變化比過去還多，原本的 CSS 主要用於排版，在 CSS3 除了排版還會包含許多效果，本篇介紹的 Blend Mode 就是混合模式的效果，讓 CSS 像 Photoshop 一樣有圖層混合。 background-blend-mode, mix-blend-mode範例中會包含這兩種 CSS 樣式，先做簡單的介紹。 background-blend-modebackground-blend-mode 這一個 CSS 屬性是針對 背景圖片 的混合模式，所以並不會影響畫面中其他物件色彩。 mix-blend-modemix-blend-mode 這種混合模式就如同 Photoshop 中的 圖層混合模式 較為接近，會有下層圖層的色彩進行混合。 範例 範例連結網址：http://wcc723.github.io/WorkShop-gh-pages/cssBlendMode/ 範例介紹 Background Blend Mode：背景的混合模式 Background Color：*背景色彩 Text：中央文字 Text Color：*文字色彩 Text Mix Blend Mode：中央文字的圖層混合模式 Background URL：背景網址 (預設是超辣的朝天椒) * 如果你的瀏覽器不支援 HTML5 input 選色的，可以直接輸入色碼或是色名，如(#FF0000 or red) CSS 值background-blend-mode 及 mix-blend-mode 這兩種混合模式的值是相同的，這些值是不是似曾相識呢!?這些與繪圖軟體的混合模式工具是相同的唷～。 normal multiply screen overlay darken lighten color-dodge color-burn hard-light soft-light difference exclusion hue saturation color luminosity 結語透過直接的範例，減少用文字的說明，可以較快速的了解 CSS 的特性，畢竟 CSS 主要是用來處理視覺上的效果。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Compass 替代方案(3) - 加入 SVG Sprites","slug":"replace-compass-with-node-sass-3","date":"2016-01-02T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2016/01/03/replace-compass-with-node-sass-3/","link":"","permalink":"https://wcc723.github.io/sass/2016/01/03/replace-compass-with-node-sass-3/","excerpt":"Compass 的 CSS Sprites 是非常好用的工具，在以前有介紹過 compass 的 Sprites 作法，只要把圖片丟一丟就可以完成，而且也可以做 for Retina 版本，但是使用SVG 製作 Sprites 就沒有辦法。一直以來我都是以向量工具做設計，如果不能轉 SVG 這樣高品質的圖檔，對我來說也是挺困擾的。 這篇就要介紹如何使用 Gulp 來製作 SVG Sprites，並且同時產生一般 png 版本來相容於舊版的瀏覽器。 先前的 Sprites 介紹文章 Spriting with Compass Sprites for Retina","text":"Compass 的 CSS Sprites 是非常好用的工具，在以前有介紹過 compass 的 Sprites 作法，只要把圖片丟一丟就可以完成，而且也可以做 for Retina 版本，但是使用SVG 製作 Sprites 就沒有辦法。一直以來我都是以向量工具做設計，如果不能轉 SVG 這樣高品質的圖檔，對我來說也是挺困擾的。 這篇就要介紹如何使用 Gulp 來製作 SVG Sprites，並且同時產生一般 png 版本來相容於舊版的瀏覽器。 先前的 Sprites 介紹文章 Spriting with Compass Sprites for Retina CSS Sprites製作 CSS Sprites 不外乎就是要減少 HTTP Request(請求數)，藉此來達到更好的網站瀏覽效能。但 CSS Sprites 在製作上有點兒麻煩，一般來說會有以下流程。 製作許多小圖示 將小圖示合併成一張大張的圖 依據每張小圖示給予對應的 class 計算每張小圖在大圖中的絕對位置 取得每張小圖在大圖的絕對位置本身就是一件麻煩事，更麻煩的是如果大圖中要插入新圖，有可能會造成其他小圖需要更新座標 =..=。當然在以前介紹的 Compass 就能達到這些功能，而這次介紹的工具除了 Compass 原有的能力以外，還包含新的功能。 將 SVG 製作成 SVG Sprites 同時提供 .png 版本供舊版瀏覽器使用 同時提供 SVG 對應 HTML 說明文件。 可自訂產生的 CSS 樣式表 使用 SVG Sprites持續更新的範例：https://github.com/Wcc723/gulp-node-sass 這次用的套件是 gulp-svg-sprites，這個套件有個缺點就是 #NOTICE - NOT ACTIVELY MAINTAINED …。不過他滿足我所需的所有功能，所以本篇還是用這個套件。 12345678910111213141516171819202122232425262728293031323334353637var gulp = require('gulp'), // svgSprite svgSprite = require(\"gulp-svg-sprites\")var paths = &#123; 'source': './source/', 'bower' : './bower_components/', 'sass': './source/stylesheets/', 'img': './source/images/', 'public': './public/', 'tpls': './gulp-tpls/'&#125;// SVG Spritegulp.task('svg-sprite', function() &#123; gulp.src('./source/images/sprites/*.svg') // 來源路徑 .pipe(plumber()) .pipe(svgSprite(&#123; svg: &#123; sprite: \"images/sprites/sprite.svg\" // 輸出 svg 路徑 &#125;, cssFile: 'stylesheets/sprite.css', //輸出 css 路徑 selector: \"icons-%f\", // 前綴詞 templates: &#123; css: require(\"fs\").readFileSync(paths.tpls + 'svg-sprite.css', \"utf-8\") // css 樣板 &#125; &#125;)) .pipe(gulp.dest(paths.public)) .pipe(filter(\"**/*.svg\")) .pipe(svg2png()) .pipe(gulp.dest(paths.public));&#125;);watch('./source/images/sprites/*.svg', function() &#123; gulp.start('svg-sprite');&#125;);gulp.task('default', ['svg-sprite']); 這段程式碼僅是局部，在我的範例內產生的 CSS 會再由 PostCSS 合併。 接下來準備一些 SVG ，其中還加入一張包含漸層的 Skype 圖示 (如果是 icon fonts 就無法直接使用漸層色或是更豐富的色彩)。 輸入 gulp 編譯完會得到 sprite.css、sprite.png、sprite.svg以及sprite.html這些檔案，打開 sprite.html 會看到本次專案 sprites 的說明文件。 這個範例檔可以看到有哪些 Sprites 可以用運用，並且可以切換背景色以及 html code 的提示。 和 Compass 不同在於它是屬於另外產生的CSS，有時候和本身專案的 CSS 可能會有衝突，它也能透過 css template 客制屬於專案的範本。 1234567891011121314151617181920212223&#123;#common&#125;.&#123;common&#125; &#123; font-size: &#123;baseSize&#125;px;&#125;.&#123;common&#125;:before &#123; content:' '; vertical-align:middle; display: inline-block; background-image: url(\"&#123;svgPath&#125;\"); background-repeat: no-repeat; background-size: &#123;relWidth&#125;em &#123;relHeight&#125;em;&#125;.no-svg .&#123;common&#125;:before &#123; background-image: url(\"&#123;pngPath&#125;\");&#125;&#123;/common&#125;&#123;#svg&#125;&#123;#common&#125;.&#123;common&#125;&#123;/common&#125;.&#123;name&#125;:before &#123; background-position: &#123;relPositionX&#125;em &#123;relPositionY&#125;em; width: &#123;relWidth&#125;em; height: &#123;relHeight&#125;em;&#125;&#123;/svg&#125; 注意在製作 SVG 時，建議使用 Sketch 或 Affinity Designer 軟體，Adobe Illustrator 在轉 SVG 有可能會產生錯誤的格式造成無法製作 Sprites 。 Illustrator 會將漸層轉成 Base64 ，並非 SVG的漸層 本篇介紹的是 SVG Sprites，適合用在有色彩的圖案上，如果說專案只需要單色的圖示，建議可以使用 icon fonts 就可以了，icon fonts 的文章可以參考 將 Sketch icons 轉成 web icon fonts。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"Compass 替代方案(2) - 透過 PostCSS，停止加入不必要的 prefix","slug":"replace-compass-with-node-sass-2","date":"2015-12-24T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/12/25/replace-compass-with-node-sass-2/","link":"","permalink":"https://wcc723.github.io/sass/2015/12/25/replace-compass-with-node-sass-2/","excerpt":"承上篇，因為 compass 很久沒維護，所以在找替代方案。而這篇是要介紹很火紅的 post-css，主要是要解決 css3 prefix 的問題，post-css和 sass 不同的是，在 prefix 的方法不需要先定義成 @mixin ，可以在事後再決定是否加入 prefix，這讓不斷在更新改變的 prefix 流程簡化很多，並且可以有效減少 css 的檔案大小 (prefix 是很肥大的)。 Prefix 的減少速度也是相當快速，像是 box-shadow 的 Prefix 可能消失超過一年， transform 也大約一年左右不需要 Prefix，如果不想要明年慢慢的移除自己所種的 Prefix，或許可以參考看看 post-css的 autoprefixer 工具。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～","text":"承上篇，因為 compass 很久沒維護，所以在找替代方案。而這篇是要介紹很火紅的 post-css，主要是要解決 css3 prefix 的問題，post-css和 sass 不同的是，在 prefix 的方法不需要先定義成 @mixin ，可以在事後再決定是否加入 prefix，這讓不斷在更新改變的 prefix 流程簡化很多，並且可以有效減少 css 的檔案大小 (prefix 是很肥大的)。 Prefix 的減少速度也是相當快速，像是 box-shadow 的 Prefix 可能消失超過一年， transform 也大約一年左右不需要 Prefix，如果不想要明年慢慢的移除自己所種的 Prefix，或許可以參考看看 post-css的 autoprefixer 工具。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～ 什麼是 PostCSSSass、Less、Stylus 這些工具稱為預處理器，意指本身無法被直接使用，需要再編譯的語言，編譯後就能夠被瀏覽器渲染，副檔名也會從 .sass 改為 .css；而 post-css 本身就是 .css，只是透過工具去優化目前的 CSS。 目前 post-css 的社群就已經相當龐大，有許多插件也廣泛地被使用，如： autoprefixer: 可以加入 css3 prefix，甚至自訂 prefix 時代版本，或者是特定瀏覽器 lost: grid system 工具，直接在 CSS 內寫類似 susy 的 grid cssnext: css 界的 ES6，讓你可以寫下一代的 CSS (可參考：http://cssnext.io/features/) precss: 讓你可以在 css 內寫類似 sass 的語法 (例如：巢狀) 相關的插件是非常非常多的，這篇只會介紹 prefix ，如果有興趣的可以看 PostCSS Plugins。仔細看他的插件…，其實說他是另一種 sass 也不為過了…。 使用 postcss autoprefixer持續更新的範例：https://github.com/Wcc723/gulp-node-sass 會選擇引入 autoprefixer 主要是因為 compass 很久沒更新，許多 prefix 已經沒在使用，如果要自己一個一個設定也需要花很多時間。像是 Bootstrap 3 sass 版本，也是由開發團隊寫 prefix @mixin，這都面臨相同的問題 “專案的 CSS Prefix 到底是哪個時代啊!?” 。 最近為了客制 Bootstrap 3 刪 Prefix 也是刪的很累啊… 123456789101112131415161718192021222324252627282930var gulp = require('gulp'), // PostCSS postcss = require('gulp-postcss'), autoprefixer = require('autoprefixer'); // postCSS 的套件原則上都是要一個一個載入var paths = &#123; 'source': './source/', 'bower' : './bower_components/', 'sass': './source/stylesheets/', 'img': './source/images/', 'public': './public/', 'tpls': './gulp-tpls/'&#125;// postCSSgulp.task('css', function () &#123; // 在 processors 內定義需要用哪些套件，這邊只有使用 autoprefixer var processors = [ autoprefixer(&#123;browsers: ['last 1 version']&#125;) ]; watch(paths.public + 'stylesheets/**/**.css', function()&#123; gulp.src(paths.public + 'stylesheets/**/**.css') .pipe(plumber()) .pipe(concat('all.css')) .pipe(postcss(processors)) .pipe(gulp.dest(paths.public + './css')); &#125;);&#125;);gulp.task('default', ['css']); 這段程式碼僅是局部，在我的範例內是由 node-sass 編譯完再由 post-css 處理。 就已最新版的瀏覽器設定來說，其實大部分 prefix 其實都已經不用加入了，如：flex、transform、backgroud等，就下面的範例來說，只有 filter 需要 prefix。 如果說，產品的使用者客群略微廣些，只要大於一個百分比的使用者都需要重視，可以修改插件的設定檔，如下 (市佔率大於 1%，且連IE 7 都不放過)。 var processors = [ autoprefixer({browsers: [&apos;&gt; 1%&apos;, &apos;IE 7&apos;]}) ]; 那麼如果有支援的 prefix 他都會加入，會得到以下結果： 其實會發現，-moz-、-o-這些也不存在啊啊啊啊，Oprea 已經改用webkit，Firefox 強制更新，目前市面上的版本不需要 Prefix。 線上玩玩 PostCSS另外 Codepen 也有提供 post-css 的環境，只要在 CSS 的區域下選擇設定 &gt; CSS Preprocessor &gt; PostCSS 就可以使用 @use 加入想使用的 post-css 插件。 如下圖，透過 @use cssnext; 就可以使用 cssnext 插件。 結語Autoprefixer 是目前 post-css 看到最必須導入的工具，有效減少 prefix 的問題。其他的工具 cssnext、lost等等，目前僅會做測試或研究並不會導入。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"Compass 替代方案(1) - 更快速的 Sass","slug":"replace-compass-with-node-sass","date":"2015-12-19T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/12/20/replace-compass-with-node-sass/","link":"","permalink":"https://wcc723.github.io/sass/2015/12/20/replace-compass-with-node-sass/","excerpt":"Compass 是一套非常優秀的 Sass 擴充套件，從剛開始學 Sass 就一直用到現在，許多優點是一般 CSS 或 Sass 較難達到的，如： CSS Sprites：可以將圖片轉成Sprite，並提供 CSS class。 CSS3 mixin：prefix 啊～ Vertical Rhythm：CSS 文字排版的救星。 image-url, image-size：圖片路徑的取代以及取得圖片的尺寸。 但現在有些問題讓我考慮放棄使用 Compass 如： 很久沒更新，距離上次更新已將近一年 基於ruby sass，效能較差，編譯速度慢 因為久沒更新，很多 css3 @mixin 已不符合現在規範 CSS Sprites 沒有 SVG 版本 接下來會連續幾篇開始介紹透過 Node sass 取代 Compass 的相關技術研究，當然 Compass 不會馬上被取代，但也要準備好替代方案，畢竟工具只是要增加產能使用，並非一定要追最新的才行。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～","text":"Compass 是一套非常優秀的 Sass 擴充套件，從剛開始學 Sass 就一直用到現在，許多優點是一般 CSS 或 Sass 較難達到的，如： CSS Sprites：可以將圖片轉成Sprite，並提供 CSS class。 CSS3 mixin：prefix 啊～ Vertical Rhythm：CSS 文字排版的救星。 image-url, image-size：圖片路徑的取代以及取得圖片的尺寸。 但現在有些問題讓我考慮放棄使用 Compass 如： 很久沒更新，距離上次更新已將近一年 基於ruby sass，效能較差，編譯速度慢 因為久沒更新，很多 css3 @mixin 已不符合現在規範 CSS Sprites 沒有 SVG 版本 接下來會連續幾篇開始介紹透過 Node sass 取代 Compass 的相關技術研究，當然 Compass 不會馬上被取代，但也要準備好替代方案，畢竟工具只是要增加產能使用，並非一定要追最新的才行。 如果還在使用Compass的使用者可以當作參考就好，工具還是要用得上手比較重要～ Compass 可以被取代的部分Compass 功能那麼多，說實在要取代全部還真的不容易，另一方面就算取代了全部功能，也不一定容易上手，所以打算先從經常使用的功能去改變，並且適應看看。 CSS Sprites：這部分我從 gulp 中找到 svg sprites，稍微改寫一下就足以替代。 CSS3 mixin：這是Compass的一大特色，但也是令人詬病的地方，因為久沒更新許多 prefix 早已有改變，這部分我從 post-css 找到了解決方案。 Vertical Rhythm：還未解決。 image-url, image-size：通常取用image-url是用來做icon、背景圖，這部分如果可以用svg-sprites就可以解決，但如果是為了達到一些視覺效果必須使用 image-size 那就還沒有辦法了…。 clearfix, inline-block 等現成的mixin：還未解決，靠 Sass 的架構去處理。 目前這些解決方案都還在研究中，也會分幾篇介紹這些方法的優缺點，這篇會先介紹 node-sass。 node-sass持續更新的範例：https://github.com/Wcc723/gulp-node-sass 在Bootstrap 3的時候，開發團隊選擇 Less 作為開發環境，其中一個原因是 Sass 編譯速度太慢了，後來 sass 提供了 lib-sass，讓不同的環境都可以運行sass，其中也包含了 node-sass ，因此現在 Bootstrap 4 也改為 sass 開發。 Moved from Less to Sass. Bootstrap now compiles faster than ever thanks to Libsass, and we join an increasingly large community of Sass developers.http://blog.getbootstrap.com/2015/08/19/bootstrap-4-alpha/ 如果說不使用 Compass， node-sass 將是一個不錯的選擇，我也嘗試使用 node-sass 編譯與 ruby-sass 編譯做比較，是相當有感的…(有些較具規模的compass專案會到達10秒以上的編譯時間)。 Your browser does not support the video tag. 影片中同時編譯 Bootstrap sass 版本，左邊是 node-sass，右方是 ruby-sass，都有包含sourcemaps，由於是同一個資料夾，所以是同時開始編譯。 就編譯時間來看，大概都是 2 ~ 4，不過單位不同…，node-sass是 毫秒，ruby-sass是 秒。 使用 node-sass 可以參考 gulp-sass，另外在監控可以使用 gulp-watch，讓新增刪除檔案時也會被監控到。 1234567891011121314151617181920212223242526272829var gulp = require('gulp'), plumber = require('gulp-plumber'), sass = require('gulp-sass'), watch = require('gulp-watch');// Pathsvar paths = &#123; 'source': './source/', 'bower' : './bower_components/', 'sass': './source/stylesheets/', 'img': './source/images/', 'public': './public/', 'tpls': './gulp-tpls/'&#125;// Sassgulp.task('sass', function() &#123; gulp.src([paths.sass + '**/**.scss']) .pipe(plumber()) .pipe(sass(&#123;outputStyle: 'nested'&#125;) .on('error', sass.logError)) .pipe(gulp.dest(paths.public + './stylesheets'))&#125;);watch([paths.sass + '**/**.scss'], function() &#123; gulp.start('sass', 'scss-lint');&#125;);gulp.task('default', ['sass']); 持續更新的範例：https://github.com/Wcc723/gulp-node-sass 接下來還會介紹 sass-lint、gulp-svg-sprites、gulp-postcss，對於以上有其他建議也歡迎一起在下方留言。 另外…Webm真是好物，中間的那個短片就是webm，不到1mb的影片甚至比gif還小。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"被討厭的勇氣","slug":"be-your-self","date":"2015-12-11T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"life/2015/12/12/be-your-self/","link":"","permalink":"https://wcc723.github.io/life/2015/12/12/be-your-self/","excerpt":"你過得快樂嗎？如果不快樂，代表你不夠在乎你自己。 “被討厭的勇氣”是我今年看過最值得閱讀的一本書，書中的引言有許多人提到為何沒有早一點看到這本書，在我讀完以後也會有這樣的感覺，可見內容之精彩。 本書的內容是以故事性的方式呈現，大綱是一位哲學家與具有反社會心態的年輕人對話，在不同的夜裡年輕人不斷挑戰哲學家的阿德勒學說，在這一正一反的對話內容，更能凸顯出本書的內容以及古代哲學對話與辯論的精神。 在這書中有幾個段落對我啟發很深： 心理創傷並不存在 屬於別人的課題 尋找自己的歸屬感 認真地活在當下，人生的價值就在於此","text":"你過得快樂嗎？如果不快樂，代表你不夠在乎你自己。 “被討厭的勇氣”是我今年看過最值得閱讀的一本書，書中的引言有許多人提到為何沒有早一點看到這本書，在我讀完以後也會有這樣的感覺，可見內容之精彩。 本書的內容是以故事性的方式呈現，大綱是一位哲學家與具有反社會心態的年輕人對話，在不同的夜裡年輕人不斷挑戰哲學家的阿德勒學說，在這一正一反的對話內容，更能凸顯出本書的內容以及古代哲學對話與辯論的精神。 在這書中有幾個段落對我啟發很深： 心理創傷並不存在 屬於別人的課題 尋找自己的歸屬感 認真地活在當下，人生的價值就在於此 心理創傷並不存在(在博客來上就可以閱讀到這一段…預覽) 我也是在博客來上看完後就覺得很棒，就買了這本書，書中的其中一句話：「不要由經驗來決定自我，而是由我們賦予經驗的意義來決定」。每個人都有不同的過去經驗，不好的過去還特別容易被記住，過去的經驗也足以影響現在，但經驗的好壞可由當下的想法去改變。 好比說兒童時期家境不佳，雖然餓不死但也沒吃過什麼好料，現在的當下可以有不同的想法如： 小時候家境不好，認為輸人太多，怎樣也追不上富二代。 小時候沒什麼錢，了解家境不好是什麼感覺，所以要更加努力去改變它，並且去幫助需要幫助的人。 這是一個常見的故事，雖然過去會影響現在，但真正支配者是現在的自己，並非過去的自己，不同的想法就足以改變未來。 屬於別人的課題我常常會不能理解別人的想法，就像是對於宗教狂熱、政治狂熱、政治上的惡人(!?)，或者是在生活上、工作上總是會遇到許多不易理解的人，其中也包含自己熟悉的人。在本書中有提及，所有人都是做自己認為善的事情，”善”不一定是好的事情，而是自己認為”對”的事情，每個人生活背景不同、學習過程不同，所以在善的理解上一定也不同。 如果當自己的想法與別人的善不同時，可以試著與對方溝通，但沒必要強迫對方理解，而是可以與對方分享自己的善，因為對方能不能接受是對方的課題。就如同書中的哲學家一樣，他不會要年輕人立刻接受他的想法，而是慢慢地分享想法，讓年輕人從中思考，最後他也能發展屬於自己的善。 同樣的再對別人的好，也不能去要求對方的回饋，因為對方是否回饋，是屬於對方的課題，我們只要做好自己認為有價值的事情，讓自己心中感到滿足就好。 每個人的生活環境不同，會有不同理解的善 不必想要說服他人，只要和他人分享自己的善即可 對於他人的回報是屬於他人的課題，我們只需做好自己認為有價值的事情 尋找自己的歸屬感很高興你看到了現在還沒離開，這段想先問個問題： 對於目前的家庭、情人、工作、朋友、群體是否感到自在？ 如果對於目前有感到不自在的環境，過去是否有更好的經驗？ 一直以來我想要追求更好的生活，想要賺更多的錢、領更多的薪水，也因此離開原有的環境，但現在卻覺得無聊、乏味，沒辦法表現出自我。在書中也就介紹到了，如果你無法在目前環境感受到自在，代表無法從中獲得歸屬感…。 而朋友、戀人也是相同的道理，每個人不一定能夠選擇最完美的戀人，只要能夠選擇到讓你感到自在的，就是合適的。 認真地活在當下，人身的價值就在於此大家或許都會對過去或目前的生活不夠滿意，不斷的思考未來要怎麼發展，學生時代想著如果考上大學期許以後能有好工作，上班後也不斷的在思考怎樣進入大公司或者職位的晉升。 但其實最美好的時間就在當下，我們必須去體驗現在所發生的任何美好，當然這本書也不是在鼓勵人自私，每個時間點都值得所有人去舞動，讓當下活得更有價值，書中舉例說：人生就像登山攻頂，而人生就像是在半路上。我認為更像是沒有盡頭的成長，只要做好每個當下，每天成長一點點，就是美好的人生。 後來我還買了另一本書，”什麼都能賣出好價錢：頂尖經紀人教你賣什麼都讓人買單“，在看了本書的第一章會認為與”被討厭的勇氣”有許多相似的地方，書中開頭就提到先別管行銷了──第一步該是找到你自己，這樣的開頭以及”被討厭的勇氣”讓我感受到自己的重要性，這樣的生活不僅自由，而且充滿了價值。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"客製化屬於你的 Bootstrap 4","slug":"bootstrap-and-compass","date":"2015-11-30T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/12/01/bootstrap-and-compass/","link":"","permalink":"https://wcc723.github.io/sass/2015/12/01/bootstrap-and-compass/","excerpt":"Bootstrap 是目前最流行的CSS Framework，第四版也釋出了開發版本，無論第幾版對於工程師來說 Bootstrap 就是那麼的容易上手，但扯上設計就要多多配合了，不同身份看待 Bootstrap 也有不同看法，例如： 設計師：Bootstrap 很醜誒，你看那個濁濁的顏色 (當然每個設計師觀點不同啦…)。 前端：Bootstrap 要配合設計師的稿，似乎有點麻煩…(看著對不上的Grid system)。 後端：不是都長一樣嗎？ 其實Bootstrap的設定檔就有許多細節可以調整，不需要 Overwite，載入前就可以先調整，而且並不是一定要全部元件載入，可以只使用部分的元件，靈活的使用框架，才能發揮更大的價值。","text":"Bootstrap 是目前最流行的CSS Framework，第四版也釋出了開發版本，無論第幾版對於工程師來說 Bootstrap 就是那麼的容易上手，但扯上設計就要多多配合了，不同身份看待 Bootstrap 也有不同看法，例如： 設計師：Bootstrap 很醜誒，你看那個濁濁的顏色 (當然每個設計師觀點不同啦…)。 前端：Bootstrap 要配合設計師的稿，似乎有點麻煩…(看著對不上的Grid system)。 後端：不是都長一樣嗎？ 其實Bootstrap的設定檔就有許多細節可以調整，不需要 Overwite，載入前就可以先調整，而且並不是一定要全部元件載入，可以只使用部分的元件，靈活的使用框架，才能發揮更大的價值。 如何開始這個範例會使用 Node.js, Gulp, Compass 所以請先確定有以上環境，其中最重要的是 Compass，有Compass環境，也是可以達到相同的效果。 本篇範例需要以下環境 Ruby compass 1.0 + Node.js Bower Gulp 先運行一次，從中瞭解運作認真的範例：https://github.com/Wcc723/gulp-compass-bootstrap-demo 下載這個範例，目前的結構如下： |- package.json # gulp 的套件管理 |- gulpfile.js # gulp 執行檔案 |- config.rb # compass 設定檔 (重要) |- bower.json # Bower 套件管理 (載入Bootstrap) |- source # 專案資料夾 |- index.html # 範例檔 |- scss # sass 範例檔 |- all.scss |- helper |- variables.scss # Sass 設定檔 在nodejs環境下執行以下指令 $ npm install $ bower install $ gulp 檔案結構改變如下 |- package.json # --- |- gulpfile.js # --- |- config.rb # --- |- bower.json # --- |- bower_components # Bower 下載的套件資料夾 (Bootstrap, Jquery) |- node_modules # node 模組資料夾，這個範例主要是 gulp |- source # --- |- index.html # --- |- scss # --- |- public # ** 編譯完的檔案夾 ** |- index.html # copy 過來的 |- stylesheets # 編譯後的 CSS 在這 |- js # jQuery.js 與 Bootstrap.js 的合併檔 接下來打開/public/index.html可以看到主色被改成 purple，這就是被調整變數後的 Bootstrap，通常網站的設計都會有一個主要色，只要調整_variables.scss中的 $brand-primary，就可以定義Bootstrap的主要顏色。 針對一個變數($brand-primary)調整，按鈕的顏色從藍色被修改成紫色。 打開 config.rb載入 bower bootstrap 的關鍵在於config.rb內的 additional_import_paths，這是 compass 載入外部 sass 檔案的方法，透過這個方法引用 Bootstrap 就像是本地端資料夾引用一樣。 # 匯入 Bootstrap v4 additional_import_paths = &quot;./bower_components/bootstrap/scss/&quot; 調整變數Bootstrap 的變數在 bower_components\\bootstrap\\scss\\_variables.scss，直接複製此檔案到 source\\scss\\ 內。 我的習慣架構是放在 source\\scss\\helpers\\_variables.scss。 以基本色彩來說，原始檔案內會有變數 + 值 + !default，修改只要加入新的值，並移除 !default 即可。 12345$brand-primary: #0275d8 !default;$brand-success: #5cb85c !default;$brand-info: #5bc0de !default;$brand-warning: #f0ad4e !default;$brand-danger: #d9534f !default; 接下來可以看看範例檔案，我調整了其中一個顏色，再載入後，Sass 就會以我的設定檔為優先去編譯它。 m…，其實我是打算顏色全部換掉，後來發現我只加了紫色。 12345$brand-primary: purple;$brand-success: #5cb85c;$brand-info: #5bc0de;$brand-warning: #f0ad4e;$brand-danger: #d9534f; 當會修改顏色以後，可以在看Bootstrap有提供多少的變數供修改。 注意：這份是複製檔，並非最新版 Bootstrap的設定檔 自定載入元件Bootstrap 是一個良好OOCSS範例，所有的CSS元件都模組化，基本上分為以下幾大類型。 變數 (Core variables and mixins)：這邊是基本設定，建議載入 重置 (Reset and dependencies)：主要是讓HTML標籤樣式一致，建議載入，有需求可透過變數修改 核心 CSS (Core CSS)：主要、常用的 CSS 元件 (Components)：基於核心或是Web經常使用的CSS元件，可以選擇是否載入 JavaScript 套件 (Components w/ JavaScript)：好用的 Bootstrap js 套件，如果沒有需求可以不載入 雜項 (Utility classes)：主要是單一的CSS樣式，建議載入 接下來再打開 source\\scss\\all.scss，Sass載入 Bootstrap 的方式也有兩種，一種是全部載入，另一種是載入特定元件。 如果要移除不要的元件，請選擇方法二，並將不要的元件直接刪除或是註解即可 1234567891011121314151617181920212223242526272829303132333435// import 自己的變數@import \"helpers/variables\";// **** 方法一：載入全部的Bootstrap 4 **** ////// @import \"bootstrap\";// **** 方法二：自選要的元件 **** ////// Core variables and mixins@import \"variables\";@import \"mixins\";// Reset and dependencies@import \"normalize\";@import \"print\";// Core CSS@import \"reboot\";@import \"type\";@import \"images\";@import \"code\";@import \"grid\";@import \"tables\";@import \"forms\";@import \"buttons\";// Components@import \"animation\";@import \"dropdown\";@import \"button-group\";@import \"input-group\";//...... 略 Bootstrap 是很重視行動版的框架，但有時在行動版上，有時少可以再更少，如果想減少載入的 CSS 不妨從元件、js套件上開始移除。 優缺點這樣做法可以節省大量的時間，並且減少CSS的錯誤(相容性、延展性等等)，但有些問題也是必須去思考： 優點： 快速建置 相對穩定 減少對不上的問題 (相信很多人有 input 和 button 對不上的問題) 工程師套用容易 缺點 環境建置學習成本較高 雖然可以自訂，但想法容易被侷限 必須花一定的時間成本學習 Bootstrap (尤其是需要自定義元件時) Bootstrap 4 觀察了一段時間，裡面許多的概念很喜歡，包括 flex、navbar、Utilities 這些的改進…，當然更重要的是從LESS轉到SASS(雖然他用的是node sass lib，但我總是用 ruby sass 去載入)。 不過也有一點真心覺得麻煩，就是他的單位許多改成用rem，em、rem、px轉來轉去，我不是數學腦啊!!!","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"bootstrap","slug":"bootstrap","permalink":"https://wcc723.github.io/tags/bootstrap/"},{"name":"compass","slug":"compass","permalink":"https://wcc723.github.io/tags/compass/"}]},{"title":"過去的學習 每天一分享","slug":"ashareaday","date":"2015-11-27T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"tools/2015/11/28/ashareaday/","link":"","permalink":"https://wcc723.github.io/tools/2015/11/28/ashareaday/","excerpt":"很多人會問我設計師怎麼轉工程師，主要的方式當然是每天練啊！ (故事回到了2013…)當時會的不多，基本的CSS(還有一些些sass)、簡單的jquery，不會任何框架，所有的技術都很基本，那時給自己的目標是連續一百天發文…。","text":"很多人會問我設計師怎麼轉工程師，主要的方式當然是每天練啊！ (故事回到了2013…)當時會的不多，基本的CSS(還有一些些sass)、簡單的jquery，不會任何框架，所有的技術都很基本，那時給自己的目標是連續一百天發文…。 一個奇怪的 SPASPA(sigle page application)這種名詞也是現在才知道，當時只是想要快速建立一個站點，讓我方便練習技術，所以就花一天的時間透過Javascript寫出怪異的Blog。 當時也不會 git，更別說github，所以網站是放在自己買的空間上，而空間後來也就沒有再付費，所以就關閉了…。 A share a day這個網站我稱為 Ashareaday，用意就是為了每天分享，就算是只有一點點，也要持續的進步。網站後來的主要內容大多都被轉移到現在這部落格上，所以也就沒有再將它建立起來。 現在，有人詢問我怎麼開始學習前端時，總是會想到這一個站，所以現在轉移到 Github Page 上，如果有人詢問時，可以再繼續分享這樣的過去。 網站連結：http://wcc723.github.io/ashareaday/","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"更棒的 Jekyll 編寫工具","slug":"better-jekyll-markdown-editor","date":"2015-11-24T16:00:00.000Z","updated":"2016-10-13T06:29:40.000Z","comments":true,"path":"tools/2015/11/25/better-jekyll-markdown-editor/","link":"","permalink":"https://wcc723.github.io/tools/2015/11/25/better-jekyll-markdown-editor/","excerpt":"這個Blog也維持很長一段時間了，曾經會想要放棄維護轉到其它平台，主要原因是Jekyll上稿有些麻煩的地方，其中一項最痛的就是上圖…。在上圖之前，都必須先將圖片放到/images，接下來再手動寫相對位置，如果圖片要換，就必須再打開/images資料夾，一來一往必須花很多時間。 最近發現了Atom編輯器有套件可以自動把圖片搬移到該資料夾，並且還有許多Jekyll的輔助功能，讓我可以更專注於Blog的文章內容。 如果您跟我一樣是 Jekyll 的使用者，相信你會很喜歡這編輯工具。 圖片來自於 Atom 官網","text":"這個Blog也維持很長一段時間了，曾經會想要放棄維護轉到其它平台，主要原因是Jekyll上稿有些麻煩的地方，其中一項最痛的就是上圖…。在上圖之前，都必須先將圖片放到/images，接下來再手動寫相對位置，如果圖片要換，就必須再打開/images資料夾，一來一往必須花很多時間。 最近發現了Atom編輯器有套件可以自動把圖片搬移到該資料夾，並且還有許多Jekyll的輔助功能，讓我可以更專注於Blog的文章內容。 如果您跟我一樣是 Jekyll 的使用者，相信你會很喜歡這編輯工具。 圖片來自於 Atom 官網 如何使用在開始前，必須先安裝Atom，這是Github所開發的編輯器，大致上與 sublime text 3 相當接近，但對於套件的管理更為直覺，而且還可以容易的安裝各種 Theme(?。本篇就是要介紹他其中一個套件Markdown-Writer。 安裝 Atom 安裝 Markdown-Writer 所以先到Atom的官網下載 Atom 安裝吧。 安裝 Markdown-WriterAtom 的使用相當直覺，只要直接選擇 Perferences(cmd + ,)就可以打開設定，其中就可以找到套件安裝(Install Packages)，如下圖就可以搜尋到Markdown-Writer，再按下 install 就會開始安裝(這邊我已經裝囉)。 設定 Markdown-Writer設定最重要的…Blog路徑，這如果沒有設定，等等也玩不下去。一樣在設定內可以找到 Packages，列表上可以找到剛剛安裝的 Markdown-Writer。 Site Local Directory 這就是必要的設定，這請填入 Jekyll Blog 的本地位置。 在開始使用前，在介紹一下快捷鍵的設置。在 command(cmd + shift + p) 執行 Markdown Writer: Create Default keymaps。 再把下面的 code 找地方貼進去，這樣就可以運行 Markdown Writer 所提供的快捷鍵。 &quot;.platform-darwin atom-text-editor[data-grammar~=&apos;gfm&apos;]&quot;: &quot;shift-cmd-K&quot;: &quot;markdown-writer:insert-link&quot; &quot;shift-cmd-I&quot;: &quot;markdown-writer:insert-image&quot; &quot;cmd-i&quot;: &quot;markdown-writer:toggle-italic-text&quot; &quot;cmd-b&quot;: &quot;markdown-writer:toggle-bold-text&quot; &quot;cmd-&apos;&quot;: &quot;markdown-writer:toggle-code-text&quot; &quot;cmd-k&quot;: &quot;markdown-writer:toggle-keystroke-text&quot; &quot;cmd-h&quot;: &quot;markdown-writer:toggle-strikethrough-text&quot; &quot;ctrl-alt-1&quot;: &quot;markdown-writer:toggle-h1&quot; &quot;ctrl-alt-2&quot;: &quot;markdown-writer:toggle-h2&quot; &quot;ctrl-alt-3&quot;: &quot;markdown-writer:toggle-h3&quot; &quot;ctrl-alt-4&quot;: &quot;markdown-writer:toggle-h4&quot; &quot;ctrl-alt-5&quot;: &quot;markdown-writer:toggle-h5&quot; &quot;shift-cmd-O&quot;: &quot;markdown-writer:toggle-ol&quot; &quot;shift-cmd-U&quot;: &quot;markdown-writer:toggle-ul&quot; &quot;shift-cmd-&gt;&quot;: &quot;markdown-writer:toggle-blockquote&quot; &apos;shift-cmd-&quot;&apos;: &quot;markdown-writer:toggle-codeblock-text&quot; &quot;cmd-j cmd-p&quot;: &quot;markdown-writer:jump-to-previous-heading&quot; &quot;cmd-j cmd-n&quot;: &quot;markdown-writer:jump-to-next-heading&quot; &quot;cmd-j cmd-d&quot;: &quot;markdown-writer:jump-between-reference-definition&quot; &quot;cmd-j cmd-t&quot;: &quot;markdown-writer:jump-to-next-table-cell&quot; 使用 Markdown-Writer在建立一個 Markdown 的檔案後，就可以嘗試插入圖片 cmd + shift + i，選擇圖片後，再勾選 Copy Image to Site Image Directory，這樣就能夠把其他位置的圖片直接移動到/images資料夾內，並且會自動新增 年/月 資料夾。 (光是這個功能就足以讓我痛哭流涕…) 其他功能在使用時會感受到，例如： 程式碼標記自動插入頭尾 (`) 快捷鍵控制各種文字標記 ex: cmd + h 文字加入刪除線 還有超多功能可以在設定裡找到…(太多了，記不住) Markdown-Writer 可能出現的錯誤在第一次使用時，可能是Atom版本較舊，所以出現錯誤，這時候建議先更新Atom，並且先 Disabled 套件後解除安裝，再重新安裝 Markdown-Writer 套件。 這段時間也研究了很多部落格平台，考慮的原因也很多，最後決定繼續維護目前的 Jekyll，原因有下： 平台的 Editor 是否好用，難寫的根本撐不下去 (超重要) 平台的費用，平台是否有另外買網址的必要 (github.io 根本潮) 平台的使用者數量 (Jekyll 有 Github 罩) 不論用哪種平台，都必須思考平台未來的發展 (什麼時候會消失，文章是否能匯出) 基於這些原因，最後還是認為 Jekyll 適合我，也因此特別將Blog版型更新了一翻(雖然還有很多Bug Q_Q)…。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"將 Sketch icons 轉成 web icon fonts","slug":"sketch-convert-to-web-icon-fonts","date":"2015-11-19T16:00:00.000Z","updated":"2016-10-13T06:29:11.000Z","comments":true,"path":"tools/2015/11/20/sketch-convert-to-web-icon-fonts/","link":"","permalink":"https://wcc723.github.io/tools/2015/11/20/sketch-convert-to-web-icon-fonts/","excerpt":"在之前轉web font icons 通常是使用Icomoon，他提供不錯的介面以及大量的icons供開發者使用，但有些時候Icomoon並不符合我們的需求，例如： 公司專案，不宜上傳到第三方空間 有版本控管需求時 設計師控制慾很強時(? 而萬能的Sketch及Gulp再合體之後，就有了Sketch to icon fonts 的功能，只要轉一次，同時提供了： icon fonts 字型檔 寫好的css檔 還有HTML使用範本 對於前端以及設計師簡直接就是一大福音。","text":"在之前轉web font icons 通常是使用Icomoon，他提供不錯的介面以及大量的icons供開發者使用，但有些時候Icomoon並不符合我們的需求，例如： 公司專案，不宜上傳到第三方空間 有版本控管需求時 設計師控制慾很強時(? 而萬能的Sketch及Gulp再合體之後，就有了Sketch to icon fonts 的功能，只要轉一次，同時提供了： icon fonts 字型檔 寫好的css檔 還有HTML使用範本 對於前端以及設計師簡直接就是一大福音。 如何使用寫得很清楚的開發文件：https://github.com/cognitom/symbols-for-sketch 在開始前，請先確認有以下環境： Mac 正版的Sketch Node.js 有gulp更好 Sketch 是這次主要來輸出icons的繪圖軟體，由於只能在Mac上運行，所以Mac也是必須的，本文最後會在介紹直接使用.svg轉icon fonts的方法；Node.js是用來運行gulp的環境，如果還沒安裝可以直接到官網下載https://nodejs.org/en/；Gulp是這次的主角，負責將sketch轉成icon fonts的工具，如果熟悉javascript的開發者將會很容易上手，當然不熟也沒關係，本文會用圖文說明以下的步驟。 安裝Node.js如果你還沒安裝Node.js，就到官網找到下載點，目前的版本有4.2.2及5.1.0，不管你是哪個版本，與本次的實作影響都不大。 安裝完以後再打開 Terminal 輸入以下指令，只要有跳出版本號就算成功了(我的版本追不上時代啊～)。 $ node -v 如果還沒安裝gulp，可以順便安裝，指令如下： $ npm install gulp -g 如果不行請加 `sudo` 在前方 $ sudo npm install gulp -g 在npm 前方加入sudo代表最高權限，通常只有在安裝全域(-g, -global)才有可能使用。 下載專案接下來到https://github.com/cognitom/symbols-for-sketch把專案抓下來，如果熟悉git的開發者可以使用git指令將repo抓下來；另一種更潮的方式，就是直接選擇網站上下角的Download zip。 下載後請解壓縮它。 再次打開你的 Terminal，剩下簡單的三步驟就完成了打開Terminal後，請到剛剛下載的資料夾，如果不熟可以參考以下這個指令(我常常把檔案丟桌面，所以以下指令是針對放在桌面上的)。 $ cd /Users/*****/Desktop/symbols-for-sketch-master 安裝node gulp 相依套件這個步驟是要將gulp相依的套件從網路上抓下來，相依套件同時會放在這個資料夾(node_modules)。 $ npm install 安裝Sketch tool這有兩個方法，其中一種是使用指令，但在測試時沒有成功，所以這邊是使用方法二。 方法一：直接輸入以下指令，我沒成功… $ npm run installtool 方法二：先下載http://sketchtool.bohemiancoding.com/sketchtool-latest.zip，解壓縮後到該資料夾，輸入以下指令： $ cd ~/Downloads/sketchtools/ $ sudo ./install.sh 將Sketch轉成icon fonts最後，透過gulp指令結束這個回合吧！ $ gulp symbols 到剛剛的資料夾，資料夾內增加了dist以及編譯完成的字型檔、CSS以及範例的html。 範例的HTML可以看到成果。 將.svg 轉成icon fonts以上的Sketch轉icons如果有成功，接下來的.svg轉icons也是相當容易，只要用相同的模組改幾行程式碼就可以運行。不過要注意的是這有可能編譯失敗(原因很多，包含svg的檔案也有可能造成編譯失敗)。 這邊是使用Google Material Design 所提供的 icon，直接放在剛剛的資料夾內即可。 接下來打開gulpfile.js，找到以下幾行替換成gulp.src([&#39;./svg/*.svg&#39;]) (路徑可以自行決定)。 12345678gulp.task('symbols', function()&#123; //gulp.src('symbol-font-14px.sketch') // 將原本轉換sketch的改成轉svg //.pipe(sketch(&#123; // export: 'artboards', // formats: 'svg' //&#125;)) gulp.src(['./svg/*.svg'])&#125;) 和先前的一樣，在 Terminal 輸入 $ gulp symbols 就可以了。 $ gulp symbols 完成～ 在以前都是使用 Icomoon 的服務再轉 web fonts，最早的時候還忘記要登入，結果整份 web fonts資料都要重建，透過這樣的工具可以自己轉、自己做版控，除了CDN的問題外，倒是挺方便的。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"},{"name":"icon fonts","slug":"icon-fonts","permalink":"https://wcc723.github.io/tags/icon-fonts/"},{"name":"sketch","slug":"sketch","permalink":"https://wcc723.github.io/tags/sketch/"}]},{"title":"SVG 客製化 checkbox","slug":"styling-checkbox","date":"2015-10-18T16:00:00.000Z","updated":"2016-10-13T06:28:27.000Z","comments":true,"path":"tools/2015/10/19/styling-checkbox/","link":"","permalink":"https://wcc723.github.io/tools/2015/10/19/styling-checkbox/","excerpt":"先前有看到酷炫的checkbox效果，一直想要做看看，最近在整理資料的時候發現還沒做(因為坑還很多)，這次就來介紹這樣的效果要怎麼完成。","text":"先前有看到酷炫的checkbox效果，一直想要做看看，最近在整理資料的時候發現還沒做(因為坑還很多)，這次就來介紹這樣的效果要怎麼完成。 在很久之前有寫一篇文章，是透過svg的stroke做動態描繪效果(CSS + SVG stroke動態描繪)，本篇也是利用類似的方法達成，另外還有參考一些文章。 參考 http://tympanus.net/Development/AnimatedCheckboxes/ http://blogs.adobe.com/dreamweaver/2015/08/css-vs-svg-styling-checkboxes-and-radio-buttons.html 先準備svg 這一個範例的重點還是在svg，最簡單的產生方式還是使用向量繪圖軟體繪製，在這個範例上是透過sketch繪製 50px * 50px的手繪風格路徑，在繪製的時候有些部分還是需要注意： 圖片大小與實際圖最好一樣大 盡量一個筆畫到底，如果兩個筆畫要做出先後效果，可以設定 transition delay 路徑的頭尾先後與繪製的先後順序有關 再轉成svg後僅需要原始碼，所以請用文字編輯器打開 .svg，接下可以參考以下的HTML結構，把 .svg的內容置入。 1234567&lt;input type=\"checkbox\" id=\"checkbox\"&gt;&lt;label for=\"checkbox\" class=\"label\"&gt; Click me &lt;svg width=\"50px\" height=\"50px\" viewBox=\"0 0 50 50\" class=\"checkbox-draw\"&gt; &lt;!-- 剛剛轉出的svg請放這 --&gt; &lt;/svg&gt;&lt;/label&gt; CSSCSS的重點一個部分是checkbox的選取器，透過 :checked ~ 來控制後方的svg動畫是否啟用。 另一個重點就是 stroke-dashoffset: 500; 及 stroke-dasharray: 500; ，這就是效果繪製的重點，相關的細節可以參考http://wcc723.github.io/svg/2014/06/15/svg-css-stroke-animation/，只要將stroke-dashoffset的值修改為0，就會有描繪動畫的效果。 12345678910111213141516171819202122232425262728#checkbox &#123; opacity: 0; width: 50px; height: 50px;&#125;.label &#123; position: relative; display: inline-block; padding-left: 50px; cursor: pointer; font-size: 36px;&#125;.checkbox-draw &#123; width: 50px; height: 50px; position: absolute; left: -50px; top: 0; border: 2px solid white;&#125;.checkbox-draw path&#123; stroke-dashoffset: 500; stroke-dasharray: 500; transition: stroke-dashoffset .5s linear;&#125;#checkbox:checked ~ label .checkbox-draw path &#123; stroke-dashoffset: 0;&#125; 完成效果記得點一下看效果唷。 範例網址","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"Hotjar 網站熱圖","slug":"hotjar-heat-map","date":"2015-10-06T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"tools/2015/10/07/hotjar-heat-map/","link":"","permalink":"https://wcc723.github.io/tools/2015/10/07/hotjar-heat-map/","excerpt":"Hotjar 是監視網站使用者資訊的工具，提供 Heatmap、Recording、Funnels、Forms 四種監測服務，透過這四種服務可以分析使用者行為，判斷使用者操作是否符合預期。","text":"Hotjar 是監視網站使用者資訊的工具，提供 Heatmap、Recording、Funnels、Forms 四種監測服務，透過這四種服務可以分析使用者行為，判斷使用者操作是否符合預期。 服務：https://www.hotjar.com/ 註冊在註冊時分為兩個步驟，第一階段是一般註冊資訊，第二階段會要求建立要監測的站台，如果還沒有站台，其實先隨意填也沒關係，在註冊後還是可以修改。 測試 heatmap登入到Dashborad後，他會要求在網站內加入一段 &lt;script&gt; ，這段需要有在線上的網站才能夠運行，本文先以這 http://wcc723.github.io/ 做為測試，將以下 &lt;script&gt; 加入網站的主版。 另外加入後，他會有一個 驗證script 按鈕，驗證網頁是否有正確加入，如果正確就會詢問出現以下畫面，讓開發者選擇服務。 接下來開一個 Heatmap 服務，操作上也相當容易，只要填入名稱、網址即可。 接下來靜置個一段時間…，不然就是自己動手測試(Blog太久沒更新流量降低 orz…)就可以獲得一些些data。 最後就可以獲得以下的熱點圖，而目前這個blog版型是使用 Material design lite，在scroll上有些bug，因此監測scroll的準確度很低，如果要正常使用，網頁的scroll也必須注意。 Manage up to 3 Heatmaps with Hotjar Basic. Need more? Delete old Heatmaps or go unlimited. 基本版提供三個Heatmap服務 Recording這個工具用影片的方式呈現使用者的行為，啟用以後就可以進行全站錄製，但和heatmap一樣，目前本blog有scroll的bug ＝ ＝…，所以沒辦法錄得很好，只能先體驗一下。 監視工具還會提供使用者的基本資料，如國家、裝置、瀏覽器、系統還有操作時間等等，只要點 PLAY ，就可以預覽錄製的影片。 就這樣使用者的行為被開發者摸得一清二楚!? Manage up to 300 recordings with Hotjar Basic. Need more? Delete old recordings or go unlimited. 基本版提供300個影片紀錄 由於本 Blog 不適合繼續玩 Funnel、Form 所以只能留給大家自己玩了。 許多時候設計師和工程師在介面上各有意見時，不仿試試看監測工具，分析使用者的行為，或許使用者操作會超乎所有開發者的預期。而相關的工具也越來越多，只能多方嘗試，選定合適才是上策。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"動手玩 CSS，快速學會Flex","slug":"css-flex","date":"2015-08-13T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/08/14/css-flex/","link":"","permalink":"https://wcc723.github.io/css/2015/08/14/css-flex/","excerpt":"上次製作了CSS column的範例，對於學習CSS column可以快速地瞭解(但實際運用相信坑非常多)，這次用angular製作了flex的範例，讓大家透過動手玩來快速瞭解這是怎樣的坑。","text":"上次製作了CSS column的範例，對於學習CSS column可以快速地瞭解(但實際運用相信坑非常多)，這次用angular製作了flex的範例，讓大家透過動手玩來快速瞭解這是怎樣的坑。 簡單範例在學理論之前，我們先動手玩一次，再來理解各個屬性的用途。而這份範例分為上下兩部分，上部分是Flex 的外容器，下半部是Flex 元件的設定。 Flex 容器Flex的容器，這部分選項較少，這範例是反覆測試後，認為比較有明顯效果的。 範例連結 Flex 屬性align-items這物件垂直對齊的屬性 flex-start : 緊靠起始的邊界 flex-end : 靠近終點的邊界 center : 對齊中間 baseline : 對齊基線 (line-height) stretch : 延展 (本範例不適合) justify-content這是物件水平對齊的屬性 flex-start : 緊靠起始的邊界 flex-end : 靠近終點的邊界 center : 對齊中間 space-between : 平均分配空間 space-around : 平均分配空間，且包含與邊界的距離 stretch : 延展 (本範例不適合) flex-direction決定物件的排列方向 row : 水平 row-reverse : 水平反轉 column : 垂直 column-reverse : 垂直反轉 flex-wrap容器的換行模式，在本範例需縮小視窗。 nowrap : 堅決不換行 wrap : 如果超過空間就換行 wrap-reverse : 換行還要後面的往前排 (請縮小視窗) Flex 元件這部分可以自由增減元件，試著去調整每個元件的屬性，或者配合外容器，看看彼此之間的關係。 範例連結 Flex 屬性flex這個屬性在本範例並沒有列出來，他其實是包含了以下三個屬性。 &lt;&apos;flex-grow&apos;&gt; &lt;&apos;flex-shrink&apos;&gt;? || &lt;&apos;flex-basis&apos;&gt; ] 所以在本範例中，就直接提供以下三個屬性的各別調整。 flex-basisflex屬性的基準值，值可以是各種單位數值，如10px、10%、10vh。 但如果沒有單位，僅有數值，那代表的是等份，如有三個元件的flex-basis分別為 1、1、2，那麼他們分別的大小則為 四分之一、四分之一、四分之二。 flex-growflex-grow、flex-shrink，建議調整視窗大小玩看看。 元件的伸展比率，預設值為1，如果說設定為0，代表元件尺寸不會大於flex-basis的值。 flex-shrink元件的收縮比率，預設值為1，如果說設定為0，代表元件尺寸不會小於flex-basis的值。 所以flex-grow、flex-shrink都設定為0，代表元件不會縮放。 align-self和外容器的align-items的屬性類似，但是只能控制元件本身的對齊。 結語以前有寫過Flex文章，有些時候偷懶都會用flex來排垂直置中的物件，而上次製作了css column，就會引發更多的思考，column可以拿來排什麼；這次的flex也是一樣的道理，直接動手玩一次，能更了解每個屬性的用途，等到機會來臨，就可以輕鬆上手。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"隨意玩玩的 nw.js","slug":"nwjs-build-web-app","date":"2015-08-12T16:00:00.000Z","updated":"2016-10-13T06:24:45.000Z","comments":true,"path":"web/2015/08/13/nwjs-build-web-app/","link":"","permalink":"https://wcc723.github.io/web/2015/08/13/nwjs-build-web-app/","excerpt":"之前就有聽說 web可以上桌面應用程式，也找到相關的工具，這次就是把實驗的成果記錄下來。","text":"之前就有聽說 web可以上桌面應用程式，也找到相關的工具，這次就是把實驗的成果記錄下來。 安裝nw.js環境http://nwjs.io/ 到官網下載指定版本的工具，由於我是使用mac，最後結果是可行的，但windows等其他環境我就都沒有試過。 下載後直接安裝到Mac OS應用程式內就可以了。 下載範例包https://github.com/zcbenz/nw-sample-apps 這個測試包可以快速瞭解是否有成功，實際上我也沒寫過(遮臉)。 下載後解壓縮內容大概如上，接下來在這個路徑下打開Terminal，輸入以下指令nw.js就會直接打開desktop web app。 $ /Applications/nwjs.app/Contents/MacOS/nwjs {資料夾名稱} 像這樣輸入以上指令，就可以打開應用程式。 這是控制應用程式導覽列的範例。 除此之外這包還有許多不錯的範例，像是Camera…，如果有興趣可以自己打開來看看。","categories":[{"name":"web","slug":"web","permalink":"https://wcc723.github.io/categories/web/"}],"tags":[{"name":"web","slug":"web","permalink":"https://wcc723.github.io/tags/web/"}]},{"title":"CSS column 教學","slug":"css-column","date":"2015-07-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/07/23/css-column/","link":"","permalink":"https://wcc723.github.io/css/2015/07/23/css-column/","excerpt":"CSS column對於文字排版有很大的幫助，就類似Adobe indesign在文字排版時，只要指定文字欄數，再將文字全部匯入即可。這樣在文字編排時則會以內容為優先，並非受限於html規則。","text":"CSS column對於文字排版有很大的幫助，就類似Adobe indesign在文字排版時，只要指定文字欄數，再將文字全部匯入即可。這樣在文字編排時則會以內容為優先，並非受限於html規則。 簡單範例可以直接透過以下範例，操作互動來了解CSS column各個屬性的操作結果，試試看以後再來了解各屬性的用途。 column-count auto 1 2 3 4 5 column-width 100px 150px 200px 250px 300px column-gap 0 5px 10px 15px 20px 30px column-rule-style none solid dashed dotted column-rule-width 0 1px 2px 5px 8px column-rule-color h3 : column-span none all column-break-inside： auto avoid column-break-before： auto always avoid left right column-break-after： auto always avoid left right 高溫狀況越來越容易發生！ 根據美國的氣象資料顯示，今年6月全球平均氣溫、上半年全球均溫、陸溫及海溫都創新高，昨天台灣因西南風沉降作用的關係也熱得發燙，新竹高溫飆上37度，創下當地今夏最高溫紀錄。氣象局預報中心主任鄭明典說，高溫狀況越來越容易發生！ 台灣溫度趨勢和全球變化一致，氣象局長期預報課李明營表示，上半年台灣均溫比氣候值高出0.68度，今年6月均溫則達29.53度，比平均氣候值高1.95度，是1947年以來最熱的6月。他說台灣今年6月均溫飆高的原因和太平洋副高壓強勁有關，但導致太平洋副高增強主因有待探究。 昨天中午新竹出現37度高溫，刷新當地今夏最高紀錄，鄭明典表示，當時西南風轉偏南風，中部以北的西半部地區以離岸風為主，海風吹不進來，加上雲量偏低，氣溫便飆高，「近年趨勢是，高溫狀況越來越容易發生！」 所幸高溫的情形在今天會有所改善，氣象局預報員張心華表示，隨著華南低壓帶逐漸往東移出，今天水氣和雲量增加，溫度會略降1至2度，但沒下雨的時候，北部有機會達35度左右。 今天中南部降雨範圍廣，北部及澎湖、金門和馬祖則有局部短暫雨，午後各地有機會出現雷陣雨，且易伴隨瞬間大雨、雷擊、強陣風和溪水暴漲；沿海地區易有9至10級強陣風，西南部及恆春半島沿海易有長浪發生，提醒民眾留意。 高溫狀況越來越容易發生！ 根據美國的氣象資料顯示，今年6月全球平均氣溫、上半年全球均溫、陸溫及海溫都創新高，昨天台灣因西南風沉降作用的關係也熱得發燙，新竹高溫飆上37度，創下當地今夏最高溫紀錄。氣象局預報中心主任鄭明典說，高溫狀況越來越容易發生！ 台灣溫度趨勢和全球變化一致，氣象局長期預報課李明營表示，上半年台灣均溫比氣候值高出0.68度，今年6月均溫則達29.53度，比平均氣候值高1.95度，是1947年以來最熱的6月。他說台灣今年6月均溫飆高的原因和太平洋副高壓強勁有關，但導致太平洋副高增強主因有待探究。 昨天中午新竹出現37度高溫，刷新當地今夏最高紀錄，鄭明典表示，當時西南風轉偏南風，中部以北的西半部地區以離岸風為主，海風吹不進來，加上雲量偏低，氣溫便飆高，「近年趨勢是，高溫狀況越來越容易發生！」 所幸高溫的情形在今天會有所改善，氣象局預報員張心華表示，隨著華南低壓帶逐漸往東移出，今天水氣和雲量增加，溫度會略降1至2度，但沒下雨的時候，北部有機會達35度左右。 今天中南部降雨範圍廣，北部及澎湖、金門和馬祖則有局部短暫雨，午後各地有機會出現雷陣雨，且易伴隨瞬間大雨、雷擊、強陣風和溪水暴漲；沿海地區易有9至10級強陣風，西南部及恆春半島沿海易有長浪發生，提醒民眾留意。 屬性說明column-count這屬性只要直接填入數值即可，用來定義欄位數量。 column-widthcolumn-count及column-width只能二擇一，前者是直接定義欄位數量，後者則是定義欄位寬度。 column-gap欄位空隙寬度。 column-rule-style欄與欄之間的border樣式。 column-rule-width欄與欄之間的border寬度。 column-rule-color欄與欄之間的border色彩。 column-span設定指定元素不受column影響。(可以使用在標題或是重要的文字上) column-break-inside文字換欄設定 auto: 自動 avoid: 文字段落結束後才換欄 column-break-before, column-break-after指定元素的前後是否強制換欄。可以放在整個段落的前後 $(document).ready(function(){ var column = 'column-count'; var columnProps = ['column-count', 'column-width', 'column-gap', 'column-rule-width', 'column-rule-style', 'column-rule-color', ]; var h3columnProps = 'column-span'; var columnBreakInside = 'column-break-inside'; var breakColumnProps = [ '', 'column-break-before', 'column-break-after' ]; $.each(columnProps, function(i, prop){ console.log($('#'+prop)); $('#'+prop).on('change', function(){ console.log('a'); var val = $(this).val(); $('.column-demo').css(prop, val); }); }); $.each(breakColumnProps, function(i, prop){ console.log($('#'+prop)); $('#'+prop).on('change', function(){ console.log('a'); var val = $(this).val(); $('.columnBreak').css(prop, val); }); }); $('#'+columnBreakInside).on('change', function(){ console.log('a'); var val = $(this).val(); $('.column-demo p').css(columnBreakInside, val); }); $('#'+h3columnProps).on('change', function(){ console.log('a'); var val = $(this).val(); $('.column-demo h3').css(h3columnProps, val); }); });","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"用CSS呈現影像比對效果","slug":"image-comparison-slider","date":"2015-07-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/07/22/image-comparison-slider/","link":"","permalink":"https://wcc723.github.io/css/2015/07/22/image-comparison-slider/","excerpt":"http://lea.verou.me/這位工程師的CSS能力非常優異，他的blog有很多意想不到的效果(而且是個正妹)，這邊來分享他的其中一個效果。","text":"http://lea.verou.me/這位工程師的CSS能力非常優異，他的blog有很多意想不到的效果(而且是個正妹)，這邊來分享他的其中一個效果。 本篇來源：http://lea.verou.me/2014/07/image-comparison-slider-with-pure-css/ 範例Lea Verou 這個範例中並沒有使用到js，並且用少量的css就能達到效果，其中的resize:是關鍵的屬性，這可以讓使用者控制範圍大小，這個屬性讓div像 textarea一樣。 12345678&lt;div class=\"d0722 demo\"&gt; &lt;div class=\"image-slider\"&gt; &lt;div&gt; &lt;img src=\"/images/2015-07-22_demoimage01.jpg\" alt=\"\"&gt; &lt;/div&gt; &lt;img src=\"/images/2015-07-22_demoimage02.jpg\" alt=\"\"&gt; &lt;/div&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233.image-slider&#123; // 外部容器定位 position: relative; display: inline-block; // 上層的最大範圍不會超過image line-height: 0; &amp; &gt; div &#123; // 內部上層影像容器 position: absolute; top: 0; bottom: 0; left: 0; width: 25px; max-width: 100%; overflow: hidden; resize: horizontal; //使用者可以重新調整區塊大小 &amp;:before &#123; // 右下方提示可縮放的示意三角形 content: ''; position: absolute; right: 0; bottom: 0; width: 13px; height: 13px; padding: 5px; background: linear-gradient(-45deg, white 50%, transparent 0); background-clip: content-box; cursor: ew-resize; -webkit-filter: drop-shadow(0 0 2px black); filter: drop-shadow(0 0 2px black); //使用filter 可以用圖示輪廓做陰影 &#125; &#125; img &#123; user-select: none; //圖片無法被選擇 max-width: 400px; &#125;&#125; 後記本站重新改變了風格，也是重新開始新的篇章(版型來源)，接下來繼續來寫CSS吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"壓縮css的終極必殺技","slug":"gulp-uncss","date":"2015-05-05T16:00:00.000Z","updated":"2016-10-13T03:57:25.000Z","comments":true,"path":"gulp/2015/05/06/gulp-uncss/","link":"","permalink":"https://wcc723.github.io/gulp/2015/05/06/gulp-uncss/","excerpt":"CSS 再怎麼開起開壓縮，頂多縮個幾十k，uncss可以搜尋html內所用的class、id，再將.css內的多餘class or id移除，達到最佳化的壓縮。","text":"CSS 再怎麼開起開壓縮，頂多縮個幾十k，uncss可以搜尋html內所用的class、id，再將.css內的多餘class or id移除，達到最佳化的壓縮。 注意雖然標題很聳動，但是有個問題比較麻煩，就是他無法偵測動態產生的標籤，像是js產生的，所以在移除時可能會有些錯誤…。uncss有提供解決的方案，就是使用忽略，但實際上有可能自己都忘記忽略。 使用gulp在先前的文章有介紹過gulp，本篇也是會用gulp。 首先先安裝gulp-uncss $ npm install gulp-uncss –save-dev 簡單使用npm可參考:https://www.npmjs.com/package/gulp-uncss 文件:https://github.com/giakki/uncss#within-nodejs 1234567891011var gulp = require('gulp');var uncss = require('gulp-uncss');gulp.task('default', function() &#123; return gulp.src('site.css') //輸入的css .pipe(uncss(&#123; html: ['index.html', 'posts/**/*.html', 'http://example.com'], //檢查的頁面(網址也可) ignore: ['.ui-datepicker','dropdown'] // 忽略的class or id &#125;)) .pipe(gulp.dest('./out')); //輸出&#125;); 壓縮範例如下這次的壓縮並沒有針對js的問題加以修正，僅是範例而已。 壓縮前 壓縮後 透過這個方法，可以有效的壓縮css，但其實在使用上並沒有那麼容易(需要補上ignore)。","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"}]},{"title":"關於學習","slug":"about-study","date":"2015-04-29T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"study/2015/04/30/about-study/","link":"","permalink":"https://wcc723.github.io/study/2015/04/30/about-study/","excerpt":"在學習上和以前看法有很大的不同，以前讀書是為了分數，但我本來功課就不好，也對分數沒什麼追求，只要勉強及格就好，記得在復興商工(復興美工)的時候，每年祈禱不要留級就好…。 現在學習比以前更有成就感，認真學習可以效率更高、拿到更好的薪水、甚至認識更多的高手。不過就這幾年來的心得，學習並不是短時間所達到的，是長時間的累積，所以通常我會採取以下作法：","text":"在學習上和以前看法有很大的不同，以前讀書是為了分數，但我本來功課就不好，也對分數沒什麼追求，只要勉強及格就好，記得在復興商工(復興美工)的時候，每年祈禱不要留級就好…。 現在學習比以前更有成就感，認真學習可以效率更高、拿到更好的薪水、甚至認識更多的高手。不過就這幾年來的心得，學習並不是短時間所達到的，是長時間的累積，所以通常我會採取以下作法： 1. 長期習慣：在生活習慣上，每天都有固定的行程，像是上下班都是搭乘捷運，這個時間盡量別使用手機，多去看周圍的事物，也可以多思考近期內的計畫，畢竟每天看電腦的時間已經夠長了，再搭捷運、走路的時間可以讓腦袋放鬆，以及發現有趣的事物。 到了晚上，通常也不會讓自己過於勞累，工作一整天已經很疲憊了，就行程上不能過度，一般而言行程會是用餐 -&gt; 散步 -&gt; 自由安排 -&gt; 洗澡 -&gt; 睡覺。每天用餐完我都會固定散步一段時間，除了散步也可以補充一些日常生活用品，這屬於讓腦袋較為放鬆的時間，也可多與家人聊天。 接下來，每天如果還有重要工作，就會在散步完在做，然後一直到睡覺前的一段時間，我會閱讀一些書籍。睡前盡量別使用手機，會影響睡眠，閱讀可以看些大家推薦，但屬於其他領域的書籍。 2. 短期衝刺每年都有一段學習計畫，前年是CSS，去年是d3.js。長時間的堅持學習，可以讓知識越來越廣闊，而短時間的學習，可以讓專業更有深度。 進行短期衝刺的學習之前，先擬定好學習的進度、內容(或者教材)以及學習目標，固定的進度會逼迫自己前進，預先設定好的內容有助於學習順暢，而目標，可以檢視自己學習的成果。 而每年通常會安排一段時間，來做這樣的專業學習訓練，讓我額外多學習了很多技術。CSS、d3.js是個例子，但其實還有許多技術，都是短時間練到一定程度，像是git、angular等等…。 3. 發現知識這和對工作的熱情有很大關係了，很多人會說工作要看待成career而不是job，前者是長期的規劃，後者是固定領薪水上下班，如果對於自己的專業有興趣，就不易感到厭煩，可以長時間的投入。而發現知識就是在空閒的時間，還持續投入自己的專業。 以我來說，通常會用facebook追蹤各種社群，或者是定期瀏覽一些技術網站、Blog，再看到關鍵字後，在搜尋這技術對於我的專業上是否有幫助，以及學習的適切性，如果可以再安排進自己的學習時程。 而對於學習，不太需要擔心學了用不到，在研究所時，我從設計師轉學Flash Actionscript 3.0，在當完兵後Flash被賈伯斯批的一文不值，Actionscript 3.0也跟著沒落，但這段學習影響到後來javascript。同樣的還有許多技術學習，會衍伸其他觀念的理解，只要保持開放的心胸，保持學習，人生的旅途自然會越來越開闊。","categories":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/categories/study/"}],"tags":[{"name":"study","slug":"study","permalink":"https://wcc723.github.io/tags/study/"}]},{"title":"Middleman + Reactjs","slug":"reactjs-environment2","date":"2015-04-26T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"js/2015/04/27/reactjs-environment2/","link":"","permalink":"https://wcc723.github.io/js/2015/04/27/reactjs-environment2/","excerpt":"上一篇是使用gulp來轉換jsx，這篇是介紹用middleman 結合 React.js。","text":"上一篇是使用gulp來轉換jsx，這篇是介紹用middleman 結合 React.js。 Middleman建立專案參考本篇請先安裝好middleman，如果沒有可參考以下連結/tools/2015/03/23/middle-intro/。 建立middleman專案，並且安裝middleman-react的gem。 $ middleman init React-middleman $ gem install middleman-react Gemfile內請加入以下這行。 gem &quot;middleman-react&quot; config.rb加入以下程式碼 # activate react # 啟用React activate :react # option if need Sprockets loading # 可以載入 react.js after_configuration do sprockets.append_path File.dirname(::React::Source.bundled_path_for(&apos;react.js&apos;)) end 如果剛剛有啟用Sprockets loading，可以打開all.js做以下調整(用途是合併react.js)，請先載入react，再載入其他script，如下範例。 //= require react //= require_tree . 最後在***.jsx內就可直接使用jsx格式(和其他javascript放在同層即可)，如果執行middleman server時出現以下錯誤： Invariant Violation: _registerComponent(...): Target container is not a DOM element 請將你的&lt;%= javascript_include_tag &quot;all&quot; %&gt; 放在 &lt;body&gt;的後方。","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"Reactjs JSX格式轉換","slug":"reactjs-environment","date":"2015-04-22T16:00:00.000Z","updated":"2016-10-13T03:57:25.000Z","comments":true,"path":"js/2015/04/23/reactjs-environment/","link":"","permalink":"https://wcc723.github.io/js/2015/04/23/reactjs-environment/","excerpt":"剛接觸React.js通常遇到一個問題，就是開發環境怎麼配置，原因在於JSX的格式需要轉換。JSX讓javascript內可以插入html tag，雖然是可以選擇使用，但官方也建議使用JSX格式來進行開發，如果對於React.js有興趣的，不妨參考一下這篇JSX格式轉換吧。","text":"剛接觸React.js通常遇到一個問題，就是開發環境怎麼配置，原因在於JSX的格式需要轉換。JSX讓javascript內可以插入html tag，雖然是可以選擇使用，但官方也建議使用JSX格式來進行開發，如果對於React.js有興趣的，不妨參考一下這篇JSX格式轉換吧。 參考文章：http://tylermcginnis.com/reactjs-tutorial-pt-2-building-react-applications-with-gulp-and-browserify/ 安裝Node.js &amp; Gulp首先要先安裝Node.js 和 Gulp，如果還沒安裝的可以參考我之前的文章。 /gulp/2014/09/22/gulp-install/ 檔案格式架構建立以下的檔案 gulpfile.js |-- app |-- index.html |-- js |-- app.js index.html code&lt;script src=&quot;app/app.js&quot;&gt;&lt;/script&gt;放在body後方，只是要避免dom的錯誤。 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;React.js&lt;/title&gt; &lt;script src=\"http://fb.me/react-0.13.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"app\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;!-- build:js --&gt;&lt;script src=\"app/app.js\"&gt;&lt;/script&gt;&lt;!-- endbuild --&gt;&lt;/html&gt; app.js code僅是要測試JSX用。 123456789101112131415161718192021var Child = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; and this is the &lt;b&gt;&#123;this.props.name&#125;&lt;/b&gt;. &lt;/div&gt; ) &#125;&#125;);var Parent = React.createClass(&#123; render: function()&#123; return ( &lt;div&gt; &lt;div&gt; This is the parent. &lt;/div&gt; &lt;Child name=\"child\"/&gt; &lt;/div&gt; ) &#125;&#125;);React.render(&lt;Parent /&gt;, document.getElementById('app')); 安裝gulp套件在Terminal下依序輸入以下兩行指令，而npm init是用來建立package.json，輸入後會有一些問題，一直按Enter就可以了^ ^。 $ npm init $ npm install gulp gulp-concat gulp-uglify gulp-react gulp-html-replace --save-dev gulpfile.js這範例不包含webserver，主要是轉換JSX，如果對於gulp js很熟悉的使用者，也可只參考其中的JSX轉換即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var gulp = require('gulp');var concat = require('gulp-concat'); // 串接var uglify = require('gulp-uglify'); // 醜化jsvar react = require('gulp-react');var htmlreplace = require('gulp-html-replace');// 定義變數var path = &#123; HTML: 'app/index.html', ALL: ['app/js/*.js', 'app/js/**/*.js', 'app/index.html'], JS: ['app/js/*.js', 'app/js/**/*.js'], MINIFIED_OUT: 'build.min.js', DEST_SRC: 'dist/app', DEST_BUILD: 'dist/build', DEST: 'dist'&#125;;// 建立任務，轉換JSXgulp.task('transform', function()&#123; gulp.src(path.JS) .pipe(react()) .pipe(gulp.dest(path.DEST_SRC));&#125;);// 複製index.html到dist資料夾gulp.task('copy', function()&#123; gulp.src(path.HTML) .pipe(gulp.dest(path.DEST));&#125;);// 監控以上兩個任務gulp.task('watch', function()&#123; gulp.watch(path.ALL, ['transform', 'copy']);&#125;);// 定義預設動作gulp.task('default', ['watch']);// gulu buildgulp.task('build', function()&#123; gulp.src(path.JS) .pipe(react()) //轉換jsx .pipe(concat(path.MINIFIED_OUT)) // 串接所有js .pipe(uglify(path.MINIFIED_OUT)) // 最小化js .pipe(gulp.dest(path.DEST_BUILD));&#125;);// 轉換js路徑gulp.task('replaceHTML', function()&#123; gulp.src(path.HTML) .pipe(htmlreplace(&#123; 'js': 'build/' + path.MINIFIED_OUT &#125;)) .pipe(gulp.dest(path.DEST));&#125;);// production 輸出gulp.task('production', ['replaceHTML', 'build']); 到這部分基本上就完成了，只要透過gulp或gulp production就能預覽jsx轉換成js。","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"Reactjs 元件的生命週期","slug":"reactjs-life-cycle","date":"2015-04-20T16:00:00.000Z","updated":"2016-10-13T03:57:25.000Z","comments":true,"path":"js/2015/04/21/reactjs-life-cycle/","link":"","permalink":"https://wcc723.github.io/js/2015/04/21/reactjs-life-cycle/","excerpt":"這篇也是React.js的學習過程文章。","text":"這篇也是React.js的學習過程文章。 參考文章：http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/ 元件生命週期上一篇有提到元件生命週期，這邊照著做來瞭解以下的內容。 Component LifeCycle - 元件生命週期 componentWillMount – 元件建立 componentDidMount – 元件已經建立 componentWillReceiveProps – This life cycle is not called on the initial render, but is instead called whenever there is a change to props. Use this method as a way to react to a prop change before render() is called by updating the state with setState.(原文) componentWillUnmount – This life cycle is invoked immediately before a component is unmounted from the DOM. This is where you can do necessary clean up. For example, going back to out firebase example this is the life cycle event where you would clean up your firebase reference you set in componentWillMount.(原文) 12345678910111213141516171819202122232425262728293031323334353637var LifeCycle = React.createClass(&#123; getInitialState: function()&#123; // 元件初始化 alert('getInitialState 的狀態'); return &#123; name: '比克' &#125; &#125;, textClick: function()&#123; this.setState(&#123; name: '悟飯' &#125;) &#125;, componentWillMount: function()&#123; // 元件即將建立 alert('componentWillMount 的狀態'); &#125;, componentDidMount: function()&#123; // 元件建立 alert('componentDidMount 的狀態'); &#125;, componentWillReceiveProps: function()&#123; // 尚未測試出來 alert('componentWillReceiveProps 的狀態'); &#125;, render: function()&#123; return( &lt;div onClick=&#123;this.textClick&#125;&gt; 必殺, &#123;this.state.name&#125; &#123;this.props.skill&#125; &lt;/div&gt; ) &#125;&#125;);React.render(&lt;LifeCycle skill=\"魔貫光殺砲\" /&gt;,document.getElementById('app')); JS Bin","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"開始學習 React js","slug":"learn-reactjs","date":"2015-04-19T16:00:00.000Z","updated":"2016-10-13T03:57:46.000Z","comments":true,"path":"js/2015/04/20/learn-reactjs/","link":"","permalink":"https://wcc723.github.io/js/2015/04/20/learn-reactjs/","excerpt":"最近開始來學react，相關的文章不會寫得非常細，主要是要寫學習過程。 參考文章：http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/","text":"最近開始來學react，相關的文章不會寫得非常細，主要是要寫學習過程。 參考文章：http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/ 關於參考文章我參考的文章還挺多的，但每篇都花時間寫很細有點難，所以這篇是參考http://tylermcginnis.com/reactjs-tutorial-a-comprehensive-guide-to-building-apps-with-react/去實作的過程，有興趣的可以參考該網站即可。 React 專有名詞這blog將常用名詞放在第一篇，我認為很棒，這樣有助於了解整個框架。 JSX – react將html 元件直接寫在js內，透過jsx可以在js內寫類似html 格式的程式碼，再轉換成純js。 Virtual DOM - 透過js產生出真實的DOM。 React.createClass – 這個方法用來產生html 元件。 render (method) – 繪製html元件。 React.render – 將元件繪製到html dom上。 state – 元件的內部儲存資料。 getInitialState – 設置元件的初始狀態。 setState – 改變元件的狀態。 props – 從父層的元件取得值並傳送到子元件。 propTypes – 驗證父層的值。 getDefaultProps – 設定預設的值。 Component LifeCycle - 元件生命週期 componentWillMount – Fired before the component will mount componentDidMount – Fired after the component mounted componentWillReceiveProps – Fired whenever there is a change to props componentWillUnmount – Fired before the component will unmount Events onClick onSubmit onChange 學習 React.js環境在環境上可以使用jsbin，有些小地方稍微調整一下就可以簡單上手(如下圖)。 接下來隨意用個demo，選擇run with js，就可以看看有沒有成功了。 建構第一個元件第一個元件主要介紹如何透過JSX來繪製。 123456789101112var TheFirst = React.createClass(&#123; // 建立新的元件 render: function()&#123; //畫出你想要的元件架構 return( // 元件開始 &lt;div&gt; The First &lt;/div&gt; ) // 元件結束 &#125;&#125;);React.render(&lt;TheFirst /&gt;, // 輸入剛剛宣告的元件名稱 document.getElementById('app') // 目標DOM); JS Bin 點擊run with js 預覽 加一點狀態在元件上1234567891011121314151617var TheFirst = React.createClass(&#123; // 建立新的元件 getInitialState: function()&#123; // 定義預設狀態 return &#123; // 回傳json格式狀態 userstate: '單腳站容易歪' &#125; &#125;, render: function()&#123; // 畫出你想要的元件架構 return( // 直接用&#123;&#125;帶入值 &lt;div&gt; The First &#123;this.state.userstate&#125; &lt;/div&gt; ) // 元件結束 &#125;&#125;);React.render(&lt;TheFirst /&gt;, // 輸入剛剛宣告的元件名稱 document.getElementById('app') // 目標DOM); JS Bin 事件控制123456789101112131415161718192021222324var TheFirst = React.createClass(&#123; // 建立新的元件 getInitialState: function()&#123; // 定義預設狀態 return &#123; // 回傳json格式狀態 userstate: '單腳站容易歪' &#125; &#125;, handleChangeA: function(e)&#123; //自訂事件名稱 this.setState(&#123; // 設定狀態 userstate: e.target.value &#125;); &#125;, render: function()&#123; // 畫出你想要的元件架構 return( // 透過onChange觸發handleChangeA事件 &lt;div&gt; The First &#123;this.state.userstate&#125; &lt;br /&gt; change state : &lt;input type=\"text\" value=&#123;this.state.userstate&#125; onChange=&#123;this.handleChangeA&#125; /&gt; &lt;/div&gt; ) // 元件結束 &#125;&#125;);React.render(&lt;TheFirst /&gt;, // 輸入剛剛宣告的元件名稱 document.getElementById('app') // 目標DOM); JS Bin 從父層抓取資料傳回值12345678910var HelloUser = React.createClass(&#123; render: function()&#123; return ( // 透過this.props 抓取父層屬性 &lt;div&gt; 必殺, &#123;this.props.skill&#125;！&lt;/div&gt; ) &#125;&#125;);React.render(&lt;HelloUser skill=\"魔貫光殺砲\"/&gt;, // 父層屬性document.getElementById('app')); JS Bin 巢狀元件這邊有個陷阱，沒注意到卡超久，當載入另一個元件時，必須在用一個標籤包起載入的元件。 1234567891011121314151617181920212223242526272829303132333435363738var SkillList = React.createClass(&#123; render: function()&#123; // 透過 this.props 讀取父層得值 var listItems = this.props.skills.map(function(item)&#123; console.log(&#123;item&#125;); return &lt;li&gt;&#123;item&#125;&lt;/li&gt;; &#125;); return ( &lt;div&gt; &lt;h2&gt;技能列表&lt;/h2&gt; &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;);var HelloDragonBall = React.createClass(&#123; getInitialState: function()&#123; return &#123; skill: \"魔貫光殺砲\", allskills: ['龜派氣功', '元氣彈', '太陽拳'] //要給內層用的陣列 &#125; &#125;, render: function()&#123; return ( // 注意，這種做法外層必須有標籤 &lt;div&gt; &lt;h1&gt;必殺, &#123;this.state.skill&#125;！&lt;/h1&gt; &lt;SkillList skills=&#123;this.state.allskills&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);React.render(&lt;HelloDragonBall /&gt;,document.getElementById('app')); JS Bin 經典模組，新增清單1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677var AddSkill = React.createClass(&#123; // 這元件包含了input、button，用來增加新的技能 getInitialState: function()&#123; return &#123; newSkill: '' &#125; &#125;, updateNewSkill: function(e)&#123; //每次輸入更新值 this.setState(&#123; newSkill: e.target.value &#125;) &#125;, handleAddNew: function()&#123; // 按下button時，將資料更新到父層 this.props.addNew(this.state.newSkill); this.setState(&#123; newSkill: '' &#125;) &#125;, render: function()&#123; return( &lt;div&gt; &lt;input type=\"text\" value=&#123;this.state.newSkill&#125; onChange=&#123;this.updateNewSkill&#125; /&gt; &lt;button onClick=&#123;this.handleAddNew&#125;&gt;Add new Skill&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;);var SkillList = React.createClass(&#123; render: function()&#123; // 透過 this.props 讀取父層得值 var listItems = this.props.skills.map(function(item)&#123; console.log(&#123;item&#125;); return &lt;li&gt;&#123;item&#125;&lt;/li&gt;; &#125;); return ( &lt;div&gt; &lt;h2&gt;技能列表&lt;/h2&gt; &lt;ul&gt; &#123;listItems&#125; &lt;/ul&gt; &lt;/div&gt; ) &#125;&#125;);var HelloDragonBall = React.createClass(&#123; getInitialState: function()&#123; return &#123; skill: \"魔貫光殺砲\", allskills: ['龜派氣功', '元氣彈', '太陽拳'] //要給內層用的陣列 &#125; &#125;, addNewSkill: function(newSkill)&#123; console.log(newSkill); // 更新allskills資料 this.state.allskills.push(newSkill); this.setState(&#123; allskills: this.state.allskills &#125;) &#125;, render: function()&#123; return ( // 模組子層addNew更新時，觸發addNewSkill &lt;div&gt; &lt;h1&gt;必殺, &#123;this.state.skill&#125;！&lt;/h1&gt; &lt;AddSkill addNew=&#123;this.addNewSkill&#125; /&gt; &lt;SkillList skills=&#123;this.state.allskills&#125; /&gt; &lt;/div&gt; ) &#125;&#125;);React.render(&lt;HelloDragonBall /&gt;,document.getElementById('app')); JS Bin 累了，React的tag有沒有什麼工具…，純手打好累。","categories":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"reactjs","slug":"reactjs","permalink":"https://wcc723.github.io/tags/reactjs/"}]},{"title":"Javascript 閉包","slug":"js-function-closures","date":"2015-04-09T16:00:00.000Z","updated":"2016-10-13T03:56:42.000Z","comments":true,"path":"javascript/2015/04/10/js-function-closures/","link":"","permalink":"https://wcc723.github.io/javascript/2015/04/10/js-function-closures/","excerpt":"一直以來我都不太敢寫純 Javascript的文章，主要原因是底子不夠深，害怕寫了之後錯誤太多，但最近想學看看React.js，如果說一直不敢寫的話，那麼就無法進步。 這篇是要介紹Javascript閉包，參考的是這篇文章，這篇寫得不錯，從頭到尾看到有感受到閉包的用法，但或許有錯誤，也在這邊重頭到尾表達一次，在詢問大家是否有需要糾正的。","text":"一直以來我都不太敢寫純 Javascript的文章，主要原因是底子不夠深，害怕寫了之後錯誤太多，但最近想學看看React.js，如果說一直不敢寫的話，那麼就無法進步。 這篇是要介紹Javascript閉包，參考的是這篇文章，這篇寫得不錯，從頭到尾看到有感受到閉包的用法，但或許有錯誤，也在這邊重頭到尾表達一次，在詢問大家是否有需要糾正的。 變數與作用域範例一首先一開始要先了解最基本的變數，變數可以分為全域及區域變數，以下範例的name = &quot;阿帕契&quot;就是全域變數，所以當alert(name);時就會直接調用全域的&quot;阿帕契&quot;；在funcA()內的var name = &quot;澇哥哥&quot;則是區域變數，所以執行funcA()則會運算內部的&quot;澇哥哥&quot;。 123456789var name = \"阿帕契\";function funcA()&#123; var name = \"澇哥哥\"; alert(name);&#125;funcA(); // \"澇哥哥\"alert(name); // \"阿帕契\" 範例二這個範例和剛剛很類似只是把函式funA()內的var name = &quot;澇哥哥&quot;;改成name = &quot;澇哥哥&quot;;，這樣就會有全然不同的結果。 首先第一個alert(name);會直接調用全域的name，所以結果會是&quot;阿帕契&quot;。 接下來執行funcA()，會得到函式內的name = &quot;澇哥哥&quot;;，但其實這時候全域的name已經被取代成&quot;澇哥哥&quot;。 最後的alert(name);顯示的是被取代的name也就是&quot;澇哥哥&quot;。 12345678910var name = \"阿帕契\";function funcA()&#123; name = \"澇哥哥\"; alert(name);&#125;alert(name); // \"阿帕契\"funcA(); // \"澇哥哥\"alert(name); // \"澇哥哥\" 所以在函式內部使用var則會定義區域變數，不使用則是全域 閉包和原作文章來比，我會省略掉很多內容，主要是要介紹作用域、閉包。 在阿帕契案中，一開始只因為某藝人在Facebook上上傳了阿帕契的觀光照片，所以爆出了這個案件(var Apache = funcA();)，許多人就開始搜尋或者調查阿帕契(alert(name);)，不論是機種還是性能等等。後來阿帕契案件越滾越大，發現每天調查多會多一團(Apache();, Apache();, Apache();)。 12345678910111213141516var name = \"阿帕契\";function funcA()&#123; var name = \"澇哥哥一團\"; alert(name); return function()&#123; name = name + \" 再多一團\"; alert(name); &#125;;&#125;var Apache = funcA(); //\"澇哥哥一團\"alert(name); //\"阿帕契\"Apache(); // \"澇哥哥一團 再多一團\"Apache(); // \"澇哥哥一團 再多一團 再多一團\"Apache(); // \"澇哥哥一團 再多一團 再多一團 再多一團\" var Apache = funcA();這整個過程中，全域的name = &quot;阿帕契&quot;;依然都沒有變動，而執行var Apache = funcA()時，區域變數的name宣告為&quot;澇哥哥一團&quot;，這整個函式也就結束，所以第一次執行也就到&quot;澇哥哥一團&quot;。 Apache();var Apache = funcA(); 以上這段執行後，&quot;澇哥哥一團&quot;也是大家都知道的事情了，其實也就沒必要一直反覆提()，只是檢調每次調查時，都會再多出一團，這段就是return function()，他調用存在Apache();函式中的name，並且在每次執行時再多一團。 所以閉包就是能訪問另一個函式的變數(var Apache = funcA();)。 This1234567891011121314var name = \"阿帕契\";function funcA()&#123; var name = \"澇哥哥一團\"; alert(name); return function()&#123; name = name + \" 再多一團\"; alert(this.name); &#125;;&#125;var Apache = funcA(); //\"澇哥哥一團\"alert(name); //\"阿帕契\"Apache(); //\"阿帕契\" 文中最後還提到了this，它提到this是調用目前函式的對象，所以在閉包內使用this，我們實際是執行以下的函式。 window.funcA(); 所以指向的都是全域的var name = &quot;阿帕契&quot;;。 更棒的文章在寫完這篇後，我看到一篇更棒的文章http://blog.taian.su/2012-10-17-explaining-javascript-scope-and-closures-by-robert-nyman/，這篇將閉包解釋得更清楚，且還有許多的範例，有機會一定要跟著做一次喔。 如果本文有錯誤，煩請提出，我會盡快理解在修正。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"Zeplin, 跨越工程師與設計師的鴻溝","slug":"zeplin-intro","date":"2015-04-08T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"tools/2015/04/09/zeplin-intro/","link":"","permalink":"https://wcc723.github.io/tools/2015/04/09/zeplin-intro/","excerpt":"從去年開始，做網頁設計時都開始使用Sketch，一方面是對於Web來說，Sketch相當的合適，另一方面則是Sketch有相當多的擴增工具，讓在執行上可以方便不少。 這次就來介紹Sketch的擴增工具Zeplin，設計師可以透過這套工具，快速的傳達設計的內容，包含顏色、間距、字型等等，而工程師不會因為色弱，老是用錯顏色，且工程師不需要安裝Sketch就可以使用，Zeplin甚至提供Web版來快速上手。","text":"從去年開始，做網頁設計時都開始使用Sketch，一方面是對於Web來說，Sketch相當的合適，另一方面則是Sketch有相當多的擴增工具，讓在執行上可以方便不少。 這次就來介紹Sketch的擴增工具Zeplin，設計師可以透過這套工具，快速的傳達設計的內容，包含顏色、間距、字型等等，而工程師不會因為色弱，老是用錯顏色，且工程師不需要安裝Sketch就可以使用，Zeplin甚至提供Web版來快速上手。 Zeplin: https://zeplin.io/ 申請帳號如果有興趣的朋友，要先申請帳號，我在很久之前就有申請了，所以有點忘記流程，所以有興趣下載的朋友，請先提出申請吧～。 收到邀請後，也可以拿到測試版的軟體 軟體介紹注意：Sketch is Mac only. Zeplin目前我還沒有在多人環境測試 安裝完後，他會先要求登入，然後再建立檔案同時上傳到伺服器，這樣可以和其他合作夥伴同步討論。 在建立專案時，可以開Androi, iOS, Web，而這些都可以匯出不同的資料，就以Web來說，他可以將色票匯出成Sass的變數。這邊我就先選Web來建立。 開好專案後會提示在Sketch內按下cmd + E，這樣就能夠將設計稿匯入。 打開Sketch，手邊剛好有一份Bootstrap的Sketch template，就按下cmd + E。 可以看到專案的列表，就把圖片匯入剛剛開的專案上吧。 接下來回到Zeplin，可以找到剛剛Bootstrap的Sketch template，隨便點個地方，可以看到尺標都標好了，並且將顏色標出。 如果點的是內文，則可以複製內文 右方的色票旁邊有個水滴圖案，如果點了就會標示顏色的”色名” (色弱救星)，並且將他加到常用的色彩列表。 Border and fill設計師都不需要另外標顏色了~ Guildeline頁面可以看到剛剛選擇的顏色、畫面上所用到的字型以及輸出CSS。如果點Generate CSS，可以產出如下的Sass變數(色名是Zeplin取的)。 $limed-oak: #58b957; 除此之外，也可以按住cmd點選畫面上的物件，這樣就可以在物件上寫一些註解，如果多人的話也可以透過這來討論。 你相信嗎？這是Web版的頁面，就算是工程師也能透過Web版來進行討論，只要先有一個帳號就可以了。 如果撇除Mac有點貴之外，Sketch是相當值得入手的軟體，加上現在對Sketch的支援越來越多(Zeplin，或者是Google Material Design也支援Sketch範本)，有興趣的不仿來試試看。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"},{"name":"zeplin","slug":"zeplin","permalink":"https://wcc723.github.io/tags/zeplin/"}]},{"title":"Middleman 超級快上手","slug":"middle-intro","date":"2015-03-22T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"tools/2015/03/23/middle-intro/","link":"","permalink":"https://wcc723.github.io/tools/2015/03/23/middle-intro/","excerpt":"之前長時間都是使用Fire.app(到目前也有在用)，因為少許原因，所以一直有在嘗試其他工具，而之前有介紹過Gulp，他可以透過Node.js做出類似Fire.app的工具。而最近，有人和我介紹了Middleman，嘗試了一小段時間後，比想像中更容易，更貼近Fire.app，比Gulp更好設定，有興趣的就來安裝看看吧～。","text":"之前長時間都是使用Fire.app(到目前也有在用)，因為少許原因，所以一直有在嘗試其他工具，而之前有介紹過Gulp，他可以透過Node.js做出類似Fire.app的工具。而最近，有人和我介紹了Middleman，嘗試了一小段時間後，比想像中更容易，更貼近Fire.app，比Gulp更好設定，有興趣的就來安裝看看吧～。 官方網站：https://middlemanapp.com/ Middleman是基於Ruby環境的工具，因此請先確認有Ruby環境。 安裝安裝上問題不大，但是可能有ruby 版本的限制，2.0.0裝不進去，rvm切到2.1.2之後很順利安裝，或許是和gem的版本有關(反正我就裝進去了!)。 $ gem install middleman 建立專案這一套和fire.app有許多相似的地方，為了讓使用者可以快速開始，也有提供快速建立專案的方法，等等會介紹一些fire.app沒有的地方。 $ middleman init 啟動middleman的服務。 $ middleman server 這樣在進入localhost:4567之後，就可以開啟預設的畫面。 安裝其他插件接下來介紹他的一些特色，這不僅像Fire.app，也很類似Ruby on rails，所以除了一些預設的基本功能，還可以透過gemfile來擴增插件。 SlimSlim也是很多人在使用的template language，如果要產生slim的預設版型，就必須先安裝middleman-slim。 $ gem install middleman-slim 接下來init就可以產生slim的template(和原本的middleman init產生的內容是一樣，僅是改成slim的副檔名)。 $ middleman init PROJECT_NAME --template slim Sass接下來還需要其他的gem，可以直接寫入gemfile，像是sass, compass。所以打開gemfile，把以下三行加進去就可以了。 # Sass gem &quot;sass&quot; gem &quot;compass&quot; 回到terminal輸入bundle install，就可以使用sass囉(記得sass用法吧，副檔名記得要改成.sass or .scss)。 livereload這個版本的livereload已經把gem寫在裡面了，但是要自己啟動，打開config.rb，將以下的註解拿掉。 # configure :development do # activate :livereload # end 不需要重啟服務，直接就可以開始使用。 jquery如果要jquery的lib，也是將套件先寫在gemfile內，gemfile內加入以下這行，然後一樣在Terminal輸入bundle install。 gem &quot;jquery-middleman&quot; 接下來打開source/javascript/all.js裡面加入以下這行，這樣就完成了。 //= require jquery 參考：https://github.com/jasl/jquery-middleman 使用slim template languagemiddleman 不僅有template language，還支援許多類似fire.app的假字功能，這邊用一個範例來介紹： 打開index.html.slim - 5.times do p == lorem.sentence 這一段的意思是執行五次內容，包含了&lt;p&gt;以及產生lorem.sentence的假字，結果如下。 結語相對於gulp來說，middleman非常非常的容易上手，如果對於fire.app熟悉的話，並且略懂rails，大概只要20分鐘就可以開始用了。 如果說缺點，就是他並不像gulp那樣的靈活，可以與其他語言服務一起混用。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"投資自己、投資資產","slug":"we-need-more","date":"2015-03-15T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"life/2015/03/16/we-need-more/","link":"","permalink":"https://wcc723.github.io/life/2015/03/16/we-need-more/","excerpt":"之前就有打算Blog的內容不全部都是技術文，最近看了不同領域的資料，有很多不一樣的看法，其中有一本書對我的看法有很大的改變，富爸爸告訴你，為什麼A咖學生當員工，C咖學生當老闆！，這本書是屬於理財方面的書籍，之前理財完全沒有概念，想說閱讀看看，說不定有幫助，看完之後想法改變非常多…。","text":"之前就有打算Blog的內容不全部都是技術文，最近看了不同領域的資料，有很多不一樣的看法，其中有一本書對我的看法有很大的改變，富爸爸告訴你，為什麼A咖學生當員工，C咖學生當老闆！，這本書是屬於理財方面的書籍，之前理財完全沒有概念，想說閱讀看看，說不定有幫助，看完之後想法改變非常多…。 為什麼有這樣的想法工作經歷也將近屆滿三年了(也可以直接算三年啦)，前兩年薪水不算高，每年頂多存下來10萬(住外面還有學貸等等)，每年都因為薪水太少感到煩躁，後來技術上來了，薪水也提昇了不少，就開始算算要存多少錢，老了以後才能好好過(維持一定水準的生活品質)。 退休金… 雖然沒算到通貨膨脹，但這就是真真實實的問題，退休要多少錢。現在的醫療水準比以前高很多，有可能養老的時間比工作時間還要長(我阿公年紀破百)，加上醫療費等等，確實不容忽視。 改變我一直都在思考我們這一代要面臨的問題，高房價、不公平的社會福利、還沒出社會就一屁股的學貸等等，一直在思考怎麼逆轉這些問題。思考的結果是順應著這個環境，認為要養好自己身體，並且工作到七八十歲(日本 老人兼職工作到七十 「退休年齡」可以廢止了)，這是不錯的政策，我也有著這樣的信仰，但如果身體不好呢？ 現在的社會福利有非常大的問題，如果相信老了以後還有退休金可以領，那基本上領到的錢一定不夠用，別不斷說現在老人把錢吃光，就算他們不吃光，我們到時也是有相同的問題(雖然如此，也不能白白讓他們吃光啊啊)。 後來看上了富爸爸、窮爸爸系列書籍，雖然裡面的許多觀點相當的偏激，但許多概念值得參考。就以資產與負債來說，他大膽的提出自助宅並非是資產，是一種負債，像這樣違反社會風氣的論述，在裡面不斷的重複，也可以從中發現到現在的美國與鬼島台灣面臨許多相似的問題。 規畫學習前端以及技術，其中一個目標不正是提高自己的價值，賺取更多的薪水嗎？因此，除了前端的技術，還有許多可以做的事情： 學習更廣泛的技能(App、物聯、語文等) 投資資產(現金流) 創業!? 目前還沒有明確要做什麼，但並不會那樣的恐懼，不好的環境，還是有辦法成功，與其抱怨，不如去尋找希望。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"Sass map get","slug":"sass-map-get","date":"2015-02-10T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2015/02/11/sass-map-get/","link":"","permalink":"https://wcc723.github.io/sass/2015/02/11/sass-map-get/","excerpt":"去年有介紹sass模組的開發方式連結，sass 3.3 釋出以後有更好的方式去執行，這篇來介紹快速且好管理的模組製作方法。","text":"去年有介紹sass模組的開發方式連結，sass 3.3 釋出以後有更好的方式去執行，這篇來介紹快速且好管理的模組製作方法。 注意這篇要介紹的是sass map，所以請先確認自己的sass版本是3.3以上，如果要確認自己sass版本，可以在Terminal輸入 sass -v就可以看到目前系統內的版本。 $ sass -v 結果先來看預期的結果，按鈕是類似bootstrap，但是我簡化了很多部分的程式碼(縮短比較好閱讀)，重點是在scss內的$btn-config，透過這config可以快速調整按鈕的樣式，如果有增減，也只需要調整config即可。 See the Pen EaovPd by Wcc723 (@Wcc723) on CodePen. 開始html的部分就只有這三段代表不同的按鈕，不同的地方只有btn-xxx用來套用不同按鈕樣式。 123&lt;a href=\"#\" class=\"btn btn-default\"&gt;Button default&lt;/a&gt;&lt;a href=\"#\" class=\"btn btn-primary\"&gt;Button primary&lt;/a&gt;&lt;a href=\"#\" class=\"btn btn-danger\"&gt;Button danger&lt;/a&gt; 按鈕中還有包含基本的樣式，這不是本篇的重點，大概看過就好。 1234567891011.btn &#123; display: inline-block; margin-bottom: 0; text-align: center; vertical-align: middle; padding: 6px 12px; cursor: pointer; border: 1px solid transparent; white-space: nowrap; text-decoration: none;&#125; Scss 重點開始我長期以來都是寫sass格式的，但因為sass map的關係，最近開始改寫scss…。 Sass map的格式有點類似json，只是把{}改成了()，以下代表了三組按鈕的樣式設定檔(default, primary, danger)，每一組還有包含他的class name、color、background、border-color，清楚的標示可以讓未來更容易閱讀程式碼。 123456789101112131415161718192021// 定義按鈕的不同狀態設定，類似json格式$btn-config:( default:( class: &apos;default&apos;, color: #333, bg: #fff, border-color: #ccc ), primary:( class: &apos;primary&apos;, color: #fff, bg: $brand-primary, border-color: darken($brand-primary, 0) ), danger:( class: &apos;danger&apos;, color: #fff, bg: $brand-danger, border-color: darken($brand-danger, 0) )); 透過sass的$each把$btn-config每一組設定帶出來，這方法有點類似jquery的$.each。接下來的map-get是sass map新的function，取出值以後，就像平常寫scss一樣，把變數寫在樣式內就完成了。 123456789101112131415161718// 用$each 帶入設定值@each $name, $value in $btn-config &#123; $class: map-get($value, class); // 用map-get取出各個設定值 $color: map-get($value, color); $bg: map-get($value, bg); $border-color: map-get($value, border-color); // 接下來將變數加到class內就完成了 .btn-#&#123;$class&#125;&#123; color: $color; background-color: $bg; border-color: $border-color; &amp;:hover&#123; background-color: darken($bg, 5%); border-color: darken($border-color, 5%); &#125; &#125;&#125; 延伸如果後來發現按鈕的樣式不夠，其實只要改$btn-config就可以了，如果有興趣，試著把下面這段加到範例裡的$btn-config吧～。 123456dark:( class: &apos;dark&apos;, color: #fff, bg: #333, border-color: darken(#333, 0)) 如果在html內加入這段，有看到黑色的按鈕代表成功了。 1&lt;a href=\"#\" class=\"btn btn-dark\"&gt;Button dark&lt;/a&gt; 再看一次範例。 See the Pen EaovPd by Wcc723 (@Wcc723) on CodePen.","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS 5種垂直置中方法","slug":"css-magic","date":"2015-01-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/01/16/css-magic/","link":"","permalink":"https://wcc723.github.io/css/2015/01/16/css-magic/","excerpt":"說到垂直置中一直是網頁設計師的痛，早期解決方法沒有那麼多，最常見到的就是height = line-height這種方式，可是這方式彈性很低，如果遇到多行文字就無法使用。 然而隨著CSS的演進，越來越多種垂直置中的方法，這邊就介紹幾種實用性高的垂直置中方法。","text":"說到垂直置中一直是網頁設計師的痛，早期解決方法沒有那麼多，最常見到的就是height = line-height這種方式，可是這方式彈性很低，如果遇到多行文字就無法使用。 然而隨著CSS的演進，越來越多種垂直置中的方法，這邊就介紹幾種實用性高的垂直置中方法。 條件這篇文章所介紹的垂直置中方式，都不會使用絕對值(px)，大多可以運用在各種環境，但實際上還是需要配合CSS的特性去做選用。 這次用鳴人的圖片來做介紹，這張圖片是用背景的方式載入。 12345678//sass code.naruto background-image: image-url(&quot;narutoR.png&quot;) background-color: orange background-repeat: no-repeat width: (image-width(&quot;narutoR.png&quot;) / 2) height: (image-height(&quot;narutoR.png&quot;) / 2) +background-size(cover) 外框的部分就直接加入height: 350px的屬性。 12%box height: 350px 方法一：table此table不是真table，這是IE8以上才支援的CSS語法，將div的屬性轉成table，再套用垂直置中的方式來完成。 優點：概念簡單、支援度高(IE8+) 缺點：html結構較多層、有table的特性 123456789.table @extend %box display: table width: 100%.table-cell display: table-cell vertical-align: middle.naruto margin: 0 auto 方法二：display: inline-blockvertical-align: middle可以做垂直置中，但是限制只能使用在inline及inline-block上，而且還有諸多的限制…，但是透過一點小技巧，vertical-align: middle會是一個非常實用的置中方式(目前也常把這方法套用在專案上)。 重點在於透過偽元素製作一個垂直100%的物件，而需要置中的元素也轉換為inline-block，並且套用vertical-align: middle。 優點：相容性不錯，如果要ie7則必須自己手動插入偽元素的部分。 缺點：必須轉成inline-block 1234567891011.box-wrap @extend %box text-align: center &amp;:before content: &quot;&quot; display: inline-block height: 100% vertical-align: middle.naruto display: inline-block vertical-align: middle 什麼是vertical-align：http://css-tricks.com/what-is-vertical-align/ 方法三：這方法類似於margin: 0 auto的水平置中，但套用在垂直的元素上，只要將內元素設定absolute並將上下左右的距離皆設定為0，再補上margin: auto就大功告成了，但這方法只能用在內元素有明確的寬與高。 優點：相容性高 缺點：內元素必須有明確的寬高值 12345678910.box-wrap @extend %box position: relative.naruto position: absolute top: 0 left: 0 bottom: 0 right: 0 margin: auto 方法四：translateY(- 50%)以前常會用一種方式做垂直置中top: 50%; margin-top: -(元素高 / 2);，先用top往下推50%的距離，再利用margin-top拉回元素的一半高度，這方式雖然很好用，但是必須用在元素有明確高度上。 而這邊所介紹是相同的道理，但是是用transform: translateY(- 50%)將元素垂直向上50%的距離，這50%則是元素的高度，且語法都集中在元素上。 優點：如果不提到ie就沒有缺點 缺點：如果提到ie就是缺點(ie9+) 12345.naruto position: relative top: 50% margin: 0 auto +transform(translateY(- 50%)) 方法五：flex近幾年W3C針對CSS的layout提出了新的語法 flex，經過多番的波折目前也差不多定案，所以主流的瀏覽器幾乎都支援 flex。 透過Compass(1.0+)，許多前輟詞都可以省略。 12345.flex-wrap +display-flex //flex +flex-wrap(wrap) //flex外框 +align-items(center) //水平置中 +justify-content(center) //垂直置中 優點：很潮 缺點：如果提到ie就是缺點(全部)、建議熟悉flex概念 前年的鐵人賽我有介紹過flex，也可以參考前年的文章，flex看似簡單，但似乎沒有那麼容易…。 display:flex CSS3 Flex的排版方式 CSS3 Flex的對齊","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS 冷知識","slug":"css-magic","date":"2015-01-12T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2015/01/13/css-magic/","link":"","permalink":"https://wcc723.github.io/css/2015/01/13/css-magic/","excerpt":"前幾天參加了Happy designer + RGBA的活動，這次不僅僅是兩個社群的合作，還是以CSS為主題作為介紹。這次活動不只介紹了CSS架構，還介紹了許多CSS的奇妙解法，想到很久以前也寫過類似的文章(CSS 冷知識)，個人認為這類冷僻解法相當有趣…，有機會應該定期發表CSS冷知識。","text":"前幾天參加了Happy designer + RGBA的活動，這次不僅僅是兩個社群的合作，還是以CSS為主題作為介紹。這次活動不只介紹了CSS架構，還介紹了許多CSS的奇妙解法，想到很久以前也寫過類似的文章(CSS 冷知識)，個人認為這類冷僻解法相當有趣…，有機會應該定期發表CSS冷知識。 隨著視窗縮放的背景圖CSS背景圖相當的實用，但是有個問題就是無法等比例縮放，這個奇妙解法可以解決視窗縮放的問題(關鍵字：padding-bottom)。 首先還是必須要知道圖片的比例，這次範例直接使用Fireapp的宣傳圖…(Blog內這張最適合QQ)，經過計算可以知道圖片的寬高比為100:42，那麼就寫出下面這樣的sass code，寬為100%，padding-bottom為42%。 1234.img-responsive-fire background-size: contain backgroubd-repeat: no-repeat padding-bottom: 42% 將Class套用至圖內並加入style=&quot;background-image: url(/path/img.jpg)&quot;，這樣背景圖就可以隨視窗縮放了 CSS background HTML img 12345&lt;div class=\"img-responsive-fire\" style=\"background-image: url(/images/20130917fireapp.jpg)\"&gt;&lt;/div&gt;&lt;em&gt;CSS background&lt;/em&gt;&lt;br&gt;&lt;img src=\"/images/20130917fireapp.jpg\" class=\"img-responsive\" alt=\"\"&gt;&lt;em&gt;HTML img&lt;/em&gt; 只靠Class增加CSS權重http://www.w3.org/TR/CSS2/cascade.html#specificity CSS權重一直是網頁設計中常遇到的問題，就以Bootstrap來說，Bootstrap大量使用.class &gt; .class這種方式去製作Component，如果是不熟悉的開發者，在overwrite時就會加上!important以確保自己得樣式會呈現。而這個範例解法，可以避免使用!important 或 id來增加CSS的權重。 這邊先寫一個簡單的範例，一個是單純的.green，另一個是.demo &gt; .green.blue，就以優先度來說，後者大勝前者，所以當標籤套用class=&quot;blue green&quot;必定為藍色。 1234.green color: green.demo &gt; .green.blue color: blue 這裏有一段文字 class=\"green\" 這裏有一段文字 class=\"blue green\" 如果此時要覆蓋CSS，就是不斷的增加Class的權重如下…。 12.red.red.red.red.red.red.red.red.red.red.red.red color: red 就算是.demo &gt; .green.blue也不過區區 3分 的權重，而.red*12 有高達 12分 的權重，雖然這樣做好像看起來怪怪的…，不過確實也是可行。 這裏有一段文字 class=\"blue green red\" @Supports() 判斷瀏覽器的核心@Suports 可以用來判斷瀏覽器是否支援特定CSS語法，所以再加上CSS前啜詞就能判斷目前的瀏覽器核心。就以下列範例來說-webkit-transition，就可以判斷使用者的瀏覽器是否支援-webkit-transition，然後在執行其內容CSS。 12345678910@supports (-webkit-transition: all) .supports color: red &amp;:after content: &quot;-webkit-&quot;@supports (-moz-transition: all) .supports color: blue &amp;:after content: &quot;-moz-&quot; 這範例就只支援-webkit-與-moz-相容的瀏覽器，Chrome、Safari、Opera 應該會顯示紅色，Firefox會顯示藍色。 你的瀏覽器支援 結語如果看完這篇，還有想到什麼CSS冷知識，拜託…，跟我分享…。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"2014年度回顧","slug":"2014-year-report","date":"2015-01-07T16:00:00.000Z","updated":"2016-10-13T03:52:14.000Z","comments":true,"path":"life/2015/01/08/2014-year-report/","link":"","permalink":"https://wcc723.github.io/life/2015/01/08/2014-year-report/","excerpt":"2014年在學習上是豐收的一年…，踩著過往的基礎，學習速度越來越快；但還有許多地方經歷不足，對於許多事情也相當任性，除了能力的上升以外，對於人生也要多學習啊～。","text":"2014年在學習上是豐收的一年…，踩著過往的基礎，學習速度越來越快；但還有許多地方經歷不足，對於許多事情也相當任性，除了能力的上升以外，對於人生也要多學習啊～。 學習成就學習上，今年算是收穫滿滿，不僅學習了許多新技術，也實際運用在工作上，產能也明顯有所改變。除此之外，還接觸了自身領域以外的技術，透過這樣的學習，越來越能夠分辨如何是好。不過也要思考，這樣的跨出自身領域的學習，也要適可而止，別讓自己迷失方向。 CSS ArchitectureCSS的架構規範等不論是OOCSS、SMACSS，重點還是需要實際的運用，去年在工作上實作了一套CSS Framework，可以運用在數個專案上，並且可以客制調整所需，如色彩、文字大小、Class name都只需要修改設定檔即可，透過這樣的實作，才會瞭解何種架構是適合用在目前的專案上。 就以Bootstrap grid system 與 Susy 來說明，前者是整套的CSS Framework，已經將網格系統可能運用到的部分模組化，讓執行可以更加快速；Susy 可以自訂網格的各種方法，並且可以讓網格區塊更加語義化，讓HTML程式碼更為整齊。就結果上，Bootstrap grid system的概念較適合大型專案，並且產出專門的文件使協作更為容易；Susy 適合小型專案，可以快速建立彈性佳的網格，所以在使用上，必須了解目前專案適合的執行方式。故大型專案，我推類似Bootstrap grid system的方式執行(自幹啦)。 SASS &amp; Compass 前年開始專精於CSS以及SASS，這兩者影響我非常多，2014年也有不斷地精進這部分，尤其是在寫法上有更多的變化。Sass的學習上，有一部分是多看其他人的做法(Bootsrap sass有很多架構面可以學習，另外台灣也有很多高手可以參考)，還有多加練習及思考，只有實作才是進步的最佳方法；另外就是Sass 3.3的推出，多了許多新功能，不會這塊主要就用Source map而已…，就沒有仔細繼續鑽研了…。 D3.js 鐵人賽D3.js列表：http://wcc723.github.io/d3js/2014/10/29/Ironman-30-days-30/ 一度認為學了D3.js可以做出酷炫而且好用的圖表，這點我是誤會很深，在鐵人賽的時候花了很多時間學習D3.js(大概學了兩個多月)，許多細節都還沒辦法相當了解，死命的硬刻出自己想要的圖表…。以下是學習後的感受： 資料從何而來：資料取得是一個大問題，且各個地方的資料格式不同，怎樣可以降低取得資料的難度也是個大問題。 圖表呈現的正確性：資料是正確的，轉換過程也沒有出錯，但是圖可能是錯誤的(表達方法錯誤)，這樣會造成錯誤的訊息傳達。 演算法、統計學：圖表的製作，會牽扯到許多演算法及統計學的觀念，以我目前的能力完全無法了解這些學科，整個只能哭哭。 GitGit從前年開始接觸，去年上保哥的課程以及保哥的30日挑戰Git，在觀念上有很大的進展，且後來在公司內推廣Git以及推坑架設Gitlab，不斷的磨練後可以應付許多基本問題。 而Git的使用上，一開始是學習command line，現在多用Gui，主要原因是每次簽入時，我會習慣的整個看過簽入的檔案內容，檢查簽入內容是否正確、是否有不需要簽入的檔案、簽入訊息是否與檔案符合，這些步驟在Gui上較容易完成，而不足的功能，配合Google search及command line也足矣。 Gulp當初也猶豫很久，已經有了Fire.app是否有需要學習Gulp，後來也是抱著嘗試的心態去學習。兩者之間的比較是Fire.app已經提供大部分前端常用的工具，如Sass、Coffeescript、livereload、Template language等等，且易於使用，而Gulp是可以自定義這些工具，但必須寫一些script去執行它。所以在工作上只需要提供Html+CSS的專案上，我大多都是使用Fire.app；但如果是已經在進行的，或者是部分需要客制工具的專案(需搭配的部分較為複雜)，我則會使用Gulp來自定所需要的工具。 Angular雖然學過保哥Angular課程，但到現在我還只能算入門，但angular有很重要的觀念就是前端MVC以及two-way binding，如果說下一個要學習的Js lib，我會選擇angular專精…。 實務達成除了學習上，也有達成一些工作以外的項目。 IT鐵人賽兩度優選(獎盃寄到台北的家…還沒辦法拍照) 前年的IThome鐵人賽主題是CSS沒有極限，當時費盡心力寫45篇，讓我的CSS功力大幅精進。而去年IT鐵人賽運氣也不錯得了優選，主題是D3.js。 前年參加完，真的很累，想說別再參加這種競賽，結果去年又再一次…，今年會嗎…？ 發起翻譯Google Matrial Design Google Matrial Design 中譯版：http://wcc723.gitbooks.io/google_design_translate/ 目前這本書再Gitbook上還在前5名，非常感謝曾經幫助我翻譯的人(還配合翻譯第二輪&gt; &lt;)，且我也從執行這專案中學習了不少經驗。 開源專案的坑：在執行的開始，我知道要順利的完成，就必須讓參與者知道目前的狀態，不能讓參與者感覺到這專案的不安定性。我在hackpad上不斷的更新專案的進度以及預期的發展，讓參與者除了知道整體專案的狀態外，還可以知道其他參與者做了什麼。 把路鋪好：每個人都是從不同領域，憑藉的熱情來參與，在執行的習慣上多少有些不同，所以盡量將規則直接鋪好。在開始前我會先翻譯個幾篇當作範例，接下來會直接提供英文版的格式，讓翻譯者專注於翻譯，減少編寫習慣的不同，第一次時間上沒辦法執行的很徹底，但在第二次翻譯的時就是照這樣的方式執行。 更新：這部分也是相當費工的，如果有人檢查有翻譯上的問題，或者是Google Material更新，也是必須配合更新，好在有高手一起協助…。 2015的期望技術學習上還沒有思考要繼續學什麼，可能是繼續專精CSS，或者是學Angular，也有可能玩玩Rails，這都還在思考中。 但有另一個比較明確的方向，就是在高雄推廣開源專案。很羨慕台北有g0v這樣的團體，許多不同專業的高手一起合作，設計師和工程師的協作，彼此拉高互相的價值，這樣活動讓許多國家稱羨。希望能有機會參與類似的活動，但g0v也不就是先由少數人發起嗎？於是坑就在我的腦中浮現，慢慢的具現化…。","categories":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/categories/life/"}],"tags":[{"name":"life","slug":"life","permalink":"https://wcc723.github.io/tags/life/"}]},{"title":"參與開源專案","slug":"open-project-for-kh","date":"2014-12-30T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"project/2014/12/31/open-project-for-kh/","link":"","permalink":"https://wcc723.github.io/project/2014/12/31/open-project-for-kh/","excerpt":"最近有參與高雄的開源社群Code for Kaohsiung，除了人到場以外，也想盡份心力，所以試著來提出一個構想，花了些許時間建立了模型，並且拿到社群介紹這個構想。這個構想源自於之前所研究的D3.js，在後期的學習，會思考怎樣可以簡易的建立資料，並且運用圖表分享。","text":"最近有參與高雄的開源社群Code for Kaohsiung，除了人到場以外，也想盡份心力，所以試著來提出一個構想，花了些許時間建立了模型，並且拿到社群介紹這個構想。這個構想源自於之前所研究的D3.js，在後期的學習，會思考怎樣可以簡易的建立資料，並且運用圖表分享。 這僅僅是原型 這個原型輸入Google試算表的Key後，會從試算表中擷取資料，將資料的key及value整理後，使用者只要選擇需要的key，就會直接轉換成圖。如果完成預期情況使用者會透過以下步驟： 在Google spreadsheet上建立資料表格 取得Google spreadsheet Key 在該網站上貼上Key，並開始測試圖表 儲存圖表狀態，並且儲存 分享圖表 當天雛形已經可以做到很基本的1、2、3，介紹後不少人有興趣，讓我更有信心完成它，於是就找了高雄前端社群的主辦人來協助完成。 前端執行在開始製作時，為了可以快速且順利的完成，選擇較擅長的幾個技術，搭配些許其他應用，以下是主要的CSS Framework &amp; javascript lib。 bootstrap (套用版型，以及部分plugin功能) Jquery &amp; Jquery UI (主要Javascript lib) D3.js , C3.js (繪製圖表) 這些套件已經有包含大多數所需要的功能，可以快速地完成所需要的功能，不過在執行中遇到了些問題，像是Two way binding…，原本想用Jquery寫就是希望可以快點產出，而在使用者操作的部分，如資料的選擇、圖表的切換，如果沒有使用Two way binding，是很難達到良好的使用者體驗。如果還有下次，會希望趕快研究angular，在這部分可以較容易達到這個需求。 後端後端是使用Node.js，也是想趁機了解node Express的架構，以及前端配合的方式，在實際開始時，發現node express挺好上手的(就以前端來說)，接下來我也在上面運行gulp、coffeescript、sass等等…。如果有機會，會再向大家介紹所使用的前端技術的。 Deploy到Heroku是很棒的經驗，雖然在之前學Rails有推過一次，但這次不是透過教學啊！Heroku的方式，讓我有真正轉職到工程師的感覺，多麽的輕鬆優雅指令解決繁雜步驟…。 前端半成品 網站的入口，進入後如果是老手直接填入Key就可以了，如果是新手，會引導到教學範例。 這個圖表我從主計處挖來的資料，是關於各個行業的平均薪資，也可以看出各個行業在不同時間的成長及消退，從中也可以知道什麼行業行情好…，很值得入坑…。 除此之外，還會有其他使用者分享的頁面、範例教學、圖表下載等等功能，這些頁面也是不斷地調整操作流程，試著讓使用者易於理解。 如果可能的話，會盡量在農曆年前釋出第一版，也希望大家能夠給我們更好的回饋，並且以行動支持Code for Kaohsiung，不斷的激發更好的創作能量。","categories":[{"name":"project","slug":"project","permalink":"https://wcc723.github.io/categories/project/"}],"tags":[{"name":"project","slug":"project","permalink":"https://wcc723.github.io/tags/project/"}]},{"title":"專輯封面顏色作為背景色(平均色)","slug":"html5-canvas-04","date":"2014-12-17T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/18/html5-canvas-04/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/18/html5-canvas-04/","excerpt":"現在有些音樂專輯選單做得很豐富，其中一種背景色會隨著專輯色改變，我剛好想到以前有做一個CSS專輯選單，如果結合Canvas似乎就能達到差不多的效果，所以就來試試看。","text":"現在有些音樂專輯選單做得很豐富，其中一種背景色會隨著專輯色改變，我剛好想到以前有做一個CSS專輯選單，如果結合Canvas似乎就能達到差不多的效果，所以就來試試看。 範例之前的CSS範例 去年在練習CSS時就有寫一篇文章，是把CD封面作成3D的，這次就再拿這個範例做實驗，結果如下： 為愛而生 我們是五月天 神的孩子都在跳舞 後青春期的詩 人生海海 神的孩子都在跳舞 1 2 3 4 5 6 背景的顏色是使用Canvas來抓顏色資料，所以他還是必須有canvas元素，這也是可以隱藏的。 實作這一個實作的重點在於RGB顏色的平均，上一篇有介紹怎麼取得RGB的顏色，這次其實只要將RGB的顏色平均後寫入背景色就算完成了。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455$(document).ready(function()&#123; var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); $('#album input').on('change', function()&#123; //取得選擇的專輯封面 if ($(this).is(':checked'))&#123; imgPath = $(this).next('li').find('img') .attr('src'); getImg(imgPath); &#125; &#125;); function getImg(imgPath)&#123; var img = new Image(); img.src = imgPath; //取得圖片的路徑，並且讀取後取得長寬資料 img.onload = function()&#123; ctx.canvas.width = img.width; ctx.canvas.height = img.height ; draw(this,0,0); //draw function &#125;; &#125; function draw(imgObj,w,h)&#123; var x = 0, y = 0; var r=[],g=[],b=[];//準備空的R,G,B陣列 ctx.drawImage(imgObj,x,y); //將圖片繪製在canvas上 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); for(var i = 0; i &lt; imgData.data.length; i += 4) &#123; //製作原始R,G,B陣列 // red r.push(imgData.data[i]); // green g.push(imgData.data[i + 1]); // blue b.push(imgData.data[i + 2]); &#125; rgb = avg(r) + ',' + avg(g) + ',' + avg(b); //平均R,G,B顏色 $('#album').css('background-color','rgba('+rgb+',1)'); //將顏色寫入背景 &#125; function avg(arguments) &#123; //取得平均值，並且轉為整數 var sum = 0; for (var i = 0, j = arguments.length; i &lt; j; i++) &#123; sum += arguments[i]; &#125; return Math.floor(sum / arguments.length); &#125;&#125;); 後記不過我相信實作並不是這麼容易做出來的，還會去分析顏色所佔的面積，利用較大面積色彩作為背景色，如果是這樣平均的色彩容易髒髒的，在畫面上不一定好看。並且還要去計算所適合的文字色彩，這麼說一說，似乎還有很多可以研究…。 .padding{ padding: 20px; } $(document).ready(function(){ var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); $('#album input').on('change', function(){ //取得選擇的專輯封面 if ($(this).is(':checked')){ imgPath = $(this).next('li').find('img') .attr('src'); getImg(imgPath); } }); function getImg(imgPath){ var img = new Image(); img.src = imgPath; //取得圖片的路徑，並且讀取後取得長寬資料 img.onload = function(){ ctx.canvas.width = img.width; ctx.canvas.height = img.height ; draw(this,0,0); //draw function }; } function draw(imgObj,w,h){ var x = 0, y = 0; var r=[],g=[],b=[];//準備空的R,G,B陣列 ctx.drawImage(imgObj,x,y); //將圖片繪製在canvas上 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); for(var i = 0; i < imgData.data.length; i += 4) { //製作原始R,G,B陣列 // red r.push(imgData.data[i]); // green g.push(imgData.data[i + 1]); // blue b.push(imgData.data[i + 2]); } rgb = avg(r) + ',' + avg(g) + ',' + avg(b); //平均R,G,B顏色 $('#album').css('background-color','rgba('+rgb+',1)'); //將顏色寫入背景 } function avg(arguments) { //取得平均值，並且轉為整數 var sum = 0; for (var i = 0, j = arguments.length; i < j; i++) { sum += arguments[i]; } return Math.floor(sum / arguments.length); } });","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Canvas (3)，Canvas 小畫家","slug":"html5-canvas-03","date":"2014-12-08T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/09/html5-canvas-03/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/09/html5-canvas-03/","excerpt":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 翻翻一年之前做的，才發現原來有很多很酷的東西，還好有寫成簡易的文章，讓現在再重新看可以很快瞭解，這篇是介紹用Canvas做小畫家，並且還可以下載下來的功能，有分為好幾段，這邊全部合併成一篇。","text":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 翻翻一年之前做的，才發現原來有很多很酷的東西，還好有寫成簡易的文章，讓現在再重新看可以很快瞭解，這篇是介紹用Canvas做小畫家，並且還可以下載下來的功能，有分為好幾段，這邊全部合併成一篇。 參考：http://codepen.io/hossman/pen/AyaFl 範例在開始介紹之前，先了解這個範例，這樣會更瞭解本篇所介紹的內容，Canvas範例的功能： 繪製線段 存檔 調整RGB色彩 所以可以在這上面隨意畫個幾筆，在調整色彩，最後在下載看看，這個功能簡簡單單，但是做出來挺有成就感的。 R G B R G B Sorry, your browser doesn't support the &lt;canvas&gt; element. 請先在上面隨便畫兩筆 Save Canvas HTML在看JS之前，先稍微看一下這個html，這HTML也和上面一樣，分為三個部分。 12345678910111213141516171819202122&lt;div class=\"demo\"&gt;&lt;!-- 調整色彩 --&gt; &lt;div class=\"color\"&gt; R&lt;input id=\"red\" type=\"range\" name=\"points\" min=\"0\" max=\"255\" value=\"0\"&gt;&lt;br&gt; G&lt;input id=\"green\" type=\"range\" name=\"points\" min=\"0\" max=\"255\" value=\"0\"&gt;&lt;br&gt; B&lt;input id=\"blue\" type=\"range\" name=\"points\" min=\"0\" max=\"255\" value=\"0\"&gt; &lt;/div&gt; &lt;div class=\"value\"&gt; R&lt;input id=\"vred\" type=\"text\" value=\"0\"&gt; G&lt;input id=\"vgreen\" type=\"text\" value=\"0\"&gt; B&lt;input id=\"vblue\" type=\"text\" value=\"0\"&gt; &lt;/div&gt;&lt;!-- 調整色彩end --&gt;&lt;!-- Canvas --&gt; &lt;canvas id=\"canvas\" width=\"400\" height=\"400\"&gt; Sorry, your browser doesn't support the &amp;lt;canvas&amp;gt; element. &lt;/canvas&gt;&lt;!-- Canvas end --&gt;&lt;!-- 下載 --&gt; &lt;a id=\"save\" href=\"#\" download=\"aShareaDay.png\" class=\"color-btn-green\"&gt;Save Canvas&lt;/a&gt;&lt;!-- 下載end --&gt;&lt;/div&gt; 繪製線段這篇是前幾篇的綜合，還有參考http://codepen.io/hossman/pen/AyaFl所製作出來的。 這一段的重點在於，取得滑鼠的座標getMousePos(canvas, evt)，先取得滑鼠在畫布上的座標，在每次滑鼠移動時，都會繪製在畫布上，然後再放開滑鼠時，離開偵聽的事件。 下載Html5 的 a 有新的屬性download，可以將此標籤預設為下載的功能，並且預設檔名，另外在canvas可以利用toDataURL()把canvas轉成data:image。。 12&lt;!-- html5 新增download，可以用來預設下載檔名 --&gt;&lt;a id=\"save\" href=\"#\" download=\"dl.png\" &gt;Save Canvas&lt;/a&gt; 如果把產生出來的src貼在網址列，也能產生完整的圖片。 data:image參考:http://rritw.com/a/bianchengyuyan/C__/20131018/434112.html 調整色彩接下來在抓取那三個scroll bar的rgb值，將它直接寫入到ctx.strokeStyle，strokeStyle是Canvas上的筆畫樣式，這樣就大功告成了。 123456789101112$('.color input').change(function()&#123; r = $('#red').val(); g = $('#green').val(); b = $('#blue').val(); changeColor(r,g,b); //取出input中的數值 &#125;);function changeColor(r,g,b)&#123; ctx.strokeStyle = \"rgb(\"+r+\",\"+g+\",\"+b+\")\" //將數值寫入到 strokeStyle內即可&#125;; 完整程式碼12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970var _canvas = document.getElementById('canvas');var ctx = _canvas.getContext('2d'); $('.color input').change(function()&#123; r = $('#red').val(); g = $('#green').val(); b = $('#blue').val(); changeColor(r,g,b); //取出input中的數值&#125;);function changeColor(r,g,b)&#123; colors = &#123; red : r, green : g, blue : b &#125; $.each(colors, function(_color, _value) &#123; $('#v'+_color).val(_value); &#125;); ctx.strokeStyle = \"rgb(\"+r+\",\"+g+\",\"+b+\")\" ; //將顏色的值寫到ctx.strokeStyle即可&#125;;var x = 0;var y = 0;function getMousePos(canvas, evt) &#123; var rect = canvas.getBoundingClientRect(); //getBoundingClientRect 取得物件完整座標資訊，包含寬高等 return &#123; x: evt.clientX - rect.left, y: evt.clientY - rect.top &#125;; //這個function將會傳回滑鼠在 _canvas上的座標&#125;;function mouseMove(evt) &#123; var mousePos = getMousePos(_canvas, evt); //透過getMousePos function 去取得滑鼠座標 //mousePos 是一個物件，包含x和y的值 ctx.lineTo(mousePos.x, mousePos.y); //利用取回的值畫線 ctx.stroke(); //畫!&#125;;canvas.addEventListener('mousedown', function(evt) &#123; var mousePos = getMousePos(_canvas, evt); //從按下去就會執行第一次的座標取得 evt.preventDefault(); ctx.beginPath(); //建立path物件 ctx.moveTo(mousePos.x, mousePos.y); //每次的點用moveTo去區別開，如果用lineTo會連在一起 canvas.addEventListener('mousemove', mouseMove, false); //mousemove的偵聽也在按下去的同時開啟&#125;);canvas.addEventListener('mouseup', function() &#123; canvas.removeEventListener('mousemove', mouseMove, false);&#125;, false);//如果滑鼠放開，將會停止mouseup的偵聽$('#save').on('click', function()&#123; var _url = _canvas.toDataURL(); //利用toDataURL() 把canvas轉成data:image this.href = _url; //再把href載入上面的Data:image&#125;); 在畫個小新，滑鼠挺有挑戰性的…。 雖然是一些舊的文章，但現在回頭過來看，還是有許多有趣的點，甚至可以用這些概念，配合現在會的技術，發展出更有趣的玩具。 var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); $('.color input').change(function(){ r = $('#red').val(); g = $('#green').val(); b = $('#blue').val(); changeColor(r,g,b); //取出input中的數值 }); function changeColor(r,g,b){ colors = { red : r, green : g, blue : b } $.each(colors, function(_color, _value) { $('#v'+_color).val(_value); }); ctx.strokeStyle = \"rgb(\"+r+\",\"+g+\",\"+b+\")\" ; //將顏色的值寫到ctx.strokeStyle即可 }; var x = 0; var y = 0; function getMousePos(canvas, evt) { var rect = canvas.getBoundingClientRect(); //getBoundingClientRect 取得物件完整座標資訊，包含寬高等 return { x: evt.clientX - rect.left, y: evt.clientY - rect.top }; //這個function將會傳回滑鼠在 _canvas上的座標 }; function mouseMove(evt) { var mousePos = getMousePos(_canvas, evt); //透過getMousePos function 去取得滑鼠座標 //mousePos 是一個物件，包含x和y的值 ctx.lineTo(mousePos.x, mousePos.y); //利用取回的值畫線 ctx.stroke(); //畫! }; canvas.addEventListener('mousedown', function(evt) { var mousePos = getMousePos(_canvas, evt); //從按下去就會執行第一次的座標取得 evt.preventDefault(); ctx.beginPath(); //建立path物件 ctx.moveTo(mousePos.x, mousePos.y); //每次的點用moveTo去區別開，如果用lineTo會連在一起 canvas.addEventListener('mousemove', mouseMove, false); //mousemove的偵聽也在按下去的同時開啟 }); canvas.addEventListener('mouseup', function() { canvas.removeEventListener('mousemove', mouseMove, false); }, false); //如果滑鼠放開，將會停止mouseup的偵聽 $('#save').on('click', function(){ var _url = _canvas.toDataURL(); //利用toDataURL() 把canvas轉成data:image this.href = _url; //再把href載入上面的Data:image }); input[type='range']{ width: 50%; } canvas{ margin: 0 auto; border: 1px solid #E80C7A; }","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Canvas (2)，調整Canvas圖片色調","slug":"html5-canvas-02","date":"2014-12-07T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/08/html5-canvas-02/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/08/html5-canvas-02/","excerpt":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage 這篇主要是介紹Canvas中調整RGB的值，藉此改變顏色色調。","text":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage 這篇主要是介紹Canvas中調整RGB的值，藉此改變顏色色調。 Canvas 調整色調利用canvas可以重新調整影像的樣式，其中一種就是改變色彩。 參考：http://www.html5canvastutorials.com/advanced/html5-canvas-invert-image-colors-tutorial/ 反轉顏色點陣圖是由很多的點構成的，而每一個點都是由RGB三色組成，所以要反轉顏色前必須先取得每一個點的RGB值。 //影像rgb的資訊 //以下數值每三個一組，如72,84,74這樣是一組，72是紅色(R)、84是綠色(G)、74是藍色(B) [72, 84, 74, 255, 85, 95, 86, 255, 98, 106, 95, 255, 103, 106, 97, 255, 107, 109, 98, 255, 117, 114, 105, 255, 123, 119, 108, 255, 125, 118, 108, 255, 133, 127, 115, 255, 134, 130, 118, 255, 139, 137, 125, 255, 143, 145, 132, 255, 150, 154, 140, 255, 155, 163, 148, 255, 163, 171, 158, 255, 166, 177, 163, 255, 175, 181, 169, 255, 177, 183, 171, 255, 183, 186, 175, 255, 185, 188, 177, 255, 187, 190, 179, 255, 188, 191, 180, 255, 191, 193, 182, 255, 192, 194, 183, 255, 196, 196, 184, 255…] 反轉顏色就是將(255 - 值)，這樣減了以後就會黑色變白色，黃色變藍等等。 1234567891011121314151617181920212223242526272829303132333435363738394041var _canvas = document.getElementById('canvas');var ctx = _canvas.getContext('2d');//建立canvas物件var img = new Image();img.onload = function()&#123; ctx.canvas.width = img.width ctx.canvas.height = img.height draw(this,0,0); //draw function&#125;;img.src = '/images/2013-winter/cd2.jpg';//圖片載入的事件(與上次同)function draw(imgObj,w,h)&#123;var x = 0;var y = 0;//先定義圖片的x,p坐標位置ctx.drawImage(imgObj,x,y);//將原始的圖片匯入var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height);//取得canvas物件的資訊(需要完整的坐標及範圍)var data = imgData.data;//再將資訊轉存出來console.log(data);//這時候用console.log(data)，就可以看到RGB的值for(var i = 0; i &lt; data.length; i += 4) &#123; //利用回圈將顏色全部替換 // red data[i] = 255 - data[i]; // green data[i + 1] = 255 - data[i + 1]; // blue data[i + 2] = 255 - data[i + 2]; &#125; ctx.putImageData(imgData,0,0) //重新將新的影像資訊覆蓋上去&#125; Sorry, your browser doesn't support the &lt;canvas&gt; element. Note: The getImageData() method requires that the image is hosted on a web server with the same domain as the code executing it. If this condition is not met, a SECURITY_ERR exception will be thrown.(跨網域會有問題) var _canvas = document.getElementById('canvas'); var ctx = _canvas.getContext('2d'); //建立canvas物件 var img = new Image(); img.onload = function(){ ctx.canvas.width = img.width ctx.canvas.height = img.height draw(this,0,0); //draw function }; img.src = '/images/2013-winter/cd2.jpg'; //圖片載入的事件(與上次同) function draw(imgObj,w,h){ var x = 0; var y = 0; //先定義圖片的x,p坐標位置 ctx.drawImage(imgObj,x,y); //將原始的圖片匯入 var imgData = ctx.getImageData(x, y, imgObj.width, imgObj.height); //取得canvas物件的資訊(需要完整的坐標及範圍) var data = imgData.data; //再將資訊轉存出來 console.log(data); //這時候用console.log(data)，就可以看到RGB的值 for(var i = 0; i < data.length; i += 4) { //利用回圈將顏色全部替換 // red data[i] = 255 - data[i]; // green data[i + 1] = 255 - data[i + 1]; // blue data[i + 2] = 255 - data[i + 2]; } ctx.putImageData(imgData,0,0) //重新將新的影像資訊覆蓋上去 } 手動調整色調利用剛剛的反轉顏色，再加入一些控制元素，就可以做出類似photoshop的影像調整工具(簡易版…)，說實在還挺有趣的。 首先，先新增三個input將type設定為range，min值爲0，max值爲255，這樣就能做出RGB的控制條。 12345&lt;div class=\"color\"&gt; R&lt;input id=\"colorR\" type=\"range\" name=\"points\" min=\"0\" max=\"255\" value=\"255\"&gt;&lt;br&gt; G&lt;input id=\"colorG\" type=\"range\" name=\"points\" min=\"0\" max=\"255\" value=\"0\"&gt;&lt;br&gt; B&lt;input id=\"colorB\" type=\"range\" name=\"points\" min=\"0\" max=\"255\" value=\"0\"&gt;&lt;/div&gt; R G B Sorry, your browser doesn't support the &lt;canvas&gt; element. 1234567891011121314151617181920212223242526272829303132333435363738394041424344var _canvas2 = document.getElementById('canvas2');var ctx2 = _canvas2.getContext('2d');var _colorR = $('#colorR').val();var _colorG = $('#colorG').val();var _colorB = $('#colorB').val();var x = 0;var y = 0;var img2 = new Image();img2.onload = function()&#123; ctx2.canvas.width = img2.width ctx2.canvas.height = img2.height draw2(this,0,0);&#125;;img2.src = '/images/2013-winter/cd2.jpg';//以上和上次接近，只是將幾個不太會改變的變數改成全域變數$('.color').on('change','input',function()&#123;//多一個on change的function，去監控這次加入的input//只要他改變，就會執行這個function _colorR = $('#colorR').val() _colorG = $('#colorG').val() _colorB = $('#colorB').val() //重新取得input的 RGB的值 imgObj = img2; draw2(imgObj);&#125;);function draw2(imgObj,w,h)&#123; ctx2.drawImage(imgObj,x,y); var imgData = ctx2.getImageData(x, y, imgObj.width, imgObj.height); var data = imgData.data; for(var i = 0; i &lt; data.length; i += 4) &#123; // 這邊以下將會套用新的RGB色彩 // red data[i] = _colorR - (255 - data[i]); // green data[i + 1] = _colorG - (255 - data[i + 1]); // blue data[i + 2] = _colorB - (255 -data[i + 2]); &#125; ctx2.putImageData(imgData,0,0)&#125; var _canvas2 = document.getElementById('canvas2'); var ctx2 = _canvas2.getContext('2d'); var _colorR = $('#colorR').val(); var _colorG = $('#colorG').val(); var _colorB = $('#colorB').val(); var x = 0; var y = 0; var img2 = new Image(); img2.onload = function(){ ctx2.canvas.width = img2.width ctx2.canvas.height = img2.height draw2(this,0,0); }; img2.src = '/images/2013-winter/cd2.jpg'; //以上和上次接近，只是將幾個不太會改變的變數改成全域變數 $('.color').on('change','input',function(){ //多一個on change的function，去監控這次加入的input //只要他改變，就會執行這個function _colorR = $('#colorR').val() _colorG = $('#colorG').val() _colorB = $('#colorB').val() //重新取得input的 RGB的值 imgObj = img2; draw2(imgObj); }); function draw2(imgObj,w,h){ ctx2.drawImage(imgObj,x,y); var imgData = ctx2.getImageData(x, y, imgObj.width, imgObj.height); var data = imgData.data; for(var i = 0; i < data.length; i += 4) { // 這邊以下將會套用新的RGB色彩 // red data[i] = _colorR - (255 - data[i]); // green data[i + 1] = _colorG - (255 - data[i + 1]); // blue data[i + 2] = _colorB - (255 -data[i + 2]); } ctx2.putImageData(imgData,0,0) } 以前很多的範例，久沒看真的都會在忘記，趁這段時間整理的時候再稍微複習一下，","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Canvas","slug":"html5-canvas-01","date":"2014-12-03T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"canvas/2014/12/04/html5-canvas-01/","link":"","permalink":"https://wcc723.github.io/canvas/2014/12/04/html5-canvas-01/","excerpt":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage","text":"這篇也是前一個Blog的文章，最近在整理就一起拿出來。 Canvas挺有趣的，在一年前試過，而網路上也有相當多的library，但是在使用lib前還是先簡單了解一下canvas的運作吧。 參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/Basic_usage 來源：http://cssdeck.com/labs/css3-webkit-vertical-scrollbars 初入HTML5 CanvasHTML Canvas標籤裡面的字當然是不必要的，只是瀏覽器不支援canvas的話就會顯示，而canvas標籤是繪製canvas必要的元素，和img元素不同，他必須要結尾的標籤。 123&lt;canvas id=\"canvas\" width=\"300\" height=\"300\"&gt; Sorry, your browser doesn't support the &lt;canvas&gt; element.&lt;/canvas&gt; Rendering context這是指渲染的方式，而就我所參考的範例，將會用2D呈現，當然也是能夠有3D的渲染方式(看瀏覽器支援程度)。 參考：http://www.w3school.com.cn/htmldom/met_canvas_getcontext.asp 12var _canvas = document.getElementById('canvas');var ctx = canvas.getContext('2d'); Canvas接下來就可以利用js把canvas繪製入canvas內了。 1234567891011121314151617181920212223242526var _canvas = document.getElementById('canvas');if (_canvas.getContext) &#123; //判斷是否支援 var ctx = canvas.getContext('2d'); //宣告ctx渲染方式 draw(); //執行draw function&#125;else &#123; alert('your browser not support canvas') //如果不支援&#125;;function draw()&#123; //利用ctx開始繪製 ctx.fillStyle = \"rgb(200,0,0)\"; //fillStyle:定義用於繪畫的顏色填充模式 ctx.fillRect (10, 10, 55, 50); //fillRect:繪製被填充的矩形 ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\"; ctx.fillRect (30, 30, 55, 50); //同上&#125; Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas = document.getElementById('Canvas'); console.log(_canvas, '111'); if (_canvas.getContext) { var ctx = _canvas.getContext('2d'); draw(); }else { alert('your browser not support canvas') }; function draw(){ ctx.fillStyle = \"rgb(200,0,0)\"; ctx.fillRect (10, 10, 55, 50); ctx.fillStyle = \"rgba(0, 0, 200, 0.5)\"; ctx.fillRect (30, 30, 55, 50); } canvas{ border: 1px rgba(255,255,255,.5) solid; } 這樣就繪製了一個簡易的Canvas圖形，跟SVG落差非常大呢。 繪製其他圖形參考：https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/Canvas_tutorial/ 畫一些方形在上一次開始canvas後，接下來要畫一些東西，並了解他一些簡單的參數設定。 fillRect(x, y, width, height) //畫一個填滿色彩的正方形 strokeRect(x, y, width, height) //畫一個正方形線段外框 clearRect(x, y, width, height) //清除一個正方形區塊，並且讓它顏色透明 123456789101112131415 var _canvas2 = document.getElementById('canvas2'); if (_canvas2.getContext) &#123; var ctx = canvas2.getContext('2d'); draw2(); &#125;function draw2()&#123; ctx.fillStyle = \"rgb(200,0,0)\"; //正方形的填滿色彩 ctx.fillRect (10, 10, 130, 130); //繪製一個填滿色彩的正方形 ctx.clearRect(20, 20, 110, 110); //摟空一個正方形區域 ctx.strokeStyle = \"rgb(0,200,0)\"; //正方形線段的色彩 ctx.strokeRect(40, 40, 70, 70); //畫一個正方形線段&#125; Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas2 = document.getElementById('canvas2'); if (_canvas2.getContext) { var ctx = canvas2.getContext('2d'); draw2(); } function draw2(){ ctx.fillStyle = \"rgb(200,0,0)\"; //正方形的填滿色彩 ctx.fillRect (10, 10, 130, 130); //繪製一個填滿色彩的正方形 ctx.clearRect(20, 20, 110, 110); //摟空一個正方形區域 ctx.strokeStyle = \"rgb(0,200,0)\"; //正方形線段的色彩 ctx.strokeRect(40, 40, 70, 70); //畫一個正方形線段 } 畫一些路徑beginPath() //建立一個線段，如果需要畫線段必須要建立一個新線段 closePath() //線段的結尾，這並不是必需的 stroke() //線段上色(筆畫) fill() //線段填滿顏色 其實這邊的觀念和adobe illustrator相當類似，Illustrator 中的線段一樣分為填色和筆畫，也有分為是不是封閉取線。 Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas3 = document.getElementById('canvasB'); if (_canvas3.getContext) { var ctx = _canvas3.getContext('2d'); draw3(); } function draw3(){ ctx.beginPath(); //線段開始 ctx.moveTo(20,100); //從20,100的點 ctx.lineTo(130,100); //畫線段到130,100 ctx.lineTo(75,25); ctx.fill(); //填滿 } 1234567891011121314 var _canvas3 = document.getElementById('canvasB'); if (_canvas.getContext) &#123; var ctx = canvas3.getContext('2d'); draw3(); &#125;function draw3()&#123; ctx.beginPath(); //線段開始 ctx.moveTo(20,100); //從20,100的點 ctx.lineTo(130,100); //畫線段到130,100 ctx.lineTo(75,25); ctx.fill(); //填滿 &#125; Move To要畫一個好看的圖案太難了(崩潰)，所以我直接參考上面的提供的網址。 Sorry, your browser doesn't support the &lt;canvas&gt; element. var _canvas4 = document.getElementById('canvasC'); if (_canvas4.getContext) { var ctx = _canvas4.getContext('2d'); draw4(); } function draw4(){ ctx.strokeStyle = \"rgb(220,200,45)\"; ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // Outer circle ctx.moveTo(110,75); ctx.arc(75,75,35,0,Math.PI,false); // Mouth (clockwise) ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // Left eye ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // Right eye ctx.stroke(); } 12345678910111213//要畫一個好看的圖案太難了，所以我直接參考上面的提供的網址。function draw4()&#123; ctx.strokeStyle = \"rgb(220,200,45)\"; //線段顏色 ctx.beginPath(); ctx.arc(75,75,50,0,Math.PI*2,true); // 最外圈的線段 ctx.moveTo(110,75); //跳到另一個線段 ctx.arc(75,75,35,0,Math.PI,false); // 嘴巴 ctx.moveTo(65,65); ctx.arc(60,65,5,0,Math.PI*2,true); // 左眼 ctx.moveTo(95,65); ctx.arc(90,65,5,0,Math.PI*2,true); // 右眼 ctx.stroke(); //筆畫上色 &#125; 這些是舊的部落格文章，最近整理出來的部分。","categories":[{"name":"canvas","slug":"canvas","permalink":"https://wcc723.github.io/categories/canvas/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"Webkit 自定義Scroll Bar外觀","slug":"css-scrollbar","date":"2014-12-02T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/12/03/css-scrollbar/","link":"","permalink":"https://wcc723.github.io/css/2014/12/03/css-scrollbar/","excerpt":"Webkit 可以利用CSS修改Scoll bar的外觀，有試過其他瀏覽器是不行的，而有時候在使用局部範圍的overflow: auto，會需要較為纖細的scroll bar，如果不在意webkit以外的瀏覽器，可以試試看這個方法。","text":"Webkit 可以利用CSS修改Scoll bar的外觀，有試過其他瀏覽器是不行的，而有時候在使用局部範圍的overflow: auto，會需要較為纖細的scroll bar，如果不在意webkit以外的瀏覽器，可以試試看這個方法。 來源：http://cssdeck.com/labs/css3-webkit-vertical-scrollbars 上面這是內建webkit的scroll bar，有些時候因為需要配合版面，這樣式並不合適，而Webkit的瀏覽器可以透過以下CSS來做調整。 123456789101112&amp;::-webkit-scrollbar//&quot;&amp;&quot;是必須與上一層同層級//-webkit-scrollbar : 整體的scrollbar樣式&amp;::-webkit-scrollbar-thumb//bar的樣式&amp;::-webkit-scrollbar-track//軌道的樣式::-webkit-scrollbar-thumb:window-inactive//頁面是在被啟用的情況下(非必要) scrollbar範例注意本範例只有Webkit瀏覽器有效，Chrome or Safari style1 style2 style3 style4 style5 style6 如果要跨瀏覽器的scrollbar，就建議使用javascript或是jquery了。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Jquery 重複點擊判斷","slug":"jquery-repeat-click","date":"2014-12-01T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"jquery/2014/12/02/jquery-repeat-click/","link":"","permalink":"https://wcc723.github.io/jquery/2014/12/02/jquery-repeat-click/","excerpt":"這篇是舊文重貼，原本是在aShareaDay上的文章，可能因為太短…，所以我沒放到這新的Blog上，但最近有人在詢問(感謝貴人提醒)，範例也相當實用，就再重新放上來。","text":"這篇是舊文重貼，原本是在aShareaDay上的文章，可能因為太短…，所以我沒放到這新的Blog上，但最近有人在詢問(感謝貴人提醒)，範例也相當實用，就再重新放上來。 Jquery有個很簡單的方式可以做到重複點擊判斷，這邊就不再多作闡述，只要看了範例就可以快速瞭解。 來源：http://jsfiddle.net/visualidiot/WJEBr/ 點我 1234$('.d0818click').click(function() &#123; $('.old').animate(&#123;left: '+=10'&#125;); $('.new').is(':animated') || $('.new').animate(&#123;left: '+=10'&#125;);&#125;); 寫到這，我突然想起來為什麼沒有放到這Blog上了…，因為當時Jekyll載入外部Js功能還沒寫好，後來寫好忘記放進來…，所以最近可以補很多以前的Js文章…。 另外舊的Blog(aShareaDay)因為空間沒有再續約，所以停了，大部分文章在這Blog都可以找到，有缺的部分也會盡量補齊，感謝大家的支持。","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"視覺前端 - 按鈕的使用情境","slug":"button-style-2","date":"2014-11-25T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"design/2014/11/26/button-style-2/","link":"","permalink":"https://wcc723.github.io/design/2014/11/26/button-style-2/","excerpt":"視覺規範沒有一定的標準，究竟是美醜優先，還是使用者體驗優先，這都沒有一個準則，當然在最理想的情況下，是能同時符合兩者。所以在按鈕的使用上，我嘗試找出一些規則，來讓畫面不至於凌亂，並且讓使用者可以感受到舒適。 而按鈕本身有著不同的個性，所以在畫面的使用上，也會依據需求的不同，來使用不同個性的按鈕。就算是同一個Framework所提供的按鈕，也會有相當多樣的選擇供開發者使用，但是選擇一多，往往也會造成困擾。 “目前的情況下該用哪種按鈕？” 上面的問題，我也思考很久，所以整理了幾種可能的性給大家參考參考。","text":"視覺規範沒有一定的標準，究竟是美醜優先，還是使用者體驗優先，這都沒有一個準則，當然在最理想的情況下，是能同時符合兩者。所以在按鈕的使用上，我嘗試找出一些規則，來讓畫面不至於凌亂，並且讓使用者可以感受到舒適。 而按鈕本身有著不同的個性，所以在畫面的使用上，也會依據需求的不同，來使用不同個性的按鈕。就算是同一個Framework所提供的按鈕，也會有相當多樣的選擇供開發者使用，但是選擇一多，往往也會造成困擾。 “目前的情況下該用哪種按鈕？” 上面的問題，我也思考很久，所以整理了幾種可能的性給大家參考參考。 外框線與填滿類型外框線與填滿類型，會因為網頁設計的底色有不同定義，假設背景是淺色系，那麼深色的按鈕就會被認定為填滿；反之，深色的背景，那麼淺色就是被認定為填滿。 這個部分我選擇Bootstrap 3的按鈕來說明(選用單純的按鈕，去除其他可能性)，左邊我稱為外框線的按鈕，右邊則是填滿的按鈕。 外框線的按鈕這種按鈕是通常是白色底或是淺灰階的底色，搭配上不同色彩的文字，文字的色彩通常預設為藍色或是黑色。 填滿的按鈕而填滿的按鈕，則是按鈕底色充滿色彩，如：黑色、藍色、紅色等等，文字的色彩通常是白色，當然也有可能會出現其他淺色系的文字。 外框線的按鈕 填滿的按鈕 吸引力 較不引人注目 吸引使用者注目 個性 輕鬆、細膩 大膽、強烈 用途 大部份的按鈕 希望使用者注意按鈕 色彩 淺色 或接近於背景色 深色 或者相對於背景色 重要度 低 高 接下來，在從一些範例來說明以上的內容。 範例奇妙清單 奇妙清單是一個雲端記事本的工具，有點類似Evernote，但是沒有那麼多功能，主要是利用列表來記錄待辦事項等等。這一類型的服務工具，首要工作就是吸引使用者的使用，有足夠的使用者試用後，才能在推銷更進階付費服務。 網站背景色是淺色系，綠色的試用按鈕以及右上方的藍色按鈕，都屬於先前所提到的填滿類型按鈕(兩者其實動作是類似的)；其他的部分如登入、觀看影片的動作都是外框線的按鈕。這也清楚地說明註冊、試用的動作比其他都還要重要，所以將註冊使用填滿類型的按鈕。 Github Github是Git雲端版本儲存庫，是目前最流行版本控管儲存庫，而這類型的工具，和一般使用者所接觸的網頁會有很大的不同，這類型網站有許多功能可以去設定、調整、觀看等等。所以在畫面上會有許多的按鈕，在這樣的情況下必須決定什麼是這畫面上最重要的，以及避免畫面的凌亂。 這畫面上，大多的按鈕都是屬於外框線類型的按鈕，只有一個綠色的填滿類型按鈕(Compare, review, create a pull request)，且是用圖示表示，那綠色按鈕是Git進行版本控管的一些功能，所以就這畫面而言，版本控管是最為重要的，這個方式不僅可以將重點標示出來，也可以保持畫面的整潔，試想：如果畫面充滿了五顏六色的按鈕，那麼重點在哪？ 另外，在Github的設定選項內，其中可以找到刪除儲存庫的功能，要特別注意到，”刪除”並不是重要的選項，而是要避免使用者誤觸，所以這部分Github使用外框線的按鈕，搭配紅色的文字。 Github這網站有相當多的功能，大家不妨隨便逛看看，它們在設計時，大多頁面通常只有一個填滿類型的按鈕(少數會超過一個)。 當然，這邊所提的原則，並不是絕對，也有很多更好設計(包含很好的UX)。但是在規劃版面按鈕還沒有任何想法時，可以嘗試這樣的規則。 找出畫面上最重要功能使用填滿類型的按鈕 其他通通都是用外框線類型的按鈕","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"高雄前端社群 - d3js","slug":"d3js-in-kh-frontend","date":"2014-11-24T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"d3js/2014/11/25/d3js-in-kh-frontend/","link":"","permalink":"https://wcc723.github.io/d3js/2014/11/25/d3js-in-kh-frontend/","excerpt":"上週在高雄前端社群介紹的D3.js，忘記放到Blog上，這次介紹的內容，和之前在鐵人賽有許多不同的點，範例很多都是全新的喲。","text":"上週在高雄前端社群介紹的D3.js，忘記放到Blog上，這次介紹的內容，和之前在鐵人賽有許多不同的點，範例很多都是全新的喲。 活動資訊KKTIX：http://gonsakon-7655f2.kktix.cc/events/a5791ac5 簡報連結：D3.js for 高雄前端 這次的範例很多，主要是想要讓大家可以透過範例快速理解(不過還是被說範例太多了orz，觀者會很累)，簡報不宜介紹過多的重點…。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"視覺前端 - 按鈕的個性","slug":"button-style-1","date":"2014-11-23T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"design/2014/11/24/button-style-1/","link":"","permalink":"https://wcc723.github.io/design/2014/11/24/button-style-1/","excerpt":"在參加完鐵人賽以後，會想要再精進UI設計的部分，所以想試著寫設計得文章，接下來會連續幾篇UI設計的文章，有些是在鐵人賽前就準備好的，最近在重新整理PO出來，希望大家會感興趣。 網路上有許多開源的Framework，通常我都會參考他們的按鈕以及表單設計，因為這是最能夠表達Framework特色的元件。按鈕與表單，按鈕更能表達一個Framework的個性，如圓角、顏色填充的方式、預設的色彩變化、單位計算方式(em or px)等等，當然表單也有，但許多為了實用性，表單會將設計簡化。","text":"在參加完鐵人賽以後，會想要再精進UI設計的部分，所以想試著寫設計得文章，接下來會連續幾篇UI設計的文章，有些是在鐵人賽前就準備好的，最近在重新整理PO出來，希望大家會感興趣。 網路上有許多開源的Framework，通常我都會參考他們的按鈕以及表單設計，因為這是最能夠表達Framework特色的元件。按鈕與表單，按鈕更能表達一個Framework的個性，如圓角、顏色填充的方式、預設的色彩變化、單位計算方式(em or px)等等，當然表單也有，但許多為了實用性，表單會將設計簡化。 現在大多的HTML元件，在執行上大多會使用CSS語法，較少使用圖片，這樣可以提高元件可用性，在維護上也較為容易。而我在設計按鈕時，以時常會參考這些Framework的做法，再加以改變，這些Framework有許多CSS細節，非常有參考價值。 以下列出幾個常見的CSS Framework button。 Bootstrap 2Bootstrap 2 自從 2 開始就是Web frontend相當主流的CSS Framework，在 3 發行之後，2 的維護也中止，使用這套Framework的開發者也相對少很多，但是在網路上還是經常可以看到由Bootstrap 2所設計的網頁，Bootstrap 2依然是一款經典的CSS Framewrok。 Bootstrap 2 按鈕設計特色 明顯的漸層 鮮豔的色彩 些許的內陰影 4px的圓角 凸起的立體感 早期的按鈕，許多都是用圖片做的，因為圖片可以表現立體感、圓角等等的質感，以前的CSS沒有辦法達到這樣的效果。直到了CSS3，圓角、漸層、陰影都可以透過CSS運用在web上，此時也就流行了透過CSS達到圖片可以做的效果，如Bootstrap 2所表現的。 這當中我最愛他的primary預設藍色漸層色彩，不僅顏色抓得恰到好處，搭配著些許內陰影，充分表現出類似圖片所能呈現的質感，但又更為精緻。 Bootstrap 3Bootstrap 3 扁平化設計 Metro UI 在Window 8推出以後(Metro UI)，許多UI設計開始導入扁平化設計(Flat Design)的概念，而Web當然也不例外。扁平化就廣義來說，是相對於擬真的設計，去除了陰影、立體感，使用色塊來組成視覺的界面。 Bootstrap 3 按鈕設計特色 單色、無漸層 顏色較為沈穩 無陰影 一樣4px的圓角 無立體感 相對於Bootstrap 2的立體效果，Bootstrap導入了扁平化設計的概念，除了圓角外，其他立體效果都被移除。雖然沒有以往的立體感，但這樣的做法可以有效地減少使用者界面複雜度，更能凸顯按鈕的功能。 整個Framework在設計上相當的偏重於功能性，移除了大部分的漸層、陰影，在單一按鈕的設計上，雖沒有Bootstrap 2 那麼的豐富，但也因為如此，他更能配合各網頁原有的設計，不會過度的突出。 Jquery Mobile 1.3Jquery Mobile 1.3 Jquery Mobile Jquery Mobile 是基於Jquery所開發的行動裝置Web Framework，不僅在樣式上，還有許多的在行動裝置可用的效果，而這款Framework也有屬於自己的CSS 樣式。 Jquery Mobile 1.3 按鈕設計特色 淺漸層 顏色較為暗沈 有陰影 1em的圓角 明顯浮起的立體感 Jquery mobile像對於其他CSS framework來說，視覺感較為工程導向，和Bootstrap2 比較來說，顏色稱不上鮮豔，較為混濁。畢竟Jquery mobile是用在行動裝置上，所以在規劃上並不是只有美觀，它凸顯了按鈕的立體感並且增加按鈕的尺寸，以便於觸控。 Jquery Mobile 1.4Jquery Mobile 1.4 Jquery Mobile 1.4和以往的設計有很大的落差，最大的差別就是導入了扁平化設計，所以在預設的款式是沒有圓角、陰影、漸層等效果。 Jquery Mobile 1.4 按鈕設計特色 無漸層 預設僅有黑白兩色 預設無陰影(可選擇) 預設無圓角(可選擇) 無立體感 就像上圖一樣，預設的按鈕相當的扁平，雖然他也提供圓角、陰影作為選擇，但沒有以往的強烈。另外在尺寸上有很重要變化，就是基本的按鈕高度為44px，44px是行動裝置上手指合適的觸控範圍尺寸。 而Jquery Mobile兩個不同版本也刻意一起放出來比較，兩個在設計上已有很大的落差，1.4去除了許多裝飾(大圓角、漸層)，也將小圖示從png圖片換成了svg，這在retina顯示器的表現更為精緻。整體設計來說，我偏愛1.4的扁平化，不知大家覺得如何？ PurePure CSS Pure CSS Framework的設計理念是為了讓CSS更為簡單化，所有的元件都分為核心以及擴充兩類別，核心通常定義元件的尺寸、瀏覽器相容性，擴充則是定義元件的色彩、更多尺寸、不同狀態等。 Pure 按鈕設計特色 無漸層 (Hover有) 單色 無陰影 2px 圓角 無立體感 Pure的按鈕，就視覺上是我喜歡的類型，有著簡單的外形、細膩的變化，用相當少量的程式碼達到跨瀏覽器的效果。另外Pure的按鈕有個很特別的特色，是其他Framework少見的效果，就是在hover的色彩，按鈕無論是哪一種顏色，都僅用半透明的漸層色覆蓋在上面，這樣可以有效地減少CSS程式碼，又能表現出hover的效果，我想這是最符合Pure簡化的個性吧。 Pure整個Framework在設計概念上就是要不斷地縮短CSS code，所以和其他Framework都有些不同，但又同時保有細膩的設計，也是很值得參考的framework。 結論以上列出了幾款不同framework的按鈕，不論他的架構，透過不同的設計，自然而然就會產生不同的個性，而這些個性，也會依據觀者的不同，會有不同的解讀方式；有人會喜歡Bootstrap 2的鮮豔漸層變化，也會有著許多人喜歡Bootstrap 3的純粹色彩，當然顏色深淺、鮮豔程度也都有不同的觀感。 在製作時，參考合適的Framework風格(設計)，並挑選合適的執行方式(CSS)，在初學上可以減少錯誤，提升專案的可執行性。 這篇看到了相當多的按鈕，接下來可能會出現一個問題，目前畫面適合放什麼按鈕，所以下一篇要介紹的是按鈕在畫面上的佈局規劃，如何透過簡單的方式，清楚了解目前畫面上合適的按鈕樣式。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"前端設計師的設計與執行","slug":"frontend-designer-how-to-work","date":"2014-11-11T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"design/2014/11/12/frontend-designer-how-to-work/","link":"","permalink":"https://wcc723.github.io/design/2014/11/12/frontend-designer-how-to-work/","excerpt":"圖片來源 google material design 看到 嫁給RD的 UI Designer 的這篇文章有感，想說也寫一下我對於這個主題的想法，在工作的流程中，每個人所佔的崗位不同，都會有不同的觀點，她的這一篇所在的角色是UI，我的看法是設計師與前端之間的角色。 從學設計到現在轉職成前端，因為設計背景的關係，所以大部份在執行時都是從設計到切版都是我做，這在執行上並一定是好的流程，只是不同崗位，有不同的觀點，同時橫跨兩個崗位，就會掌握不同的面向，但畢竟是一個人，無法面面俱到，所以這邊會提出一些我的看法及解決辦法。","text":"圖片來源 google material design 看到 嫁給RD的 UI Designer 的這篇文章有感，想說也寫一下我對於這個主題的想法，在工作的流程中，每個人所佔的崗位不同，都會有不同的觀點，她的這一篇所在的角色是UI，我的看法是設計師與前端之間的角色。 從學設計到現在轉職成前端，因為設計背景的關係，所以大部份在執行時都是從設計到切版都是我做，這在執行上並一定是好的流程，只是不同崗位，有不同的觀點，同時橫跨兩個崗位，就會掌握不同的面向，但畢竟是一個人，無法面面俱到，所以這邊會提出一些我的看法及解決辦法。 規劃首先，在設計前必須了解需求，需求不外乎包含瀏覽器限制、Responsive web design、整體色調、是否包含維護、配合的後端技術or其他framework等等…，再從這些面向去思考設計如何執行。 瀏覽器限制基本上我現在所執行的網站大多是IE8+，甚至是不用管IE(在2013年後期政府專案很多都只要ie8+)，這些直接影響了所使用的CSS layout、CSS3效果、SVG等等效果，如果還有使用webfont，雖然可以執行，但是Render 會很醜…。 如果遇到需要配合低階瀏覽器，會避免掉許多效果，像是RWD、Retina display。配合低階瀏覽器，還要做這些，無疑是拿石頭砸自己的腳；且目標客群都不想用新式瀏覽器，自然也不會在乎這網站上用了什麼技術。 設計工具講到這就突然難過了起來，以前我都是使用Illustrator，在設計Web時剛開始也就認命的辛苦些(有點難用)，直到了用過Sketch、Affinity Designer，發現不僅是程式不斷的在演化，設計工具也是必須有改變，但苦於想學的東西太多，不知不覺設計工具的優先值就被往後排了。 因此在設計前先了解對於軟體的熟悉度，以及專案是否有配合其他設計師，從中判斷用哪套軟體(現在我多用Sketch 起手)。 關於Sketch、Affinity Designer，兩套我都有買，但並非相當精通，我認為Sketch較偏向Layout，而Affinity比較適合繪製細節，像是Icon、Logo等。 Sketch Affinity Designer Responsive web design這也是重點中的重點，今年以前Responsive web design只要提出來，價碼都好說好說(以後幾乎是必備)，所以在前公司提案時，盡量都會以Responsive web design為賣點，以增加拿到案子的成功率，所以既然挖了這個坑就要自己跳了…。 RWD在執行時，要先思考使用CSS framework 或是自己用sass做，在過去我主要會使用sass 搭配 susy執行，但現在由於專案越來越大，我就會自幹CSS framework。兩者不同點在於susy 比較適合小型專案，他可以語意化Class，可以快速搭建小型專案所需的layout，但在大型專案中，所有的CSS最好都是模組化，可供各頁面重複使用，以增加工作效率。 如果真有要考慮RWD，會Sass是比較好，如果不熟Sass，使用bootstrap grid system可能會穩定些。 顏色(這部分我改天整理更完整的) 在使用繪圖軟體時，調色我都使用RGB bar去拉，再把最適合的色彩存在色票內，可能會約存5種色彩(主要顏色、底色、次要色、警告色、提示色等)，有點類似bootstrap所提供色彩，但會因為專案的不同所調整。 常用的顏色會拉下來當色票，不過建議是排整齊，別跟我一樣，排整齊之後反而找不到…。 顏色上再進入sass開發後，會定義成變數，並且在套用時進行色彩運算，如果是經常使用的色彩，也可以先運算。 123$primary-color: #009aff$primary-color-darken: darken($primary-color, 10%)$primary-color-lighten: lighten($primary-color, 10%) See the Pen zxOgZR by Wcc723 (@Wcc723) on CodePen. 這樣可以讓顏色更有系統的管理，不過變數的命名又是另一門學問了，這邊就不再多作闡述。 維護這直接影響這個專案的未來，有資歷的開發者都很有感觸，到底要不要挖坑給未來的自己跳…，只有經驗會告訴你。 不過以為專案就像石頭往河裡丟一樣，但常常像飛盤一樣飛回來打到自己。 配合的後端以及相關Framework、library執行前，有機會也可以先和配合的後端聊聊，雖然我寫的是Sass，但卻沒有配合過Rails or Node.js專案(泣)，可以先了解後端了解的事項有： 切好的Prototype如何交付 細部的已知功能工作分配 (javascript的分配) 專案架構是否為MVC，以及版面修正配合方式 接下來還可以詢問javascript library為何，一般來說最常使用的jquery，如果是jquery還要了解版本為何，以及可能會使用到的plugin，就以我工作上來說，大多會另外使用bootstrap js、datatable等等，這些在設計上就可以盡量使用。 除了這些之外，更重要的當然是怎樣做好Web UI，除了多看好的設計之外，更重要的是要閱讀Style guide，UI設計和程式有很大的關係，必須依據一定的準則，在執行及操作上才會有良好的體驗。 如果要推薦一份Style guide，當然就是Google material design，而且運氣不錯，有人翻譯成繁體中文版了(http://wcc723.gitbooks.io/google_design_translate/)。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"Gulp RUN ruby-compass","slug":"gulp-on-diff-os","date":"2014-11-06T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"gulp/2014/11/07/gulp-on-diff-os/","link":"","permalink":"https://wcc723.github.io/gulp/2014/11/07/gulp-on-diff-os/","excerpt":"最後一篇，來介紹gulp-compass，這一篇的內容較短，但是要特別注意系統是否可以運作ruby以及ruby compass(由於compass有更新)，所以和前一篇的差別會是多了ruby。","text":"最後一篇，來介紹gulp-compass，這一篇的內容較短，但是要特別注意系統是否可以運作ruby以及ruby compass(由於compass有更新)，所以和前一篇的差別會是多了ruby。 gulp-compass是呼叫ruby compass來運作，所以電腦內必須有ruby環境，所以建議先確認電腦內的ruby compass是否能正常運作，再來進行以下步驟。而目前compass的版本是1.01^，詳情就請參照compass官方網站。 http://compass-style.org 安裝Compass記得，在安裝compass與susy前，請確認電腦裡是否有ruby的環境，terminal內輸入ruby -v。 ruby -v 接下來輸入以下指令來安裝compass。可參考http://compass-style.org/install/ gem update —system gem install compass 輸入gem install susy，來安裝susy。可參考http://susydocs.oddbird.net/en/latest/install/ 輸入以下指令來驗證是否安裝成功 compass -v gem -v susy gulp-compass這一段和之前也相同，打開terminal輸入npm install —save-dev，安裝完後打開gulpfile.js。 這個範例已經包含常用的設定，當然也可以參考https://www.npmjs.org/package/gulp-compass。 123456789101112131415161718192021222324252627//gulpfile.jsvar gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), webserver = require('gulp-webserver'), compass = require('gulp-compass'), //新增gulp-compass coffee = require('gulp-coffee');gulp.task('compass', function() &#123; gulp.src('app/sass/*.sass') //來源路徑 .pipe(compass(&#123; //這段內輸入config.rb的內容 css: 'app/assets/css', //compass輸出位置 sass: 'app/sass', //sass來源路徑 sourcemap: true, //compass 1.0 sourcemap style: 'compact', //CSS壓縮格式，預設(nested) comments: false, //是否要註解，預設(true) require: ['susy'] //額外套件 susy &#125;)) // .pipe(gulp.dest('app/assets/temp')); //輸出位置(非必要)&#125;);gulp.task('watch', function () &#123; //自定一個watch的排程名稱 gulp.watch('./app/coffeescripts/*.coffee', ['coffee']); //監聽路徑，以及檔案變更後所執行的任務 gulp.watch('./app/sass/*.sass', ['compass']);&#125;);gulp.task('default', ['coffee','compass','webserver','watch']); 接下來輸入gulp，就可以開始使用compass 1.0了，當然這邊要特別注意susy，這susy的版本是2，與1差異很大，如果安裝後想使用susy1，sass內import請輸入 @import “susyone”。 12345678910111213//sass 檔案內容@import &quot;compass/reset&quot;@import &quot;compass&quot;@import &quot;susy&quot;body background-color: black.container +container(80em).span6 color: orange +span(6 of 12) 會輸出成像下面這樣，還會包含source map。 12345678910/*css reset…. 略*/body &#123; background-color: black; &#125;.container &#123; max-width: 80em; margin-left: auto; margin-right: auto; &#125;.container:after &#123; content: \" \"; display: block; clear: both; &#125;.span6 &#123; color: orange; width: 49.15254%; float: left; margin-right: 1.69492%; &#125;/*# sourceMappingURL=style.css.map */ 如果是從前面的相關文章開始看，目前gulpfile.js檔案結果會像下面這樣。 1234567891011121314151617181920212223242526272829303132333435363738394041424344var gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), webserver = require('gulp-webserver'), compass = require('gulp-compass'), coffee = require('gulp-coffee');gulp.task('coffee', function() &#123; //‘coffee'是排程名稱，可自定 gulp.src('./app/coffeescripts/*.coffee') //來源檔案 .pipe(coffee()) //編譯 .pipe(concat('main.js')) //合併成一隻 .pipe(uglify()) //壓縮、醜化 .pipe(gulp.dest('./app/assets/js')) //輸出位置&#125;);gulp.task('webserver', function() &#123; gulp.src('app') //起始目錄 .pipe(webserver(&#123; host: '0.0.0.0', //host設定'0.0.0.0'，就可以用內網檢視 port: 10000, //設定一個沒在使用的port livereload: true, //auto refresh open: true //執行gulp時自動開啟browser &#125;));&#125;);gulp.task('compass', function() &#123; gulp.src('app/sass/*.sass') //來源路徑 .pipe(compass(&#123; //這段內輸入config.rb的內容 css: 'app/assets/css', //compass輸出位置 sass: 'app/sass', //sass來源路徑 sourcemap: true, //compass 1.0 sourcemap style: 'compact', //CSS壓縮格式，預設(nested) comments: false, //是否要註解，預設(true) require: ['susy'] //額外套件 susy &#125;)) // .pipe(gulp.dest('app/assets/temp')); //輸出位置(非必要)&#125;);gulp.task('watch', function () &#123; //自定一個watch的排程名稱 gulp.watch('./app/coffeescripts/*.coffee', ['coffee']); //監聽路徑，以及檔案變更後所執行的任務 gulp.watch('./app/sass/*.sass', ['compass']);&#125;);gulp.task('default', ['coffee','compass','webserver','watch']); Gulp 系列文章 Gulp 環境安裝 Gulp Task and Gulp Pipe Gulp webserver 以及在不同系統上運作 Gulp Gulp RUN ruby-compass","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"}]},{"title":"Gulp webserver 以及在不同系統上運作 Gulp","slug":"gulp-on-diff-os","date":"2014-11-05T16:00:00.000Z","updated":"2016-10-13T03:49:13.000Z","comments":true,"path":"gulp/2014/11/06/gulp-on-diff-os/","link":"","permalink":"https://wcc723.github.io/gulp/2014/11/06/gulp-on-diff-os/","excerpt":"透過以上兩篇，基本上已經可以套用許多gulp的工具，而這篇要介紹的是gulp webserver，以及在不同環境使用gulp (mac OS, Windows)。","text":"透過以上兩篇，基本上已經可以套用許多gulp的工具，而這篇要介紹的是gulp webserver，以及在不同環境使用gulp (mac OS, Windows)。 Gulp web server首先，先裝gulp-webserver，這一套已經包含許多功能，甚至livereload都已經含在內部。 npm install --save-dev gulp-webserver 一樣打開Gulpfile.js，加上以下js。 1234567891011121314151617var gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), webserver = require('gulp-webserver’), //定義webserver coffee = require('gulp-coffee’);gulp.task('webserver', function() &#123; gulp.src('app') //起始目錄 .pipe(webserver(&#123; host: '0.0.0.0', //host設定'0.0.0.0'，就可以用內網檢視 port: 10000, //設定一個沒在使用的port livereload: true, //auto refresh open: true //執行gulp時自動開啟browser &#125;));&#125;);gulp.task('default', ['coffee','webserver','watch']); //加上web server 接下來一樣回到terminal，輸入gulp，就會直接打開web，webserver這一套直接可以auto refresh，而且在跨裝置的情況下一樣可行。 特別注意：如果有開啓其他有auto refresh的軟體，可能會造成其中一方auto refresh失效(EX:Fire.app)。 這時候修改index.html或者是其他檔案修改後都會自動refresh，也不需要額外安裝套件(所以沒有限定Chrome)。 接下來直接使用wifi的內網ip加上port，也可以直接瀏覽，這個網址直接複製到使用相同wifi的裝置上也是可行的。 修改內文也一樣，裝置上的網頁也會自動refresh。 在windows上執行Gulp先前的所有範例，都是在Mac上做範例，如果此時加入使用其他環境的開發該如何配合？且Git上如何管理？ 在剛剛所介紹的範例中，所有的gulp 套件都會安裝在node_modules這個資料夾內，只要透過package.json，就可以一個指令安裝回所有的套件。所以如果有使用git，就可以直接忽略這個資料夾，同理，在給其他開發者，也不需要這個資料夾。 將整個專案移到windows內(不需要node_modules資料夾)。 只需要保留gulpfile、package.json、app資料夾即可。 輸入npm install ，就可還原node_modules資料夾，接下來一樣執行gulp就可以運行了。 這樣就可以還原整個專案，且在不同作業系統都可以正常運作。","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"},{"name":"nodejs","slug":"nodejs","permalink":"https://wcc723.github.io/tags/nodejs/"}]},{"title":"D3.js 鐵人賽的結束","slug":"Ironman-30-days-30","date":"2014-10-28T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/29/Ironman-30-days-30/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/29/Ironman-30-days-30/","excerpt":"這次參加鐵人賽，我也猶豫了很久，在開始前我已經準備好了近十篇另一個主題(視覺前端與前端技術)，但是牙一咬就報名了另一個主題d3.js，用意是想學d3.js。學習的過程中挫折也是挺大的，因為我對於資料處理並不擅長，光在json的處理就費盡心思，還好在學習的過程中有許多人可以讓我詢問該怎麼做，不然真知道怎撐到最後。","text":"這次參加鐵人賽，我也猶豫了很久，在開始前我已經準備好了近十篇另一個主題(視覺前端與前端技術)，但是牙一咬就報名了另一個主題d3.js，用意是想學d3.js。學習的過程中挫折也是挺大的，因為我對於資料處理並不擅長，光在json的處理就費盡心思，還好在學習的過程中有許多人可以讓我詢問該怎麼做，不然真知道怎撐到最後。 在寫的過程中，原本想要在SVG結束之後，看著書做到底就好…，又怕被覺得太混，於是就一直到處挖可以用的資料或是技術，結果越挖越遠，造成文章順序有點跳躍式的…，為了避免這個問題，下次還是選熟悉些的技術好了，哈哈。 再怎麼說，透過這次的鐵人，也是有達到目的，就和上次一樣，一個月的密集研究，可以快速地學習一項技術，就像進入精神時光屋一樣，在30天內進步其他人一年的程度…。 在此就列出30天的成就吧： SVG SVG 簡介 SVG 超硬派了解 line, polygon, polyline, path (手工繪製) SVG 超硬派了解 path Arcs SVG Defs 以及 CSS SVG Stroke , Marker 以及 CSS D3.js 基礎 初入D3.js D3js 將資料投影到SVG上 D3.js Scale 尺度 D3.js 國慶日在家裡畫長條圖 D3.js 讀取CSV資料並繪製成長條圖 D3.js 軸線(Axis) D3.js 折線圖(Line Chart) D3.js Transition動態效果 D3.js 資料數量增減 D3.js 主題範例 D3.js 究竟搭不搭捷運與死亡率有沒有關係？(1) D3.js 究竟搭不搭捷運與死亡率有沒有關係？(2) - Google 試算表 D3.js 究竟搭不搭捷運與死亡率有沒有關係？(3) - 將資料繪製成折線圖 像jQuery 一樣的D3.js，柯P野生官網API D3.js 也可以像音樂一樣動吃動吃動(1) D3.js 也可以像音樂一樣動吃動吃動(2) D3.js layout (以環保局資料為例) D3.js 再看更多layout前，先來轉換json結構 柯P的財務報表套用 D3js Partition Layout D3.js 小玩意 D3.js 圈圈小效果 D3.js 超粘的Voronoi Diagram繪圖 其他工具 D3js 前置作業，製作簡易Server D3.js 利用Excel建立資料(CSV) PDF轉CSV，利用Tabula 以上次這次鐵人賽的文章，如果對文章內容有問題，也歡迎留言給我。下次還是不幸被推坑的話，還是做視覺前端的相關主題吧！ 另外，我在暑假期間的時候有發起翻譯Google Material的活動，目前還是Gitbook上的暢銷書，在此推薦大家閱讀。 http://wcc723.gitbooks.io/google_design_translate/ 就這麼樣，我們下次見(如果還有力氣的話)。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"PDF轉CSV，利用Tabula","slug":"Ironman-30-days-29","date":"2014-10-27T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/28/Ironman-30-days-29/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/28/Ironman-30-days-29/","excerpt":"D3.js最重要的就是資料，所以需要有許多不同的資料轉換方式。PDF是常見的檔案格式，因為製作方便，又可以跨裝置，所以PDF也是經常取得的檔案格式之一，相信大家都使用過PDF格式，它很適合閱讀，但至於轉成資料格式呢？似乎就沒有那麼容易。 這篇就來介紹Tabula將PDF轉換成CSV作為D3.js所需要的資料格式","text":"D3.js最重要的就是資料，所以需要有許多不同的資料轉換方式。PDF是常見的檔案格式，因為製作方便，又可以跨裝置，所以PDF也是經常取得的檔案格式之一，相信大家都使用過PDF格式，它很適合閱讀，但至於轉成資料格式呢？似乎就沒有那麼容易。 這篇就來介紹Tabula將PDF轉換成CSV作為D3.js所需要的資料格式 Tabula在幾個月前，Code for Kaohsiung辦了一個小活動，想讓工程師動手幫高雄，就類似g0v，不過區域不同而已。那次請到了g0v的高村長，他介紹了一個工具可以將PDF迅速轉成CSV，那就是Tabula，這次就來介紹這神奇的工具吧。 安裝Tabula : http://tabula.nerdpower.org/ 在進入Tabula官網後，就可以下載windows、Mac OS的安裝檔，如果是老手的話，也可以選擇Github手動安裝，而我是選擇直接download for Mac。 啟動安裝完後，啟動Tabula他會自動開啟瀏覽器，並且進入Tabula，如果沒有可以手動輸入127.0.0.1:8080，再不行請看看8080 port是不是被佔據了(預設為8080 port)。 使用使用上非常容易，只要以下幾個步驟就可以完成： 選擇檔案 選擇範圍 匯出 1.選擇檔案開啟網站後，下方就有很明顯的選擇檔案。 2.選擇範圍選擇範圍是利用圈選的，如果Pdf有相當多頁，可以選擇repeat this selection，就會用相同的大小、位置套用在每個頁面(如果每頁都對不上就手動了…)，至於小技巧，就是要多操作才能體會了。 選好區域後，就選擇Download csv吧。 3.匯出接下來略等一小段時間，就會跳出轉好的表格，這部分是預覽轉出的狀態，確認是接近預期的狀態後，就下載CSV，或者是複製到剪貼簿也行。 到這部分Tabula工作已經結束了。 整理檔案範例檔案：http://kptaipei.tw/?page_id=3366 這次的範例檔案是柯P的競選經費PDF檔，轉完之後還是需要到編輯器略作處理，就以這個範例來說，每個頁面的標頭也被轉出來了，那麼就必須將它刪去。 存檔以後，一份資料CSV就完成了，就可以供d3.js使用，相信對需要整理政府資料的工程師相當實用…。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"柯P的財務報表套用 D3js Partition Layout","slug":"Ironman-30-days-28","date":"2014-10-26T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/27/Ironman-30-days-28/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/27/Ironman-30-days-28/","excerpt":"看到KP API裡面有提供競選經費查詢，如果之前把資料撈回來，很難了解支出收入的關係，而且在支出與收入之中，何者比例較高。","text":"看到KP API裡面有提供競選經費查詢，如果之前把資料撈回來，很難了解支出收入的關係，而且在支出與收入之中，何者比例較高。 D3.js Partition layout參考：http://bl.ocks.org/mbostock/4348373 透過這張圖，雖然沒有數值可以了解精確的關係，但可以透過視覺快速比較彼此之間的概略比率，這也是d3.js內建的layout之一，且在這頁面上可以看到完整的程式碼，只要套用就可以了。 不過在套用前，要先轉換json的格式，昨天的文章對此有介紹，所以對d3js結構轉換可參考casper/d3js/2014/10/26/Ironman-30-days-27/。 範例詳細競選經費，還是以柯文哲官網提供為主 資料來源一樣是透過KP的API，只要資料結構轉換完，可以很輕鬆的套用各種d3.js layout範例。另外，在這個範例中整個圓並不是代表總金額，而只是支出與收入的比較圖。 Infomation 款項 : 類別 : 金額 : 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122kpPath = 'http://api.kptaipei.tw/v1/financial/all'// 將nest資料改成name, childrenfunction reSortRoot(root,value_key) &#123; for (var key in root) &#123; if (key == \"key\") &#123; root.name = root.key; delete root.key; &#125; if (key == \"values\") &#123; root.children = []; for (item in root.values) &#123; root.children.push(reSortRoot(root.values[item],value_key)); &#125; delete root.values; &#125; if (key == value_key) &#123; root.value = parseFloat(root[value_key]); delete root[value_key]; &#125; &#125; return root; &#125;// 將nest資料改成name, childrend3.json(kpPath, function(d)&#123; //透過KP API撈資料 dataset = d.data; var nodesByType = d3.nest() //匯入資料轉成巢狀 .key(function(d) &#123; return d.type; &#125;) .key(function(d) &#123; return d.account; &#125;) .entries(dataset); //匯入KP資料 var root = &#123;&#125;; //定義一個空的物件 root.key = \"Data\"; //定義物件名稱 root.values = nodesByType; //以及物件來源 //將json的key轉成name, children root = reSortRoot(root,\"KpData\"); console.log(root) runChart(root) //資料轉完後就來開始畫圖&#125;);function runChart(root)&#123; //畫圖 &lt;--主要插入資料位置 var width = 660, height = 500, radius = Math.min(width, height) / 2; //定義圓的大小 var x = d3.scale.linear() //建立尺度 .range([0, 2 * Math.PI]); //圓周率是也 var y = d3.scale.sqrt() //尺度，開平方根，這真的太難了 .range([0, radius]); // var color = d3.scale.category20c(); //載入d3.js 內建顏色 var svg = d3.select(\".demo\").append(\"svg\") //圖形繪製的位置及大小 .attr(\"width\", width) .attr(\"height\", height) .append(\"g\") .attr(\"transform\", \"translate(\" + width / 2 + \",\" + (height / 2 + 10) + \")\"); var partition = d3.layout.partition() // 建立d3.js partition layout .value(function(d) &#123; return d.price; &#125;); //資料值來源為 Price(金額) var arc = d3.svg.arc() //建立弧形元件 .startAngle(function(d) &#123; return Math.max(0, Math.min(2 * Math.PI, x(d.x))); &#125;) .endAngle(function(d) &#123; return Math.max(0, Math.min(2 * Math.PI, x(d.x + d.dx))); &#125;) .innerRadius(function(d) &#123; return Math.max(0, y(d.y)); &#125;) .outerRadius(function(d) &#123; return Math.max(0, y(d.y + d.dy)); &#125;); var path = svg.selectAll(\"path\") //繪製path .data(partition.nodes(root)) //匯入資料 &lt;-- 主要插入資料位置 .enter().append(\"path\") //用資料去跑 .attr(\"d\", arc) .style(\"fill\", function(d) &#123; return color((d.children ? d : d.parent).name); &#125;) // .on(\"click\", click); //點擊事件 function click(d) &#123; path.transition() .duration(750) //轉場效果 .attrTween(\"d\", arcTween(d)); //當點擊時執行縮放 &#125; d3.select(self.frameElement).style(\"height\", height + \"px\"); // 縮放事件 function arcTween(d) &#123; var xd = d3.interpolate(x.domain(), [d.x, d.x + d.dx]), yd = d3.interpolate(y.domain(), [d.y, 1]), yr = d3.interpolate(y.range(), [d.y ? 20 : 0, radius]); return function(d, i) &#123; return i ? function(t) &#123; return arc(d); &#125; : function(t) &#123; x.domain(xd(t)); y.domain(yd(t)).range(yr(t)); return arc(d); &#125;; &#125;; &#125; //滑鼠滑入事件 svg.selectAll(\"path\").on('mouseover', function(d)&#123; mousePos = d3.mouse(this); //取得座標 var xPos = mousePos[0] + radius; //修正座標 var yPos = mousePos[1] + radius; //修正座標 d3.select('#tooltip') //顯示資料 .style(&#123; 'left': xPos + 'px', 'top': yPos + 'px' &#125;) .classed('hidden', false) //切換Class d3.select('#tooltip .account').html(d.account) //顯示資料 d3.select('#tooltip .type').html((d.children ? d : d.parent).name) d3.select('#tooltip .price').html('$ ' + d.value) &#125;).on('mouseout', function(d)&#123; //滑鼠移出 d3.select('#tooltip').classed('hidden', true) //切換Class，隱藏tooltip &#125;);&#125; 大略看一下柯文哲的支出收入，目前還沒有結束，收入部分主要是來自於個人捐贈以及網路捐贈，而支出部分主要是在人事以及宣傳上。 做完柯P財務報表，也會做看看連阿文的了…，不知道收入主要來源是不是爸爸。 path { stroke: #fff; fill-rule: evenodd; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; } kpPath = 'http://api.kptaipei.tw/v1/financial/all' // 將nest資料改成name, children function reSortRoot(root,value_key) { for (var key in root) { if (key == \"key\") { root.name = root.key; delete root.key; } if (key == \"values\") { root.children = []; for (item in root.values) { root.children.push(reSortRoot(root.values[item],value_key)); } delete root.values; } if (key == value_key) { root.value = parseFloat(root[value_key]); delete root[value_key]; } } return root; } // 將nest資料改成name, children d3.json(kpPath, function(d){ //透過KP API撈資料 dataset = d.data; var nodesByType = d3.nest() //匯入資料轉成巢狀 .key(function(d) { return d.type; }) .key(function(d) { return d.account; }) .entries(dataset); //匯入KP資料 var root = {}; //定義一個空的物件 root.key = \"Data\"; //定義物件名稱 root.values = nodesByType; //以及物件來源 //將json的key轉成name, children root = reSortRoot(root,\"KpData\"); console.log(root) runChart(root) //資料轉完後就來開始畫圖 }); function runChart(root){ //畫圖","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"d3.js 再看更多layout前，先來轉換json結構","slug":"Ironman-30-days-27","date":"2014-10-25T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/26/Ironman-30-days-27/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/26/Ironman-30-days-27/","excerpt":"上次提到d3.js有包含許多的layout，但是每種layout都有些結構上的限制，就比如說 Tree Map，這樣的layout就需要巢狀結構的json才可以製作，D3js也有提供巢狀結構的轉換，這邊就來介紹最常用的轉換方式。","text":"上次提到d3.js有包含許多的layout，但是每種layout都有些結構上的限制，就比如說 Tree Map，這樣的layout就需要巢狀結構的json才可以製作，D3js也有提供巢狀結構的轉換，這邊就來介紹最常用的轉換方式。 資料來源這次的資料又是柯P的，他的資料真的很好用…，不過今天不看圖，今天都來看console.log。 首先透過柯P的API，可以抓到以下的資料，在寫這篇文章時，總共有408筆資料，每一筆資料都是獨立的。 我打算將他分類，以Type(支出、收入)、account(帳戶)作為分類。 D3.js巢狀結構只要透過d3.js巢狀的函式，就能輕鬆達到剛剛的需求，如下： 1234567891011121314kpPath = 'http://api.kptaipei.tw/v1/financial/all'; //KP資料路徑d3.json(kpPath, function(d)&#123; dataset = d.data; console.log(dataset, \"原始資料\"); //顯示原始資料 var nodesByType = d3.nest() //轉換成巢狀架構 .key(function(d) &#123; return d.type; &#125;) //回傳type .key(function(d) &#123; return d.account; &#125;) //回傳account .entries(dataset); //輸入的資料 console.log(nodesByType, \"基本d3.js巢狀結構轉換\")&#125;); 透過這個函式，就能完成最基本的巢狀資料的轉換，比自幹簡單很多吧…，結果會像下面這樣： 剛剛所設定的type會被轉成第一層的key，而account則會被轉成第二層的key，資料責會被轉成value。 轉換Key還有一些麻煩的事情要處理，就以剛剛介紹的Tree Map為例，他們所需要的Json格式是像下圖這樣，用的是name、children，並不是剛剛的key、value，所以還要再轉換一下。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748kpPath = 'http://api.kptaipei.tw/v1/financial/all'// --- 轉換巢狀結構的key ---function reSortRoot(root,value_key) &#123; for (var key in root) &#123; if (key == \"key\") &#123; root.name = root.key; delete root.key; &#125; if (key == \"values\") &#123; root.children = []; for (item in root.values) &#123; root.children.push(reSortRoot(root.values[item],value_key)); &#125; delete root.values; &#125; if (key == value_key) &#123; root.value = parseFloat(root[value_key]); delete root[value_key]; &#125; &#125; return root; &#125;// --- 轉換巢狀結構的key ---d3.json(kpPath, function(d)&#123; dataset = d.data; console.log(dataset, \"原始資料\") var nodesByType = d3.nest() //轉換成巢狀架構 .key(function(d) &#123; return d.type; &#125;) .key(function(d) &#123; return d.account; &#125;) .entries(dataset); console.log(nodesByType, \"基本d3.js巢狀結構轉換\") var root = &#123;&#125;; // 將資料命名 root.key = \"Data\"; root.values = nodesByType; // 修改資料的的key, children名稱，並且依指定規則套用。 root = reSortRoot(root,\"KpData\"); //layout用巢狀架構 console.log(root, \"layout用巢狀架構\")&#125;); 接下來就換看到KP的資料都轉成d3.js layout所需的巢狀json，這樣有助於直接套用許多的樣式。 kpPath = 'http://api.kptaipei.tw/v1/financial/all' // --- 轉換巢狀結構的key --- function reSortRoot(root,value_key) { for (var key in root) { if (key == \"key\") { root.name = root.key; delete root.key; } if (key == \"values\") { root.children = []; for (item in root.values) { root.children.push(reSortRoot(root.values[item],value_key)); } delete root.values; } if (key == value_key) { root.value = parseFloat(root[value_key]); delete root[value_key]; } } return root; } // --- 轉換巢狀結構的key --- d3.json(kpPath, function(d){ dataset = d.data; console.log(dataset, \"原始資料\") var nodesByType = d3.nest() //轉換成巢狀架構 .key(function(d) { return d.type; }) .key(function(d) { return d.account; }) .entries(dataset); console.log(nodesByType, \"基本d3.js巢狀結構轉換\") var root = {}; // 將資料命名 root.key = \"Data\"; root.values = nodesByType; // 修改資料的的key, children名稱，並且依指定規則套用。 root = reSortRoot(root,\"KpData\"); //layout用巢狀架構 console.log(root, \"layout用巢狀架構\") });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"d3.js layout (以環保局資料為例)","slug":"Ironman-30-days-26","date":"2014-10-24T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/25/Ironman-30-days-26/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/25/Ironman-30-days-26/","excerpt":"介紹這麼多，但是還沒有介紹到d3.layout，這用途是可以快速建立圖表，這篇來介紹pie layout，用的是環保局的資料。","text":"介紹這麼多，但是還沒有介紹到d3.layout，這用途是可以快速建立圖表，這篇來介紹pie layout，用的是環保局的資料。 資料來源這次用的是環保局的Open data，環保局的資料也是不錯使用，包含許多個是，CSV、json、XML等等，在政府資料中，優點是還算標準且穩定。 而且只要會Jquery，就可以很輕鬆的把資料抓回來，範例如下： 1234567891011var path = &#123; url: 'http://opendata.epa.gov.tw/ws/Data/WRRecovery/?$skip=0&amp;$top=1000&amp;format=json', dataType: 'jsonp', &#125;$.ajax(path) .done(function (d) &#123; //如果成功 console.log(data) &#125;) .fail(function(jqxhr, textStatus, error)&#123; console.log('GG,沒戲唱了'); //失敗&#125;); 圓餅圖d3.js有出許多的layout，只要把資料給他就可以運作，程式碼參考如下，只要先建立一個layout pie物件，在設定輸入的值，套用後就可以轉成圓餅圖。 123var pie = d3.layout.pie() //建立D3.layout pie物件 .sort(null) //是否排序 .value(function(d) &#123;return d.Amount; &#125;); //傳入的值 範例 Infomation 回收項目 : 回收率 : 範例中的資料(json)是用jquery去抓，在用d3去轉換成圖形。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192$(function() &#123; //定義json 路徑var path = &#123; url: 'http://opendata.epa.gov.tw/ws/Data/WRRecovery/?$skip=0&amp;$top=1000&amp;format=json', dataType: 'jsonp', &#125;var data = \"\";var w = 450, h = 450;var svg = d3.select('.demo').append('svg') //插入SVG .attr('width', w) .attr('height', h);$.ajax(path) .done(function (d) &#123; //如果成功 data = d; console.log(data) runChart('102') &#125;) .fail(function(jqxhr, textStatus, error)&#123; console.log('GG,沒戲唱了'); //失敗&#125;);runChart = function(filter)&#123; var color = d3.scale.category10(); //D3 內存產生顏色的function var pie = d3.layout.pie() //建立D3.layout pie物件 .sort(null) .value(function(d) &#123;return d.Amount; &#125;); var outerRadius = h / 2 , innerRadius = h / 4; //弧形的位置 var arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius) //定義內外圈位置 var arcs = svg.selectAll('g.arc') .data(pie(dataFilter(data, filter))) //將資料放入pie .enter() .append('g') //塞好'g' .attr('class', 'arc') //準備好Class .attr('transform', 'translate(' + outerRadius + ',' + outerRadius + ')') //移動圓心的位置 arcs.append('path') .attr('fill', function(d,i)&#123; return color(i); //招喚前面的color function &#125;) .attr('d', arc) // 前面的 arc function //需要 pie()所產生出來得值 arcs.append('text') .attr('transform', function(d)&#123; return 'translate('+ arc.centroid(d) +')'; //centroid()任何形狀的中心點 &#125;) .attr('text-anchor', 'middle') .text(function(d)&#123; return d.data.Item + d.data.Amount; //在每個形狀的中央插入文字 &#125;) .attr('fill', 'white'); svg.selectAll('.arc').on('mouseover', function(d)&#123; //滑鼠事件 mousePos = d3.mouse(this); //取得滑鼠座標 var xPos = mousePos[0] + outerRadius; //修正滑鼠座標 var yPos = mousePos[1] + outerRadius; //修正滑鼠座標 d3.select('#tooltip') //將Tooltip補上資料 .style(&#123; 'left': xPos + 'px', //加上位置 'top': yPos + 'px' &#125;) .classed('hidden', false) d3.select('#tooltip .name').html(d.data.Item) //插入名稱 d3.select('#tooltip .value').html(d.data.Amount + '%') &#125;).on('mouseout', function(d)&#123; d3.select('#tooltip').classed('hidden', true) //切換顯示及隱藏 &#125;);&#125;;dataFilter = function(data, filter)&#123; //過濾部分資料 var newData = []; $.each(data, function(i,d)&#123; if (d.Year == filter)&#123; newData.push(d); &#125; &#125;); return newData&#125;;&#125;); 結語接下會幾篇會介紹幾種不同的layout，透過不同的範例，感謝收看(MOPCON打這篇，有時候都不知道自己在打什麼…)。 path { /*stroke: DodgerBlue; stroke-width: 1; fill: none;*/ } .axis { font-size: 11px; fill: gray; } svg{ font-size: 11px; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; } $(function() { //定義json 路徑 var path = { url: 'http://opendata.epa.gov.tw/ws/Data/WRRecovery/?$skip=0&$top=1000&format=json', dataType: 'jsonp', } var data = \"\"; var w = 450, h = 450; var svg = d3.select('.demo').append('svg') //插入SVG .attr('width', w) .attr('height', h); $.ajax(path) .done(function (d) { //如果成功 data = d; console.log(data) runChart('102') }) .fail(function(jqxhr, textStatus, error){ console.log('GG,沒戲唱了'); //失敗 }); runChart = function(filter){ var color = d3.scale.category10(); //D3 內存產生顏色的function var pie = d3.layout.pie() //建立D3.layout pie物件 .sort(null) .value(function(d) {return d.Amount; }); var outerRadius = h / 2 , innerRadius = h / 4; //弧形的位置 var arc = d3.svg.arc() .innerRadius(innerRadius) .outerRadius(outerRadius) //定義內外圈位置 var arcs = svg.selectAll('g.arc') .data(pie(dataFilter(data, filter))) //將資料放入pie .enter() .append('g') //塞好'g' .attr('class', 'arc') //準備好Class .attr('transform', 'translate(' + outerRadius + ',' + outerRadius + ')') //移動圓心的位置 arcs.append('path') .attr('fill', function(d,i){ return color(i); //招喚前面的color function }) .attr('d', arc) // 前面的 arc function //需要 pie()所產生出來得值 arcs.append('text') .attr('transform', function(d){ return 'translate('+ arc.centroid(d) +')'; //centroid()任何形狀的中心點 }) .attr('text-anchor', 'middle') .text(function(d){ return d.data.Item + d.data.Amount; //在每個形狀的中央插入文字 }) .attr('fill', 'white'); svg.selectAll('.arc').on('mouseover', function(d){ //滑鼠事件 mousePos = d3.mouse(this); //取得滑鼠座標 var xPos = mousePos[0] + outerRadius; //修正滑鼠座標 var yPos = mousePos[1] + outerRadius; //修正滑鼠座標 d3.select('#tooltip') //將Tooltip補上資料 .style({ 'left': xPos + 'px', //加上位置 'top': yPos + 'px' }) .classed('hidden', false) d3.select('#tooltip .name').html(d.data.Item) //插入名稱 d3.select('#tooltip .value').html(d.data.Amount + '%') }).on('mouseout', function(d){ d3.select('#tooltip').classed('hidden', true) //切換顯示及隱藏 }); }; dataFilter = function(data, filter){ //過濾部分資料 var newData = []; $.each(data, function(i,d){ if (d.Year == filter){ newData.push(d); } }); return newData }; });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 也可以像音樂一樣動吃動吃動(2)","slug":"Ironman-30-days-25","date":"2014-10-23T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/24/Ironman-30-days-25/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/24/Ironman-30-days-25/","excerpt":"上一篇介紹了資料的來源以及動機，這篇就來介紹執行的層面吧。 在原本的範例中，是只有一個圓在跳動，但是音樂所能擷取的資料是一段很長的陣列，我就思考著是不是有辦法做成折線圖，並且讓他有躍動的感覺。","text":"上一篇介紹了資料的來源以及動機，這篇就來介紹執行的層面吧。 在原本的範例中，是只有一個圓在跳動，但是音樂所能擷取的資料是一段很長的陣列，我就思考著是不是有辦法做成折線圖，並且讓他有躍動的感覺。 音樂來源：http://unlimited.kptaipei.tw/ 範例參考：http://webfinal.herokuapp.com/slides.html HTML先看一下HTML的結構，在左邊呈現圖像化的效果，右邊是柯P的音樂選單，重要的是下方的class=&quot;controller&quot;，這並不是js的套件或是code，僅僅是Chrome的html5物件。 12345678910&lt;div class=\"demo\"&gt;&lt;div class=\"player\"&gt; &lt;div class=\"visual\"&gt; &lt;/div&gt; &lt;div class=\"playlist\"&gt; &lt;/div&gt; &lt;div class=\"controller\"&gt; &lt;/div&gt;&lt;/div&gt;&lt;/div&gt; 柯P資料直接透過d3.json去接柯P的資料，之前有提過KP這方面處理得相當好，用d3.js就可以直接接資料，接回來的範例如下，也可以直接打開chrome console看更完整資料。 12345d3.json(kpMusic, function(data)&#123; //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function&#125;); Line Chart這一段是特別需要注意的，因為音樂的所傳回的陣列長度是2048，值大概像下面這樣，範圍由-1 ~ 1，也因為長度過長，在繪製成圖形上會有效能上的問題，所以擷取其中一段即可。 所以該段js大概像這樣： 123456789101112131415161718//buffer 為傳來的值newBuffer = Array.prototype.slice.call(buffer,0,64)//由於來源陣列長度有2048，這邊只取64就好var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d); //利用尺度運算資料的值，傳回y的位置 &#125;); path.attr('d', line(newBuffer)); //將音樂資料套用至曲線 DEMO請先選擇右方音樂，再點選播放 很抱歉，目前本範例只支援Chrome 完整Code如果有興趣想要跟著實驗，只要把這段貼回家就可以玩囉 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137var kpMusic = 'http://api.kptaipei.tw/v1/musics/1?accessToken=kp54103aa1efbe14.85567715'//柯p資料路徑var dataMusic = \"\"; //音樂資料var colorBase = 0; //圓圈的顏色起始var context; //音樂格式var h = 100, w = 300;d3.json(kpMusic, function(data)&#123; //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function&#125;);//這部分是建立基本的layoutvar svg = d3.select(\".visual\").append('svg') .attr(&#123; width: 300, height: 300 &#125;);//畫面中的圓圈circle = svg.append('circle') .attr(&#123; cx: 150, cy: 150 &#125;);//播放中音樂的文字playtext = svg.append('text') .attr(&#123; x: 20, y: 20, width: 260, fill: \"white\" &#125;)//中央跳動的曲線rect = svg.append('g')//增加一個群組g .attr('width', w) .attr('height', h) .attr('transform', 'translate(0,' + (h) + ')');path = rect.append('path')var audio = new Audio(); //建立音樂function playlist()&#123;d3.select(\".playlist\").selectAll(\"a\").data(dataMusic) //右方先插入歌單 .enter() .append(\"a\") .text(function(d)&#123; return d.song_name &#125;) //傳入音樂名稱 .attr(\"class\", \"song\"); //插入Class，作為控制用 audio.controls = true; //html5 音樂控制器 audio.preload = true; //html5 預先下載 document.querySelector('.controller').appendChild(audio); //指定部分插入html5 audio元件 d3.selectAll(\".song\").on(\"click\", function(d)&#123; playsong(d); //點擊歌單時載入音樂 &#125;);&#125;//瀏覽器驗證try&#123; context = new webkitAudioContext();&#125;catch(e)&#123; try &#123; context= new AudioContext(); &#125; catch(e) &#123; &#125;&#125;function processAudio(e) &#123; //如果音樂開始執行時 //取得音軌資訊 var buffer = e.inputBuffer.getChannelData(0); var out = e.outputBuffer.getChannelData(0); var amp = 0; // Iterate through buffer to get max amplitude for (var i = 0; i &lt; buffer.length; i++) &#123; var loud = Math.abs(buffer[i]); if(loud &gt; amp) &#123; amp = loud; &#125; // write input samples to output unchanged out[i] = buffer[i]; &#125;; newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d); //利用尺度運算資料的值，傳回y的位置 &#125;); colorBase ++; //讓顏色隨著時間變化 var color = d3.hsl(colorBase % 360, .7,.7); //d3.hsl色彩運算 circle.attr(\"r\",20+(amp*50)) //圓圈大小變換，以及顏色變換 .attr(\"fill\", color) .attr(\"stroke\", color); path.attr('d', line(newBuffer)); //將音樂資料套用至曲線&#125;//以下為音樂相關的codevar node = context.createMediaElementSource(audio);var processor = context.createScriptProcessor(2048,1,1);function playsong(d)&#123; console.log(d) audio.src = d.stream_url; playtext.text(d.song_name + ' / ' + d.groupname) audio.addEventListener('canplaythrough',function() &#123; processor.onaudioprocess = processAudio; node.connect(processor); processor.connect(context.destination); &#125;);&#125; 還有CSS要補上喔～ 123456789101112131415161718192021222324252627282930313233.player &#123; background-color: #000; width: 540px; padding: 20px; border-radius: 2px;&#125;.player circle&#123; fill: none;&#125;path &#123; stroke: DodgerBlue; fill: none;&#125;.visual&#123; float: left;&#125;.playlist&#123; float: right; width: 200px; height: 300px; overflow-y: auto;&#125;.playlist a&#123; color: white; display: block; cursor: pointer;&#125;.playlist a.selected &#123; color: DeepSkyBlue;&#125;.controller&#123; clear: both;&#125; 後記鐵人賽快要結束了，不過我到快結束才更了解D3js，有很多豐富的技巧還沒介紹的說…。 .player { background-color: #000; width: 540px; padding: 20px; border-radius: 2px; } .player circle{ fill: none; } path { stroke: DodgerBlue; fill: none; } .visual{ float: left; } .playlist{ float: right; width: 200px; height: 300px; overflow-y: auto; } .playlist a{ color: white; display: block; cursor: pointer; } .playlist a.selected { color: DeepSkyBlue; } .controller{ clear: both; } var kpMusic = 'http://api.kptaipei.tw/v1/musics/1?accessToken=kp54103aa1efbe14.85567715' //柯p資料路徑 var dataMusic = \"\"; //音樂資料 var colorBase = 0; //圓圈的顏色起始 var context; //音樂格式 var h = 100, w = 300; d3.json(kpMusic, function(data){ //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function }); //這部分是建立基本的layout var svg = d3.select(\".visual\").append('svg') .attr({ width: 300, height: 300 }); //畫面中的圓圈 circle = svg.append('circle') .attr({ cx: 150, cy: 150 }); //播放中音樂的文字 playtext = svg.append('text') .attr({ x: 20, y: 20, width: 260, fill: \"white\" }) //中央跳動的曲線 rect = svg.append('g')//增加一個群組g .attr('width', w) .attr('height', h) .attr('transform', 'translate(0,' + (h) + ')'); path = rect.append('path') var audio = new Audio(); //建立音樂 function playlist(){ d3.select(\".playlist\").selectAll(\"a\").data(dataMusic) //右方先插入歌單 .enter() .append(\"a\") .text(function(d){ return d.song_name }) //傳入音樂名稱 .attr(\"class\", \"song\"); //插入Class，作為控制用 audio.controls = true; //html5 音樂控制器 audio.preload = true; //html5 預先下載 document.querySelector('.controller').appendChild(audio); //指定部分插入html5 audio元件 d3.selectAll(\".song\").on(\"click\", function(d){ playsong(d); //點擊歌單時載入音樂 }); } //瀏覽器驗證 try { context = new webkitAudioContext(); } catch(e) { try { context= new AudioContext(); } catch(e) { } } function processAudio(e) { //如果音樂開始執行時 //取得音軌資訊 var buffer = e.inputBuffer.getChannelData(0); var out = e.outputBuffer.getChannelData(0); var amp = 0; // Iterate through buffer to get max amplitude for (var i = 0; i < buffer.length; i++) { var loud = Math.abs(buffer[i]); if(loud > amp) { amp = loud; } // write input samples to output unchanged out[i] = buffer[i]; }; newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d); //利用尺度運算資料的值，傳回y的位置 }); colorBase ++; //讓顏色隨著時間變化 var color = d3.hsl(colorBase % 360, .7,.7); //d3.hsl色彩運算 circle.attr(\"r\",20+(amp*50)) //圓圈大小變換，以及顏色變換 .attr(\"fill\", color) .attr(\"stroke\", color); path.attr('d', line(newBuffer)); //將音樂資料套用至曲線 } //以下為音樂相關的code var node = context.createMediaElementSource(audio); var processor = context.createScriptProcessor(2048,1,1); function playsong(d){ console.log(d) audio.src = d.stream_url; playtext.text(d.song_name + ' / ' + d.groupname) audio.addEventListener('canplaythrough',function() { processor.onaudioprocess = processAudio; node.connect(processor); processor.connect(context.destination); }); }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 也可以像音樂一樣動吃動吃動(1)","slug":"Ironman-30-days-24","date":"2014-10-22T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/23/Ironman-30-days-24/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/23/Ironman-30-days-24/","excerpt":"學習D3之後會常思考有什麼樣的資料可以圖形化，除了Open data外，還想到一個就是音樂，以前使用Media Player，有許許多多的音樂視覺化的效果，都是透過聲音大小變化，所以如果有聲音大小變化的資訊，似乎就可以達到這樣的效果。","text":"學習D3之後會常思考有什麼樣的資料可以圖形化，除了Open data外，還想到一個就是音樂，以前使用Media Player，有許許多多的音樂視覺化的效果，都是透過聲音大小變化，所以如果有聲音大小變化的資訊，似乎就可以達到這樣的效果。 音樂來源：http://unlimited.kptaipei.tw/ 範例參考：http://webfinal.herokuapp.com/slides.html 參考不久前在網路上看到一份D3.js的簡報，寫得真的不錯，文中介紹到一個很沒用的效果(他自己說沒用的..)，範例中會播放著音樂，而中間的圓圈會隨著音樂跳動，看著圓圈不斷地跳動，讓我發現很有趣的資訊，就是音樂啊，那不是我正在尋找的資料嗎～ 在翻閱他的範例中，可以看到他把音軌轉換成陣列的資訊，會依據音樂的品質轉換…，大概像以下這樣的陣列。 以這個範例來說，是2048長度的陣列，數值為-1 ~ 1，更新速度相當的快，只要有這個值，就可以做出上面範例的跳動圓圈。 資料技術上已經找到方向，另一個問題就是音樂的來源，由於版權問題，也不太可能隨意使用歌手的音樂。再以柯P的資料做練習時，有稍微看一下創作音樂的部分，創作音樂是使用sound cloud平台，json內在提供sound cloud平台上的資訊。運氣不錯，其中剛好有串流音樂的格式(感謝野生官網、Sound Cloud)。 這樣取得的線上音樂，就可以試著放入自己設計的播放器去執行(一開始用本機的流行樂&gt; &lt;)。 規劃一開始只有做隨機一首歌去播放，後來發現真的很有趣，而且這些音樂挺好聽的，看著自己做的曲線配合著音樂跳動，就把整個音樂清單也做出來了。 請先選擇右方音樂，再點選播放 很抱歉，目前本範例只支援Chrome 後記這範例也拿去給朋友看，部分的人也說這好像沒什麼用(泣…)，不過這就是創造的浪漫啊！ .player { background-color: #000; width: 540px; padding: 20px; border-radius: 2px; } .player circle{ fill: none; } path { stroke: DodgerBlue; fill: none; } .visual{ float: left; } .playlist{ float: right; width: 200px; height: 300px; overflow-y: auto; } .playlist a{ color: white; display: block; cursor: pointer; } .playlist a.selected { color: DeepSkyBlue; } .controller{ clear: both; } var kpMusic = 'http://api.kptaipei.tw/v1/musics/1?accessToken=kp54103aa1efbe14.85567715' //柯p資料路徑 var dataMusic = \"\"; //音樂資料 var colorBase = 0; //圓圈的顏色起始 var context; //音樂格式 var h = 100, w = 300; d3.json(kpMusic, function(data){ //取得柯P音樂資料 console.log(data.data) dataMusic = data.data; //存到dataMusic playlist() //執行下一個function }); //這部分是建立基本的layout var svg = d3.select(\".visual\").append('svg') .attr({ width: 300, height: 300 }); //畫面中的圓圈 circle = svg.append('circle') .attr({ cx: 150, cy: 150 }); //播放中音樂的文字 playtext = svg.append('text') .attr({ x: 20, y: 20, width: 260, fill: \"white\" }) //中央跳動的曲線 rect = svg.append('g')//增加一個群組g .attr('width', w) .attr('height', h) .attr('transform', 'translate(0,' + (h) + ')'); path = rect.append('path') var audio = new Audio(); //建立音樂 function playlist(){ d3.select(\".playlist\").selectAll(\"a\").data(dataMusic) //右方先插入歌單 .enter() .append(\"a\") .text(function(d){ return d.song_name }) //傳入音樂名稱 .attr(\"class\", \"song\"); //插入Class，作為控制用 audio.controls = true; //html5 音樂控制器 audio.preload = true; //html5 預先下載 document.querySelector('.controller').appendChild(audio); //指定部分插入html5 audio元件 d3.selectAll(\".song\").on(\"click\", function(d){ playsong(d); //點擊歌單時載入音樂 }); } //瀏覽器驗證 try { context = new webkitAudioContext(); } catch(e) { try { context= new AudioContext(); } catch(e) { } } function processAudio(e) { //如果音樂開始執行時 //取得音軌資訊 var buffer = e.inputBuffer.getChannelData(0); var out = e.outputBuffer.getChannelData(0); var amp = 0; // Iterate through buffer to get max amplitude for (var i = 0; i < buffer.length; i++) { var loud = Math.abs(buffer[i]); if(loud > amp) { amp = loud; } // write input samples to output unchanged out[i] = buffer[i]; }; newBuffer = Array.prototype.slice.call(buffer,0,64) //由於來源陣列長度有2048，這邊只取64就好 console.log(newBuffer.length) var xScale = d3.scale.linear().domain([0, newBuffer.length]).range([0, w]); var yScale = d3.scale.linear().domain([1, -1]).range([h, 0]); //先前有提到資料最大及最小就是-1 ~ 1，輸出範圍就是曲線跳動的最大範圍 var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d); //利用尺度運算資料的值，傳回y的位置 }); colorBase ++; //讓顏色隨著時間變化 var color = d3.hsl(colorBase % 360, .7,.7); //d3.hsl色彩運算 circle.attr(\"r\",20+(amp*50)) //圓圈大小變換，以及顏色變換 .attr(\"fill\", color) .attr(\"stroke\", color); path.attr('d', line(newBuffer)); //將音樂資料套用至曲線 } //以下為音樂相關的code var node = context.createMediaElementSource(audio); var processor = context.createScriptProcessor(2048,1,1); function playsong(d){ console.log(d) audio.src = d.stream_url; playtext.text(d.song_name + ' / ' + d.groupname) audio.addEventListener('canplaythrough',function() { processor.onaudioprocess = processAudio; node.connect(processor); processor.connect(context.destination); }); }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"像jQuery 一樣的D3.js，柯P野生官網API","slug":"Ironman-30-days-23","date":"2014-10-21T16:00:00.000Z","updated":"2016-10-13T02:50:19.000Z","comments":true,"path":"d3js/2014/10/22/Ironman-30-days-23/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/22/Ironman-30-days-23/","excerpt":"D3.js其實最重要的還是資料，恰巧有一位候選人做了Open data，他的API格式相當優良，如果對於找不到合適資料，但需要做些練習，不如試試看柯文哲野生官網吧！ http://unlimited.kptaipei.tw/","text":"D3.js其實最重要的還是資料，恰巧有一位候選人做了Open data，他的API格式相當優良，如果對於找不到合適資料，但需要做些練習，不如試試看柯文哲野生官網吧！ http://unlimited.kptaipei.tw/ 野生官網的使用相當容易，對於會使用jquery的開發者，也可以很快瞭解，這邊也簡單介紹一下野生官網API的使用方式吧。 申請Token在使用API前，需要先申請一組Token，野生官網在這部分也做得相當乾脆，只要填入暱稱、電子郵件之後，系統就會發一組Token及介紹信給申請者。 畫面如下，填入相關資料即可： 收到Mail後，隨信會附上Token，開始動手試試看吧。 用D3.js撈撈看D3.js原則上不能進行跨站請求資料(jsonp)，但野生官網這部分已經處理掉了，所以可以直接用D3處理這一段。 先前介紹撈Google drive資料，是用jQuery處理jsonp。 參考官網提供的Api [類別內容查詢]這部分很適合做練習，就直接用官網提供的範例，用D3來試試看(結果如下)。 kpapi = \"http://api.kptaipei.tw/v1/category/41/?accessToken=kp54103aa1efbe14.85567715\"; d3.json(kpapi, function(d){ data = d.data; length = data.length; num = Math.floor(Math.random()*length); demo = d3.select('.demo'); demo.select('.demo article').html(data[num].content); }); 12345678910kpapi = \"http://api.kptaipei.tw/v1/category/41/?accessToken=kp54103aa1efbe14.85567715\";//柯p API路徑d3.json(kpapi, function(d)&#123; //d3js json function data = d.data; length = data.length; //取得資料筆數 num = Math.floor(Math.random()*length); //隨機一則筆數 demo.select('.demo article').html(data[num].content); //將文章插入&#125;); 上面這一個範例，就是用d3.js來抓柯P的API，並且隨機抓一篇文章，寫法大致上都很是不是很像jquery呢？ 剛開始的相簿在一剛開始介紹D3.js時，有展示一個柯P的相簿，作法其實類似上一個範例，不同的是用d3.data來做jQuery.each的動作，再來回顧一次這個範例吧。 12345678910111213var url = \"http://api.kptaipei.tw/v1/albums/72157646559528926\";//柯p API路徑d3.json( url ,function(d)&#123; var dataset = d.data.photos; d3.select('.demo').selectAll('img') .data(dataset) //用d3.data來插入資料 .enter() .append('div') .attr('class', 'col-xs-2') .append('img').attr('class', 'img-responsive') .attr('src', function(d)&#123; return d.images.large_square; &#125;);&#125;); 如果下方視窗沒有顯示範例，請點選Run with JS JS Bin 這樣來回介紹，應該會更了解D3.js吧～","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 資料數量增減","slug":"Ironman-30-days-22","date":"2014-10-20T16:00:00.000Z","updated":"2016-10-13T02:55:13.000Z","comments":true,"path":"d3js/2014/10/21/Ironman-30-days-22/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/21/Ironman-30-days-22/","excerpt":"資料很多時候需要比較、切換，所以可能會同時加入多筆資料，前一篇文章所介紹的是相同數量的資料，這次要做隨機的資料量。","text":"資料很多時候需要比較、切換，所以可能會同時加入多筆資料，前一篇文章所介紹的是相同數量的資料，這次要做隨機的資料量。 資料轉換資料數量不同時，如果增加到沒什麼，因為原本就是從無到有，都是利用Append去增加新的物件： bars.enter().append(&apos;rect&apos;); 但是如果資料比原本還要少時，就要選取多餘的元件(exit)，並且移除它(remove)。 bars.exit() //選擇多餘的部分 .remove() //清除物件 下面這個範例，預設會先用20筆資料，接下來點擊button，就會隨機的增減資料，另外動態做稍微誇張一些，覺得挺有趣的，玩了幾個動態模式，這個最彈了…。 Click Me 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159var dataset = [];var numValues = 20; //一開始的資料數量是固定的var randDataset = function(num)&#123; for (var i=0; i &lt; num; i++)&#123; var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(&#123; key : i, value: newNum&#125;); //產生一段陣列，包含key and value &#125;&#125;//只要給予資料\"數量\"，就會產生隨機資料var key = function(d) &#123; return d.key; &#125;randDataset(numValues); //一開始預設的20筆資料console.table(dataset); //打開console開結果var originDataLength = dataset.length // 將原始的資料長度記錄var h=200,w = 500, barMargin = 1;maxDataset = d3.max(dataset, function(d)&#123; return d.value &#125;); //從value 取得最大值var xScale = d3.scale.ordinal()//不同於linear的尺度，可以處理非數字資料 .domain(d3.range(dataset.length)) //這範例是給予資料的長度 .rangeRoundBands([0, w], 0); //利用整體的寬度去做運算var yScale = d3.scale.linear() //y尺度和先前是相同的，都是線性尺度 .domain([0 , maxDataset]) //輸入值範圍 .range([0, h]); //輸出值範圍var svg = d3.select('.demo').append('svg').attr('width',w).attr('height', h); //建立svgsvg.selectAll('rect').data(dataset, key) //插入資料 .enter().append('rect') //直條圖用rect~ .attr(&#123; 'x': function(d, i)&#123; return xScale(i); //利用尺度算出每個rect的x軸位置 &#125;, 'y': function(d)&#123; return h - yScale(d.value); //算出y的位置(因為需要置底) &#125;, 'width': w / dataset.length - barMargin, //每個rect寬度是固定的，但需要補上間距 'height': function(d)&#123; return yScale(d.value)&#125;, //算出高度 'fill': function(d)&#123; return d3.hsl(320 + d.value % 360 , .5 , .5)&#125; //利用資料產生不同色彩 &#125;);var dataText = svg.selectAll('text').data(dataset, key).enter().append('text'); //補上文字dataText.text(function(d)&#123;return d.value&#125;) .attr(&#123; 'x': function(d,i)&#123; return xScale(i) + 11; //算出x位置 &#125;, 'y': function(d)&#123; return (h - yScale(d.value) + 15)&#125;, //算出文字y的位置 'fill': 'white', //文字反白 'text-anchor': 'middle', //文字置中 'font-size': '11px' //字小一點比較秀氣 &#125;);var chartFn = function()&#123; //這一段是在點擊後觸發的函式 dataset = []; //資料清空 var numValues = 1 + Math.floor(Math.random() * 30); //隨機長度的資料 randDataset(numValues); //重新製作一組資料 newDataLength = dataset.length // 儲存新的資料長度 xScale.domain(d3.range(dataset.length)) //資料長度不同，所以domain改變 maxDataset = d3.max(dataset, function(d)&#123; return d.value &#125;); yScale.domain([0 , maxDataset]) //資料最大值不同，所以domain改變 var bars = svg.selectAll(\"rect\") .data(dataset, key); //重新套用資料 var texts = svg.selectAll('text') .data(dataset, key); //檢查資料長度，如果比原本長就需要移除 if (newDataLength &gt; originDataLength)&#123; //如果比原本長 bars.enter().append('rect') .transition() .attr('x', w); //增加新的rect，以及進場的方式 texts.enter().append('text').text(function(d)&#123;return d.value&#125;) .attr(&#123; 'x': w, 'y': function(d)&#123; return (h - yScale(d.value) + 15)&#125; &#125;); //類似同上 originDataLength = newDataLength; //儲存資料長度 &#125; else if (newDataLength &lt; originDataLength)&#123; bars.exit() //選擇多餘的部分 .transition() //退場方式 //.duration(500) .attr('width', 0) //寬度降為0 .remove() //清除物件 texts.exit().transition().duration(500) .attr('width', 0) .remove() //清除文字物件 originDataLength = newDataLength; //儲存資料長度 &#125; bars.transition() .delay(500) //延遲新的效果(等前方的進退場動畫結束) // .delay(function(d, i) &#123; // return i / dataset.length * 1000; // // 每個物件套用不同的delay 時間 // &#125;) .duration(1500) // 持續時間(豪秒) .ease('elastic') // 動畫型態 .attr(&#123; //這段同前 'x': function(d, i)&#123; return xScale(i) &#125;, 'y': function(d)&#123; return h - yScale(d.value) &#125;, 'width': w / dataset.length - barMargin, 'height': function(d)&#123; return yScale(d.value); &#125;, 'fill': function(d)&#123; return d3.hsl(320 + d.value % 360 , .5 , .5)&#125; &#125;) texts.transition() //文字也是同前 .delay(500) .duration(1500) // 持續時間(豪秒) .ease('elastic') // 動畫型態 .attr(&#123; 'x': function(d,i)&#123; //return i * (w / dataset.length) return xScale(i) + 11 &#125;, 'y': function(d)&#123; return (h - yScale(d.value) + 15)&#125;, 'fill': 'white', 'text-anchor': 'middle', 'font-size': '11px' &#125;);&#125;;// 點擊button時，更新資料d3.select('.update_btn').on('click', function()&#123; chartFn();&#125;); 接下來，明天又要來亂抓Open data來玩囉～ var dataset = []; var numValues = 20; //一開始的資料數量是固定的 var randDataset = function(num){ for (var i=0; i < num; i++){ var newNum = 5 + Math.floor(Math.random() * 30); dataset.push({ key : i, value: newNum}); //產生一段陣列，包含key and value } }//只要給予資料\"數量\"，就會產生隨機資料 var key = function(d) { return d.key; } randDataset(numValues); //一開始預設的20筆資料 console.table(dataset); //打開console開結果 var originDataLength = dataset.length // 將原始的資料長度記錄 var h=200,w = 500, barMargin = 1; maxDataset = d3.max(dataset, function(d){ return d.value }); //從value 取得最大值 var xScale = d3.scale.ordinal() //不同於linear的尺度，可以處理非數字資料 .domain(d3.range(dataset.length)) //這範例是給予資料的長度 .rangeRoundBands([0, w], 0); //利用整體的寬度去做運算 var yScale = d3.scale.linear() //y尺度和先前是相同的，都是線性尺度 .domain([0 , maxDataset]) //輸入值範圍 .range([0, h]); //輸出值範圍 var svg = d3.select('.demo').append('svg').attr('width',w).attr('height', h); //建立svg svg.selectAll('rect').data(dataset, key) //插入資料 .enter().append('rect') //直條圖用rect~ .attr({ 'x': function(d, i){ return xScale(i); //利用尺度算出每個rect的x軸位置 }, 'y': function(d){ return h - yScale(d.value); //算出y的位置(因為需要置底) }, 'width': w / dataset.length - barMargin, //每個rect寬度是固定的，但需要補上間距 'height': function(d){ return yScale(d.value)}, //算出高度 'fill': function(d){ return d3.hsl(320 + d.value % 360 , .5 , .5)} //利用資料產生不同色彩 }); var dataText = svg.selectAll('text').data(dataset, key).enter().append('text'); //補上文字 dataText.text(function(d){return d.value}) .attr({ 'x': function(d,i){ return xScale(i) + 11; //算出x位置 }, 'y': function(d){ return (h - yScale(d.value) + 15)}, //算出文字y的位置 'fill': 'white', //文字反白 'text-anchor': 'middle', //文字置中 'font-size': '11px' //字小一點比較秀氣 }); var chartFn = function(){ //這一段是在點擊後觸發的函式 dataset = []; //資料清空 var numValues = 1 + Math.floor(Math.random() * 30); //隨機長度的資料 randDataset(numValues); //重新製作一組資料 newDataLength = dataset.length // 儲存新的資料長度 xScale.domain(d3.range(dataset.length)) //資料長度不同，所以domain改變 maxDataset = d3.max(dataset, function(d){ return d.value }); yScale.domain([0 , maxDataset]) //資料最大值不同，所以domain改變 var bars = svg.selectAll(\"rect\") .data(dataset, key); //重新套用資料 var texts = svg.selectAll('text') .data(dataset, key); //檢查資料長度，如果比原本長就需要移除 if (newDataLength > originDataLength){ //如果比原本長 bars.enter().append('rect') .transition() .attr('x', w); //增加新的rect，以及進場的方式 texts.enter().append('text').text(function(d){return d.value}) .attr({ 'x': w, 'y': function(d){ return (h - yScale(d.value) + 15)} }); //類似同上 originDataLength = newDataLength; //儲存資料長度 } else if (newDataLength < originDataLength){ bars.exit() //選擇多餘的部分 .transition() //退場方式 //.duration(500) .attr('width', 0) //寬度降為0 .remove() //清除物件 texts.exit().transition().duration(500) .attr('width', 0) .remove() //清除文字物件 originDataLength = newDataLength; //儲存資料長度 } bars.transition() .delay(500) //延遲新的效果(等前方的進退場動畫結束) // .delay(function(d, i) { // return i / dataset.length * 1000; // // 每個物件套用不同的delay 時間 // }) .duration(1500) // 持續時間(豪秒) .ease('elastic') // 動畫型態 .attr({ //這段同前 'x': function(d, i){ return xScale(i) }, 'y': function(d){ return h - yScale(d.value) }, 'width': w / dataset.length - barMargin, 'height': function(d){ return yScale(d.value); }, 'fill': function(d){ return d3.hsl(320 + d.value % 360 , .5 , .5)} }) texts.transition() //文字也是同前 .delay(500) .duration(1500) // 持續時間(豪秒) .ease('elastic') // 動畫型態 .attr({ 'x': function(d,i){ //return i * (w / dataset.length) return xScale(i) + 11 }, 'y': function(d){ return (h - yScale(d.value) + 15)}, 'fill': 'white', 'text-anchor': 'middle', 'font-size': '11px' }); }; // 點擊button時，更新資料 d3.select('.update_btn').on('click', function(){ chartFn(); });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js Transition動態效果","slug":"Ironman-30-days-21","date":"2014-10-19T16:00:00.000Z","updated":"2016-10-13T02:51:47.000Z","comments":true,"path":"d3js/2014/10/20/Ironman-30-days-21/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/20/Ironman-30-days-21/","excerpt":"先前的資料，都是固定的，沒有任何變化，這次要介紹的是利用資料的轉變以及transition的效果。","text":"先前的資料，都是固定的，沒有任何變化，這次要介紹的是利用資料的轉變以及transition的效果。 Transition這次的範例是之前提到那本書上的唷～。 D3.js的transition和CSS的transition很像，都是放在開始的地方，然後再加入一些時間，這樣就完成了，像下面這個範例： d3.select(&apos;div&apos;) .transition() //套用動態效果 .duration(250) //動態持續時間 .attr(/* do something */) 如果和資料有關係，作法大致是相同的，再加入資料後，一樣加入.transition()： d3.select(&apos;div&apos;).data(dataset) .transition() //套用動態效果 .duration(250) //動態持續時間 .attr(/* do something */) 下面這一個範例中，只要點擊’Click Me’，就會產生出一組新的陣列並且套用入SVG，可以看到圓型以及左方、下方的軸線也會跟著轉場變化。 Click Me 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141var w = 600,h = 400,padding = 30;var dataset = []; //產生空的陣列var numDataPoints = 100; //最大點的數量是100var xRange = Math.random() * 1000;var yRange = Math.random() * 1000; //隨機範圍最大值都是1000for (var i = 0; i &lt; numDataPoints; i++)&#123; var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) //運算出新的值，並加到dataset&#125;var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;); //計算最大值var xScale = d3.scale.linear() //線性尺度 .domain([0, Xmax]) //輸入值 .range([padding , w - padding]) //輸出值 .nice() //取最適合數值var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice()var svg = d3.select('.demo').append('svg').attr(&#123;'width': w,'height': h&#125;)//裁切區域svg.append('clipPath') //新增svg裁切區域 .attr('id', 'chart-area') //定義id .append('rect') //再增加一個矩型 .attr(&#123; 'x': padding, 'y': padding, 'width': w - padding * 2, 'height': h - padding * 2 &#125;) svg.append('g') .attr('clip-path', 'url(#chart-area)') //套用裁切區域 .selectAll('circle') .data(dataset).enter() //輸入資料 .append('circle') //加入圓 .attr(&#123; 'cx': function(d)&#123;return xScale(d[0])&#125;, //用x尺度算出cx位置 'cy': function(d)&#123;return yScale(d[1])&#125;, //用y尺度算出cy位置 'r': '3px' &#125;);//Axisvar xAxis = d3.svg.axis().scale(xScale) //用x尺度製作x軸線 .orient(\"bottom\") //標示位置 .ticks(6) //尺度數量var yAxis = d3.svg.axis().scale(yScale) .orient(\"left\") //標示位置 .ticks(6) //尺度數量svg.append('g').attr('class', 'x axis') //定義尺度樣式 .attr('transform', 'translate(0, '+ (h - padding) +')') //移動到下方 .call(xAxis) //套用x軸線svg.append('g').attr('class', 'y axis') .attr('transform', 'translate('+ (padding) +')', 0) .call(yAxis)//轉場時的code，其實有許多是和原本相同//如果有興趣的可以先全部讀完，再重新製作一次d3.select('.btn').on('click', function()&#123; //每次點擊的時候 dataset = []; //將陣列清空 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; for (var i = 0; i &lt; numDataPoints; i++)&#123; var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) &#125; //這段和前面一樣，YA var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;); //一樣 var xScale = d3.scale.linear() //由於尺度有重新計算，所以必須再跑一次 .domain([0, Xmax]) .range([padding , w - padding]) .nice() //取整數 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() svg.selectAll('circle').data(dataset) // .enter() //這不需要再加入 // .append('circle') //這也不需要 .transition() //套用動態效果 .duration(250) //動態持續時間 .each('start', function()&#123; //過場開始執行 d3.select(this) .attr('fill', 'DeepPink') .attr('r', 2) &#125;) .transition() //套用動態效果 .duration(1000) //第二段時間 .attr(&#123; 'cx': function(d)&#123;return xScale(d[0])&#125;, 'cy': function(d)&#123;return yScale(d[1])&#125;, 'r': '3px', 'fill': 'black', 'r': 5 &#125;); // 更新Axis var xAxis = d3.svg.axis().scale(xScale) .orient(\"bottom\") //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(\"left\") //標示位置 .ticks(6) //尺度數量 svg.select('.x.axis') .transition() //動態尺度 .duration(1000) .call(xAxis); svg.select('.y.axis') .transition() .duration(1000) .call(yAxis);&#125;); 如果圖表會產生變化，觀者可以感受到位移，可以感受到數值的變化，在繪製圖表的時候，適當的加入不僅可以更吸引人，而且閱讀性更佳(增加前後比較的資訊)，但如果過度的效果，就會讓人眼花撩亂。 var w = 600,h = 400,padding = 30; var dataset = []; //產生空的陣列 var numDataPoints = 100; //最大點的數量是100 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; //隨機範圍最大值都是1000 for (var i = 0; i < numDataPoints; i++){ var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) //運算出新的值，並加到dataset } var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}); //計算最大值 var xScale = d3.scale.linear() //線性尺度 .domain([0, Xmax]) //輸入值 .range([padding , w - padding]) //輸出值 .nice() //取最適合數值 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //裁切區域 svg.append('clipPath') //新增svg裁切區域 .attr('id', 'chart-area') //定義id .append('rect') //再增加一個矩型 .attr({ 'x': padding, 'y': padding, 'width': w - padding * 2, 'height': h - padding * 2 }) svg.append('g') .attr('clip-path', 'url(#chart-area)') //套用裁切區域 .selectAll('circle') .data(dataset).enter() //輸入資料 .append('circle') //加入圓 .attr({ 'cx': function(d){return xScale(d[0])}, //用x尺度算出cx位置 'cy': function(d){return yScale(d[1])}, //用y尺度算出cy位置 'r': '3px' }); //Axis var xAxis = d3.svg.axis().scale(xScale) //用x尺度製作x軸線 .orient(\"bottom\") //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(\"left\") //標示位置 .ticks(6) //尺度數量 svg.append('g').attr('class', 'x axis') //定義尺度樣式 .attr('transform', 'translate(0, '+ (h - padding) +')') //移動到下方 .call(xAxis) //套用x軸線 svg.append('g').attr('class', 'y axis') .attr('transform', 'translate('+ (padding) +')', 0) .call(yAxis) //轉場時的code，其實有許多是和原本相同 //如果有興趣的可以先全部讀完，再重新製作一次 d3.select('.btn').on('click', function(){ //每次點擊的時候 dataset = []; //將陣列清空 var xRange = Math.random() * 1000; var yRange = Math.random() * 1000; for (var i = 0; i < numDataPoints; i++){ var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) } //這段和前面一樣，YA var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}); //一樣 var xScale = d3.scale.linear() //由於尺度有重新計算，所以必須再跑一次 .domain([0, Xmax]) .range([padding , w - padding]) .nice() //取整數 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) .nice() svg.selectAll('circle').data(dataset) // .enter() //這不需要再加入 // .append('circle') //這也不需要 .transition() //套用動態效果 .duration(250) //動態持續時間 .each('start', function(){ //過場開始執行 d3.select(this) .attr('fill', 'DeepPink') .attr('r', 2) }) .transition() //套用動態效果 .duration(1000) //第二段時間 .attr({ 'cx': function(d){return xScale(d[0])}, 'cy': function(d){return yScale(d[1])}, 'r': '3px', 'fill': 'black', 'r': 5 }); // 更新Axis var xAxis = d3.svg.axis().scale(xScale) .orient(\"bottom\") //標示位置 .ticks(6) //尺度數量 var yAxis = d3.svg.axis().scale(yScale) .orient(\"left\") //標示位置 .ticks(6) //尺度數量 svg.select('.x.axis') .transition() //動態尺度 .duration(1000) .call(xAxis); svg.select('.y.axis') .transition() .duration(1000) .call(yAxis); }); .axis path, .axis line{ fill: none; stroke: black; shape-rendering: cirspEdges; } .axis text{ font-size: 11px; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 超粘的Voronoi Diagram繪圖","slug":"Ironman-30-days-20","date":"2014-10-18T16:00:00.000Z","updated":"2016-10-13T02:42:53.000Z","comments":true,"path":"d3js/2014/10/19/Ironman-30-days-20/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/19/Ironman-30-days-20/","excerpt":"Voronoi Diagram這個繪圖我在Blog的Banner上，主要原因也是因為他很有趣，除了視覺感外，它還包含了簡單的互動。","text":"Voronoi Diagram這個繪圖我在Blog的Banner上，主要原因也是因為他很有趣，除了視覺感外，它還包含了簡單的互動。 來源：http://bl.ocks.org/mbostock/4060366 這個繪圖的方式，經過我同事的指點，我才發現他是有理論基礎的(可參考：http://www.csie.ntnu.edu.tw/~u91029/VoronoiDiagram.html)，然而D3.js內建這樣的Layout不經讓我覺得對D3.js的誤會很大，原本認為D3.js是繪製資料圖表而已，但在透過上面那個理論的網站，會發現很多很多的數學原理，都和D3.js有些關聯。 Voronoi Diagram 是大自然的圖案，諸如長頸鹿的斑紋、蜻蜓的翅膀、葉片的細胞壁。應用相當廣泛。 互動在這一個範例中，一開始會先繪製一個Voronoi Diagram圖案，接下來滑鼠滑過之後，會替換掉其中一個，並且會隨著滑鼠的移動不斷的改變其週邊的外形。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556var svgSize = &#123; w : 960, h : 500 &#125; var hslValue = 3; var vertices = d3.range(100).map(function(d) &#123; return [Math.random() * svgSize.w, Math.random() * svgSize.h]; //產生100個坐標，位置是隨機的 &#125;); console.log(vertices) var voronoi = d3.geom.voronoi() //套用voronoi，這段只有裁切區域 .clipExtent([[0,0], [svgSize.w , svgSize.h]]) //裁切voronoi區域 var svg = d3.select('.chart').append('svg') .attr('width', svgSize.w) .attr('height', svgSize.h) .on('mousemove', function() &#123; vertices[0] = d3.mouse(this);//殘忍地將第一個替換掉 redraw(); //將滑鼠的坐標帶入redraw &#125;) var path = svg.append('g').selectAll('path'); //等等要用path來畫間隔線 svg.selectAll('circle') .data(vertices) //將剛剛產生的x,y插入 .enter().append('circle') //補上原點的位置 .attr('transform', function(d)&#123; return 'translate(' + d + ')'; &#125;) //位置坐標如資料 .attr('r', 1.5) //大小是1.5px redraw() function redraw()&#123; path = path.data(voronoi(vertices) , polygon) // voronoi(vertices) 會傳回path 所需要的路徑坐標 // 然後用polygon function執行 path.exit().remove(); //如果多餘就移除 path.enter().append('path') .attr('d', polygon) //調用下方的polygon函示 .style('fill', function(d, i)&#123; return d3.hsl((120 + i * hslValue % 360),.6,.6)&#125;) path.order(); //這段似乎有沒有都沒差... &#125; function polygon(d) &#123; console.log(d) return \"M\" + d.join(\"L\") + \"Z\"; &#125; 123path &#123; stroke: white;&#125; 另外我的Blog上的Banner，也是這個方式去做出來的，只是改變了兩個效果： RWD(自適應) 色彩 原始碼在https://github.com/Wcc723/wcc723.github.io/blob/master/assets/themes/casper2013/js/d3_banner.js，有興趣的可以參考看看～(無註解) var svgSize = { w : 600, h : 500 } var hslValue = 3; var vertices = d3.range(60).map(function(d) { return [Math.random() * svgSize.w, Math.random() * svgSize.h]; //產生100個坐標，位置是隨機的 }); console.log(vertices) var voronoi = d3.geom.voronoi() //套用voronoi，這段只有裁切區域 .clipExtent([[0,0], [svgSize.w , svgSize.h]]) //裁切voronoi區域 var svg = d3.select('.demo').append('svg') .attr('width', svgSize.w) .attr('height', svgSize.h) .on('mousemove', function() { vertices[0] = d3.mouse(this);//殘忍地將第一個替換掉 redraw(); //將滑鼠的坐標帶入redraw }) var path = svg.append('g').selectAll('path'); //等等要用path來畫間隔線 svg.selectAll('circle') .data(vertices) //將剛剛產生的x,y插入 .enter().append('circle') //補上原點的位置 .attr('transform', function(d){ return 'translate(' + d + ')'; }) //位置坐標如資料 .attr('r', 1.5) //大小是1.5px redraw() function redraw(){ path = path.data(voronoi(vertices) , polygon) // voronoi(vertices) 會傳回path 所需要的路徑坐標 // 然後用polygon function執行 path.exit().remove(); //如果多餘就移除 path.enter().append('path') .attr('d', polygon) //調用下方的polygon函示 .style('fill', function(d, i){ return d3.hsl((120 + i * hslValue % 360),.6,.6)}) path.order(); //這段似乎有沒有都沒差... } function polygon(d) { console.log(d) return \"M\" + d.join(\"L\") + \"Z\"; } path { stroke: white; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 圈圈小效果","slug":"Ironman-30-days-19","date":"2014-10-17T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/18/Ironman-30-days-19/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/18/Ironman-30-days-19/","excerpt":"D3js除了繪製圖表外，還有許多開發者拿來作為視覺或者互動效果，假日的文章，就來介紹一些網路上所找到的效果。","text":"D3js除了繪製圖表外，還有許多開發者拿來作為視覺或者互動效果，假日的文章，就來介紹一些網路上所找到的效果。 抱怨…，今天中華電信網路出問題，附近的商家…捷運站網路也都掛了，害我跑很遠才有網路可用…&gt; &lt;。 在學D3的過程中，除了看書就是不斷的找範例，有些範例並不是實用型，只是些效果，但是可以從中看到別人怎麼活用D3.js。 互動範例來源：http://bl.ocks.org/mbostock/1062544 這一個範例中我認為最重要是他所寫的滑鼠、觸控監聽事件，範例如下： 123svg.append('rect').attr('width', width) .attr('height', height) .on('ontouchstart' in document ? 'touchmove' : 'mousemove', particle); 在下面黑色區域滑動滑鼠，或者是用觸控都可以有圓圈圈的效果。 1234567891011121314151617181920212223242526272829303132333435var width = 600, height = 500;var i = 0; //場上圓圈的數量，預設是0var svg = d3.select('.demo').append('svg') //插入SVG .attr('width', width) .attr('height', height);svg.append('rect').attr('width', width) .attr('height', height) .on('ontouchstart' in document ? 'touchmove' : 'mousemove', particle); //偵測是滑鼠還是觸控事件function particle()&#123; var m = d3.mouse(this) //m是陣列，只有x,y 坐標 svg.insert('circle', 'rect') //在rect內新增circle .attr('cx', m[0])//滑鼠x坐標 .attr('cy', m[1])//滑鼠y坐標 .attr('r', 1e-6) //(0.000001 ,科學計算法) .style('stroke', d3.hsl((i = (i+1) % 360), 1, .5)) //(i = (i+1) % 360) 取餘數 .style('stroke-opacity', 1) //一開始是不透明 .transition() //轉場效果 .duration(2000) //動畫轉場時間2秒 .ease(Math.sqrt) //取得平方根，不懂在這邊有什麼意義 .attr('r', 100) //不斷放大 .style('stroke-opacity', 1e-6) //轉變成半透明 .remove(); //時間到後移除物件 d3.event.preventDefault(); //移除預設事件&#125; 12345svg.selectAll('.class').on('mouseover', function(d)&#123; //do something &#125;).on('mouseout', function(d)&#123; //do something &#125;); 明天要介紹我部落格上方的Banner喔～ var width = 600, height = 500; var i = 0; //場上圓圈的數量，預設是0 var svg = d3.select('.demo').append('svg') //插入SVG .attr('width', width) .attr('height', height); svg.append('rect').attr('width', width) .attr('height', height) .on('ontouchstart' in document ? 'touchmove' : 'mousemove', particle); //偵測是滑鼠還是觸控事件 function particle(){ var m = d3.mouse(this) //m是陣列，只有x,y 坐標 svg.insert('circle', 'rect') //在rect內新增circle .attr('cx', m[0])//滑鼠x坐標 .attr('cy', m[1])//滑鼠y坐標 .attr('r', 1e-6) //(0.000001 ,科學計算法) .style('stroke', d3.hsl((i = (i+1) % 360), 1, .5)) //(i = (i+1) % 360) 取餘數 .style('stroke-opacity', 1) //一開始是不透明 .transition() //轉場效果 .duration(2000) //動畫轉場時間2秒 .ease(Math.sqrt) //取得平方根，不懂在這邊有什麼意義 .attr('r', 100) //不斷放大 .style('stroke-opacity', 1e-6) //轉變成半透明 .remove(); //時間到後移除物件 d3.event.preventDefault(); //移除預設事件 } svg { background: black; } rect { fill: none; pointer-events: all; } circle { fill: none; stroke-width: 2px; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 究竟搭不搭捷運與死亡率有沒有關係？(3) - 將資料繪製成折線圖","slug":"Ironman-30-days-18","date":"2014-10-16T16:00:00.000Z","updated":"2016-10-13T02:57:04.000Z","comments":true,"path":"d3js/2014/10/17/Ironman-30-days-18/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/17/Ironman-30-days-18/","excerpt":"有了資料跟一些D3.js基礎後，就可以嘗試把資料轉換成圖，雖然萬事已經具備，但要繪製成圖，還是需要費些心力。","text":"有了資料跟一些D3.js基礎後，就可以嘗試把資料轉換成圖，雖然萬事已經具備，但要繪製成圖，還是需要費些心力。 在資料上，先前有提到高雄縣市合併有影響死亡率，所以這次還有再補上高雄縣市合併的資料。 互動這次還之前的不同，還有加上簡單的互動，而D3js的互動和jQuery寫法觀念相當接近，只是操作DOM時把$換成了d3，如果熟悉jquery的開發者很快就能上手。 範例大概如下： 12345svg.selectAll('.class').on('mouseover', function(d)&#123; //do something &#125;).on('mouseout', function(d)&#123; //do something &#125;); 剩下的部分，就直接看code應該會比較理解～ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163$(function() &#123;var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&amp;callback=?', shList = [ &#123; 'listKey': 'od6', &#125;,&#123; 'listKey': 'ol1cvs7', &#125; ,&#123; 'listKey': 'objevh6', &#125; //這部分是高雄縣市的合併資料 ]var url = shPath + shKey + '/' + shList + shCallback; //合併路徑var dataRemote = []; //建立空的陣列//讀入每一個資料表$.each(shList, function(i, list)&#123; $.getJSON( shPath + shKey + '/' + list.listKey + shCallback) .done(function (data) &#123; //如果成功 list.dataName = [] var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t //資料頁的標題 dataRemote.push(&#123; //存回陣列 'title': title, 'data': entry &#125;); //送回dataset jsonDone(); //執行驗證 &#125;) .fail(function(jqxhr, textStatus, error)&#123; console.log('GG,沒戲唱了'); //失敗 &#125;);&#125;)//驗證資料跑完沒jsonDone = function()&#123; if (shList.length != dataRemote.length)&#123; console.log('快好了'); //驗證未完成 &#125; else if (shList.length == dataRemote.length)&#123; console.log('好了', dataRemote); //驗證成功 dataset = dataRemote runChart(); //繪製圖表 &#125;&#125;;//真的開始畫圖了runChart = function()&#123; var margin = &#123;top: 60, right: 40, bottom: 50, left: 60&#125;; var w = 560 ; // 寬 var h = 300 ; // 高 console.log(dataset[0].data.length) datatime = []; //將時間存成陣列，作為Xscale用處 $.each(dataset[0].data,function(i,d)&#123; datatime.push(d.gsx$time.$t) &#125;); var xScale = d3.scale.linear().domain([0,dataset[0].data.length]).range([0,w]) var yScale = d3.scale.linear().domain([.2, .85]).range([h, 0]); //Y的Scale就不另外寫，先直接設定值 // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d.gsx$percent.$t); //利用尺度運算資料的值，傳回y的位置 &#125;); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 var xAxis = d3.svg.axis().scale(xScale).ticks(5).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); $.each(dataset,function(i,d)&#123; svg.append('path').attr('d', line(d.data)) .style(&#123; 'stroke': d3.hsl((120 + 90*i), .6, .6),//d3.hsl是d3提供的顏色function 'stroke-width':1, &#125;);//將每個資料繪製成折線，並且套用不同的色彩 svg.append('g').selectAll('circle').data(d.data).enter() //增加原點 .append('circle') .attr(&#123; 'cx': function(d, i)&#123;return xScale(i + 1) &#125;, 'cy': function(d)&#123;return yScale(d.gsx$percent.$t)&#125;, //x,y算法都類似line function 'r':'2px', 'class': 'dot' //這圓點主要是要給hover使用的 &#125;) .style(&#123; 'fill': d3.hsl((120 + 90*i), .6, .6)//套用相同色彩 &#125;) svg.append('g').append('text') //補上左上示意文字 .text(d.title) .style(&#123; 'fill': d3.hsl((120 + 90*i), .6, .6), 'transform': 'translate(8px,'+ ((i * 15) + 12) //拉開間距 +'px)', 'font-size':'12px' &#125;) &#125;); showTips = function(id)&#123; //這部分是要作為Hover用的資料 date = dataset[0].data[id].gsx$time.$t //時間取其中一份的即可 var html = '' $.each(dataset, function(i, dataset)&#123; //將資料定義，並回傳 title = dataset.title; percent = dataset.data[id].gsx$percent.$t; html = html + '&lt;div&gt;&lt;span&gt;'+title+'&lt;/span&gt;/&lt;span&gt; '+percent+'%&lt;/span&gt;&lt;/div&gt;' &#125;); html = '&lt;div&gt;'+date+'&lt;/div&gt;' + html; return html; //回傳整理好的html &#125;; svg.selectAll('.dot').on('mouseover', function(d)&#123; //d3 function，類似jquery，直接可以控制class var xPos = parseFloat(d3.select(this).attr('cx')) + margin.left //截取點的位置 var yPos = parseFloat(d3.select(this).attr('cy')) + margin.top //這一個目標(d)，裡面也包含了資料，所以d.gsx$id可以抓到這個點所包含的資料 var id = d.gsx$id.$t - 1 //抓取資料id d3.select('#tooltip') //將div抓來用 .style(&#123; 'left': xPos + 'px', 'top': yPos + 'px' &#125;) .classed('hidden', false) //移除隱藏的class .html(showTips(id)) //將剛剛的showTips function帶入 &#125;).on('mouseout', function(d)&#123; //如果移出的話 d3.select('#tooltip').classed('hidden', true); //補回剛剛的Class &#125;);&#125;&#125;); 有注意到嗎？在互動的事件上是使用一般的div，所以SVG與HTML是可以混合使用的，不過也記得要補上html部分的程式碼。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647path &#123; stroke: DodgerBlue; stroke-width: 1; fill: none;&#125;.axis &#123; font-size: 11px; fill: gray;&#125;.x.axis line &#123; stroke: lightgrey;&#125;.x.axis .minor &#123; stroke-opacity: .5;&#125;.x.axis path &#123; stroke: #fafafa;&#125;.y.axis line, .y.axis path &#123; fill: none; stroke: lightgrey;&#125;.x.axis text&#123; display: none;&#125;.demo&#123; position: relative;&#125;#tooltip&#123; position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px;&#125;#tooltip.hidden&#123; opacity: 0;&#125; $(function() { var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&callback=?', shList = [ { 'listKey': 'od6', },{ 'listKey': 'ol1cvs7', } ,{ 'listKey': 'objevh6', } //這部分是高雄縣市的合併資料 ] var url = shPath + shKey + '/' + shList + shCallback; //合併路徑 var dataRemote = []; //建立空的陣列 //讀入每一個資料表 $.each(shList, function(i, list){ $.getJSON( shPath + shKey + '/' + list.listKey + shCallback) .done(function (data) { //如果成功 list.dataName = [] var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t //資料頁的標題 dataRemote.push({ //存回陣列 'title': title, 'data': entry }); //送回dataset jsonDone(); //執行驗證 }) .fail(function(jqxhr, textStatus, error){ console.log('GG,沒戲唱了'); //失敗 }); }) //驗證資料跑完沒 jsonDone = function(){ if (shList.length != dataRemote.length){ console.log('快好了'); //驗證未完成 } else if (shList.length == dataRemote.length){ console.log('好了', dataRemote); //驗證成功 dataset = dataRemote runChart(); //繪製圖表 } }; //真的開始畫圖了 runChart = function(){ var margin = {top: 60, right: 40, bottom: 50, left: 60}; var w = 560 ; // 寬 var h = 300 ; // 高 console.log(dataset[0].data.length) datatime = []; //將時間存成陣列，作為Xscale用處 $.each(dataset[0].data,function(i,d){ datatime.push(d.gsx$time.$t) }); var xScale = d3.scale.linear().domain([0,dataset[0].data.length]).range([0,w]) var yScale = d3.scale.linear().domain([.2, .85]).range([h, 0]); //Y的Scale就不另外寫，先直接設定值 // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d.gsx$percent.$t); //利用尺度運算資料的值，傳回y的位置 }); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 var xAxis = d3.svg.axis().scale(xScale).ticks(5).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); $.each(dataset,function(i,d){ svg.append('path').attr('d', line(d.data)) .style({ 'stroke': d3.hsl((120 + 90*i), .6, .6),//d3.hsl是d3提供的顏色function 'stroke-width':1, });//將每個資料繪製成折線，並且套用不同的色彩 svg.append('g').selectAll('circle').data(d.data).enter() //增加原點 .append('circle') .attr({ 'cx': function(d, i){return xScale(i + 1) }, 'cy': function(d){return yScale(d.gsx$percent.$t)}, //x,y算法都類似line function 'r':'2px', 'class': 'dot' //這圓點主要是要給hover使用的 }) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6)//套用相同色彩 }) svg.append('g').append('text') //補上左上示意文字 .text(d.title) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6), 'transform': 'translate(8px,'+ ((i * 15) + 12) //拉開間距 +'px)', 'font-size':'12px' }) }); showTips = function(id){ //這部分是要作為Hover用的資料 date = dataset[0].data[id].gsx$time.$t //時間取其中一份的即可 var html = '' $.each(dataset, function(i, dataset){ //將資料定義，並回傳 title = dataset.title; percent = dataset.data[id].gsx$percent.$t; html = html + ''+title+'/ '+percent+'%' }); html = ''+date+'' + html; return html; //回傳整理好的html }; svg.selectAll('.dot').on('mouseover', function(d){ //d3 function，類似jquery，直接可以控制class var xPos = parseFloat(d3.select(this).attr('cx')) + margin.left //截取點的位置 var yPos = parseFloat(d3.select(this).attr('cy')) + margin.top //這一個目標(d)，裡面也包含了資料，所以d.gsx$id可以抓到這個點所包含的資料 var id = d.gsx$id.$t - 1 //抓取資料id d3.select('#tooltip') //將div抓來用 .style({ 'left': xPos + 'px', 'top': yPos + 'px' }) .classed('hidden', false) //移除隱藏的class .html(showTips(id)) //將剛剛的showTips function帶入 }).on('mouseout', function(d){ //如果移出的話 d3.select('#tooltip').classed('hidden', true); //補回剛剛的Class }); } }); path { stroke: DodgerBlue; stroke-width: 1; fill: none; } .axis { font-size: 11px; fill: gray; } .x.axis line { stroke: lightgrey; } .x.axis .minor { stroke-opacity: .5; } .x.axis path { stroke: #fafafa; } .y.axis line, .y.axis path { fill: none; stroke: lightgrey; } .x.axis text{ display: none; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 究竟搭不搭捷運與死亡率有沒有關係？(2) - Google 試算表","slug":"Ironman-30-days-17","date":"2014-10-15T16:00:00.000Z","updated":"2016-10-13T02:57:22.000Z","comments":true,"path":"d3js/2014/10/16/Ironman-30-days-17/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/16/Ironman-30-days-17/","excerpt":"上一篇提到資料是放在Google 試算表上，然後再透過web 前端去接資料，當初會想這麼做的原因有以下幾點： 資料路徑穩定，不易掛點 技術上只要成功一次，以後都沒問題 資料建立簡單，大部份的人都可以參與 可以多人協作 對我來說，資料怎麼接一直是很大的問題，也在想如果沒有後端技術，要處理資料是不是比較複雜，還好有Google Drive，不僅解決了資料處理以及介接的問題，還有許多的優點可以去活用。","text":"上一篇提到資料是放在Google 試算表上，然後再透過web 前端去接資料，當初會想這麼做的原因有以下幾點： 資料路徑穩定，不易掛點 技術上只要成功一次，以後都沒問題 資料建立簡單，大部份的人都可以參與 可以多人協作 對我來說，資料怎麼接一直是很大的問題，也在想如果沒有後端技術，要處理資料是不是比較複雜，還好有Google Drive，不僅解決了資料處理以及介接的問題，還有許多的優點可以去活用。 相信試算表大部分功能大家都很熟悉了，這邊就只提幾個可以注意的小地方，供大家參考參考。 試算表路徑： https://docs.google.com/spreadsheets/d/1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM/edit#gid=0 資料格式資料怎麼找，就各憑本事了，能力好會用知道怎麼爬，能力普通可以像我一樣用Google搜尋就好，但是找來的資料格式許多都不是想要的，所以還是需要稍作整理，那麼就可以趁轉到Google Drive上時順便改成自己想要的格式。 就以時間來說，也可以趁這時候轉成西元年，並且套用成時間格式。 表格標頭試算表的標頭，建議使用英文名稱，再轉成json後他會以key的方式呈現，就以百分比來說，他會像下面的方式呈現： gsx$percent.$t 發佈到網路這一段我找很多資料，看起來很複雜，其實很簡單，只是我關鍵字下錯了…。 匯出成json讓其它工具使用，經我略微的測試與該試算表的權限沒什麼關係，只要選擇 檔案 &gt; 發佈到網路(位置會隨著版本不同而更換) ，接下來把該開啟的都打開就可以了。 如圖，我是把整份文件打開。 試算表的Key~最後要接資料，每份試算表都有一組key，它是固定的，只要開一份新的試算表都會產生，在剛剛發佈到網路那動作網址列其中一段就是key。 1https://spreadsheets.google.com/feeds/list/&#123;Key&#125;/&#123;list&#125;/public/values?alt=json-in-script&amp;callback=? 另外還有一個是分頁的key，如果只有一個分頁，預設的key基本上是od6，但如果有超過兩個以上的分頁，試算表也會指定不同的key給分頁，查詢的方式如下連結。 1https://spreadsheets.google.com/feeds/worksheets/&#123;Key&#125;/public/basic 接下來在這個網頁可以找到很多網址，分頁的key就隱藏在其中…，基本上都在public前後啦…。 如果有更好地搜尋方式也歡迎大家提供 &gt; &lt;。 Demo接下來就來用一小段Code來測試是否可以使用，如果下面的範例成功，會抓取一些些資料顯示在下面，如果失敗的話會顯示”GG,沒戲唱了”。 12345678910111213141516171819202122$(function()&#123; var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&amp;callback=?', shList = 'ol1cvs7' var dataset = [] $.getJSON( shPath + shKey + '/' + shList + shCallback) .done(function (data) &#123; //如果成功 var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t dataset.push(&#123; 'title': title, 'data': entry &#125;); //送回dataset console.log(dataset) $('.demo .log').text('success:' + dataset[0].title + ',' + dataset[0].data[5].gsx$time.$t) &#125;) .fail(function(jqxhr, textStatus, error)&#123; $('.demo .log').text('GG,沒戲唱了'); //失敗 &#125;);&#125;); $(function(){ var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&callback=?', shList = 'ol1cvs7' var dataset = [] $.getJSON( shPath + shKey + '/' + shList + shCallback) .done(function (data) { //如果成功 var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t dataset.push({ 'title': title, 'data': entry }); //送回dataset console.log(dataset) $('.demo .log').text('success:' + dataset[0].title + ',' + dataset[0].data[5].gsx$time.$t) }) .fail(function(jqxhr, textStatus, error){ $('.demo .log').text('GG,沒戲唱了'); //失敗 }); });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 究竟搭不搭捷運與死亡率有沒有關係？(1)","slug":"Ironman-30-days-16","date":"2014-10-14T16:00:00.000Z","updated":"2016-10-13T03:25:22.000Z","comments":true,"path":"d3js/2014/10/15/Ironman-30-days-16/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/15/Ironman-30-days-16/","excerpt":"D3js最終還是需要與資料串接，在玩了一段時間基本的功能後，就會想找點東西試試看，於是就到處搜尋可以用的資料(希望與時事結合)，雖然取得資料方法相當多，但是能夠派上用場而且又要會使用，就沒有那麼容易。 因為我的jsonp，或者json能力並不是挺好，所以在找資料前，有先研究怎麼與Google Drive做介接，所以這幾篇還會介紹怎麼從Google試算表取得資料。","text":"D3js最終還是需要與資料串接，在玩了一段時間基本的功能後，就會想找點東西試試看，於是就到處搜尋可以用的資料(希望與時事結合)，雖然取得資料方法相當多，但是能夠派上用場而且又要會使用，就沒有那麼容易。 因為我的jsonp，或者json能力並不是挺好，所以在找資料前，有先研究怎麼與Google Drive做介接，所以這幾篇還會介紹怎麼從Google試算表取得資料。 本篇統計僅供參考 資料來源資料來源http://statis.moi.gov.tw/micst/stmain.jsp?sys=100 無意間剛好逛到這個網站，發現裡面有許多的人口資料，裡面包含了死亡人數統計，也恰巧有”粗死亡率”，想說最近有討論到搭不搭捷運與死亡率的關係，所以就來試試看這份資料可不可行。 首先來了解一下基本資訊 臺北捷運營運：1996年3月28日 高雄捷運營運：2008年3月9日 高雄縣市合併(來源資料)：2011年1月 這份資料是抓取兩個都市的粗死亡率(所以不呈現人口數)，另外在高雄市2010年以前是合併前的資料，2011年以後是合併資料，來源當然是能撈多少就多少。 Demo雖然有很多工具可以呈現這樣的資料，但是就以目前的主題我選擇d3js + Jquery。 資料在確定要哪些後，就把原始的資料轉貼到Google Drive，除了可以將資料統一格式外，也可以降低我對於跨網域的煩惱…。 資料上我以都市為單位拆成三個資料表，每個圖表都包含了id、時間、死亡人數、粗死亡率。 接下來就開始串啦～，結果大概像下面這樣，Hover到點上，會顯示該時間點的資料。 高雄市與台北市粗死亡率 以上資料來源：http://statis.moi.gov.tw/micst/stmain.jsp?sys=100 高雄縣市合併時間(來源資料)：2011年1月 12 結語至於搭不搭捷運與死亡率有沒有關係，恩…可能研究不夠透徹，所以看不太出來，不過城鄉差距與死亡率關係倒是挺明顯的(可參考http://statis.moi.gov.tw/micst/stmain.jsp?sys=100)，所以縣市合併以後，高雄市的死亡率確實有略微增高。 另外為什麼每年二、三月似乎死亡率高些…(抖)，尤其在2009年二月高很多，稍微有查詢一下，可能是經濟不景氣的關係(Wiki 2009台灣年表)。 透過這些圖表，可以容易看到表格資料不易發現的地方，這或許也是圖像化迷人的點吧。 $(function() { var shPath = 'https://spreadsheets.google.com/feeds/list/', shKey = '1hX3lqWLHFuwYiQeaBL0WevleUEOBAPKzshj2fJHogsM', shCallback = '/public/values?alt=json-in-script&callback=?', shList = [ { 'listKey': 'od6', 'dataName': 'dataTaipei' },{ 'listKey': 'ol1cvs7', 'dataName': 'dataKaohsiung' } // ,{ // 'listKey': 'objevh6', // 'dataName': 'dataKaohsiungOld' // } ] var url = shPath + shKey + '/' + shList + shCallback; var dataRemote = []; //讀入每一個資料表 $.each(shList, function(i, list){ $.getJSON( shPath + shKey + '/' + list.listKey + shCallback) .done(function (data) { //如果成功 list.dataName = [] var entry = data.feed.entry //只取feed entry的部分 var title = data.feed.title.$t dataRemote.push({ 'title': title, 'data': entry }); //送回dataset jsonDone(); }) .fail(function(jqxhr, textStatus, error){ console.log('GG,沒戲唱了'); //失敗 }); }) //驗證資料跑完沒 jsonDone = function(){ if (shList.length != dataRemote.length){ console.log('快好了'); //驗證未完成 } else if (shList.length == dataRemote.length){ console.log('好了', dataRemote); //驗證成功 runData(); //整理資料 } }; //整理資料 runData = function(){ //整理資料 dataset = dataRemote runChart(); }; //真的開始畫圖了 runChart = function(){ var margin = {top: 60, right: 40, bottom: 50, left: 60}; var w = 560 ; // 寬 var h = 300 ; // 高 console.log(dataset[0].data.length) // var Ymax = d3.max(dataset[0].data, function(d,i){ return d.data.gsx$percent.$t}), // Ymin = d3.min(dataset[0].data, function(d,i){ return d.data.gsx$percent.$t}); datatime = []; $.each(dataset[0].data,function(i,d){ datatime.push(d.gsx$time.$t) }); console.log(datatime) var xScale = d3.scale.linear().domain([0,dataset[0].data.length]).range([0,w]) var yScale = d3.scale.linear().domain([.2, .85]).range([h, 0]); // console.log(Ymax,Ymin) // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d.gsx$percent.$t); //利用尺度運算資料的值，傳回y的位置 }); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 // tickSubdivide不清楚是什麼用處 var xAxis = d3.svg.axis().scale(xScale).ticks(5).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); parseArray = function(data, l){ array = []; $.each(data,function(i,d){ array.push(d.l) }) } // svg.append('path').attr('d', line(dataset[0].data)); // svg.append('path').attr('d', line(dataset[1].data)); $.each(dataset,function(i,d){ svg.append('path').attr('d', line(d.data)) .style({ 'stroke': d3.hsl((120 + 90*i), .6, .6), 'stroke-width':1, })// svg.append('g').selectAll('circle').data(d.data).enter() .append('circle') .attr({ 'cx': function(d, i){return xScale(i + 1) }, 'cy': function(d){return yScale(d.gsx$percent.$t)}, 'r':'2px', 'stroke':'transparent', 'stroke-width':'3px', 'class': 'dot' }) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6) }) svg.append('g').append('text') .text(d.title) .style({ 'fill': d3.hsl((120 + 90*i), .6, .6), 'transform': 'translate(8px,'+ ((i * 15) + 12) +'px)', 'font-size':'12px' }) }); showTips = function(id){ date = dataset[0].data[id].gsx$time.$t var html = '' $.each(dataset, function(i, dataset){ title = dataset.title; percent = dataset.data[id].gsx$percent.$t; html = html + ''+title+'/ '+percent+'%' }) console.log(date) html = ''+date+'' + html; return html } svg.selectAll('.dot').on('mouseover', function(d){ var xPos = parseFloat(d3.select(this).attr('cx')) + margin.left var yPos = parseFloat(d3.select(this).attr('cy')) + margin.top var id = d.gsx$id.$t - 1 d3.select('#tooltip') .style({ 'left': xPos + 'px', 'top': yPos + 'px' }) .classed('hidden', false) .html(showTips(id)) }).on('mouseout', function(d){ d3.select('#tooltip').classed('hidden', true) }) } }); path { stroke: DodgerBlue; stroke-width: 1; fill: none; } .axis { font-size: 11px; fill: gray; } .x.axis line { stroke: lightgrey; } .x.axis .minor { stroke-opacity: .5; } .x.axis path { stroke: #fafafa; } .y.axis line, .y.axis path { fill: none; stroke: lightgrey; } .x.axis text{ display: none; } .demo{ position: relative; } #tooltip{ position: absolute; max-width: 220px; padding: 10px; background-color: #fff; border-radius: 2px; box-shadow: 0 2px 2px rgba(0,0,0, .16); pointer-events: none; transition: opacity .2s; opacity: 1; font-size: 11px; } #tooltip.hidden{ opacity: 0; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 折線圖(Line Chart)","slug":"Ironman-30-days-15","date":"2014-10-13T16:00:00.000Z","updated":"2016-10-13T02:58:10.000Z","comments":true,"path":"d3js/2014/10/14/Ironman-30-days-15/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/14/Ironman-30-days-15/","excerpt":"在開始有題到網頁互動式資料視覺化：使用D3這本書，整本大致上都看完了，但是裡面居然沒有折線圖！雖然這本書主要教的是觀念，不過折線圖還是很重要，所以還是另外找了折線圖的範例來仔細學習一下。","text":"在開始有題到網頁互動式資料視覺化：使用D3這本書，整本大致上都看完了，但是裡面居然沒有折線圖！雖然這本書主要教的是觀念，不過折線圖還是很重要，所以還是另外找了折線圖的範例來仔細學習一下。 Demo先前有介紹過SVG:Path，大概像下面這樣： 1&lt;path d=\"M12,294.11764705882354L24,300L36,270.5882352941176L48,294.11764705882354L60,282.3529411764706L72,276.47058823529414L84.1,264.70588235294116L96,276.47058823529414L108,247.05882352941177L120,241.1764705882353L132,229.41176470588235L144,241.1764705882353L156,223.52941176470588L168.3,217.6470588235294L180,200L192,223.52941176470588L204.3,200L216,211.76470588235293L228,211.76470588235293L240,223.52941176470588L252,217.6470588235294L264,200L276,188.23529411764707L288,164.7058823529412L300,176.47058823529414L312,200L324,217.6470588235294L336.6,188.23529411764707L348,158.8235294117647L360,152.94117647058823L372,135.2941176470588L384,117.64705882352942L396,100L408.6,111.76470588235296L420.6,88.23529411764707L432,76.47058823529412L444,47.05882352941177L456,41.176470588235304L468,52.94117647058826L480,47.05882352941177L492.6,17.64705882352939L504,29.411764705882376L516,29.411764705882376L528,23.529411764705912L540,35.29411764705884L552,23.529411764705912L564,17.64705882352939L576,0L588,17.64705882352939L600,41.176470588235304\"&gt;&lt;/path&gt; 雖然之前有介紹過自幹的方式…，可是用來上資料真的會有點痛，不過還好d3有一個function d3.svg.line()可以用來繪製svg “path”，只要給予x、y，剩下d3都會處理。 本篇的範例參考自http://bl.ocks.org/benjchristensen/2579599 範例我可是花了點時間調的比他漂亮呢！(挺 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960var margin = &#123;top: 60, right: 40, bottom: 50, left: 60&#125;;var w = 580 ; // 寬var h = 300 ; // 高var dataset = []; //建立空的資料陣列var Num = 20for (var i=0; i &lt; 50; i++)&#123; var newNum = Num + (5 - Math.floor(Math.random() * 10)); dataset.push(newNum); Num = newNum;&#125;//隨機產生一組隨機的數字陣列，數字的值，每次加減不超過5//X是資料的數量，Y則是資料的值console.log(dataset)var Ymax = d3.max(dataset), Ymin = d3.min(dataset);var xScale = d3.scale.linear().domain([0, dataset.length]).range([0, w]);var yScale = d3.scale.linear().domain([Ymin, Ymax]).range([h, 0]);// 增加一個line function，用來把資料轉為x, yvar line = d3.svg.line() .x(function(d,i) &#123; return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 &#125;) .y(function(d) &#123; return yScale(d); //利用尺度運算資料的值，傳回y的位置 &#125;);//增加一個SVG元素var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');// 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高// tickSubdivide不清楚是什麼用處var xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickSize(-h).tickSubdivide(true);// SVG加入x軸線svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis);// 建立y軸線，4個刻度，數字在左var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left');// SVG加入y軸線svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft);svg.append('path').attr('d', line(dataset)); //將資料套用d3.svg.line() CSS 1234567891011121314151617181920212223242526path &#123; stroke: DodgerBlue; stroke-width: 1; fill: none;&#125;.axis &#123; font-size: 11px; fill: gray;&#125;.x.axis line &#123; stroke: lightgrey;&#125;.x.axis .minor &#123; stroke-opacity: .5;&#125;.x.axis path &#123; stroke: #fafafa;&#125;.y.axis line, .y.axis path &#123; fill: none; stroke: lightgrey;&#125; 不知道大家對於到目前的範例難度感覺如何，對我而言還挺難的，尤其資料、json的處理我相當的不擅長，不過既然稱為D3.js，還是要來玩一些資料，明天開始來找資料玩玩吧～ var margin = {top: 60, right: 40, bottom: 50, left: 60}; var w = 580 ; // 寬 var h = 300 ; // 高 var dataset = []; //建立空的資料陣列 var Num = 20 for (var i=0; i < 50; i++){ var newNum = Num + (5 - Math.floor(Math.random() * 10)); dataset.push(newNum); Num = newNum; } //隨機產生一組隨機的數字陣列，數字的值，每次加減不超過5 //X是資料的數量，Y則是資料的值 console.log(dataset) var Ymax = d3.max(dataset), Ymin = d3.min(dataset); var xScale = d3.scale.linear().domain([0, dataset.length]).range([0, w]); var yScale = d3.scale.linear().domain([Ymin, Ymax]).range([h, 0]); // 增加一個line function，用來把資料轉為x, y var line = d3.svg.line() .x(function(d,i) { return xScale(i + 1); //利用尺度運算資料索引，傳回x的位置 }) .y(function(d) { return yScale(d); //利用尺度運算資料的值，傳回y的位置 }); //增加一個SVG元素 var svg = d3.select('.demo').append('svg') .attr('width', w + margin.left + margin.right) //將左右補滿 .attr('height', h + margin.top + margin.bottom) //上下補滿 .append('g') //增加一個群組g .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')'); // 增加x軸線，tickSize是軸線的垂直高度，-h會往上拉高 // tickSubdivide不清楚是什麼用處 var xAxis = d3.svg.axis().scale(xScale).orient('bottom').tickSize(-h).tickSubdivide(true); // SVG加入x軸線 svg.append('g') .attr('class', 'x axis') .attr('transform', 'translate(0,' + h + ')') .call(xAxis); // 建立y軸線，4個刻度，數字在左 var yAxisLeft = d3.svg.axis().scale(yScale).ticks(4).orient('left'); // SVG加入y軸線 svg.append('g') .attr('class', 'y axis') .attr('transform', 'translate(0,0)') .call(yAxisLeft); svg.append('path').attr('d', line(dataset)); //將資料套用d3.svg.line() path { stroke: DodgerBlue; stroke-width: 1; fill: none; } .axis { font-size: 11px; fill: gray; } .x.axis line { stroke: lightgrey; } .x.axis .minor { stroke-opacity: .5; } .x.axis path { stroke: #fafafa; } .y.axis line, .y.axis path { fill: none; stroke: lightgrey; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 軸線(Axis)","slug":"Ironman-30-days-14","date":"2014-10-12T16:00:00.000Z","updated":"2016-10-13T03:07:37.000Z","comments":true,"path":"d3js/2014/10/13/Ironman-30-days-14/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/13/Ironman-30-days-14/","excerpt":"到上一次為止，其實就可以畫出簡單的資料圖表，現在開始就要讓資料圖表更為豐富且好閱讀。 今天要介紹的軸線(Axis)，讓圖表上多一個可以閱讀的尺標，D3.js正好有提供這樣的函式，可以輕鬆的產出軸線。","text":"到上一次為止，其實就可以畫出簡單的資料圖表，現在開始就要讓資料圖表更為豐富且好閱讀。 今天要介紹的軸線(Axis)，讓圖表上多一個可以閱讀的尺標，D3.js正好有提供這樣的函式，可以輕鬆的產出軸線。 如果要憑空畫出這樣的軸線(Axis)，說實在還有點複雜，D3提供的函式d3.svg.axis()，只要這短短一行就能產生軸線，並且加上尺度.scale()就完成一半了，剩下就只要調整位置、刻度範圍、單位等等就完成了。 所以這範例，主要也是看程式碼，加油吧！ Demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var w = 600,h = 400,padding = 30;//random datavar dataset = [];var numDataPoints = 100; //總共100個點var xRange = Math.random() * 500;var yRange = Math.random() * 1000;for (var i = 0; i &lt; numDataPoints; i++)&#123; var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2])&#125;//和更早之前一樣，我們用假的資料來做範例console.table(dataset)var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;) //取得X,Y的最大及最小值var xScale = d3.scale.linear() //製作線性尺度 .domain([0, Xmax]) //輸入的範圍 .range([padding , w - padding]) //輸出的範圍var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding])var svg = d3.select('.demo').append('svg').attr(&#123;'width': w,'height': h&#125;) //增加SVG容器 svg.selectAll('circle').data(dataset).enter() //插入資料 .append('circle') //增加圓形物件 .attr(&#123; 'cx': function(d)&#123;return xScale(d[0])&#125;, //利用尺度算出圓心x位置 'cy': function(d)&#123;return yScale(d[1])&#125;, //同上算出y 'r': '2px', //圓心大小 'fill': 'black' //填色 &#125;); svg.selectAll('text').data(dataset).enter() //插入資料 .append('text') //增加文字區塊 .text(function(d)&#123; return d[0]+ ',' + d[1]&#125;) //補上坐標文字 .attr(&#123; 'x': function(d)&#123;return xScale(d[0])&#125;, 'y': function(d)&#123;return yScale(d[1])&#125;, 'fill': 'red', //填滿紅色 'font-size': '10px' //文字大小 &#125;);//Axisvar xAxis = d3.svg.axis().scale(xScale) //增加軸線物件，並套用尺度(x) .orient(\"bottom\") //標示位置 .ticks(6) //刻度數量var yAxis = d3.svg.axis().scale(yScale) //增加軸線物件，並套用尺度(y) .orient(\"left\") //標示位置 .ticks(10) //刻度數量//刻度化標籤，這範例不使用// var formatAsAxis = d3.format('.1%');// xAxis.tickFormat(formatAsAxis);//刻度化標籤svg.append('g').attr('class', 'axis') //增加一個群組並加上class=\"axis\" .attr('transform', 'translate(0, '+ (h - padding) +')') //移動到下方 .call(xAxis); //將軸線匯入svg.append('g').attr('class', 'axis') .attr('transform', 'translate('+ (padding) +')', 0) //移動到左方 .call(yAxis); 剛剛最後還有加Class，別忘了…，記得補上喔。 123456789.axis path, .axis line&#123; fill: none; stroke: SlateGray; shape-rendering: cirspEdges;&#125;.axis text&#123; font-size: 11px; fill: #999;&#125; var w = 600,h = 400,padding = 30; //random data var dataset = []; var numDataPoints = 100; //總共100個點 var xRange = Math.random() * 500; var yRange = Math.random() * 1000; for (var i = 0; i < numDataPoints; i++){ var num1 = Math.floor(Math.random() * xRange); var num2 = Math.floor(Math.random() * yRange); dataset.push([num1,num2]) }//和更早之前一樣，我們用假的資料來做範例 console.table(dataset) var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}) //取得X,Y的最大及最小值 var xScale = d3.scale.linear() //製作線性尺度 .domain([0, Xmax]) //輸入的範圍 .range([padding , w - padding]) //輸出的範圍 var yScale = d3.scale.linear() .domain([0, Ymax]) .range([ h - padding ,padding]) var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //增加SVG容器 svg.selectAll('circle').data(dataset).enter() //插入資料 .append('circle') //增加圓形物件 .attr({ 'cx': function(d){return xScale(d[0])}, //利用尺度算出圓心x位置 'cy': function(d){return yScale(d[1])}, //同上算出y 'r': '2px', //圓心大小 'fill': 'black' //填色 }); svg.selectAll('text').data(dataset).enter() //插入資料 .append('text') //增加文字區塊 .text(function(d){ return d[0]+ ',' + d[1]}) //補上坐標文字 .attr({ 'x': function(d){return xScale(d[0])}, 'y': function(d){return yScale(d[1])}, 'fill': 'red', //填滿紅色 'font-size': '10px' //文字大小 }); //Axis var xAxis = d3.svg.axis().scale(xScale) //增加軸線物件，並套用尺度(x) .orient(\"bottom\") //標示位置 .ticks(6) //刻度數量 var yAxis = d3.svg.axis().scale(yScale) //增加軸線物件，並套用尺度(y) .orient(\"left\") //標示位置 .ticks(10) //刻度數量 //刻度化標籤，這範例不使用 // var formatAsAxis = d3.format('.1%'); // xAxis.tickFormat(formatAsAxis); //刻度化標籤 svg.append('g').attr('class', 'axis') //增加一個群組並加上class=\"axis\" .attr('transform', 'translate(0, '+ (h - padding) +')') //移動到下方 .call(xAxis); //將軸線匯入 svg.append('g').attr('class', 'axis') .attr('transform', 'translate('+ (padding) +')', 0) //移動到左方 .call(yAxis); .axis path, .axis line{ fill: none; stroke: SlateGray; shape-rendering: cirspEdges; } .axis text{ font-size: 11px; fill: #999; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 讀取CSV資料並繪製成長條圖","slug":"Ironman-30-days-13","date":"2014-10-11T16:00:00.000Z","updated":"2016-10-13T03:07:53.000Z","comments":true,"path":"d3js/2014/10/12/Ironman-30-days-13/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/12/Ironman-30-days-13/","excerpt":"有了Excel的資料，也可以用d3.js去轉換成json，再結合前幾篇所做的長條圖，不就可以輕易的完成資訊圖表了!?是的，這次就來完成這個圖表吧。","text":"有了Excel的資料，也可以用d3.js去轉換成json，再結合前幾篇所做的長條圖，不就可以輕易的完成資訊圖表了!?是的，這次就來完成這個圖表吧。 今天的流程，算是這幾次的整合，如果有看前幾篇的話，這篇不會很難，但是卻很實用。 DemoCSV範例。 這個範例將會用到昨天所介紹的d3.csv()這個函示去取得本地端的CSV檔案，並且轉換成Json，接下來就把它套用在先前所作好的範例上…，這次的程式碼雖然很長，但都是前幾天剪剪貼貼就可以完成的，而所有的註解，我都一起寫在原始碼上，也方便各位對照(覺得SlateGray這個顏色很好看)。 那麼有了資料，我們再跟先前所練習的範例做結合吧。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081dataPath = '/demoFile/d3data/';dataFile = 'd3demoData141011.csv';dataUrl = dataPath + dataFile;//定義SVG的大小d3.csv(dataUrl, function(data)&#123; console.debug(JSON.stringify(data)); dataset = data; var w = 600,h = 250,padding = 30, barMargin = 2; //定義寬高,padding等等值 var Ymax = d3.max(dataset, function(d)&#123;return d.value&#125;), Ymin = d3.min(dataset, function(d)&#123;return d.value&#125;); //取得Y軸的最大值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var colorScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([0, 700]) //這次顏色都要用尺度來算 var barWidth = (w - padding*2) / dataset.length - barMargin; var svg = d3.select('.demo').append('svg').attr(&#123;'width': w,'height': h&#125;) //接下來開始產生SVG svg.selectAll('rect').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('rect') // 增加圓到SVG內 .attr(&#123; //加入屬性到圓 'x': function(d, i)&#123;return xScale(i)&#125;, //利用尺度算出X的位置 'y': function(d)&#123;return h - yScale(d.value)&#125;, //同理算出Y 'width': barWidth, 'height':function(d)&#123;return yScale(d.value)&#125;, //同理算出Y // 'r': function(d)&#123;return Math.sqrt(h - d[1])&#125;, //圓的大小是高 - Y值的平方 'fill': function(d)&#123; var color = 0.2 + colorScale(d.value) * 0.001; return d3.hsl(200 ,color, color); //利用尺度來算出顏色 &#125;, 'title': function(d)&#123; return 'Name : ' + d.name; &#125; //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) &#125;); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d)&#123; return d.value&#125;) //將值寫到SVG上 .attr(&#123; 'x': function(d, i)&#123;return xScale(i) + barWidth/2&#125;, //和上面相同，算出X、Y的位置 'y': function(d)&#123;return h - yScale(d.value) + 15&#125;, 'fill': 'white', //文字填滿為紅色 'text-anchor': 'middle', 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ &#125;); svg.append('g').selectAll('text').data(dataset).enter() //這邊再多做一個人名顯示的區域 .append('text') .text(function(d)&#123; return d.name&#125;) //寫入人名 .attr(&#123; 'x': function(d, i)&#123;return xScale(i) + barWidth/2&#125;, //和上面相同，算出X、Y的位置 'y': function(d)&#123;return h - yScale(d.value) - 10&#125;, 'fill': 'SlateGray', //文字填滿為超漂亮灰色 'text-anchor': 'middle', 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ &#125;);&#125;); dataPath = '/demoFile/d3data/'; dataFile = 'd3demoData141011.csv'; dataUrl = dataPath + dataFile; //定義SVG的大小 d3.csv(dataUrl, function(data){ console.debug(JSON.stringify(data)); dataset = data; var w = 600,h = 250,padding = 30, barMargin = 2; //定義寬高,padding等等值 var Ymax = d3.max(dataset, function(d){return d.value}), Ymin = d3.min(dataset, function(d){return d.value}); //取得Y軸的最大值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var colorScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([0, 700]) //這次顏色都要用尺度來算 var barWidth = (w - padding*2) / dataset.length - barMargin; var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //接下來開始產生SVG svg.selectAll('rect').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('rect') // 增加圓到SVG內 .attr({ //加入屬性到圓 'x': function(d, i){return xScale(i)}, //利用尺度算出X的位置 'y': function(d){return h - yScale(d.value)}, //同理算出Y 'width': barWidth, 'height':function(d){return yScale(d.value)}, //同理算出Y // 'r': function(d){return Math.sqrt(h - d[1])}, //圓的大小是高 - Y值的平方 'fill': function(d){ var color = 0.2 + colorScale(d.value) * 0.001; return d3.hsl(200 ,color, color); //利用尺度來算出顏色 }, 'title': function(d){ return 'Name : ' + d.name; } //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d.value}) //將值寫到SVG上 .attr({ 'x': function(d, i){return xScale(i) + barWidth/2}, //和上面相同，算出X、Y的位置 'y': function(d){return h - yScale(d.value) + 15}, 'fill': 'white', //文字填滿為紅色 'text-anchor': 'middle', 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ }); svg.append('g').selectAll('text').data(dataset).enter() //這邊再多做一個人名顯示的區域 .append('text') .text(function(d){ return d.name}) //寫入人名 .attr({ 'x': function(d, i){return xScale(i) + barWidth/2}, //和上面相同，算出X、Y的位置 'y': function(d){return h - yScale(d.value) - 10}, 'fill': 'SlateGray', //文字填滿為超漂亮灰色 'text-anchor': 'middle', 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ }); });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 利用Excel建立資料(CSV)","slug":"Ironman-30-days-12","date":"2014-10-10T16:00:00.000Z","updated":"2016-10-13T03:08:17.000Z","comments":true,"path":"d3js/2014/10/11/Ironman-30-days-12/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/11/Ironman-30-days-12/","excerpt":"做了那麼多，資料都是隨機產生的，雖然每次打開都不一樣，但是還是假的資料，這次來試試看讀取Excel的資料吧。","text":"做了那麼多，資料都是隨機產生的，雖然每次打開都不一樣，但是還是假的資料，這次來試試看讀取Excel的資料吧。 CSVExcel可以轉出一種稱為csv(Comma-Separated Values)格式的檔案，檔案的資料內容都是用逗點隔開的，大概像下面這樣： name,value Tyler,234 Boy,124 Joe,357 第一行的name,value可以當作是標題或者是變數名稱，第二行開始的Tyler,234....都是值，d3.js可以將csv轉換成Json檔案格式，可以直接用來作為繪圖所需要的資料。 Excel今天又是假日，所以code就短一點，來介紹Excel怎麼做CSV，打開Excel以後，建立如下的資料。 接下來選擇另存新檔，附檔名選擇.CSV。 如果用文字編輯器打開，預期會出現下面的結果，而這就是D3所需要的csv格式。 如果不想自己做，也可以下載我做好的範例。 D3.js接下了Excel的工作就完成了，來試試看用D3js讀取看看吧，其實方式也相當簡單，只要用d3.csv()就可以讀取並且轉換成json資料格式，只要給d3.js路徑即可。 12345678dataPath = '/demoFile/d3data/'; //檔案路徑dataFile = 'd3demoData141011.csv'; //檔名dataUrl = dataPath + dataFile; //路徑加檔名//定義SVG的大小d3.csv(dataUrl, function(data)&#123; console.table(data); //用table的方式在console呈現json d3.select('.demo').text(JSON.stringify(data)) //把json寫到.demo上&#125;); 如果對於json還認為不好閱讀的人，可以使用console.table()來呈現json，這樣會好閱讀很多。 而這個範例所轉換出來的json格式就像下面這樣。 那麼有了資料，我們明天再跟先前所練習的範例做結合吧。 dataPath = '/demoFile/d3data/'; //檔案路徑 dataFile = 'd3demoData141011.csv'; //檔名 dataUrl = dataPath + dataFile; //路徑加檔名 //定義SVG的大小 d3.csv(dataUrl, function(data){ console.table(data); //用table的方式在console呈現json d3.select('.demo').text(JSON.stringify(data)) //把json寫到.demo上 });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js 國慶日在家裡畫長條圖","slug":"Ironman-30-days-11","date":"2014-10-09T16:00:00.000Z","updated":"2016-10-13T03:08:32.000Z","comments":true,"path":"d3js/2014/10/10/Ironman-30-days-11/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/10/Ironman-30-days-11/","excerpt":"上一篇的重點相當重要，可以運用在各種圖表上，而其實在之前介紹的用div繪製直條圖，在SVG上當然也是行得通，而且相當容易，今天是國慶日，當然就要來點簡易好吸收的主題。","text":"上一篇的重點相當重要，可以運用在各種圖表上，而其實在之前介紹的用div繪製直條圖，在SVG上當然也是行得通，而且相當容易，今天是國慶日，當然就要來點簡易好吸收的主題。 有了上一篇的觀念，這個直條圖就能更容易地呈現，無論資料量的多寡，或者是資料值的大小，都能完整地呈現在SVG上。 Demo在SVG上繪製直條圖，要注意的事情並不多，只有兩點需要略微注意： 直條Bar是從底部往上，但是一般SVG是由上往下 Bar的寬度、間距要怎麼定義 問題一：最簡單的方式，就是將Bar向下位置一個距離(距離為高 - 資料值)，接下來再往下延伸資料值的Bar，這個範例直接看圖可能比較好理解。 問題二：定義了Bar的寬度，如果資料的數量較多，可能多的部分會跑出SVG畫布，比較好的方式是定義間距的寬度就好，Bar的寬度由資料的總量來決定。 接下來不囉唆，快快看完今天的範例，來去過國慶日了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657var w = 600,h = 250,padding = 30, barMargin = 2;//定義SVG的大小，但是只要定義直條的間距就好，寬度用算的就好var dataset = [];for (var i=0; i &lt; 20; i++)&#123; var Num1 = 5 + Math.floor(Math.random() * 255); dataset.push(Num1);&#125;;console.log(dataset);//和先前一樣，產生一組隨機的資料var Ymax = d3.max(dataset, function(d)&#123;return d&#125;), Ymin = d3.min(dataset, function(d)&#123;return d&#125;)//這個函示可以取得資料的最大值、最小值var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值改為資料的數量 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的paddingvar yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度var barWidth = (w - padding*2) / dataset.length - barMargin;//算出每一個bar的寬度var svg = d3.select('.demo').append('svg').attr(&#123;'width': w,'height': h&#125;)//接下來開始產生SVGsvg.selectAll('rect').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入.append('rect') // 增加圓到SVG內.attr(&#123; //加入屬性到圓 'x': function(d, i)&#123;return xScale(i)&#125;, //利用尺度算出X的位置 'y': function(d)&#123;return h - yScale(d)&#125;, //同理算出Y，但是要放在底部，所以要y-yScale(d) 'width': barWidth, //bar的寬度 'height':function(d)&#123;return yScale(d)&#125;, //高度算法與Y相同 'fill': function(d)&#123; var color = 0.2 + d * 0.002; return d3.hsl(200 ,color, color); &#125; //顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度)&#125;);svg.selectAll('text').data(dataset).enter() //補上資料數值.append('text').text(function(d)&#123; return d&#125;) //將值寫到SVG上.attr(&#123; 'x': function(d, i)&#123;return xScale(i) + barWidth/2&#125;, //和上面相同，算出X、Y的位置 'y': function(d)&#123;return h - yScale(d) + 15&#125;, //數值放在bar 內 'fill': 'white', //文字填滿為白色 'text-anchor': 'middle', //文字置中 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～&#125;); var w = 600,h = 250,padding = 30, barMargin = 2; //定義SVG的大小，但是只要定義直條的間距就好，寬度用算的就好 var dataset = []; for (var i=0; i < 20; i++){ var Num1 = 5 + Math.floor(Math.random() * 255); dataset.push(Num1); }; console.log(dataset); //和先前一樣，產生一組隨機的資料 var Ymax = d3.max(dataset, function(d){return d}), Ymin = d3.min(dataset, function(d){return d}) //這個函示可以取得資料的最大值、最小值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([0, dataset.length]) //傳入的值改為資料的數量 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([padding, h - padding]) //類似X軸的尺度 var barWidth = (w - padding*2) / dataset.length - barMargin; //算出每一個bar的寬度 var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //接下來開始產生SVG svg.selectAll('rect').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('rect') // 增加圓到SVG內 .attr({ //加入屬性到圓 'x': function(d, i){return xScale(i)}, //利用尺度算出X的位置 'y': function(d){return h - yScale(d)}, //同理算出Y，但是要放在底部，所以要y-yScale(d) 'width': barWidth, //bar的寬度 'height':function(d){return yScale(d)}, //高度算法與Y相同 'fill': function(d){ var color = 0.2 + d * 0.002; return d3.hsl(200 ,color, color); } //顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d}) //將值寫到SVG上 .attr({ 'x': function(d, i){return xScale(i) + barWidth/2}, //和上面相同，算出X、Y的位置 'y': function(d){return h - yScale(d) + 15}, //數值放在bar 內 'fill': 'white', //文字填滿為白色 'text-anchor': 'middle', //文字置中 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3.js Scale 尺度","slug":"Ironman-30-days-10","date":"2014-10-08T16:00:00.000Z","updated":"2016-10-13T03:08:57.000Z","comments":true,"path":"d3js/2014/10/09/Ironman-30-days-10/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/09/Ironman-30-days-10/","excerpt":"上一篇其實就已經介紹了D3.js相當重要的data()以及enter()，今天要介紹的也是很重要，就是(Scale)尺度。","text":"上一篇其實就已經介紹了D3.js相當重要的data()以及enter()，今天要介紹的也是很重要，就是(Scale)尺度。 尺度尺度是一個D3的函式可以設定輸入以及輸出的範圍，就以下方的圖來說，如果來源的資料範圍是10~990，目標輸出的範圍必須限制在0~100，透過尺度函式後，所有的資料就會依據這尺度進行轉換，就像是輸入的資料值如果是500，那麼在目標輸出值就會是50。 所以在使用時必須定義輸入及輸出的資料範圍，就以這個範例來說，他的函式會如下，domain([10, 990])表示輸入範圍，range([0, 100])表示輸出範圍。 12345var d3Scale = d3.scale.linear() //產生一個線性尺度 .domain([10, 999]) //傳入的值 .range([0 , 100]) //輸出的範圍console.log(\"輸出的值 = \" + d3Scale(500)) 在本頁可以打開瀏覽器的開發工具 &gt; console，就可以看到輸出的值是”50”。 Demo接下來我們利用這個概念來做一個範例，這個範例的值是隨機產生的，值得範圍很不一定，因此還必須取得資料的最大值及最小值，這部分d3也有提供函式可以處理，d3.max()、d3.min()這兩個函式可以取得最大值及最小值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051var w = 600,h = 250,padding = 20;//定義SVG的大小var dataset = [];for (var i=0; i &lt; 20; i++)&#123; var Num1 = 5 + Math.floor(Math.random() * 900); var Num2 = 5 + Math.floor(Math.random() * 220); dataset.push([Num1, Num2]);&#125;;console.log(dataset);//和先前一樣，產生一組隨機的資料var Xmax = d3.max(dataset, function(d)&#123;return d[0]&#125;), Xmin = d3.min(dataset, function(d)&#123;return d[0]&#125;), Ymax = d3.max(dataset, function(d)&#123;return d[1]&#125;), Ymin = d3.min(dataset, function(d)&#123;return d[1]&#125;)//這個函示可以取得資料的最大值、最小值var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([Xmin, Xmax]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的paddingvar yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([ h - padding ,padding]) //類似X軸的尺度var svg = d3.select('.demo').append('svg').attr(&#123;'width': w,'height': h&#125;) //接下來開始產生SVGsvg.selectAll('circle').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入.append('circle') // 增加圓到SVG內.attr(&#123; //加入屬性到圓 'cx': function(d)&#123;return xScale(d[0])&#125;, //利用尺度算出X的位置 'cy': function(d)&#123;return yScale(d[1])&#125;, //同理算出Y 'r': function(d)&#123;return Math.sqrt(h - d[1])&#125;, //圓的大小是高 - Y值的平方 'fill': function(d)&#123;return d3.hsl(d[0] % 360, .6, .6 );&#125; //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度)&#125;);svg.selectAll('text').data(dataset).enter() //補上資料數值.append('text').text(function(d)&#123; return d[0]+ ',' + d[1]&#125;) //將值寫到SVG上.attr(&#123; 'x': function(d)&#123;return xScale(d[0])&#125;, //和上面相同，算出X、Y的位置 'y': function(d)&#123;return yScale(d[1])&#125;, 'fill': 'red', //文字填滿為紅色 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～&#125;); 有了這些函式，就可以讓圖形資料乖乖的在範圍內呈現了。 var d3Scale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([10, 990]) //傳入的值是原始資料的最小及最大值 .range([0 , 100]) //輸出的範圍是左邊的padd距離，到右邊的padding console.log(\"輸出的值 = \" + d3Scale(500)) var w = 600,h = 250,padding = 20; //定義SVG的大小 var dataset = []; for (var i=0; i < 20; i++){ var Num1 = 5 + Math.floor(Math.random() * 900); var Num2 = 5 + Math.floor(Math.random() * 220); dataset.push([Num1, Num2]); }; console.log(dataset); //和先前一樣，產生一組隨機的資料 var Xmax = d3.max(dataset, function(d){return d[0]}), Xmin = d3.min(dataset, function(d){return d[0]}), Ymax = d3.max(dataset, function(d){return d[1]}), Ymin = d3.min(dataset, function(d){return d[1]}) //這個函示可以取得資料的最大值、最小值 var xScale = d3.scale.linear() //產生一個屬於X軸的線性尺度 .domain([Xmin, Xmax]) //傳入的值是原始資料的最小及最大值 .range([padding , w - padding]) //輸出的範圍是左邊的padd距離，到右邊的padding var yScale = d3.scale.linear() .domain([Ymin, Ymax]) .range([ h - padding ,padding]) //類似X軸的尺度 var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //接下來開始產生SVG svg.selectAll('circle').data(dataset).enter() //和先前一樣，選取'circle'並把資料加入 .append('circle') // 增加圓到SVG內 .attr({ //加入屬性到圓 'cx': function(d){return xScale(d[0])}, //利用尺度算出X的位置 'cy': function(d){return yScale(d[1])}, //同理算出Y 'r': function(d){return Math.sqrt(h - d[1])}, //圓的大小是高 - Y值的平方 'fill': function(d){return d3.hsl(d[0] % 360, .6, .6 );} //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d[0]+ ',' + d[1]}) //將值寫到SVG上 .attr({ 'x': function(d){return xScale(d[0])}, //和上面相同，算出X、Y的位置 'y': function(d){return yScale(d[1])}, 'fill': 'red', //文字填滿為紅色 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ });","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3js 將資料投影到SVG上","slug":"Ironman-30-days-09","date":"2014-10-07T16:00:00.000Z","updated":"2016-10-13T03:09:18.000Z","comments":true,"path":"d3js/2014/10/08/Ironman-30-days-09/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/08/Ironman-30-days-09/","excerpt":"先前介紹SVG那麼多的篇幅，結果上一篇居然用Div了事，這樣怎麼說得過去…，所以這篇要用SVG把”資料”畫出來。","text":"先前介紹SVG那麼多的篇幅，結果上一篇居然用Div了事，這樣怎麼說得過去…，所以這篇要用SVG把”資料”畫出來。 為何又是SVG在上一篇的介紹，相信對D3js有很基本的了解，就是資料進來，然後加入html物件，接下來調整外觀…，大致上是如此。在”資料驅動物件”這基礎上，目標物件事要容易被控制且有彈性，SVG俱有這樣的特色，SVG可以在範圍內隨意定義位置、色彩甚至是外形，且屬性單純(吧…)。 Demo這篇就來份不怎麼安分的資料，他是陣列內還包陣列的資料，大概像下面這樣： var dataset = [[5, 20], [480, 90], [250, 50]] 不只是這樣，我們還要隨機的，增加的豐富性，當然這邊就直接看範例以及程式碼吧。 12345678910111213141516171819202122232425262728293031323334var w = 600;var h = 250;var dataset = [];for (var i=0; i &lt; 20; i++)&#123; var Num1 = 5 + Math.floor(Math.random() * 480); //產生第一個數值 var Num2 = 5 + Math.floor(Math.random() * 230); //產生第二個數值 dataset.push([Num1, Num2]); //兩個合併成一個陣列&#125;;console.log(dataset); //檢查看看有沒有怪怪的var svg = d3.select('.demo').append('svg').attr(&#123;'width': w,'height': h&#125;)//產生一個SVGsvg.selectAll('circle').data(dataset).enter() //記得喔 data(dataset).enter() 把資料放入.append('circle').attr(&#123; 'cx': function(d)&#123;return d[0] + 10&#125;, //定義圓心的x，在第一個值 'cy': function(d)&#123;return d[1] + 10&#125;, //定義圓心的y，在第二個值 'r': function(d)&#123;return Math.sqrt(h - d[1])&#125;, //圓心的半徑，第二個值開平方 'fill': function(d)&#123;return d3.hsl(d[0] % 360, .6, .6 );&#125; //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度)&#125;);svg.selectAll('text').data(dataset).enter() //補上資料數值.append('text').text(function(d)&#123; return d[0]+ ',' + d[1]&#125;) //將值寫到SVG上.attr(&#123; 'x': function(d)&#123;return d[0] + 10&#125;, //和上面相同，算出X、Y的位置 'y': function(d)&#123;return d[1] + 10&#125;, 'fill': 'red', //文字填滿為紅色 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～&#125;); var w = 600; var h = 250; var dataset = []; for (var i=0; i < 20; i++){ var Num1 = 5 + Math.floor(Math.random() * 480); //產生第一個數值 var Num2 = 5 + Math.floor(Math.random() * 230); //產生第二個數值 dataset.push([Num1, Num2]); //兩個合併成一個陣列 }; console.log(dataset); //檢查看看有沒有怪怪的 var svg = d3.select('.demo').append('svg').attr({'width': w,'height': h}) //產生一個SVG svg.selectAll('circle').data(dataset).enter() //記得喔 data(dataset).enter() 把資料放入 .append('circle') .attr({ 'cx': function(d){return d[0] + 10}, //定義圓心的x，在第一個值 'cy': function(d){return d[1] + 10}, //定義圓心的y，在第二個值 'r': function(d){return Math.sqrt(h - d[1])}, //圓心的半徑，第二個值開平方 'fill': function(d){return d3.hsl(d[0] % 360, .6, .6 );} //介紹一個顏色的function hsl，可以將顏色算出後轉成色碼 //格式 (360色相, 1彩度, 1明度) }); svg.selectAll('text').data(dataset).enter() //補上資料數值 .append('text') .text(function(d){ return d[0]+ ',' + d[1]}) //將值寫到SVG上 .attr({ 'x': function(d){return d[0] + 10}, //和上面相同，算出X、Y的位置 'y': function(d){return d[1] + 10}, 'fill': 'red', //文字填滿為紅色 'font-size': '10px' //Fill、font-size也可以用CSS寫喔～ }); 這一篇難度也沒有很高，主要只是要介紹怎麼使用D3.js畫在SVG上，但是下一篇，將會有很重要的觀念需要了解。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"初入D3.js","slug":"Ironman-30-days-08","date":"2014-10-06T16:00:00.000Z","updated":"2016-10-13T02:47:29.000Z","comments":true,"path":"d3js/2014/10/07/Ironman-30-days-08/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/07/Ironman-30-days-08/","excerpt":"先前的練習差不多了，接下來要開始實作，不過要先聲明本文是學習過程的記錄，所以很多範例是參考網頁互動式資料視覺化: 使用D3，當然到了後面也會有很多不同的運用，並不會重頭到尾都是這本書的內容，就像上一篇一樣，還可以玩玩柯P的API。","text":"先前的練習差不多了，接下來要開始實作，不過要先聲明本文是學習過程的記錄，所以很多範例是參考網頁互動式資料視覺化: 使用D3，當然到了後面也會有很多不同的運用，並不會重頭到尾都是這本書的內容，就像上一篇一樣，還可以玩玩柯P的API。 D3 的強項就許多資料所介紹D3js是一套js library，D3是利用資料(Data)來”驅動”文件的物件(DOM)，所以就這點就和Jquery有很大的差別，Jquery容易上手，就在於它對DOM的操作相對容易；而D3js在操作DOM上有點類似Jquery，但它的重點在於使用資料來控制文件。 資料資料的格式相當多種，在學習D3js之前(到現在也是)，我對於資料的處理相當的不在行，就連基本陣列都有問題，更不用提到json，所以就…慢慢開始吧。 最基本的資料就是陣列，D3js只要有陣列就可以開始驅動文件，一般來說最基本的陣列像下面這樣： [30,26,27,31,13,10,20,20,24,25,25,21,17,21,6,7,13,23,27,31] 這個陣列是用隨機的方式去產生的，可以用以下的Js程式碼來產生： 12345678var dataset = []; //定義空的陣列for (var i=0; i &lt; 20; i++)&#123; //如果數量少於20 var newNum = 5 + Math.floor(Math.random() * 30); //產生一個 0...30的整數，並且加上5 dataset.push(newNum); //將整數送到剛剛的空陣列&#125; 如果對於上面這段程式碼覺得沒有問題，那麼就可以繼續的往下學習了。 使用 D3js首先，當然要先把d3.js加到HTML上。 1&lt;script src=\"/js/d3.min.js\"&gt;&lt;/script&gt; 接下來要寫點Script ，範例如下： 12345678910111213141516var dataset = []; //建立空的資料陣列for (var i=0; i &lt; 20; i++)&#123; var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(newNum);&#125;//隨機產生一組長度20，值為5~35的數字。d3.select('.demo').selectAll('div') //選取 class內的div .data(dataset) // 將資料加入至 div .enter() // return data .append('div') // 這邊加入的div已經有包含data .attr('class','bar') //套用class .style('height', function(d)&#123; //將data的值取出作為高 return (d*3) + 'px' &#125;) 這一段程式碼中要特別注意的是.data(dataset).enter()這一段，這段是將剛剛所產生的陣列用迴圈的方式執行，所以在這之後的append(&#39;div&#39;)就會依據資料的量去執行，如果量有20筆，那麼就會執行append(&#39;div&#39;)20次。 DEMO 隨機的資料。 最後再補點樣式。 1234567.bar &#123; display: inline-block; width: 20px; height: 75px; margin-right: 3px; background-color: RoyalBlue;&#125; D3js我就是這樣開始的，當然為了學這個，也是翻遍了許多資料，希望剩下文章能夠帶給大家學習上的參考。 var dataset = []; for (var i=0; i < 20; i++){ var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(newNum); } d3.select('.pre').text(dataset); d3.select('.demo').selectAll('div') .data(dataset) // D3 data computing .enter() .append('div') .attr('class','bar') .style('height', function(d){ return (d*3) + 'px' }); console.log(d3.select('.demo').selectAll('div')) .bar { display: inline-block; width: 20px; height: 75px; margin-right: 3px; background-color: RoyalBlue; }","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"D3js 前置作業，製作簡易Server","slug":"Ironman-30-days-07","date":"2014-10-05T16:00:00.000Z","updated":"2016-10-13T02:19:39.000Z","comments":true,"path":"d3js/2014/10/06/Ironman-30-days-07/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/06/Ironman-30-days-07/","excerpt":"部分情況下，直接點兩下index.html就可以打開網頁，而且js都可以正常運行，但某些瀏覽器會限制js載入本地端的檔案，主要是安全性考量，這也可能影響到d3js嘗試載入任何外部檔案(CSV、Json等等)，為了避免往後的範例有這樣的問題，所以必須要有個簡易的伺服器。","text":"部分情況下，直接點兩下index.html就可以打開網頁，而且js都可以正常運行，但某些瀏覽器會限制js載入本地端的檔案，主要是安全性考量，這也可能影響到d3js嘗試載入任何外部檔案(CSV、Json等等)，為了避免往後的範例有這樣的問題，所以必須要有個簡易的伺服器。 製作伺服器的方式相當多，像是windows也可以用IIS來建立，而我自己是直接購買Fire.app(http://fireapp.kkbox.com/)，開啟專案後直接就會產生簡易的Server，除了Fire.app外，本篇提供兩個簡單的方式來製作簡易的Webserver。 Fire.app Python Simple ServerMac 和 Linux 內建就有Python，打開Terminal(終端機)後，先輸入Python –version，如果版本是2.x，只要在對應的資料夾路徑下輸入以下指令，就可以使用簡易的webserver(我沒什麼用Python，所以我的版本是2.x)。 python -m SimpleHTTPServer 8888 &amp; 如果是更高的3.x版本，我手上的資料是輸入以下指令： python -m http.server 8888 &amp; 開啟python webserver後，在瀏覽器輸入localhost:8888就可以打開這網頁。 Node Gulp WebserverNode.js 有許多不錯的工具相當好用，而Gulp是其中一個，這是一個任務管理工具，可以編譯Sass、CoffeeScript等等(不久前我在Blog有介紹過，可以參考http://wcc723.github.io/gulp/2014/09/22/gulp-install/)。 這次不會用相當多的功能，主題是要介紹D3.js，所以我已經有準備好Gulp Webserver所需要的簡易script，大家只要安裝好Node.js後，按照以下步驟即可(比Python略微複雜，但Windows也可使用，熟練的話也可以多運用Gulp)。 Gulp 環境安裝首先，先到官網下載，並安裝Node.js。 接下來在Mac Terminal或是Windows 命令提示字元下輸入以下指令： node -v npm -v 預期會出現以下結果 接下來安裝Gulp，輸入以下指令(我Mac懶得重裝&gt; &lt;)： npm install -g gulp 到這邊環境就算安裝完成了。 執行Gulp到https://github.com/Wcc723/D3js_WebServer_Demo下載我精心準備的簡易Webserver，裡面包含一個簡單的D3 範例以及Gulp Script。 下載後解壓縮，Terminal或是命令提示字元進入該資料夾，並輸入npm install，就會把Gulp所需要的模組安裝到這個資料夾。 輸入Gulp，就會開啟Webserver同時將瀏覽器開啟，這個Demo我是抓柯P Api所提供的相簿，接下來大家也可以在自己的電腦上練習D3.js了。 小Demo JS Bin","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG Stroke , Marker 以及 CSS","slug":"Ironman-30-days-06","date":"2014-10-04T16:00:00.000Z","updated":"2016-10-13T03:09:38.000Z","comments":true,"path":"d3js/2014/10/05/Ironman-30-days-06/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/05/Ironman-30-days-06/","excerpt":"今天是假日，就來個簡單的收尾，來介紹這幾天的混合用法，當然，我不會想在假日看到&lt;Path&gt;…。 會先介紹之前Blog所提到的stroke animation，在介紹marker，marker是製作一個圖形，套用在line、path、polygon等等的線段上，可以定義在起始點、終點、以及轉折點上。","text":"今天是假日，就來個簡單的收尾，來介紹這幾天的混合用法，當然，我不會想在假日看到&lt;Path&gt;…。 會先介紹之前Blog所提到的stroke animation，在介紹marker，marker是製作一個圖形，套用在line、path、polygon等等的線段上，可以定義在起始點、終點、以及轉折點上。 Stroke Dash參考來源http://cssdeck.com/labs/ironman-svg-line-animation 作者是把這效果用在描繪鋼鐵人上，做得很酷，而本篇是介紹它的原理。 stroke-dasharray + stroke-dashoffsetstroke-dasharray是把stroke做成了是虛線的效果，線段會被拆成線段、空白、線段、空白，效果就像下面這樣。 123line &#123; stroke-dasharray: 60;&#125; 如上顯示，線段被拆成60px的line在空60px的space。 stroke-dashoffset而stroke-dashoffset屬性是將上面的虛線推移，兩者會有以下幾點特性： 推移後，dasharray還是會保持循環。 dashoffset的值不會大於dasharray。 如果dashoffset 等於 dasharray，線段起始點會是空白。 所以這部分就再加上40的stroke-dashoffset來看看結果。 123line.l2&#123; stroke-dashoffset: 40;&#125; 如果兩者數值相等，線段的起始點就會呈現空白，這邊先設較小的值(200)。 1234line.l3&#123; stroke-dasharray: 200; stroke-dashoffset: 200;&#125; 如果數值相當的大，就能夠將整個線段隱藏。 結合CSS aniamtionaniamtion 相關的瀏覽器前輟詞問題，可參考/css/2013/10/17/css-animation-keyframe/ 這邊就show重要的CSS code，利用上面的原理將線段隱藏，然後透過animation將線段拉回來，這樣就會有動態描繪的感覺。 1234567891011121314//sass.stroke stroke-dashoffset: 2000 stroke-dasharray: 2000//動畫效果 10秒 線性動畫 無限循環.ani animation: circle-draw 10s linear infinite//keyframes的值//將dashoffset拉回至0@keyframes circle-draw 80% stroke-dashoffset: 0 1234567891011121314151617181920&lt;svg class=\"stroke ani\" height=\"400\" width=\"100%\" &gt; &lt;g&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"10\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"20\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"30\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"40\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"50\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"60\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"70\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"80\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"90\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"100\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"110\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"120\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"130\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"140\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"150\"/&gt; &lt;circle cx=\"200\" cy=\"200\" r=\"160\"/&gt; &lt;/g&gt;&lt;/svg&gt; 以上的SVG code，當然這也可以用Illustrator來繪製，只要把svg code換掉就可以了。 注意，儘量不要在網頁上做無限循環的重復播放，很耗效能。 .stroke{ stroke-dashoffset: 2000; stroke-dasharray: 2000; } .ani { -webkit-animation: circle-draw 10s linear infinite; } @-webkit-keyframes circle-draw{ 80% { stroke-dashoffset: 0; } } 回到Marker根據上一篇的介紹，Marker做法和漸層相當的類似，除了需要定義id外，一樣需要寬與高，不過marker還多了refx 和 refy，這是用來給路徑套用時所參照的相對位置；所以下面的範例refx=&quot;5&quot; refy=&quot;5&quot;，也是要給circle使用的位置。 在定義完後，Polyline的style內加上marker-mid: url(#midCircle);就完成對marker的套用，當然這篇的另一個範例所使用的CSS(Class)也可以繼續套用在這範例上。 1234567891011121314151617&lt;svg width=\"100%\" height=\"200\"&gt; &lt;defs&gt; &lt;marker id=\"midCircle\" markerWidth=\"8\" markerHeight=\"8\" refx=\"5\" refy=\"5\"&gt; &lt;circle id=\"dot\" cx=\"5\" cy=\"5\" r=\"3\" fill=\"red\" /&gt; &lt;/marker&gt; &lt;marker id=\"endCircle\" markerWidth=\"8\" markerHeight=\"8\" refx=\"5\" refy=\"5\"&gt; &lt;circle id=\"dot\" cx=\"5\" cy=\"5\" r=\"3\" fill=\"white\" stroke=\"red\" /&gt; &lt;/marker&gt; &lt;/defs&gt; &lt;polyline class=\"stroke ani\" points=\"20,140 60,120 80,100 100,95 120,120 140,80 160,85 180,125 200,80 220,95 240,140 260,145 280,120 300,95 320,88 340,80 360,102\" style=\"fill:none; stroke:red; stroke-width:1; marker-mid: url(#midCircle); marker-end: url(#endCircle); \" /&gt;&lt;/svg&gt; 這樣就做出簡易的折線圖，SVG的觀念和一般的Html有些的不同，這次的鐵人賽主要介紹的不是SVG，只是略微帶過，有興趣的可以參考 http://tutorials.jenkov.com/svg/index.html 所寫的SVG教學。 台灣也有高手是介紹SVG的也可以多向他學習http://www.oxxostudio.tw/index.html?tag-web，不止基礎的教學，還包含許多豐富的技法，令人歎為觀止(跪)。 接下來開始，就會進入D3js的世界，有許多沒辦法做很好的地方，就試試看用硬派的方式去處理吧。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG Defs 以及 CSS","slug":"Ironman-30-days-05","date":"2014-10-03T16:00:00.000Z","updated":"2016-10-13T02:18:11.000Z","comments":true,"path":"d3js/2014/10/04/Ironman-30-days-05/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/04/Ironman-30-days-05/","excerpt":"SVG內還有一個相當有趣的標簽&lt;def&gt;，用途是先定義一些圖形、漸層、形狀等等，甚至可以把它們群組起來，等待使用，如果用Illustrator 來介紹的話，就像是圖樣工具。","text":"SVG內還有一個相當有趣的標簽&lt;def&gt;，用途是先定義一些圖形、漸層、形狀等等，甚至可以把它們群組起來，等待使用，如果用Illustrator 來介紹的話，就像是圖樣工具。 教程參考：http://tutorials.jenkov.com/svg/ .rect{ fill: url(#gradient); } @-webkit-keyframes rotate { from { -webkit-transform: rotate(0deg); } to { -webkit-transform: rotate(360deg); } } .pos{ -webkit-transform: translate(82px, 82px); } .circle1{ background-position: center center; background-repeat: no-repeat; fill: none; stroke-width: 1; -webkit-transition: all .5s; stroke: url(#gradient); -webkit-animation: rotate 1s infinite linear; } svg:hover .circle1{ stroke-width: 3; } 漸層我們先用&lt;def&gt;定義一個漸層的範圍，這難度比path簡單太多了…，在經過苦痛般的path鍛鍊，下面這段範例看完相信大家已經懂一半了。 簡易步驟： 定義linearGradient，包含id、x,y位置、spreadMethod(展開的模式，這邊只會做簡單的範例)。 設定每一段的色彩位置、顏色、透明度。 套用 範例如下正方形，先定義好linearGradient標簽，並給予需要的屬性，最後在rect矩形內加入fill=&quot;url(#gradient)&quot;就可以套用了。 12345678910111213&lt;svg width=\"100%\" height=\"180\"&gt; &lt;defs&gt; &lt;linearGradient id=\"gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\" spreadMethod=\"pad\"&gt; &lt;stop offset=\"0%\" stop-color=\"DodgerBlue\" stop-opacity=\"1\"/&gt; &lt;stop offset=\"50%\" stop-color=\"DeepSkyBlue\" stop-opacity=\"1\"/&gt; &lt;stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"0\"/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;rect x=\"5\" y=\"5\" width=\"150\" height=\"150\" fill=\"url(#gradient)\" /&gt;&lt;/svg&gt; 結合CSS先前都沒有介紹到SVG與CSS的關係，其實大部份的SVG屬性都可以用CSS去控制，所以這部分在用CSS去強化漸層的運用。 This demo only for webkit 以下有完整的程式碼，但特別注意，CSS的transform使用在SVG上，transform-origin的位置會受x、y改變，所以在用一個&lt;g&gt;群組包起來。另外我這有寫Hover的效果，也可以試試看(只是改Stroke的寬度而已)。 123456789101112131415&lt;svg width=\"100%\" height=\"180\"&gt; &lt;defs&gt; &lt;linearGradient id=\"gradient\" x1=\"0%\" y1=\"0%\" x2=\"0%\" y2=\"100%\" spreadMethod=\"pad\"&gt; &lt;stop offset=\"0%\" stop-color=\"DodgerBlue\" stop-opacity=\"1\"/&gt; &lt;stop offset=\"50%\" stop-color=\"DeepSkyBlue\" stop-opacity=\"1\"/&gt; &lt;stop offset=\"100%\" stop-color=\"white\" stop-opacity=\"0\"/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; &lt;g class=\"pos\"&gt; &lt;circle class=\"circle1\" cx=\"0\" cy=\"0\" r=\"79\" /&gt; &lt;/g&gt;&lt;/svg&gt; 1234567891011121314151617181920@-webkit-keyframes rotate &#123; from &#123; -webkit-transform: rotate(0deg); &#125; to &#123; -webkit-transform: rotate(360deg); &#125;&#125;.pos&#123; -webkit-transform: translate(82px, 82px);&#125;.circle1&#123; background-position: center center; background-repeat: no-repeat; fill: none; stroke-width: 3; -webkit-transition: all .5s; stroke: url(#gradient); -webkit-animation: rotate 1s infinite linear;&#125;","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG 超硬派了解 path Arcs","slug":"Ironman-30-days-04","date":"2014-10-02T16:00:00.000Z","updated":"2016-10-13T02:23:04.000Z","comments":true,"path":"d3js/2014/10/03/Ironman-30-days-04/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/03/Ironman-30-days-04/","excerpt":"這次來到Path的最後一個屬性A，A是所謂的弧形，和先前不同的是，弧形一個屬性可以比上一章全部的難度…。這次看看能不能用硬派的方式來學習Arcs弧形…。 本篇建議使用超過720px裝置觀看","text":"這次來到Path的最後一個屬性A，A是所謂的弧形，和先前不同的是，弧形一個屬性可以比上一章全部的難度…。這次看看能不能用硬派的方式來學習Arcs弧形…。 本篇建議使用超過720px裝置觀看 教程參考：http://tutorials.jenkov.com/svg/ Arcs svg text{ font-size: 10px; } 弧形就本質上來說，是屬於圓形或是橢圓的一部份，因此Mozilla MDN也介紹他擁有以下的屬性，我認為直接觀看這些屬性還是很難理解，所以決定都用硬派的方式標上坐標！。 a使用方法： A rx ry x-axis-rotation large-arc-flag sweep-flag x y Example 1參考http://www.oxxostudio.tw/articles/201406/svg-05-path-2.html。 110, 315 起點 162, 225 終點 w 200(rx) h 200(ry) A rx ry x-axis-rotation large-arc-flag sweep-flag x y //剛剛的值 A 1 2 0 0 1 310 215 rx、ry如果小於起點到終點的長度，那麼會是依比率的，所以是1:2的橢圓形；sweep-flag為1，是順時鐘方向(逆時鐘會往下跑)；310 215是終點的位置。 123456789101112131415&lt;svg width=\"100%\" height=\"250\"&gt; &lt;path d=\"M10 215 L 110 215 A 1 2 0 0 1 310 215 L 540 215\" stroke=\"#333\" fill=\"Crimson\" stroke-width=\"3\" fill-opacity=\"0.5\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"110\" cy=\"215\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"110\" y=\"225\" fill=\"red\"&gt;110, 315 起點&lt;/text&gt; &lt;circle cx=\"310\" cy=\"215\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"310\" y=\"225\" fill=\"red\"&gt;162, 225 終點&lt;/text&gt; &lt;line x1=\"110\" y1=\"215\" x2=\"310\" y2=\"215\" style=\"stroke: green;\"/&gt; &lt;text x=\"150\" y=\"210\" fill=\"green\"&gt;w 200(rx)&lt;/text&gt; &lt;line x1=\"210\" y1=\"215\" x2=\"210\" y2=\"15\" style=\"stroke: green;\"/&gt; &lt;text x=\"210\" y=\"110\" fill=\"green\"&gt;h 200(ry)&lt;/text&gt;&lt;/svg&gt; Example 2接下來我們在旋轉的角度上補了30，弧形的角度就會旋轉(綠色的線，僅有旋轉，並沒有修正成圓心的位置)。 110, 315 起點 162, 225 終點 12345678910111213&lt;svg width=\"100%\" height=\"250\"&gt; &lt;path d=\"M10 215 L 110 215 A 1 2 30 0 1 310 215 L 540 215\" stroke=\"#333\" fill=\"Crimson\" stroke-width=\"3\" fill-opacity=\"0.5\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"110\" cy=\"215\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"110\" y=\"225\" fill=\"red\"&gt;110, 315 起點&lt;/text&gt; &lt;circle cx=\"310\" cy=\"215\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"310\" y=\"225\" fill=\"red\"&gt;162, 225 終點&lt;/text&gt; &lt;line x1=\"110\" y1=\"215\" x2=\"310\" y2=\"215\" style=\"stroke: green;\" transform=\"rotate(30, 210, 215)\"/&gt; &lt;line x1=\"210\" y1=\"215\" x2=\"210\" y2=\"15\" style=\"stroke: green;\" transform=\"rotate(30, 210, 215)\"/&gt;&lt;/svg&gt; Example sweep-flag &amp; large-arc-flag範例取自於https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths。 M 80 80 125 125 終點 http://www.oxxostudio.tw/articles/201406/svg-05-path-2.html 有很棒的解釋，這部分我要用個人的方式解釋囉～ 這張圖，據說可以解釋 “sweep-flag &amp; large-arc-flag”，那麼就來試著說說看吧。 //這個範例僅有改變 large-arc-flag sweep-flag 兩個值，其餘皆相同 A rx ry x-axis-rotation large-arc-flag sweep-flag x y 思考一下這以下可能代表什麼 sweep-flag:1 = 順時鐘 sweep-flag:0 = 逆時鐘 large-arc-flag:1 = 取較長的弧線 large-arc-flag:0 = 取較短的弧線 rx ry必須大於半徑才能產生長弧線及短弧線 左上：逆時鐘，取較短的弧線 右上：逆時鐘，取較長弧線 左下：順時鐘，取較短的弧線 右下：順時鐘，取較長弧線 試試看所以在稍早的範例，只要增加A的rx、ry也可以這樣做喔～。將rx、ry調整後，large-arc-flag也可以使用，值為1就會採用較長的弧線(實線的部分)，值為0就會採用短的弧線(虛線的部分)。 110, 315 起點 162, 225 終點 A 120 120 123456789101112131415161718&lt;svg width=\"100%\" height=\"250\"&gt; &lt;path d=\"M10 215 L 110 215 A 120 120 0 1 1 310 215 L 540 215\" stroke=\"#333\" fill=\"none\" stroke-width=\"3\" fill-opacity=\"0.5\"/&gt; &lt;path d=\"M10 215 L 110 215 A 120 120 0 0 1 310 215 L 540 215\" stroke=\"#333\" stroke-dasharray=\"5, 5\" fill=\"none\" stroke-width=\"3\" fill-opacity=\"0.5\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"110\" cy=\"215\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"110\" y=\"225\" fill=\"red\"&gt;110, 315 起點&lt;/text&gt; &lt;circle cx=\"310\" cy=\"215\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"310\" y=\"225\" fill=\"red\"&gt;162, 225 終點&lt;/text&gt; &lt;line x1=\"210\" y1=\"215\" x2=\"210\" y2=\"95\" style=\"stroke: green;\" transform=\"translate(0 -67)\"/&gt; &lt;line x1=\"210\" y1=\"215\" x2=\"330\" y2=\"215\" style=\"stroke: green;\" transform=\"translate(0 -67)\"/&gt; &lt;text x=\"214\" y=\"144\" fill=\"green\"&gt;A 120 120&lt;/text&gt;&lt;/svg&gt; 真的超級難懂，不過自己試著做一次，就會好懂很多。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG 超硬派了解 line, polygon, polyline, path (手工繪製)","slug":"Ironman-30-days-03","date":"2014-10-01T16:00:00.000Z","updated":"2016-10-13T02:20:18.000Z","comments":true,"path":"d3js/2014/10/02/Ironman-30-days-03/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/02/Ironman-30-days-03/","excerpt":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 今天要介紹的是線段系列，可以想像成Illustrator的鋼筆工具(也不知道為什麼要翻譯鋼筆工具，據說是設計師不會懂貝茲曲線…)，分為line、polygon、polyline、path，而其中我認為最難的是path…，希望今天能夠突破他。我將用非天才型的硬派學習法！ 本篇建議使用超過720px裝置觀看","text":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 今天要介紹的是線段系列，可以想像成Illustrator的鋼筆工具(也不知道為什麼要翻譯鋼筆工具，據說是設計師不會懂貝茲曲線…)，分為line、polygon、polyline、path，而其中我認為最難的是path…，希望今天能夠突破他。我將用非天才型的硬派學習法！ 本篇建議使用超過720px裝置觀看 教程參考：http://tutorials.jenkov.com/svg/ Line這是最簡單的，只要標注上起點以及終點就完成了，起點是x1、y1，終點則是x2、y2。 1234&lt;svg width=\"100%\" height=\"100\"&gt; &lt;line x1=\"0\" y1=\"0\" x2=\"300\" y2=\"0\" style=\"stroke: Tomato;stroke-width: 3px\"/&gt; &lt;line x1=\"0\" y1=\"10\" x2=\"300\" y2=\"60\" x3=\"0\" y3=\"80\" style=\"stroke: Tomato; stroke-width: 3px\"/&gt;&lt;/svg&gt; 我也試試看能不能三點，寫了x3、y3都是沒用的(白目)。 PolylinePolyline我查到的中文翻譯是折線，它主要是繪製多點線段。來源… 點的位置’40,0’，40代表x，0代表y，兩個點中間會接一個空格。 12345&lt;svg width=\"100%\" height=\"100\"&gt; &lt;polyline points=\"40,0 60,60 0,60\" style=\" stroke:red; stroke-width:2\"/&gt; &lt;polyline points=\"140,0 160,60 100,60\" style=\"fill:none; stroke:red; stroke-width:2\"/&gt; &lt;polyline points=\"240,0 260,60 200,60 240,0\" style=\"fill:none; stroke:red; stroke-width:2\"/&gt;&lt;/svg&gt; Polyline開始類似Illustrator的鋼筆工具(但還不能繪製弧線)，在線段之間還能填入色彩，但特別要注意的是他並不是自動封閉線段。 PolygonPolygon中文翻譯為多邊形，用來繪製不少於3個邊的圖形，使用方式和Polyline完全相同。 12345&lt;svg width=\"100%\" height=\"100\"&gt; &lt;polygon points=\"40,0 60,60 0,60\" style=\" stroke:red; stroke-width:2\"/&gt; &lt;polygon points=\"140,0 160,60 100,60\" style=\"fill:none; stroke:red; stroke-width:2\"/&gt; &lt;polygon points=\"240,0 260,60 200,60 240,0\" style=\"fill:none; stroke:red; stroke-width:2\"/&gt;&lt;/svg&gt; 刻意使用和polyline相同的程式碼，兩者只有標簽不同，從這樣比較能夠比對出兩個不同的地方，重點就是Polygon會自動連接最後點到第一個點。 地獄般的PathSVG &lt;path&gt;是相當有難度的一個章節，每次打開到這個章節，都會想要關掉網頁。它的難度就我目前看來，就是用鍵盤畫貝茲曲線吧…。 參考資料這一張有一定的難度，所以在範例上我參考以下網站。 http://tutorials.jenkov.com/svg/path-element.html http://www.w3schools.com/svg/svg_path.asp https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths 在w3c school的教程裡有提到path常用的屬性，這在path是相當重要的所以先列出來。 其實我一直在逃避學習Path，因為他真的很複雜，所以我採用最熱血的學習方式！要用手工的方式把坐標，標在SVG上！ M = moveto L = lineto H = horizontal lineto V = vertical lineto C = curveto S = smooth curveto Q = quadratic Bézier curve T = smooth quadratic Bézier curveto A = elliptical Arc Z = closepath 接下來就用以上的資料，嘗試畫一個圖形。 svg text{ fill: red; font-size: 10px; } Example M、LM、L使用方法： M x y L x y 150, 3 300, 150 3, 150 12345678910&lt;svg width=\"100%\" height=\"200\"&gt; &lt;path d=\"M150 3 L300 150 L3 150 Z\" style=\" stroke: #333; stroke-width:3; fill: MediumOrchid\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"150\" cy=\"3\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"150\" y=\"20\" fill=\"red\"&gt;150, 3&lt;/text&gt; &lt;circle cx=\"300\" cy=\"150\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"300\" y=\"140\" fill=\"red\"&gt;300, 150&lt;/text&gt; &lt;circle cx=\"3\" cy=\"150\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"3\" y=\"140\" fill=\"red\"&gt;3, 150&lt;/text&gt;&lt;/svg&gt; 這個三角形的範例，M150 3 這樣是一個群組，所以第一個點是移動到M150 3開始，接下來劃線到L300 150這個點，再來是劃線到L3 150，最後直接用Z來封閉曲線。 因此，path的第一點通常是M: move to Example H、VH、V使用方法： M x V y 10, 10 10, 90 90, 90 90, 10 123456789101112&lt;svg width=\"100%\" height=\"100\"&gt; &lt;path d=\"M10 10 H 90 V 90 H 10 L 10 10\" fill=\"black\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"10\" cy=\"10\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"10\" y=\"20\" fill=\"red\"&gt;10, 10&lt;/text&gt; &lt;circle cx=\"10\" cy=\"90\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"10\" y=\"80\" fill=\"red\"&gt;10, 90&lt;/text&gt; &lt;circle cx=\"90\" cy=\"90\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"90\" y=\"80\" fill=\"red\"&gt;90, 90&lt;/text&gt; &lt;circle cx=\"90\" cy=\"10\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"90\" y=\"20\" fill=\"red\"&gt;90, 10&lt;/text&gt;&lt;/svg&gt; 這一個範例，是利用H、V來取代垂直以及水平移動。這一段的內容是移動到10 10，再來垂直到x90的位置，再來是水平到y90，然後再到垂直向上到x10，最後用L拉線回到10 10的位置。 最後的L也可以直接用Z來close path Example C 貝茲曲線C使用方法： C x1 y1, x2 y2, x y 這是Mozilla所提供的示意圖，看了這個圖，認為還是自己畫一個可能比較了解，所以動手來試試看吧～。 圖片來源：https://developer.mozilla.org/@api/deki/files/159/=Cubic_Bezier_Curves.png M10 10 C140 140 160 140 300 20 用這樣的圖是不是更了解呢，首先定義第一個起始點位置M10 10，接下來加入C貝茲曲線，這邊開始就幻想著自己正在畫Illustrator，首先加入C140 140，這是第一根手把的位置，之後補一個,，在依序把後面的點完成。這之間可以對照上面的範例。 1234567891011121314&lt;svg width=\"100%\" height=\"200px\"&gt; &lt;path d=\"M10 10 C140 140,160 140,300 10\" stroke=\"black\" fill=\"none\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"10\" cy=\"10\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"10\" y=\"20\" fill=\"red\"&gt;M10 10&lt;/text&gt; &lt;circle cx=\"140\" cy=\"140\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"120\" y=\"150\" fill=\"red\"&gt;C140 140&lt;/text&gt; &lt;circle cx=\"160\" cy=\"140\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"160\" y=\"130\" fill=\"red\"&gt;160 140&lt;/text&gt; &lt;circle cx=\"300\" cy=\"10\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"300\" y=\"20\" fill=\"red\"&gt;300 20&lt;/text&gt; &lt;line x1=\"10\" y1=\"10\" x2=\"140\" y2=\"140\" style=\"stroke: Tomato;\"/&gt; &lt;line x1=\"160\" y1=\"140\" x2=\"300\" y2=\"10\" style=\"stroke: Tomato;\"/&gt;&lt;/svg&gt; Example Ss使用方法： S x2 y2, x y 我用超硬派學習法，徹底了解了它的特徵…。 M10 80 C140 160 160 120 300 80 S520 40 600 100 透過超硬派學習法，一個一個刻出每個點的位置，感受到腦細胞的大量死亡，上圖的紅點是C所在的位置，C總共會有三個坐標，包含兩個手把以及最後一個點，而S是緊接在最後一個點的後方，延伸出一個綠色的手把(這一個不需要給坐標)，再補上一個藍色手把以及做後一個藍色點。 123456789101112131415161718192021&lt;svg width=\"100%\" height=\"200px\"&gt; &lt;path d=\"M10 80 C140 140,160 140 , 300 80 S 520 20,600 80\" stroke=\"black\" fill=\"none\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"10\" cy=\"80\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"10\" y=\"90\" fill=\"red\"&gt;M10 80&lt;/text&gt; &lt;circle cx=\"140\" cy=\"140\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"140\" y=\"160\" fill=\"red\"&gt;C140 160&lt;/text&gt; &lt;circle cx=\"160\" cy=\"140\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"140\" y=\"120\" fill=\"red\"&gt;160 120&lt;/text&gt; &lt;circle cx=\"300\" cy=\"80\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"300\" y=\"100\" fill=\"red\"&gt;300 80&lt;/text&gt; &lt;circle cx=\"520\" cy=\"20\" r=\"3\" fill=\"blue\"/&gt; &lt;text x=\"520\" y=\"40\" fill=\"blue\"&gt;S520 40&lt;/text&gt; &lt;circle cx=\"600\" cy=\"80\" r=\"3\" fill=\"blue\"/&gt; &lt;text x=\"600\" y=\"100\" fill=\"blue\"&gt;600 100&lt;/text&gt; &lt;line x1=\"10\" y1=\"80\" x2=\"140\" y2=\"140\" style=\"stroke: Tomato;\"/&gt; &lt;line x1=\"160\" y1=\"140\" x2=\"300\" y2=\"80\" style=\"stroke: Tomato;\"/&gt; &lt;line x1=\"520\" y1=\"20\" x2=\"600\" y2=\"80\" style=\"stroke: blue;\"/&gt; &lt;circle cx=\"440\" cy=\"20\" r=\"3\" fill=\"green\"/&gt; &lt;line x1=\"300\" y1=\"80\" x2=\"440\" y2=\"20\" style=\"stroke: green;\"/&gt;&lt;/svg&gt; Example Q TQ、T使用方法： Q x1 y1, x y T x y 剛剛提到，C有三個點，兩個是手把，一個是終點，Q則是兩個點，一個共用手把，加上終點。T則是在Q後方，在複製一個相同的點，有點類似S的翻版。 M10 80 Q150 150 300 80 T590 80 123456789101112131415&lt;svg width=\"100%\" height=\"200px\"&gt; &lt;path d=\"M10 80 Q150 150, 300 80 T590 80\" stroke=\"black\" fill=\"none\"/&gt; &lt;!-- 硬派Circles! --&gt; &lt;circle cx=\"10\" cy=\"80\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"10\" y=\"90\" fill=\"red\"&gt;M10 80&lt;/text&gt; &lt;circle cx=\"150\" cy=\"150\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"150\" y=\"170\" fill=\"red\"&gt;Q150 150&lt;/text&gt; &lt;circle cx=\"300\" cy=\"80\" r=\"3\" fill=\"red\"/&gt; &lt;text x=\"300\" y=\"100\" fill=\"red\"&gt;300 80&lt;/text&gt; &lt;line x1=\"10\" y1=\"80\" x2=\"150\" y2=\"150\" style=\"stroke: Tomato;\"/&gt; &lt;line x1=\"300\" y1=\"80\" x2=\"150\" y2=\"150\" style=\"stroke: Tomato;\"/&gt; &lt;circle cx=\"590\" cy=\"80\" r=\"3\" fill=\"blue\"/&gt; &lt;text x=\"590\" y=\"100\" fill=\"red\"&gt;T590 80&lt;/text&gt; &lt;polyline points=\"300,80 445,10 590,80\" style=\"fill:none; stroke:green; fill: none\"/&gt;&lt;/svg&gt; 小結透過本篇的超硬派教學，對於幾種線段應該會更了解吧，至少我很了解了(泣…)。SVG的文章不會太多，D3js至少會有20篇以上，大家可以放心～。 另外在D3.js的教學裡面，超複雜的Path有很簡單的處理方式…，所以只要先大致了解就可以了。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"SVG 簡介","slug":"Ironman-30-days-02","date":"2014-09-30T16:00:00.000Z","updated":"2016-10-13T02:15:17.000Z","comments":true,"path":"d3js/2014/10/01/Ironman-30-days-02/","link":"","permalink":"https://wcc723.github.io/d3js/2014/10/01/Ironman-30-days-02/","excerpt":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 SVG(Scalable Vector Graphics)，中文直譯就是”可縮放向量圖形 “，它是以XML格式儲存，而在瀏覽器上是從IE9後才開始支援SVG。也因為是XML格式，所以D3對它特別容易進行操作。","text":"這部分會持續幾篇，主要是我先前Blog整理出來的，不會相當的深入，是為了解SVG的使用方式。另外這次鐵人賽也有高手是介紹SVG，如果有興趣也可以參考其他高手的文章。 SVG(Scalable Vector Graphics)，中文直譯就是”可縮放向量圖形 “，它是以XML格式儲存，而在瀏覽器上是從IE9後才開始支援SVG。也因為是XML格式，所以D3對它特別容易進行操作。 教程參考：http://tutorials.jenkov.com/svg/ SVG 範例(直接繪製)在svg標簽內就可以直接開始繪製向量圖型，而其中xmlns=&quot;http://www.w3.org/2000/svg”在微軟MSDN的解釋為定義SVG區段的命名空間，移除也沒什麼差別。 在定義SVG時，也建議同時給予寬與高，如果沒有，預設是100%。 12345&lt;!-- SVG tag --&gt;&lt;svg xmlns=\"http://www.w3.org/2000/svg\" width=\"100%\" height=\"120\"&gt; &lt;!-- 矩行 tag --&gt; &lt;rect x=\"2\" y=\"2\" width=\"100\" height=\"100\" style=\"stroke: #333; stroke-width: 3; fill: MediumTurquoise;\"/&gt;&lt;/svg&gt; SVG 基本型SVG是屬於向量的圖形，所以他有許多的繪圖概念與Illustrator相似，如矩行、圓形、多邊形等等…。 矩形在定義一個形狀時，通常會定義以下屬性，形狀、位置、尺寸以及樣式。矩行是相當基本的圖形，所以就依序定義以下屬性。 &quot;shapes tag&quot; &quot;x&quot; &quot;y&quot; &quot;width&quot; &quot;height&quot; &quot;style&quot; 1234&lt;svg width=\"100%\" height=\"105\"&gt; &lt;rect x=\"2\" y=\"2\" width=\"100\" height=\"100\" style=\"stroke: #333; stroke-width: 3; fill: FireBrick;\"/&gt; &lt;rect x=\"120\" y=\"2\" width=\"200\" height=\"100\" style=\"stroke: #333; stroke-width: 3; fill: LightSkyBlue;\"/&gt;&lt;/svg&gt; 而矩形除了一般的方形、長方形以外，也可以增加圓角的屬性rx、ry，但這就沒有像css的border-radius那麼的自由了，只能四個角設定相同的值；rx、ry也僅僅是設定其圓角垂直以及水平的半徑而已。 1234&lt;svg width=\"100%\" height=\"105\"&gt; &lt;rect x=\"2\" y=\"2\" width=\"100\" height=\"100\" rx=\"10\" style=\"stroke: #333; stroke-width: 3; fill: FireBrick;\"&gt;&lt;/rect&gt; &lt;rect x=\"120\" y=\"0\" width=\"200\" height=\"100\" rx=\"40\" ry=\"10\" style=\"stroke: #333; stroke-width: 3; fill: LightSkyBlue;\"&gt;&lt;/rect&gt;&lt;/svg&gt; 圓形圓形中有一點要特別注意，圓形的cx,cy所代表的是圓心(r)的位置，所以在定義圓形的位置，如果不想跑到圖框外，務必cx、cy要大於r的值。 123&lt;svg width=\"100%\" height=\"105\"&gt; &lt;circle cx=\"100\" cy=\"51\" r=\"50\" style=\"stroke: #333; stroke-width: 3; fill: SeaShell;\"/&gt;&lt;/svg&gt; 橢圓形橢圓形概念和圓形也相當類似，只是將半徑r的值改成垂直及水平半徑rx、ry。 123&lt;svg width=\"100%\" height=\"100\"&gt; &lt;ellipse cx=\"100\" cy=\"51\" rx=\"80\" ry=\"30\" style=\"stroke: #333; stroke-width: 3; fill: MediumVioletRed;\"/&gt;&lt;/svg&gt; CSS樣式控制SVG就像HTML的物件一樣很好控制，但不同的是他有屬於它自己的屬性，就好比我們要將顏色填滿在一般html物件會使用background-color，而在SVG內會使用fill，這部分也會運用到D3。 1234567891011&lt;style&gt;.rect&#123; fill: HotPink; stroke: LightSlateGray; stroke-width: 3px; transition: fill .3s;&#125;.rect:hover&#123; fill: SlateGray;&#125;&lt;/style&gt; 先產生一個SVG物件，但不要設定Style，只增加class。 1234&lt;svg width=\"100%\" height=\"105\"&gt; &lt;rect x=\"2\" y=\"2\" width=\"100\" height=\"100\"/&gt; &lt;rect class=\"rect\" x=\"120\" y=\"2\" width=\"200\" height=\"100\"/&gt;&lt;/svg&gt; 接下來寫一段CSS，針對剛剛增加的class，控制它的填滿以及筆畫寬度(跟Illustrator很像吧)，還可以補上:hover。 123456789.rect&#123; fill: HotPink; stroke: LightSlateGray; stroke-width: 3px; transition: fill .3s;&#125;.rect:hover&#123; fill: SlateGray;&#125; 結果我們會看到以下這樣的結果，左邊沒有設定會是黑色(沒設定是黑色、不會是透明！)，右邊就是剛剛所設定的樣式。 小結如果對於SVG有興趣的設計師，也可以試試看把Illustrator的檔案轉出成SVG，在一個個拆解，就會發現SVG跟Illustrator根本就是太像了。用canvas的概念來思考，當然也可以將Photoshop轉成png，只是最終發現他還是一張圖…(認真)。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"2014 鐵人賽慢慢開始跑","slug":"Ironman-30-days-01","date":"2014-09-29T16:00:00.000Z","updated":"2016-10-13T00:42:07.000Z","comments":true,"path":"d3js/2014/09/30/Ironman-30-days-01/","link":"","permalink":"https://wcc723.github.io/d3js/2014/09/30/Ironman-30-days-01/","excerpt":"去年參加了鐵人賽，主題是CSS，這過程中讓我獲得很多，重點並不是在於得獎，而是在每天追求的過程中，必須在有限的時間內不斷地追求知識，也不斷的挖掘有什麼是可以分享的。","text":"去年參加了鐵人賽，主題是CSS，這過程中讓我獲得很多，重點並不是在於得獎，而是在每天追求的過程中，必須在有限的時間內不斷地追求知識，也不斷的挖掘有什麼是可以分享的。 先簡單自我介紹一下背景 我是一位設計師，目前是專職前端的工程師 去年鐵人賽摸到了優選 技術的Blog : http://wcc723.github.io 在今年的工作中，我感受到SVG (Scalable Vector Graphics)的未來性原因如下： XML標準 (相對於Canvas更容易使用CSS、JS控制) 向量圖形 (目前的裝置解析度不一，而向量圖沒有解析度問題) 格式靈活，可以用繪圖軟體或是純文字繪製 SVG library剛剛有提到，SVG有許多執行的方式，我是視覺設計出身，就會想直接用繪圖軟體畫，然後再轉存成svg格式檔案，但是這樣並沒有辦法動，所以就需要透過CSS 或是 JS。 相關的JS lib 以及 plugin 相當的多，下面介紹兩款主流的lib。 Snap.js http://snapsvg.io 透過Snap，可以更容易繪製動態的SVG圖形，假設設計師已經提供了向量原始檔，在結合Snap，就能夠像以前的Flash做出豐富的HTML5互動網站(它說像用jQuery控制DOM一樣容易…)。 對Snap繪製互動圖形有興趣，也可以參考它的基本教學 http://snapsvg.io/start/ D3.js http://d3js.org 當然，這次我報名的是D3.js，所以當然這就是這次的主角。D3在中文上的翻譯是”資料驅動文件”，圖形化的過程中，資料是非常重要的，選擇D3一部份原因也是工作需求。 參考資料D3的學習資料相當多，在這三十天中，我會先簡單介紹SVG，接下來再透過Oreilly所出版的網頁互動式資料視覺化的教學來習作，另外還會搜尋許多的範例及資料來學習。 主要參考書籍 網頁互動式資料視覺化：使用D3http://www.books.com.tw/products/0010621239 參考範例 https://github.com/mbostock/d3/wiki/Gallery 所以這三十篇不會是教學，而是個人學習記錄分享，而到了最後會有其他延伸運用。當然有遇到任何問題，也是會跟大家討論。","categories":[{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/categories/d3js/"}],"tags":[{"name":"ironman","slug":"ironman","permalink":"https://wcc723.github.io/tags/ironman/"},{"name":"d3js","slug":"d3js","permalink":"https://wcc723.github.io/tags/d3js/"}]},{"title":"Gulp Task and Gulp Pipe","slug":"gulp-task","date":"2014-09-23T16:00:00.000Z","updated":"2016-10-13T00:43:57.000Z","comments":true,"path":"gulp/2014/09/24/gulp-task/","link":"","permalink":"https://wcc723.github.io/gulp/2014/09/24/gulp-task/","excerpt":"Gulp主要有四個指令，用這些指令就可以完成大部份工作。 gulp.task(name, fn) 定義一個任務名稱，接下來指定任務的工作內容 gulp.run(task) 運行指定的任務 gulp.src(glob) 檔案來源 gulp.dest(folder) 檔案的存檔路徑 而在上回的範例裡，已經呈現了主要的三個。 123456789//gulpfile.jsvar gulp = require('gulp'), coffee = require('gulp-coffee');gulp.task('coffee', function() &#123; //'coffee'是排程名稱，可自定 gulp.src('./app/coffeescripts/*.coffee') //來源檔案 .pipe(coffee()) //編譯 .pipe(gulp.dest('./app/assets/js')) //輸出位置&#125;); 而這篇會介紹如何用gulp將一個任務串接，並且監視它。","text":"Gulp主要有四個指令，用這些指令就可以完成大部份工作。 gulp.task(name, fn) 定義一個任務名稱，接下來指定任務的工作內容 gulp.run(task) 運行指定的任務 gulp.src(glob) 檔案來源 gulp.dest(folder) 檔案的存檔路徑 而在上回的範例裡，已經呈現了主要的三個。 123456789//gulpfile.jsvar gulp = require('gulp'), coffee = require('gulp-coffee');gulp.task('coffee', function() &#123; //'coffee'是排程名稱，可自定 gulp.src('./app/coffeescripts/*.coffee') //來源檔案 .pipe(coffee()) //編譯 .pipe(gulp.dest('./app/assets/js')) //輸出位置&#125;); 而這篇會介紹如何用gulp將一個任務串接，並且監視它。 以下是今年coscup Appleboy所分享的簡報(他的投影片真得很精彩)，先前就有聽過Gulp、Grunt等等技術，但是實際要運用也是需要參考許多文章，而其中許多都是 Appleboy的資料。 另外這邊有介紹Gulp與Grunt兩者在任務流程上的不同，Gulp在處理上，是不斷的編譯、編譯、編譯，最後直接寫入檔案，這篇就來介紹，Gulp是如何串接這些任務。 來源：http://www.slideshare.net/appleboy/automating-your-workflow-with-gulp Js ugly在上次的範例中，我們有準備兩個coffee原始檔，這次就要將這兩個原始檔合併壓縮。 回到terminal中輸入以下指令。 npm install gulp-uglify gulp-concat --save-dev gulp-uglify是用來壓縮js以及去除變數，gulp-concat則是用來合併多隻檔案。所有的流程都會用’.pipe’來進行串接，結果就會像下面的程式碼，編譯coffee、合併成一隻js、壓縮、輸出。 123456789101112131415//gulpvar gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), coffee = require('gulp-coffee');gulp.task('coffee', function() &#123; //‘coffee'是排程名稱，可自定 gulp.src('./app/coffeescripts/*.coffee') //來源檔案 .pipe(coffee()) //編譯 .pipe(concat('main.js')) //合併成一隻 .pipe(uglify()) //壓縮、醜化 .pipe(gulp.dest('./app/assets/js')) //輸出位置&#125;);gulp.task('default', ['coffee']);//預設動作 執行gulp 接下來回到terminal執行gulp，應該會發現/app/assets/js內的js被合併成一隻main.js，到這邊也算達到預期的效果，但是每次不斷執行相同動作也是挺麻煩der~。所以我們要另外寫個任務，不斷地監測檔案是否修改，只要有修改檔案，就自動編譯。 Gulp watch透過gulp.watch，可以監聽指定的資料夾，而被監聽的資料夾只要有檔案變更，就會直行指定的任務。 123456//gulpgulp.task('watch', function () &#123; //自定一個watch的排程名稱 gulp.watch('./app/coffeescripts/*.coffee', ['coffee']); //監聽路徑，以及檔案變更後所執行的任務&#125;);gulp.task('default', ['coffee','watch']); 參考以上的原始碼，只要在terminal輸入gulp，就會自動監聽。 只要每次修改，就會如上一樣，不斷地執行coffee這個任務，如果要中斷目前的監聽，就在Terminal內按下Ctrl + C。 到目前為止的gulpfile.js 123456789101112131415161718var gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), coffee = require('gulp-coffee');gulp.task('coffee', function() &#123; //‘coffee'是排程名稱，可自定 gulp.src('./app/coffeescripts/*.coffee') //來源檔案 .pipe(coffee()) //編譯 .pipe(concat('main.js')) //合併成一隻 .pipe(uglify()) //壓縮、醜化 .pipe(gulp.dest('./app/assets/js')) //輸出位置&#125;);gulp.task('watch', function () &#123; //自定一個watch的排程名稱 gulp.watch('./app/coffeescripts/*.coffee', ['coffee']); //監聽路徑，以及檔案變更後所執行的任務&#125;);gulp.task('default', ['coffee','watch']); 以目前的範例結果大概會像這樣。 | app / | - coffeescripts / | - a.coffee | - b.coffee | - js/ | - jquery-1.11.0.min.js | - sass/ | - all.sass | - assets/ | js / | - main.js | - index.html | node_modules / | - 各式node module…. | - gulpfile.js | - package.json","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"Gulp 環境安裝","slug":"gulp-install","date":"2014-09-21T16:00:00.000Z","updated":"2016-10-13T00:45:44.000Z","comments":true,"path":"gulp/2014/09/22/gulp-install/","link":"","permalink":"https://wcc723.github.io/gulp/2014/09/22/gulp-install/","excerpt":"鐵人賽我有準備一些文章，如網頁視覺設計(技巧、grid system)、前端設計工具的文章，比較偏向視覺設計以及前端工程的混和，但是鐵人賽我決定要換主題，所以文章就直接放出來(都寫了別浪費…)。 這一篇是Gulp的安裝，後來還有一系列的Gulp文章。 Gulp 可以做什麼Gulp 是一個前端任務管理工具，它可以做到如Fire.app、Prepros、Grunt等等所能做的事情，如果這樣還不是很了解，那就列表給大家看看。 編譯 SASS、Coffeescript 壓縮 .CSS, .JS, 甚至圖檔 web server with Livereload 享受自己動手做Task工具的快感 others.. 雖然很多工具，都能做到類似的功能，但是如果需求不足的時候，就要開另一個工具來幫忙，如另外許多專案已經在執行中，或者是老專案，有些工具過於強大，就會顯得沒那麼合適，那麼就可以用gulp客製化屬於該專案使用的工具。","text":"鐵人賽我有準備一些文章，如網頁視覺設計(技巧、grid system)、前端設計工具的文章，比較偏向視覺設計以及前端工程的混和，但是鐵人賽我決定要換主題，所以文章就直接放出來(都寫了別浪費…)。 這一篇是Gulp的安裝，後來還有一系列的Gulp文章。 Gulp 可以做什麼Gulp 是一個前端任務管理工具，它可以做到如Fire.app、Prepros、Grunt等等所能做的事情，如果這樣還不是很了解，那就列表給大家看看。 編譯 SASS、Coffeescript 壓縮 .CSS, .JS, 甚至圖檔 web server with Livereload 享受自己動手做Task工具的快感 others.. 雖然很多工具，都能做到類似的功能，但是如果需求不足的時候，就要開另一個工具來幫忙，如另外許多專案已經在執行中，或者是老專案，有些工具過於強大，就會顯得沒那麼合適，那麼就可以用gulp客製化屬於該專案使用的工具。 Gulp 需求在開始使用Gulp前，需要先安裝Node.js，Node.js 是一個讓 Javascript 運行在服務端的開發平台。它使用了 Google 的 V8 虛擬機(Google Chrome 瀏覽器使用的 Javascript 執行環境)。 另外還有npm，是由Node.js 官方提供的第三方管理工具，並且是一種在 Node.js 應用程式中建立、分享、重複使用模組，而npm在目前的版本，都會隨著Node.js的安裝同時安裝好npm。 簡而言之，我們使用Node.js的服務，透過npm管理工具。 安裝node js(這部分與先前安裝gitbook雷同) Node.js在這一個部分windows與mac其實只是安裝檔不同， 這邊就只Show出windows版本的安裝(Mac版大致相同，而後面的介紹會兩者混用) 下載安裝後如果是windows，請打開”命令提示字元”，輸入： node -v npm -v 預期會出現以下的版本(或者更高) 如果是Mac，請打開終端機，和windows相同，輸入以下指令： node -v npm -v 預期會出現以下的版本(或者更高) 接下來，大部份的操作，也都是兩者相同，就不再一一贅述。 首先，安裝全域的Gulp。 npm install -g gulp 到目前為止，整體的環境就算完成了，接下來就是建立專案，而這部分我會先開啟一個簡單的範例，有興趣的使用者也可以下載範例來直接使用。 範例檔案這邊我們先假設專案需要編譯coffeescript、compass with susy，最後還需要webserver 並且具有livereload的功能，所以專案的架構大概如下： | app / | - coffeescripts / | - a.coffee | - b.coffee | - js/ | - jquery-1.11.0.min.js | - sass/ | - all.sass | - index.html 這個專案內容都在app/的資料夾內，coffeescripts 有兩個coffee檔，sass檔內只有一個all.sass，另外還有個jquery，也會隨後一起壓縮。 如何開始使用Gulp接下來的範例，會先在mac上執行，最後再放回windows，兩者大致相同。而一開始的範例，會先編譯coffeescript。 npm是nodejs的模組管理工具，這邊會建立一個package.json。 npm init 接下來我們就來安裝gulp以及coffeescript。 npm install --save-dev gulp gulp-coffee —save-dev的用途是將套件安裝，並且把安裝的資訊也一起寫入剛剛產生的package.json，如果打開package.json，會看到剛剛所安裝的套件名稱及版本。 1234&quot;devDependencies&quot;: &#123; &quot;gulp-coffee&quot;: &quot;^2.1.1&quot;, &quot;gulp&quot;: &quot;^3.8.7&quot;&#125; 這時候看資料夾內，也會看到node的套件安裝到資料夾內了。 這邊開始是重點https://www.npmjs.org/package/gulp-coffee 官方網站有寫出gulp-coffee怎麼使用，我們可以將它修改成適合這個專案的，首先建立gulpfile.js，檔案內容如下。 123456789//gulpfile.jsvar gulp = require('gulp'), coffee = require('gulp-coffee');gulp.task('coffee', function() &#123; //'coffee'是排程名稱，可自定 gulp.src('./app/coffeescripts/*.coffee') //來源檔案 .pipe(coffee()) //編譯 .pipe(gulp.dest('./app/assets/js')) //輸出位置&#125;); 接下來在terminal輸入gulp coffee，就可以編譯coffee了。 接下來就會在assets/js看到編譯好的兩個檔案。 以目前的範例結果大概會像這樣。 | app / | - coffeescripts / | - a.coffee | - b.coffee | - js/ | - jquery-1.11.0.min.js | - sass/ | - all.sass | - assets/ | js / | - a.js | - b.js | - index.html | node_modules / | - 各式node module…. | - gulpfile.js | - package.json 目前就可以做的簡易的coffee編譯，接下來會使用更多的工具。 工商服務 MOPCON傳說中「真．濁水溪以南最強大科技研討會」Mobile Open Platform Conference 聽說 9/22 準時開始報名, 這次單是議程講師的公司堆起來就金光閃閃啊~~~ http://mopcon.kktix.cc/events/2014-registration 官方網站 http://mopcon.org/2014/","categories":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/categories/gulp/"}],"tags":[{"name":"gulp","slug":"gulp","permalink":"https://wcc723.github.io/tags/gulp/"}]},{"title":"Gem Github pages","slug":"github-page","date":"2014-09-04T16:00:00.000Z","updated":"2016-10-13T00:45:48.000Z","comments":true,"path":"jekyll/2014/09/05/github-page/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/09/05/github-page/","excerpt":"最近聽說github pages有更新，那我也稍微看一下(真的只是稍微)，之前都是用純Jekyll寫Blog，現在發現有github pages的gem(其實已經存在很久了)，似乎可以方便很多。 這篇主要就是記錄安裝過程以及簡易使用。 https://github.com/github/pages-gem","text":"最近聽說github pages有更新，那我也稍微看一下(真的只是稍微)，之前都是用純Jekyll寫Blog，現在發現有github pages的gem(其實已經存在很久了)，似乎可以方便很多。 這篇主要就是記錄安裝過程以及簡易使用。 https://github.com/github/pages-gem 安裝github-pages裝之前請先確認有ruby環境，先前的Jekyll教學有完整的Ruby環境安裝，所以這邊就不再提了。 打開Terminal輸入以下指令(Windows沒有測試過)。 gem install github-pages 安裝完後輸入github-pages versions，可以看到目前所有相關gem的版本。 Bundle接下來要把gem寫到專案裡，打開專案後新增一個檔案Gemfile，裡面輸入以下： gem &apos;github-pages&apos; 接下來在Terminal輸入bundle install，這樣專案與Github pages的gem就會綁在一起`。 執行jekyll恩…，這真的不是很困難，所以已經到結尾了…，打開Terminal輸入以下指令就完成了。 bundle exec jekyll serve --watch 至於這樣有什麼功能呢？我也還正在閱讀中…。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"安裝Gitbook","slug":"gitbook-install","date":"2014-09-03T16:00:00.000Z","updated":"2016-10-13T00:45:52.000Z","comments":true,"path":"design/2014/09/04/gitbook-install/","link":"","permalink":"https://wcc723.github.io/design/2014/09/04/gitbook-install/","excerpt":"利用Gitbook製作電子書是相當容易的，作者只要熟悉markdown語法以及簡易的安裝，就可以快速編寫屬於自己的書籍，它有著以下幾點特色。 利用git 版本控制 用git就可以發佈新版本 利用markdown語法編寫 包含手機版 這邊就簡單介紹如何安裝gitbook server在自己本機上，以利於快速與他人合作。 注意：本文不會提到git操作，在使用gitbook前，請先熟悉git。","text":"利用Gitbook製作電子書是相當容易的，作者只要熟悉markdown語法以及簡易的安裝，就可以快速編寫屬於自己的書籍，它有著以下幾點特色。 利用git 版本控制 用git就可以發佈新版本 利用markdown語法編寫 包含手機版 這邊就簡單介紹如何安裝gitbook server在自己本機上，以利於快速與他人合作。 注意：本文不會提到git操作，在使用gitbook前，請先熟悉git。 https://www.gitbook.io/book/wcc723/google_design_translate 安裝在安裝Gitbook必須先裝Node.js，Node.js 是一個讓 Javascript 運行在服務端的開發平台。它使用了 Google 的 V8 虛擬機(Google Chrome 瀏覽器使用的 Javascript 執行環境)。 另外還有npm，是由Node.js 官方提供的第三方管理工具，並且是一種在 Node.js 應用程式中建立、分享、重複使用模組，而npm在目前的版本，都會隨著Node.js的安裝同時安裝好npm。 簡而言之，我們使用Node.js的服務，透過npm管理工具，如果還是不知道，就是照著操作就是了。 安裝node.jsNode.js在這一個部分windows與mac其實只是安裝檔不同，只要按照官方程序裝完就可以了。 這邊就只Show出windows版本的安裝(Mac版大致相同，而後面的介紹會兩者混用) 如果是windows，請打開”命令提示字元”，輸入： node -v npm -v 預期會出現以下的版本(或者更高) 如果是Mac，請打開終端機，和windows相同，輸入以下指令： node -v npm -v 預期會出現以下的版本(或者更高) 安裝gitbook由於我這邊mac已經裝完，我用windows做範例，當然結果是一樣的。 打開command輸入以下指令。 npm install -g gitbook 安裝完後輸入 gitbook version，預期會出現以下畫面。 gitbook serve範例專案：https://github.com/Wcc723/google_design_translate 接下來到一個專案的資料夾，輸入gitbook serve，它就會打開一個port，並且運行gitbook server。 網址輸入localhost:4000就可以看到這一個網站。 可能會遇到的問題我也不知道為什麼…，Mac版會出現這個錯誤，反正有解決方式。 回到Terminal，輸入ulimit -n 4096，在執行一次gitbook serve。 ulimit -n 4096 安捏，就可以正常執行了。 剩下的部分，可以參考目前範例的架構。而最近發這篇文，是因為聽說9月9日快到了。","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"翻譯Material Design心得","slug":"google-material-design","date":"2014-07-22T16:00:00.000Z","updated":"2016-10-13T00:42:07.000Z","comments":true,"path":"design/2014/07/23/google-material-design/","link":"","permalink":"https://wcc723.github.io/design/2014/07/23/google-material-design/","excerpt":"距離上次的文章也將近一個月…，這段時間主要是在翻譯Google Design，所以有一段時間沒有發新的文章。然而翻譯Google Material Design的原因，也是想要讓中文化後的更多人閱讀，進而引起大家的討論。 整體翻譯的時間從6月27日到7月23日將近一個月的時間，特別感謝從一開始就協助翻譯的Tillonter Hsu、Helen兩位，到最後都還在翻譯；也很感謝Peter、Frances的加入，讓整體進度突飛猛進，還有社群其他的好友Charlene、Mkdodos、陳聖博、Xuan沒有大家的幫忙，這是沒有辦法再這麼快的速度完成的，當然研究所的朋友Xunyi，感謝一起入坑幫忙。 https://www.gitbook.io/book/wcc723/google_design_translate","text":"距離上次的文章也將近一個月…，這段時間主要是在翻譯Google Design，所以有一段時間沒有發新的文章。然而翻譯Google Material Design的原因，也是想要讓中文化後的更多人閱讀，進而引起大家的討論。 整體翻譯的時間從6月27日到7月23日將近一個月的時間，特別感謝從一開始就協助翻譯的Tillonter Hsu、Helen兩位，到最後都還在翻譯；也很感謝Peter、Frances的加入，讓整體進度突飛猛進，還有社群其他的好友Charlene、Mkdodos、陳聖博、Xuan沒有大家的幫忙，這是沒有辦法再這麼快的速度完成的，當然研究所的朋友Xunyi，感謝一起入坑幫忙。 https://www.gitbook.io/book/wcc723/google_design_translate 進度第一次Commit的時間是6月27日，當時我同事和一位前端的好友一同翻譯(3人)，原本打算在一周後，翻譯篇數約達到10篇後再開始公開找人，但發現進度有點趕不上，且大陸那邊也發佈了(簡體中文版)[http://www.ui.cn/Material/]，所以在避免拖延太久的情況下，就在Facebook 高雄前端社群上公開找人一起翻譯。 翻譯人員如下： Charlene Frances Helen Mkdodos Tillonter Hsu Peter Xuan Xunyi 陳聖博 雖然用的技術有git、gitbook、markdown等等，但翻譯者只要有熱情，技術的問題就應當撇除，所以大家的進度都是記錄在Hackpad(簡單易用)，其餘部分會依據參與者可以配合的方式進行。 在大家一起協助翻譯後，我翻譯的篇數就變少很多，主要就是協助整理、統一格式、聯絡各個翻譯者。在進度上，是儘量不催促翻譯者的進度(畢竟每個人都有自己的生活)，而是透過Hackpad去不斷更新內容，讓參與翻譯的人都了解這計劃是不斷的在進行，這樣翻譯者自然會有更深的認同感，一直保持進度翻譯下去。 總共篇數約4X篇，在翻譯30篇左右時，我上傳至Gitbook準備公開。在7/16時，我在幾個社群網站先公開，因為怕等到整個完成後，這篇翻譯文章的價值會降低(大陸的翻譯數量變多、討論Material Design的人變少等等)，讓大家的辛苦，沒有感受到應有的掌聲…。 而在這7月23日，最後一篇超長文章也傳來了(恰巧我的生日耶)，Material Design的翻譯也算到達一個進度，接下來就是校稿，校稿則會開放更多人一起協作，當然…，校稿前也就必須要先準備一些規範orz…。 公開的第一天，以及隔天的指標。 遭遇的問題這些問題不記錄起來，下次還是會遇到…。 格式在一開始雖然有先做一份格式，也有寫一些基礎的格式規範，但參與者不一定會了解我們的明白，畢竟買電器都不會先看說明書了…，所以許多格式都要在後續做整理，這個部分花相當多的時間。 認為比較好的模式，是找擅長markdown以及gitbook規範的人員，一同協助將原文版本的格式轉換成markdown，接下來參與者，只要下載已經做好的markdown檔案，在翻譯成中文，就完成了。 缺點是在開始時，必須花較多的時間討論格式，會讓開始的時間延後，且就算討論過，每個參與者所定義的還是會有所誤差，必須重新檢視到可接受範圍內。 特殊名詞許多名詞，是否要翻譯也是問題像是Material Design，這個詞到最後都沒有被翻譯，都是用原文呈現，而其他部分都是尊重翻譯者所翻譯的內容；且有許多詞是要用類似大陸的直譯式，還是像中文會轉換成較為口語的方式，在翻譯時都有許多的疑問。 這部分有位朋友建議我，在最主要的名詞(標題)，旁邊加上括號標上原文，如：質感設計(Material Design)；但是後來想到如果這名詞在不同的頁面章節也有重複出現呢…？ 目前是規劃透過校稿來處理這個問題，但如果有下次，會考慮專有名詞先加上原文吧。 Git Branch這次在Github都是在master上執行，一方面也是我沒有特別去規定要如何上git，目前會思考branch是依據翻譯人員還是章節來做規劃(如果有人有相關意見，也歡迎來討論)。 在翻譯這計劃告一段落後，就會回到原本的計劃，學習D3.js、Susy 2；至於會不會有其它翻譯或開放專案，我也不確定，說不定iOS 8也會在借助大家的幫忙？","categories":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/categories/design/"}],"tags":[{"name":"design","slug":"design","permalink":"https://wcc723.github.io/tags/design/"}]},{"title":"D3 Js 介紹","slug":"d3-js-intro","date":"2014-06-23T16:00:00.000Z","updated":"2016-10-12T06:47:42.000Z","comments":true,"path":"d3/2014/06/24/d3-js-intro/","link":"","permalink":"https://wcc723.github.io/d3/2014/06/24/d3-js-intro/","excerpt":"之前有提到最近要學的技能是Rails以及D3.js，這也是我今年的計劃，剛好也趁最近Diablo III手氣不好，一直打不到華戒，就抽空來都學學吧。 最近的文章，都不算是什麼教學文，算是學習記錄。","text":"之前有提到最近要學的技能是Rails以及D3.js，這也是我今年的計劃，剛好也趁最近Diablo III手氣不好，一直打不到華戒，就抽空來都學學吧。 最近的文章，都不算是什麼教學文，算是學習記錄。 參考書籍不久前歐萊禮的書在博客來有特價，我就買了這本D3，雖然前面廢話有點多，但在難度設定上是屬於較為簡單的，如果說會寫jquery以及js基礎概念，相信很容易上手。 參考書籍：網頁互動式資料視覺化：使用D3 D3 簡介D3 是全名是 Data-Driven Documents，是利用資料驅動文件的js lib。它可以將資料載入後，利用資料的內容驅動HTMl上的物件，甚至是針對使用者的操作將物件轉換成其它狀態。 簡單來說，就是將資料圖表化，甚至是透過使用者的操作，呈現出不同的樣式。 為什麼選擇D3之前的文章有提到，我有在學習SVG，SVG是屬於向量的技術，而D3適合操作SVG來做圖形呈現，正好符合無限期支持向量技術的理念!?另外就是在工作上，資料驅動圖形是一個趨勢，和文字表格比起來，大家更愛看的是圖形呈現，且最好是能夠互動，基於這樣的理由…，D3是我所了解到最適合的工具。 範例我一直以為他只能操控SVG物件，但事實上第一個Demo就導正我的觀念了…，SVG儘是適合表現視覺化，但是D3是可以控制Html大多數的DOM。 簡單介紹一下本篇所使用的D3 Api。 d3.select // DOM 選取器，類似jquery的$(&apos;&apos;) d3.selectAll // 選取複數元素 selection.data // 將資料與被選擇的元素串接 selection.enter // 將資料傳送至未被串街的元素 本篇的Html(我習慣用日期分…有時候是前幾天寫的)。 本篇的CSS 1234567.bar &#123; display: inline-block; width: 20px; height: 75px; margin-right: 3px; background-color: teal;&#125; 以下是本篇的Js 1234567891011121314151617var dataset = []; //建立空的資料陣列for (var i=0; i &lt; 20; i++)&#123; var newNum = 5 + Math.floor(Math.random() * 30); dataset.push(newNum);&#125;//隨機產生一組長度20，值為5~35的數字。d3.select('.d0622').selectAll('div') //選取 class內的div .data(dataset) // 將資料加入至 div .enter() // return data .append('div') // 這邊加入的div已經有包含data .attr('class','bar') //套用class .style('height', function(d)&#123; //將data的值取出作為高 return (d*3) + 'px' &#125;) Demo 本篇雖然沒有介紹到SVG，但如果對D3有興趣，建議先對SVG有初步的了解，在學習上會更有幫助。 小感把Js寫成文字好難…。 12/3 更新由於有很多人是透過Google搜尋到本頁面，但本篇也沒有介紹非常詳細。而後來有參加鐵人賽，有製作相當多的Demo，如果對於D3.js有興趣，不妨參考看看我在鐵人賽的一些文章吧。 鐵人賽文章列表 高雄前端社群D3.js 如果有任何問題，可以直接下方留言，或者不夠好的地方，也請多多賜教，感謝。","categories":[{"name":"d3","slug":"d3","permalink":"https://wcc723.github.io/categories/d3/"}],"tags":[{"name":"js","slug":"js","permalink":"https://wcc723.github.io/tags/js/"},{"name":"d3","slug":"d3","permalink":"https://wcc723.github.io/tags/d3/"}]},{"title":"Rails 環境建設","slug":"rails-101-install","date":"2014-06-21T16:00:00.000Z","updated":"2016-10-12T06:07:29.000Z","comments":true,"path":"rails/2014/06/22/rails-101-install/","link":"","permalink":"https://wcc723.github.io/rails/2014/06/22/rails-101-install/","excerpt":"最近要學的技術有兩個，一個是D3.js，另一個是Rails，目前是參考Xdite所提供的Rails 101，安裝過程中有發生些小問題，所以特別記錄起來，以免之後要在裝的時候忘記…。 Rails不是要打算精通後端，而是希望了解，以便往後再配合後端時能更有效率的處理問題。","text":"最近要學的技術有兩個，一個是D3.js，另一個是Rails，目前是參考Xdite所提供的Rails 101，安裝過程中有發生些小問題，所以特別記錄起來，以免之後要在裝的時候忘記…。 Rails不是要打算精通後端，而是希望了解，以便往後再配合後端時能更有效率的處理問題。 安裝環境 參考的書籍：Rails 101 https://leanpub.com/rails-101 硬體：Macbook pro retina 2013 系統版本：OSX 10.9.3 安裝Homebrew在PDF書上第一個要安裝的，會想要記錄也是以下這原因…。 以上的圖是書上的範例，直接複製會得到以下的結果…，沒有空白鍵啊!!!重點是我找不到原因還卡很久… ruby-e&quot;$(curl-fsSLhttps://raw.github.com/Homebrew/homebrew/go/install)&quot; 所以沒意外的話應該是以下指令 ruby -e &quot;$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)&quot; 想說我有裝git了，跳過brew install git，直接升級。 brew update brew tap homebrew/dupes brew install apple-gcc42怎好像沒截到圖…。 安裝 XQuartz安裝XQuartz。 安裝完後登出在登入。 安裝 ImageMagick / MySQL別懷疑，這邊我完全不懂，只知道MySQL是資料庫。 brew install imagemagick 透過brew安裝時，圖示都變成啤酒了… Installing mysql unset TMDIR 這個用了沒感覺(跳過…) mysql_install_db --verbose --user=`whoami` --basedir=&quot;$(brew--prefixmysql)&quot; -\\ sudo mysqladmin -u root password &apos;123456&apos; mkdir -p ~/Library/LaunchAgents 這個用了沒感覺(跳過…) find /usr/local/Cellar/mysql/ -name &quot;homebrew.mxcl.mysql.plist&quot; -exec cp {} ~/Library/LaunchAgents/ \\; launchctl load -w ~/Library/LaunchAgents/homebrew.mxcl.mysql.plist 安裝 RVM透過rvm就可以執行特定版本的ruby及gems，rails的版本演進相當快，所以必須透過RVM來切換不同的rails版本。 bash -s stable &lt; &lt;(curl -s https://raw.github.com/wayneeseguin/rvm/master/binscripts/rvm-installer) . ~/.profile $source ~/.profile 安裝 Ruby 2.0brew install libyaml rvm pkg install openssl rvm install 2.0.0 --with-openssl-dir=$HOME/.rvm/usr --verify-downloads 1 很順利，忘記截圖… rvm use 2.0.0，這段我出了點問題，於是上網找了其他解法，依序輸入以下幾行。 source ~/.rvm/scripts/rvm type rvm | head -n 1 rvm use 2.0.0 安裝必要 Ruby gemsgem install rails --version 4.0.0 gem install mysql2 gem install capistrano gem install capistrano-ext 設定 HTTP Server (使用 Pow)簡單來說，就是看localhost:3000不爽，要換掉的意思!? curl get.pow.cx | sh gem install powder Pow用法，方法一 cd ~/.pow/ ln -s ~/projects/wiki 方法二 powder link Rails安裝環境相當複雜，如果沒有記錄，到時候也是會卡在相同的地方…。 安裝環境 全劇終…","categories":[{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/categories/rails/"}],"tags":[{"name":"ruby","slug":"ruby","permalink":"https://wcc723.github.io/tags/ruby/"},{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/tags/rails/"}]},{"title":"CSS + SVG stroke 動態描繪","slug":"svg-css-stroke-animation","date":"2014-06-14T16:00:00.000Z","updated":"2016-10-12T06:42:59.000Z","comments":true,"path":"svg/2014/06/15/svg-css-stroke-animation/","link":"","permalink":"https://wcc723.github.io/svg/2014/06/15/svg-css-stroke-animation/","excerpt":"SVG有很多有趣的效果，尤其是stroke，它有許多不同的屬性參數，套用上css animation就有意想不到的效果，雖然不能達到豐富的互動，但至少可以在視覺上令人為之一亮。 這篇要利用stroke的dash特性，做出圖形描繪的動態效果。","text":"SVG有很多有趣的效果，尤其是stroke，它有許多不同的屬性參數，套用上css animation就有意想不到的效果，雖然不能達到豐富的互動，但至少可以在視覺上令人為之一亮。 這篇要利用stroke的dash特性，做出圖形描繪的動態效果。 參考來源http://cssdeck.com/labs/ironman-svg-line-animation 作者是把這效果用在描繪鋼鐵人上，做得很酷，而本篇是介紹它的原理。 stroke-dasharray + stroke-dashoffsetstroke-dasharray是把stroke做成了是虛線的效果，線段會被拆成線段、空白、線段、空白，效果就像下面這樣。 /*這邊是CSS*/ line { stroke-dasharray: 60; } 如上顯示，線段被拆成60px的line在空60px的space。 stroke-dashoffset而stroke-dashoffset屬性是將上面的虛線推移，兩者會有以下幾點特性： 推移後，dasharray還是會保持循環。 dashoffset的值不會大於dasharray。 如果dashoffset 等於 dasharray，線段起始點會是空白。 所以這部分就再加上40的stroke-dashoffset來看看結果。 /*這邊是CSS*/ line.l2{ stroke-dashoffset: 40; } 如果兩者數值相等，線段的起始點就會呈現空白，這邊先設較小的值(200)。 line.l3{ stroke-dasharray: 200; stroke-dashoffset: 200; } 如果數值相當的大，就能夠將整個線段隱藏。 結合CSS aniamtionaniamtion 相關的瀏覽器前輟詞問題，可參考/css/2013/10/17/css-animation-keyframe/ 這邊就show重要的CSS code，利用上面的原理將線段隱藏，然後透過animation將線段拉回來，這樣就會有動態描繪的感覺。 //先將stroke隱藏 .stroke{ stroke-dashoffset: 2000 stroke-dasharray: 2000 } //動畫效果 10秒 線性動畫 無限循環 .ani { animation: circle-draw 10s linear infinite } //keyframes的值 //將dashoffset拉回至0 @keyframes circle-draw{ 80% { stroke-dashoffset: 0; } } &lt;svg class=&quot;stroke ani&quot; height=&quot;400&quot; width=&quot;100%&quot; &gt; &lt;g&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;10&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;20&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;30&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;40&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;50&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;60&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;70&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;80&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;90&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;100&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;110&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;120&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;130&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;140&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;150&quot;/&gt; &lt;circle cx=&quot;200&quot; cy=&quot;200&quot; r=&quot;160&quot;/&gt; &lt;/g&gt; &lt;/svg&gt; 以上的SVG code，當然這也可以用Illustrator來繪製，只要把svg code換掉就可以了。 注意，儘量不要在網頁上做無限循環的重復播放，很耗效能。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"SVG 漸層沒想到是這樣的做法","slug":"svg-linear-gradient","date":"2014-06-04T16:00:00.000Z","updated":"2016-10-12T06:42:23.000Z","comments":true,"path":"svg/2014/06/05/svg-linear-gradient/","link":"","permalink":"https://wcc723.github.io/svg/2014/06/05/svg-linear-gradient/","excerpt":"最近在研究SVG，在做專案的時候就會想用一些相關的技術，當時想在stroke上使用漸層色，所以就研究了SVG的漸層做法。 SVG的漸層做法，和我想像有些落差，原本以為會是類似CSS的寫法，但結果卻…。","text":"最近在研究SVG，在做專案的時候就會想用一些相關的技術，當時想在stroke上使用漸層色，所以就研究了SVG的漸層做法。 SVG的漸層做法，和我想像有些落差，原本以為會是類似CSS的寫法，但結果卻…。 SVG 漸層SVG漸層，找到的做法是在HTML先定義漸層；而CSS的漸層是直接寫在樣式表內，這樣的做法對於主要使用CSS有很大的不便(哭)。或許有用CSS的做法，但我不是很清楚。 定義漸層在任何一&lt;svg&gt;標簽內，新增一個&lt;defs&gt;，&lt;defs&gt;標簽內在新增一個&lt;linearGradient&gt;標簽，這樣就可以開始定義漸層，而結構如下： &lt;defs&gt; &lt;linearGradient id=&quot;myGradient&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;0%&quot; y2=&quot;100%&quot; spreadMethod=&quot;pad&quot;&gt; &lt;stop offset=&quot;0%&quot; stop-color=&quot;#E80C7A&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;50%&quot; stop-color=&quot;#E83D9D&quot; stop-opacity=&quot;1&quot;/&gt; &lt;stop offset=&quot;100%&quot; stop-color=&quot;#fff&quot; stop-opacity=&quot;1&quot;/&gt; &lt;/linearGradient&gt; &lt;/defs&gt; 另外重要的是linearGradient需要一個id，因為他是id，所以一個page內一個linearGradient只能定義一次(不同的SVG可以共用相同的linearGradient)。 使用接下來隨意繪製一個圖形，圖形的許多屬性都能套用剛剛定義的漸層，如在以下圓型的fill屬性值為url(#myGradient)，就可以將剛剛的漸層帶入。 &lt;svg width=&quot;164&quot; height=&quot;164&quot;&gt; &lt;circle cx=&quot;82&quot; cy=&quot;82&quot; r=&quot;79&quot; style=&quot;fill: url(#myGradient)&quot;/&gt; &lt;/svg&gt; CSS只要定義好後，CSS也能夠使用漸層色，一樣用url(id)，像是以下範例就用stroke: url(#myGradient)(再次提醒，漸層定義一次就能重複使用)。 // sass code // 這範例還偷插了stroke-width以及animation。 svg stroke-width: 1px stroke: url(#myGradient) fill: none +transition(stroke-width .5s) &amp;:hover stroke-width: 4px +animation(infinite-rotate 1s infinite linear) html的部份就不需要寫什麼了，就由CSS去定義。 //html &lt;svg width=&quot;164&quot; height=&quot;164&quot;&gt; &lt;circle cx=&quot;82&quot; cy=&quot;82&quot; r=&quot;79&quot; /&gt; &lt;/svg&gt; 最後這也是我在實驗的效果，結合SVGstroke的粗細變化，以及stroke的漸層。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"Sass 3.3 Source Maps","slug":"sass-source-maps","date":"2014-06-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/06/02/sass-source-maps/","link":"","permalink":"https://wcc723.github.io/sass/2014/06/02/sass-source-maps/","excerpt":"Sass 3.3 除了上次提到的$Map外，還有另一個很有特色的功能就是Source Maps，這功能主要是配合開發者工具，直接就可以看Sass原始碼在哪一個檔甚至是哪一段，而這篇會配合Chrome 開發者工具來介紹Source Maps。","text":"Sass 3.3 除了上次提到的$Map外，還有另一個很有特色的功能就是Source Maps，這功能主要是配合開發者工具，直接就可以看Sass原始碼在哪一個檔甚至是哪一段，而這篇會配合Chrome 開發者工具來介紹Source Maps。 注意請確認使用的Sass 版本為3.3以及Compass 1.0以上，如果不是，請參考上次這篇文章。 Chrome 設定有點忘了Chrome版本要多少才能使用sass maps，而我目前的版本是35.0.1916.114是可以直接執行的，如果發現沒有以下設定，就煩請升級到我這版本以上。 首先，打開開發者工具，右方有一個設定按鈕，按下它。 在General 內可以找到Source &gt; Enable CSS source maps，把它選起來後關掉開發者工具。 Compass 設定這邊的範例是直接用上次那篇的(上次文章)。 基本上我用Sass都會引用Compass，所以這邊直接介紹Compass的做法。打開專案資料夾，找到config.rb(沒有就自己加吧)，加入sourcemap = true。 接下來在terminal輸入compass watch，會出現兩個檔，一個是之前的screen.css，另一個是screen.css.map，.map就是等等要給Chrome看的，所以別太在意他的內容。 接下來回到Chrome使用開發者工具，隨意檢視一個物件，會發現screen.css改成用screen.sass了！ **screen.sass:14**也直接寫出在screen.sass這個檔案的第14行可以找到這段code，對於css開發者來說，就可以省去很多時間找css code了。 如果使用的是其他工具再過不知道多久的時間，Fire.app應該會更新到sass 3.3，這些工具在使用時，都可以當做一個簡易的server，適合配合livereload等工具。但是這對於source map來說會有些問題，因為Chrome source map 會對應不到最原始的檔案位置，所以必須加入原始的sass檔位置。 打開開發者工具，一樣到設定的位置，從workspace內找到Folders這選項，把原始的Sass檔案夾加入。 在開發者工具內的Sources內可以找到已經加入的資料夾。 對他點擊右鍵，選擇Map to Network Resource。 選擇對應的檔案。 接下來，按照原本的Chrome開發者工具使用方法，就可直接修改screen.sass這個檔案，配合著compass、livereload等等，畫面就會自動重整。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"}]},{"title":"CSS + html 冷知識","slug":"css-cold-knows","date":"2014-05-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/05/23/css-cold-knows/","link":"","permalink":"https://wcc723.github.io/css/2014/05/23/css-cold-knows/","excerpt":"CSS及HTML已經學了有段時間，但還有許多不清楚的點都會在(偶然)的情況下發現，而有些只是有趣，但有些發現，或許是以前忽略的，但在卻是那麼的實用…。","text":"CSS及HTML已經學了有段時間，但還有許多不清楚的點都會在(偶然)的情況下發現，而有些只是有趣，但有些發現，或許是以前忽略的，但在卻是那麼的實用…。 label 不一定要配for再用sublime text 時，如果輸入label + tab，就會出現&lt;label for=&quot;&quot;&gt;&lt;/label&gt;，我也一直認為&lt;label&gt;裡面就是要有for，但label沒有for也可以call到指定的input。 This is a check box &lt;label&gt; &lt;input type=&quot;checkbox&quot;&gt; This is a check box&lt;/label&gt; 上方的checkbox，只要點擊文字，就可以讓checkbox轉換為checked。 如上面的範例，label如果裡面有input，那麼點擊到input範圍，都可以focus到內部的input。 This is a check box 注意，兩個input就只會一個有效…。 UTF-8 字符 也能作為class name簡單來說，uff-8的小圖形也能作為class name。 核能 ☢ !? ☯ 神秘力量 HTML code &lt;div class=&quot;demo d0524&quot;&gt; &lt;div class=&quot;anti-☢&quot;&gt;核能 ☢ !?&lt;/div&gt; &lt;div class=&quot;☯-power&quot;&gt; ☯ 神秘力量&lt;/div&gt; &lt;/div&gt; Sass code //sass .anti-☢ color: orange .☯-power color: white text-shadow: 0 0 3px black 利用:before 來做垂直置中利用inline-block的特性來做到垂直置中，優點是支援before就可以，缺點是要置中的元素，也必須設定為inline-block。 這段字想要垂直至中 Sass code .vertical height: 200px border: orange 1px solid &amp;:before content: &quot;&quot; display: inline-block vertical-align: middle width: 1px height: 100% div display: inline-block","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"純CSS Drop Menu","slug":"pure-css-drop-menu","date":"2014-05-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/05/20/pure-css-drop-menu/","link":"","permalink":"https://wcc723.github.io/css/2014/05/20/pure-css-drop-menu/","excerpt":"CSS 有很多技巧，都很值得去開發，最近發現了一個很簡單的技術，就是純CSS下拉式選單，這讓我避免使用Jquery去做slider的效果，重點是…超簡單！","text":"CSS 有很多技巧，都很值得去開發，最近發現了一個很簡單的技術，就是純CSS下拉式選單，這讓我避免使用Jquery去做slider的效果，重點是…超簡單！ 重點提示這是利用max-hegiht + transition所達到的效果，好處是不用配合jquery的slider function，壞處就是…，drop-menu一定會包含overflow的屬性，如果設計不能有這屬性的話，就會被限制住。 HtmlHTML架構如下，而這篇是真的純CSS，所以會插入一個input去做切換的效果，實際製作的時候，可以直接用js來切換class，也能達到相同的效果。 &lt;div class=&quot;drop-menu&quot;&gt; &lt;label for=&quot;drop-menu&quot;&gt; 下拉式選單 &lt;/label&gt; &lt;input type=&quot;checkbox&quot; id=&quot;drop-menu&quot;&gt; &lt;ul class=&quot;menu-list&quot;&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-2&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;list-4&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; sass除了排版的樣式外，其餘的重點我都直接標示在sass code裡，而最重要的是用max-height來達到這樣的效果(height不可以喲)。 .drop-menu max-width: 300px label display: block border: 1px solid #ccc padding: 6px cursor: pointer input display: none .menu-list background-color: #FFF +box-shadow(0 0 8px rgba(black, .6)) overflow: hidden //重點 max-height: 0 //重點 +transition(max-height .3s) //重點 a display: block padding: 4px border-bottom: 1px dashed #ccc input:checked + .menu-list max-height: 300px //重點 Demo 下拉式選單 list-1 list-2 list-3 list-4 很容易吧～","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"玩玩看Rails","slug":"rails-go","date":"2014-05-08T16:00:00.000Z","updated":"2016-10-12T06:07:29.000Z","comments":true,"path":"rails/2014/05/09/rails-go/","link":"","permalink":"https://wcc723.github.io/rails/2014/05/09/rails-go/","excerpt":"對Rails有些興趣，而線上剛好有Step by step教學，不如就試試看(本篇只是個操作記錄，並不是教學)。","text":"對Rails有些興趣，而線上剛好有Step by step教學，不如就試試看(本篇只是個操作記錄，並不是教學)。 資料來源http://railsbridge-docs-zh-tw.herokuapp.com/docs/ Rails 安裝由於這台Mac已經有裝ruby、Git所以有些步驟就跳過，直接輸入sudo gem install rails就會開始安裝。 接下來會等一段時間，等待結束後，就輸入一些指令來驗證是否安裝成功。 which git which ruby which rails ruby -v rails -v 大概會有以下的結果。 設定Git這我設定好了，所以跳過～。 http://railsbridge-docs-zh-tw.herokuapp.com/installfest/configure_git?back=osx_railsinstaller 生成一個SSH Key終端機輸入以下指令 ls ~/.ssh/id_rsa 如果出現No such file or directory，就是沒有SSH Key，沒有就是要生一個，在終端機輸入以下指令。 ssh-keygen -C {your email} -t rsa 接下來會出現要安裝的資料夾，然後詢問是否要密碼，密碼會要求輸入兩次，空白的也可以。 然後會出現以下內容 Generating public/private rsa key pair. Enter file in which to save the key (/Users/student/.ssh/id_rsa): Created directory &apos;/Users/student/.ssh&apos;. Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /Users/student/.ssh/id_rsa. Your public key has been saved in /Users/student/.ssh/id_rsa.pub. The key fingerprint is: 88:54:ab:77:fe:5c:c3:7s:14:37:28:8c:1d:ef:2a:8d student@example.com SSH Key會放在~/.ssh/id_rsa.pub。 id_rsa.pub 是你的 public key（公鑰），你可以隨便拷給別人。id_rsa 是你的 private key（私鑰），請當做機密妥善保管，不可流出。 驗證SSH終端機輸入 ssh-add ~/.ssh/id_rsa 應該會出現 Identity added: /Users/apple/.ssh/id_rsa (/Users/apple/.ssh/id_rsa) 註冊Heroku 這註冊流程很容易，直接跳到安裝，註冊後他會要求安裝Toolbelt，而基本上也是下一步到底就能裝完的，安裝後終端機輸入： heroku version 有可能出現以下文字，那就是成功了 heroku-toolbelt/3.2.0 (x86_64-darwin10.8.0) ruby/1.9.3 接下來把SSH 加到Heroku先輸入以下指令： heroku keys:add 接下來會先要使用者輸入Heroku帳密，然後再選擇要用哪組SSH key。 開始Rails前面跑了很久，終於開始Rails了。找好一個資料夾後，輸入以下指令： rails new test_app 再整個專案建立完成後，輸入cd test_app，然後再輸入一下指令開始rails吧： rails server 建立DB在終端機依序輸入以下指令： rails generate scaffold drink name:string temperature:integer rake db:migrate rails server 接下來打開http://localhost:3000/drinks，會出現和之前不同的畫面，而這已經是簡單的應用程式了。 Deploy Rails 應用程式Step 1 使用Git等等沒意外的話，應該是用Git上傳，所以要先建立Git儲存庫。依序輸入以下指令： git init git add -A git commit -m &quot;initial commit&quot; 這樣git就已經簽入了。 Step 2.1 程式部署（Deploy）到 Heroku這邊教學裡有提到要建立Heroku應用程式，就先照做吧，依指令輸入： heroku create 接下來輸入git remote show來驗證是否成功，沒意外應該會出現heroku。 Step 2.2 Rails 應用程式來部署到 Heroku這部分要修改一個檔案，到text_app資料夾內學找一個Gmefile的檔案，用純文字編輯器修改。 原 gem &apos;sqlite3&apos; 修改為 group :development, :test do gem &apos;sqlite3&apos; end group :production do gem &apos;pg&apos; gem &apos;rails_12factor&apos; end 而在教學網站有提到資料庫的問題，這邊就轉貼參考吧。 http://railsbridge-docs-zh-tw.herokuapp.com/裝機趴-installfest/deploy_rails_應用程式?back=開新rails應用程式 為什麼要用 SQLite (sqlite3) 和 PostgreSQL (pg) ？SQLite 和 PostgreSQL 是兩種不同的資料庫。我們把 SQLite 用在開發環境（Development）及測試環境（Test），因為它比較好安裝。我們把 PostgreSQL 用在生產環境（Production）因為 Heroku 幫我們剛裝好了，而且功能比 SQLite 多。現在我們已經根據開發、測試、生產環境拆分了資料庫，這是 Rails 的預設。 這邊我都是按照流程操作了…，再繼續輸入指令(指令輸入久了總有一天應該會的…) bundle install --without production step 2.3 設定 root route再用編輯起打開config/routes.rb找到下面這行： # root &apos;welcome#index&apos; 然後替換成這個 root &apos;drinks#index&apos; 設定完後把這動作簽入 git add . git commit -m &quot;Updates for heroku deployment&quot; Push 到Herofu就跟平常push到github一樣，不過會問個問題而已 git push heroku master 接下來在終端機打這些字，heroku就會run起來了 heroku run rake db:migrate 接下來可以到官網或者是heroku open就可以開啟該網站。也可以透過heroku info看詳細資訊。 你應用程式的網址會是 application-name.herokuapp.com ──以上面的例子來說，它就會是 floating-winter-18.herokuapp.com。請確定你有看到應用程式的歡迎頁，然後留著瀏覽器視窗不要關掉。 登入Heroku網頁一樣可以看到應用程式的網址","categories":[{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/categories/rails/"}],"tags":[{"name":"rails","slug":"rails","permalink":"https://wcc723.github.io/tags/rails/"}]},{"title":"SVG 線段","slug":"SVG-line","date":"2014-05-04T16:00:00.000Z","updated":"2016-10-12T06:40:01.000Z","comments":true,"path":"svg/2014/05/05/SVG-line/","link":"","permalink":"https://wcc723.github.io/svg/2014/05/05/SVG-line/","excerpt":"這次要練習的是SVG的line、polyline、polygon，這三個都有點類似，但是Polyline和Polygon兩者之間卻有線與塊之間的差異。","text":"這次要練習的是SVG的line、polyline、polygon，這三個都有點類似，但是Polyline和Polygon兩者之間卻有線與塊之間的差異。 Lineline簡單來說就是兩個點之間的線段，所以起點是x1、y1，終點則是x2、y2。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;300&quot; y2=&quot;0&quot; style=&quot;stroke: pink; &quot;/&gt; &lt;line x1=&quot;0&quot; y1=&quot;10&quot; x2=&quot;300&quot; y2=&quot;10&quot; x3=&quot;200&quot; y3=&quot;30&quot; style=&quot;stroke: pink; &quot;/&gt; &lt;/svg&gt; 但是line只能當做兩點間的線段，就算寫了x3、y3都是沒用的喔(如上)。 PolylinePolyline我查到的中文翻譯是折線，它主要是繪製多點線段。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;polyline points=&quot;40,0 60,60 0,60&quot; style=&quot; stroke:red; stroke-width:2&quot;/&gt; &lt;polyline points=&quot;140,0 160,60 100,60&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;polyline points=&quot;240,0 260,60 200,60 240,0&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;/svg&gt; Polyline有點類似Illustrator的鋼筆工具(但還不能繪製弧線)，在線段之間還能填入色彩，但特別要注意的是他並不是自動封閉線段。 PolygonPolygon中文翻譯為多邊形，用來繪製不少於3個邊的圖形。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;polygon points=&quot;40,0 60,60 0,60&quot; style=&quot; stroke:red; stroke-width:2&quot;/&gt; &lt;polygon points=&quot;140,0 160,60 100,60&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;polygon points=&quot;240,0 260,60 200,60 240,0&quot; style=&quot;fill:none; stroke:red; stroke-width:2&quot;/&gt; &lt;/svg&gt; 這邊我刻意用和polyline相同的code，兩者只有標簽不同，從這樣比較能夠比對出兩個不同的地方，重點就是Polygon會自動連接最後點到第一個點。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"Sass 3.3","slug":"sass-3.3","date":"2014-05-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/05/02/sass-3.3/","link":"","permalink":"https://wcc723.github.io/sass/2014/05/02/sass-3.3/","excerpt":"Sass3.3出一段時間了，而Fire.app目前還是3.2的版本，據說是因為在等Compass 1.0正式版，而如果用Ruby的Compass確實也只能用3.2 版的sass。 不過新東西就是想用看看，上網查了一下並不複雜，所以這次就來試試看Sass 3.3 + Compass 1.0.alpha吧。","text":"Sass3.3出一段時間了，而Fire.app目前還是3.2的版本，據說是因為在等Compass 1.0正式版，而如果用Ruby的Compass確實也只能用3.2 版的sass。 不過新東西就是想用看看，上網查了一下並不複雜，所以這次就來試試看Sass 3.3 + Compass 1.0.alpha吧。 Ruby 更新Sass由於我都是使用Fire.app，所以ruby的Sass還在3.2…，而現在3.3也已經release了，所以直接update就可以了。 sudo gem update sass 安裝Compass alphaCompass 1.0還尚未release，所以如果像我這樣裝的話，會是屬於0.12版的，而它對應的Sass則是3.2版。 Compass alpha 安裝如果專案進行不受影響的情況下，可以試試看安裝Compass 1.0(或者平常沒在用Ruby在編譯的可以試試看)。 gem install compass --pre 這樣他就會安裝還在測試中的Compass 1.0，接下來就像平常用的那樣，就可以開始Watch 專案資料夾。 compass watch 測試Sass 3.3 的新功能就是$map，對我而言它可以減少模組話所需要的code，而且使用更直覺，以下就簡單介紹$map的用法，順便測試Sass 3.3能不能與Compass一起Run。 1.定義$map$all-colors: (first: #b06,next: #334,third: #666777,) //首先定義$all-colors //裡面有三組變數，包含一個名稱以及一個顏色 2.套用至樣式//利用@each將$class及$color 套用至$all-colors變數裡 @each $class, $color in $all-colors //接下來$all-colors的三組名稱及變數，都會套用到以下的樣式 .btn-#{$class} background-color: $color +background(linear-gradient($color, darken($color,10%))) //套套看Compass的CSS3 3.輸出如果沒有出錯的話剛剛的Compass watch，就能夠將Sass轉換成CSS了，轉換的結果會下方的CSS。 .btn-first { background-color: #bb0066; background: -moz-linear-gradient(#bb0066, #88004a); background: -webkit-linear-gradient(#bb0066, #88004a); background: linear-gradient(#bb0066, #88004a); } .btn-next { background-color: #333344; background: -moz-linear-gradient(#333344, #1d1d27); background: -webkit-linear-gradient(#333344, #1d1d27); background: linear-gradient(#333344, #1d1d27); } .btn-third { background-color: #666777; background: -moz-linear-gradient(#666777, #4e4f5c); background: -webkit-linear-gradient(#666777, #4e4f5c); background: linear-gradient(#666777, #4e4f5c); } 有圖有真相(有沒有好用的Macbook pro截圖軟體…，可以自動壓縮的)","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"}]},{"title":"SVG 矩形、圓形、橢圓","slug":"SVG-base-shapes","date":"2014-04-30T16:00:00.000Z","updated":"2016-10-12T06:13:13.000Z","comments":true,"path":"svg/2014/05/01/SVG-base-shapes/","link":"","permalink":"https://wcc723.github.io/svg/2014/05/01/SVG-base-shapes/","excerpt":"SVG是屬於向量的圖形，所以他有許多的繪圖概念與Illustrator，所以這次就來了解他的一些常用的基本圖形。","text":"SVG是屬於向量的圖形，所以他有許多的繪圖概念與Illustrator，所以這次就來了解他的一些常用的基本圖形。 矩形在定義一個矩形形狀時，通常會定義以下屬性，形狀、位置、尺寸以及樣式。 &quot;shapes&quot; &quot;x&quot; &quot;y&quot; &quot;width&quot; &quot;height&quot; &quot;style&quot; &lt;svg width=&quot;100%&quot; height=&quot;200&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: gray; fill: 336699;&quot;/&gt; &lt;rect x=&quot;120&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; style=&quot;stroke: gray; fill: 339966;&quot;/&gt; &lt;/svg&gt; 而矩形除了一般的方形、長方形以外，也可以增加圓角的屬性rx、ry，但這就沒有像css的border-radius那麼的自由了，只能四個角設定相同的值；rx、ry也僅僅是設定其圓角垂直以及水平的半徑而已。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;rect x=&quot;0&quot; y=&quot;0&quot; width=&quot;100&quot; height=&quot;100&quot; rx=&quot;10&quot; style=&quot;stroke: gray; fill: 336699;&quot;/&gt; &lt;rect x=&quot;120&quot; y=&quot;0&quot; width=&quot;200&quot; height=&quot;100&quot; rx=&quot;40&quot; ry=&quot;10&quot; style=&quot;stroke: gray; fill: 339966;&quot;/&gt; &lt;/svg&gt; 圓形圓形相當的容易，所以本篇才會將這些圖形合併在同一篇 圓形中有一點要特別注意，圓形的cx,cy所代表的是 圓心(r) 的位置，所以在定義圓形的位置，如果不想跑到圖框外，務必cx、cy要大於r的值。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;50&quot; style=&quot;stroke: gray; fill: 339966;&quot;/&gt; &lt;/svg&gt; 橢圓形橢圓形概念和圓形也相當類似，只是將半徑r的值改成垂直及水平半徑rx、ry。 &lt;svg width=&quot;100%&quot; height=&quot;100&quot;&gt; &lt;ellipse cx=&quot;100&quot; cy=&quot;50&quot; rx=&quot;80&quot; ry=&quot;30&quot; style=&quot;stroke: gray; fill: 990000;&quot;/&gt; &lt;/svg&gt; 小結咦…到目前為止是不是太容易點…。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"SVG Group","slug":"SVG-G","date":"2014-04-29T16:00:00.000Z","updated":"2016-10-12T06:38:43.000Z","comments":true,"path":"svg/2014/04/30/SVG-G/","link":"","permalink":"https://wcc723.github.io/svg/2014/04/30/SVG-G/","excerpt":"上一篇有簡單介紹一下SVG的元素，雖然沒有介紹很詳細，但是很多部分都和Canvas很相近，所以就不詳細介紹了。 而這篇要介紹svg &lt;g&gt;這個標簽，它的用途是群組化元素，而被群組後的元素就可以一起被控制，甚至是一起設定樣式。","text":"上一篇有簡單介紹一下SVG的元素，雖然沒有介紹很詳細，但是很多部分都和Canvas很相近，所以就不詳細介紹了。 而這篇要介紹svg &lt;g&gt;這個標簽，它的用途是群組化元素，而被群組後的元素就可以一起被控制，甚至是一起設定樣式。 群組svg SVG 上面的文字與方塊已經算是一個群組了，接下來可以在&lt;g&gt;這個元素，使用變形(transform)來一起改變外觀，像是以下這樣。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g transform=&quot;rotate(-10)&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; 像以上這樣，&lt;g&gt;群組就會被旋轉(-10 deg)。 G 的繼承在G裡面的元素，都會被外層&lt;g&gt;所設定的樣式影響，像以下內部的元素沒有設定外框，但卻可以繼承其父層的&lt;g&gt;樣式。 也就像CSS一樣，如果子元素有設定，則子元素優先。 &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g style=&quot;stroke: pink; stroke-width: 5px&quot;&gt; &lt;circle cx=&quot;40&quot; cy=&quot;35&quot; r=&quot;30&quot; style=&quot;fill: white;&quot;/&gt; &lt;circle cx=&quot;120&quot; cy=&quot;35&quot; r=&quot;30&quot; style=&quot;fill: white;&quot;/&gt; &lt;rect x=&quot;160&quot; y=&quot;5&quot; width=&quot;40&quot; height=&quot;40&quot; style=&quot;fill: white;&quot;/&gt; &lt;rect x=&quot;220&quot; y=&quot;5&quot; width=&quot;40&quot; height=&quot;40&quot; style=&quot;fill: red;&quot;/&gt; &lt;/g&gt; &lt;/svg&gt; G 沒有X,Yㄜ，反正就是沒有，這樣似乎有點困擾。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g x=&quot;40&quot; y=&quot;20&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; 向上面這樣，就算有設定&lt;g&gt;的x,y值，但就是完全沒有反應，如果要控制&lt;g&gt;的位置，就要用transform了。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g transform=&quot;translate(40,20)&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/g&gt; &lt;/svg&gt; 利用transform=”translate(40 20)”，就可以位移了，這用法和CSS3 transform相當接近，雖然類似x,y但本質上還是有所不同。 SVG &lt;svg width=&quot;100%&quot; height=&quot;150&quot;&gt; &lt;g&gt; &lt;svg x=&quot;40&quot; y=&quot;20&quot;&gt; &lt;rect y=&quot;10&quot; width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;text x=&quot;0&quot; y=&quot;130&quot; style=&quot;stroke: pink; fill: white&quot;&gt; SVG&lt;/text&gt; &lt;/svg&gt; &lt;/g&gt; &lt;/svg&gt; 不過我沒想到的是，svg還可以這樣用，在&lt;g&gt;裡面再放一個&lt;svg&gt;，這樣就可以設定他的x,y，這招太絕了，這樣就可以避免使用translate，使用x,y來設定位置。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"SVG 簡介","slug":"SVG-intro","date":"2014-04-20T16:00:00.000Z","updated":"2016-10-12T06:37:58.000Z","comments":true,"path":"svg/2014/04/21/SVG-intro/","link":"","permalink":"https://wcc723.github.io/svg/2014/04/21/SVG-intro/","excerpt":"好久沒寫文章了，這段時間工作還是經常的會翻這Blog的資料，裡面很多很多的技術雖然很基礎，但是就是很實用。 所以呢！現在要挑戰”基礎”SVG！","text":"好久沒寫文章了，這段時間工作還是經常的會翻這Blog的資料，裡面很多很多的技術雖然很基礎，但是就是很實用。 所以呢！現在要挑戰”基礎”SVG！ 無限期支持向量技術我早期多以Illustrator進行平面設計，所以在轉網頁設計這行業也是多以Illustrator，雖說許多同行的都建議用Photoshop，但我不這麼認為，且更堅定的要繼續以向量設計為主(但不會只有用Illustrator…)。 SVG簡介SVG(Scalable Vector Graphics)，中文直譯就是”可縮放向量圖形“，它是以XML格式儲存。而在瀏覽器上是從IE9後才開始支援SVG。 SVG優點 向量物件(Vector)，不同於點陣，向量並不會有解析度的問題，可自由的縮放。 嵌入式外部影像，包括PNG、JPEG、SVG等。 可有文字物件(可以被搜尋)。 開發人員可利用DOM抓取SVG物件。 SVG 範例(直接繪製) &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;100%&quot; height=&quot;120&quot;&gt; &lt;rect width=&quot;100&quot; height=&quot;100&quot; style=&quot;stroke: #777; stroke-width: 3; fill: #07B492;&quot;/&gt; &lt;/svg&gt; 在svg標簽內就可以直接開始繪製向量圖型，而其中xmlns=&quot;http://www.w3.org/2000/svg&quot;在微軟MSDN的解釋為定義SVG區段的命名空間，目前我測試移除也沒什麼差別。 SVG 外部圖形圖片來源 http://seeklogo.com/tag.html?q=Google 外部PNG &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;100%&quot; height=&quot;180&quot;&gt; &lt;image width=&quot;447&quot; height=&quot;179&quot; xlink:href=&quot;/images/google-logo.png&quot;/&gt; &lt;/svg&gt; 外部SVG &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot; width=&quot;100%&quot; height=&quot;180&quot;&gt; &lt;image width=&quot;447&quot; height=&quot;179&quot; xlink:href=&quot;/images/google-logo.svg&quot;/&gt; &lt;/svg&gt; 雖然SVG是向量的圖形，如果和Canvas做比較還有許多不同的特點，像是Html dom、外部點陣圖、不需要js也能繪製。 而這兩個技術的差別，網路上也有許多文章有提到，但我希望在日後再比較兩者的差異。 對SVG還不到相當了解可以寫非常長的文章，但我不認為要寫夠分量才值得算一篇文章，學習過程中過度的要求，會影響到學習技術的熱誠以及效率，所以很快就會有下一篇了(應該)。","categories":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/categories/svg/"}],"tags":[{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"Sprites for Retina","slug":"css-icon-sprites","date":"2014-03-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/03/24/css-icon-sprites/","link":"","permalink":"https://wcc723.github.io/css/2014/03/24/css-icon-sprites/","excerpt":"上禮拜教召，讓這篇已經準備好的文章又拖了一個禮拜…，然後現在打開卻有點忘記怎麼做…。 Compass sprites for retina來源：https://speakerdeck.com/hlb/maintainable-css-with-sass-and-compass Hlb的簡報有介紹，本篇也是參考此簡報做的。","text":"上禮拜教召，讓這篇已經準備好的文章又拖了一個禮拜…，然後現在打開卻有點忘記怎麼做…。 Compass sprites for retina來源：https://speakerdeck.com/hlb/maintainable-css-with-sass-and-compass Hlb的簡報有介紹，本篇也是參考此簡報做的。 本篇重點延續上一篇，利用compass製作sprites for retina，讓png icons在行動裝置以及有更高解析度的螢幕有更好的表現。 準備工作和上篇一樣，圖片是從http://icomoon.io/下載作為範例用，但這次是要有兩種size(其實上次就有做好了)。 而兩個資料夾對應的圖片檔名也要相同，但記得尺寸寬及高是各兩倍。 Sass首先先到https://gist.github.com/estahn/3837343下載_compass-retina-sprites.scss這隻檔案，這一個mixin中有一段device-pixel-ratio，這可以判斷目前裝置的像數比(相關文章http://rettamkrad.blogspot.tw/2013/04/retina-device-and-web-develop.html)。 如果不是很清楚，建議可以先看那篇文章，接下來就開始sass實做了。 @import compass-retina-sprites.scss //匯入普通版的icons $icons-spacing: 1px $icons-sprite-dimensions: true @import &quot;icons/*.png&quot; @include all-icons-sprites //匯入2x size的icons $icons2x-spacing: 1px $icons2x-sprite-dimensions: true @import &quot;icons2x/*.png&quot; @include all-icons2x-sprites //製作成retina款式 @include all-retina-sprites($icons-sprites, $icons2x-sprites) 接下來會產生兩種size的png sprites。 普通size 2x size 使用其實用法和上一篇一模一樣，透過css media會判斷裝置是要用哪種icons sprites，以下有兩個demo，有retina裝置的使用者不妨看看兩者之間的差異吧~(一般螢幕兩者看到的會一樣)。 &lt;div class=&quot;icons-mobile&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons-phone&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons-nice&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons-setting&quot;&gt; &lt;/div&gt; 一般 Sprites Retina Sprites 比較圖這邊另外附上比較圖。 現在許多網站的icons sprites也有做for retina，像是facebook新版的網站，當然還有非常多，不妨四處觀察看看吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Spriting with Compass","slug":"css-icon-sprites","date":"2014-03-12T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/03/13/css-icon-sprites/","link":"","permalink":"https://wcc723.github.io/css/2014/03/13/css-icon-sprites/","excerpt":"因為最近剛轉換工作，所以一段時間沒寫文章，沒寫文章的時間雖然不至於會退步，但會感覺到進步遲緩…。 這次來介紹利用Compass製作sprites，sprites 就像是的Google icons，他把許多的icons集合在同一張的png，這樣可以減少用戶對於伺服器的請求數。而這次會有兩篇sprites文章，本篇是介紹基本的sprites，下次介紹retina版sprites。 Compass sprites來源：http://compass-style.org/help/tutorials/spriting/","text":"因為最近剛轉換工作，所以一段時間沒寫文章，沒寫文章的時間雖然不至於會退步，但會感覺到進步遲緩…。 這次來介紹利用Compass製作sprites，sprites 就像是的Google icons，他把許多的icons集合在同一張的png，這樣可以減少用戶對於伺服器的請求數。而這次會有兩篇sprites文章，本篇是介紹基本的sprites，下次介紹retina版sprites。 Compass sprites來源：http://compass-style.org/help/tutorials/spriting/ 本篇重點利用compass製作css sprites，而在下一篇會介紹如何製作retina版本css srpites。 準備工作首先先準備些icons到自己的images資料夾內，而本篇的圖片是從http://icomoon.io/下載作為範例用，如下圖所示。 我在icons資料夾內放入了幾張不同size的圖檔，另外切記，製作sprites請存png。 Sass接下來開始Sass吧。 @import &quot;icons/*.png&quot; //匯入圖檔 @include all-icons-sprites //將圖檔轉成 sprites 接下來會在資料夾內看到以下的圖檔，這樣就成功一半了。 在CSS檔內會看到這樣的結果，icons是資料夾名稱，mobile是檔名，兩個串在一起就是一個class，但這範例缺少一個重要的屬性…，就是寬跟高。 .icons-mobile { background-position: 0 -134px; } Compass sprites 設定值http://compass-style.org/help/tutorials/spriting/customization-options/ Compass sprites有提供許多的設定值，相關的參數如以上網址，我們以$&lt;map&gt;-spacing為例，這是可以讓產生的sprites每張縮圖產生間距，只要把&lt;map&gt;替換成資料夾名稱即可。 如以下sass，就可以讓每張縮圖額外有1px的間距，這樣的sprites icons也比較不會互相干擾。 //$&lt;map&gt;-spacing $icons-spacing: 1px 而另一個設定是讓每一個class都會寫入當初匯入的png寬與高，$&lt;map&gt;-sprite-dimensions預設值為false，只要改為true就會將每個icon加上寬與高。 只要將這些設定值，寫在匯入的png前方，在匯入後就會依據這些設定做成sprites。 $icons-spacing: 1px $icons-sprite-dimensions: true @import &quot;icons/*.png&quot; @include all-icons-sprites 這樣匯入的每張圖，都會被補上寬與高。 .icons-mobile { background-position: 0 -137px; height: 49px; width: 30px; } 完成在tag內直接填上對應的class名稱，就可以使用了。 &lt;div class=&quot;icons1-mobile&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons1-phone&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons1-nice&quot;&gt; &lt;/div&gt; &lt;div class=&quot;icons1-setting&quot;&gt; &lt;/div&gt; 這樣就可以省去一大半用css算sprites位置的時間囉～。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Jquery 重複click判斷","slug":"jquery-repeat-click","date":"2014-02-28T16:00:00.000Z","updated":"2016-10-11T09:48:48.000Z","comments":true,"path":"jquery/2014/03/01/jquery-repeat-click/","link":"","permalink":"https://wcc723.github.io/jquery/2014/03/01/jquery-repeat-click/","excerpt":"今天要分享的是Jquery 重複click判斷。 來源參考http://jsfiddle.net/visualidiot/WJEBr/","text":"今天要分享的是Jquery 重複click判斷。 來源參考http://jsfiddle.net/visualidiot/WJEBr/ $('.d0818click').click(function(evt) { evt.preventDefault(); $('.old').animate({left: '+=10'}); $('.new').is(':animated') || $('.new').animate({left: '+=10'}); }); 點我 $('.d0818').click(function() { $('.old').animate({left: '+=10'}); $('.new').is(':animated') || $('.new').animate({left: '+=10'}); });","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"大陸面試題 如何反轉元素內容","slug":"reverse-element","date":"2014-02-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/02/26/reverse-element/","link":"","permalink":"https://wcc723.github.io/css/2014/02/26/reverse-element/","excerpt":"最近大陸網路上有篇問題文，問題：看到一道面試題：ul有10000 個li子元素，如何將這10000 個li顛倒順序。而其中有一個神回復，真的是活用CSS3的特色，所以在這邊分享給大家看看(本篇以150個為例)。 來源：http://v2ex.com/t/100982","text":"最近大陸網路上有篇問題文，問題：看到一道面試題：ul有10000 個li子元素，如何將這10000 個li顛倒順序。而其中有一個神回復，真的是活用CSS3的特色，所以在這邊分享給大家看看(本篇以150個為例)。 來源：http://v2ex.com/t/100982 神回復在本篇的五樓已經有對此文做了神回復。 ul {transform: rotate(180deg)} li {transform: rotate(180deg)} 搞定 簡單來說，就是反轉一次外圈，在反轉一次個別的元素，來達到這個效果。 ul +transform(rotate(180deg)) li +transform(rotate(180deg)) 我的提案其實他的已經是神回復了，要超越它實在是太難了，所以我提出另一個方式，就是使用display: flex，利用flex-direction來反向排列其內容。 ul display: flex flex-direction: column-reverse 兩個結果如下，最左方的是原始題目，中間是神回復，最右方是利用display: flex。 codepen :http://codepen.io/Wcc723/pen/GFgtm 以上是針對此題目的兩個CSS解法，還有人想到其他解決方案嗎？","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS設定中英文不同的字體","slug":"font-code-range","date":"2014-02-20T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/02/21/font-code-range/","link":"","permalink":"https://wcc723.github.io/sass/2014/02/21/font-code-range/","excerpt":"Just font中的字型學文章都相當有意思，而有一篇是關於中英文字搭配的問題；這篇雖然是以windows word為例，但裡面的概念在網頁上也是很有幫助，而其中一段”以 Windows 內建的三種字型為例，表現最好的是微軟正黑體，英文部分採用了微軟的 Segoe UI，粗細與中文較一致“，在目前web中當然也可以有這樣的設定，只要用CSS3的unicode-range，就能夠在中文字中套用”微軟正黑體”，英文套用”Segoe UI”。","text":"Just font中的字型學文章都相當有意思，而有一篇是關於中英文字搭配的問題；這篇雖然是以windows word為例，但裡面的概念在網頁上也是很有幫助，而其中一段”以 Windows 內建的三種字型為例，表現最好的是微軟正黑體，英文部分採用了微軟的 Segoe UI，粗細與中文較一致“，在目前web中當然也可以有這樣的設定，只要用CSS3的unicode-range，就能夠在中文字中套用”微軟正黑體”，英文套用”Segoe UI”。 本篇參考 利用 CSS 分別設定中文字、英數、注音、假名的字體：使用 CSS3 @font-face 大眾字型學(3)：Word 預設中英搭配有什麼問題？ Uni-code 字符百科 本篇重點了解unicode-range的使用方法。 效果展示unicode-range部分效果在Mac OS上測試有問題，不管是Chrome、Safari、Firefox都有點問題…。 這一句話只有\"我\"會被換成黑體 以上面這一段文字為例，在windows內，”我”這一個文字會被替換成微軟正黑體，而其他文字沒有變化。 https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-range 如果參考Mozilla 的MDN可以了解到， unicode-range: U+26 /* 單一字符 */ unicode-range: U+0025-00FF /* 範圍字符 */ unicode-range: U+4?? /* 萬用字符 */ unicode-range: U+0025-00FF, U+4?? /* 利用&apos;,&apos;，多選取字符 */ http://unicode-table.com/cn/ 再參考uni code的表，可以查詢各文字的unicode。 用這樣的方式就能夠選取特定的文字，或是語系等等。 @font-face font-family: custom-Iam src: local(&quot;Heiti TC&quot;), local(&quot;微軟正黑體&quot;), local(&quot;Microsoft JhengHei&quot;) unicode-range: U+6211 .custom-Iam font-family: custom-Iam 針對指定語系設定在一般來說，通常換字體沒有針對語系，就像下方這一個範例，我將字體換成了’Mac OS 黑體-繁’、’Windows 微軟正黑體’，但在中英文排版中，用同一種字體不一定合適(請看just font)。 This is 一個中文English交雜的sentence 中文的語系的unicode-range為U+4E00-9FFF，英語系為U+00-024F，將這個值加入到@font-face內，就能為特定語系換字體。如下範例中文還是’Mac OS 黑體-繁’、’Windows 微軟正黑體’，但英文的部份已經替換成’Helvetica’、’Segoe UI’，範例如下。 This is 一個中文English交雜的sentence 在css內只要將兩者的font-family皆設定相同名稱，但指向不同的unicode-range，就可以達到這樣的效果。 @font-face font-family: custom-sans-serif src: local(&quot;Heiti TC&quot;), local(&quot;微軟正黑體&quot;), local(&quot;Microsoft JhengHei&quot;) unicode-range: U+4E00-9FFF @font-face font-family: custom-sans-serif src: local(Helvetica), local(Segoe UI) unicode-range: U+00-024F .custom-sans-serif font-family: custom-sans-serif 其他範例不只在黑體能夠這樣做，明體當然也可以。 This is 一個中文English交雜的sentence @font-face font-family: custom-serif src: local(&quot;LiSong Pro&quot;), local(&quot;新細明體&quot;), local(&quot;PMingLiU&quot;) unicode-range: U+4E00-9FFF @font-face font-family: custom-serif src: local(Times), local(Times New Roman) unicode-range: U+00-024F .custom-serif font-family: custom-serif 延伸發現在字符百科中，不僅可以查詢的文字的unicode 編號，其實還可以查到許多符號性的文字，這些文字其實可以直接當作web font使用，還免載入外部的字型檔，就像下方的幾個不同雪花一樣。 ❄❅❆","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass 模組開發","slug":"sass-component","date":"2014-02-13T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2014/02/14/sass-component/","link":"","permalink":"https://wcc723.github.io/sass/2014/02/14/sass-component/","excerpt":"最近社群上有人分享了一個連結，是關於sass模組製作的教學，大致看了一下，發現和我的方式頗為接近，所以就在這介紹我的Sass模組開發方式。 http://www.sitepoint.com/sass-component-10-minutes/","text":"最近社群上有人分享了一個連結，是關於sass模組製作的教學，大致看了一下，發現和我的方式頗為接近，所以就在這介紹我的Sass模組開發方式。 http://www.sitepoint.com/sass-component-10-minutes/ 本篇重點以按鈕模組為例，示範Sass模組開發。 效果展示 btn-default demo-btn demo-btn Validation demo-btn Error demo-btn Warning demo-btn Information &lt;a href=&quot;#&quot; class=&quot;demo-btn&quot;&gt;demo-btn&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Validation&quot;&gt;demo-btn Validation&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Error&quot;&gt;demo-btn Error&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Warning&quot;&gt;demo-btn Warning&lt;/a&gt; &lt;a href=&quot;#&quot; class=&quot;demo-btn Information&quot;&gt;demo-btn Information&lt;/a&gt; 以上是分為兩組的範例，上面那一組是模組預設值，而下方這組是透過變數以及@each來快速產生，透過這個方式，可以有效的管理CSS程式碼，以及增加開發速度。 模組開發流程首先，分為兩個部分，一個是共通的屬性，另一部份是可變動的屬性；共通部分就是基本的格式，也是模組最基礎的屬性，可變動的可以如顏色、大小、對齊方式等等，而本篇則是用顏色。 建立@extend 及@mixin@extend就是模組的共通屬性，如果不清楚的，可以和下方的@mixin一起參考。 %buttonDemo color: #fff text-decoration: none padding: .3em 1em display: inline-block text-align: center vertical-align: middle cursor: pointer text-shadow: -1px -1px 0 rgba(00,00,00,0.3) +border-radius(3px) +box-sizing(border-box) +box-shadow(inset 0 .1em 0 rgba(255, 255, 255, .2), 0 1px 2px rgba(0, 0, 0, 0.05)) +transition(box-shadow .2s) &amp;:hover +box-shadow(inset 0 .1em .3em rgba(0, 0, 0, .3),0 1px 2px rgba(0, 0, 0, 0.05)) color: #fff &amp;:focus,&amp;:active,&amp;.current +box-shadow(inset 0 .1em .6em rgba(0, 0, 0, .4),0 1px 2px rgba(0, 0, 0, 0.05)) @mixin就是一個基本的模組，將顏色屬性先挑選出來，再透過Sass的運算可以產生許多樣式，而@extend可以避免CSS檔產生過多不必要的程式碼。 $defaultColor: #107FC9 //預設色彩 @mixin buttonDemo($className: btn-default,$color: $defaultColor) $darkenColor: saturate(darken($color, 10%),15%) $lightenColor: saturate($color, 2%) .#{$className} @extend %buttonDemo border: 1px solid $darkenColor background-color: $lightenColor margin: 1px &amp;:hover,&amp;.current background-color: $darkenColor btn-default 到這部分就有一個基本的按鈕樣式。 利用@each 大量製作+buttonDemo(.demo-btn.Validation, #5cb85c) +buttonDemo(.demo-btn.Error, #d9534f) +buttonDemo(.demo-btn.Warning, #f0ad4e) +buttonDemo(.demo-btn.Information, #5bc0de) 到了這部分，其實我們可以利用上面的方式來產生多樣模組，但其實.Validation以及後方的色彩#5cb85c都是可以重複使用的，如果我們利用$each，除了在這一個模組會更好管理外，還可以用來製作其他模組。 首先，先定義基本的class名稱及色彩。參考 $button-types: (Validation, #5cb85c) (Error, #d9534f) (Warning, #f0ad4e) (Information, #5bc0de) 製作一個新的@mixin，利用$each將每一個class名稱及色彩套用至buttonDemo這一個@mixin內。 @mixin DemoButtons($prefix: demo-btn) +buttonDemo($prefix, $defaultColor) //載入預設的樣式 @each $button-type in $button-types $thisClass: nth($button-type, 1) $thisColor: nth($button-type, 2) $thisallClass: $prefix+&quot;.&quot;+$thisClass +buttonDemo($thisallClass, $thisColor) +DemoButtons() demo-btn demo-btn Validation demo-btn Error demo-btn Warning demo-btn Information 用這方式就可以完成sass模組，且包含了許多樣式。而這模組的架構，是我目前在測試的，有興趣的可以參考就好，畢竟CSS寫法相當多樣，只有適合沒有完美的寫法，下方另外提供codepen範例。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"做網頁如果缺Icons怎麼辦","slug":"web-font-icons","date":"2014-02-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/02/10/web-font-icons/","link":"","permalink":"https://wcc723.github.io/css/2014/02/10/web-font-icons/","excerpt":"最近很多人跟我討論到的網站上icon的問題，如果要畫icon要花多久時間、使用的方法等等。而以我來說，較傾向使用免費icons或者是付費的向量icon，不建議自己畫這些icon，因為要畫一個icon所花的時間成本，都可以買一套200枚的icons了= =。 而今天要推薦的是ico moon，這在之前就有推薦過，而這次的教學，要針對於要直接使用他的icons在網頁上。 http://icomoon.io/","text":"最近很多人跟我討論到的網站上icon的問題，如果要畫icon要花多久時間、使用的方法等等。而以我來說，較傾向使用免費icons或者是付費的向量icon，不建議自己畫這些icon，因為要畫一個icon所花的時間成本，都可以買一套200枚的icons了= =。 而今天要推薦的是ico moon，這在之前就有推薦過，而這次的教學，要針對於要直接使用他的icons在網頁上。 http://icomoon.io/ 本篇重點使用Ico Moon web-font icons在網頁上，並且了解其特性。 效果展示 &lt;span class=&quot;icon-phone&quot; style=&quot;font-size: 3em&quot;&gt;&lt;/span&gt; 上面理當來說，可以看到一隻電話，使用上和bootstrap的icon相當類似，但不同的是它用偽元素插入文字，透過web-font轉換成圖形，所以基本上是需要支援偽元素的瀏覽器才能使用，在不支援的瀏覽器(ex: ie7)，ico moon也有提供解決的方式，所以大可盡量使用。 由於是web-font，屬於字體的一種，所以可以把它當作文字的屬性，自由的調整它的顏色(color)及大小(font-size)。 使用Ico Moonhttp://icomoon.io/ 首先，請打開以上連結，Ico Moon有提供web-font icon的製作，以及大量的icon，另外也可以付費取得更進階的服務。 在進入網頁後，點選右上方的Launch App，開啟製作web-font的應用程式介面。 在應用程式內可以看到大量的icons，當然是可以把他們全部通通選起來，但要記得，選越多檔案越大…，其中我喜歡Entypo這組，我就把這群組的選起來。 選完後點下面的font。 如果不想下載下來，可以點quick used，而本篇會介紹下載到本機使用。 設定在以上的步驟完後，其實就可以點選下載，其實還有提供許多設定值，如：ie7 support…。 在上一張圖的右上方，有Preferences的選項，裡面就有許多設定…。 這裡面有許多設定，參考如下： Encode &amp; Embed Font in CSS 字體內嵌入CSS檔(不需要外部字型檔) Support IE 7 (and older) 支援萬惡IE7 Include Metadata in Fonts 不清楚.. Use Class Selector 不使用屬性選取器，改用自訂選取器(如果不清楚，就用內建的吧) Font Metrics 字體規格 再都設定完後，請選擇下方的Download到本機，並且解壓縮後打開demo.html。 裡面會看到這一個範例檔，可以查詢到每一個icon所使用的Class以及範例。 使用在自己的網頁上解壓縮後，有許多的檔案，其中請把以下三個資料夾或檔案複製到自己的專案上(如果沒有support ie7就不會有ie7資料夾)。 style.css /ie7/ /fonts/ 在專案內的html檔只要插入以下程式碼，即可開始使用(如果沒有support ie7，就僅需要以下第一行)。 &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot;&gt; &lt;!--[if lt IE 8]&gt;&lt;!--&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;ie7/ie7.css&quot;&gt; &lt;!--&lt;![endif]--&gt; 範例 ie7IE 7的部分，由於新的大魔王IE 11出現，測試一直有問題，所以我用Aurora 瀏覽器模擬IE7進行測試，結果是可以的，如果有純正IE 7的使用者，不妨試試看…(不是在本站測試，本站並沒有載入ie7 fix)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"},{"name":"icons","slug":"icons","permalink":"https://wcc723.github.io/tags/icons/"}]},{"title":"Amazon book 書籍封面展示效果 (CSS 3D)","slug":"amazon-books","date":"2014-01-26T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/01/27/amazon-books/","link":"","permalink":"https://wcc723.github.io/css/2014/01/27/amazon-books/","excerpt":"自從學了CSS 3D後，就一直想嘗試使用在網頁上，但除了形象網頁外，使用CSS 3D的網站似乎不是很多，畢竟這不是必要的效果。而最近在Amazon Books的購物商城上，發現他們有用CSS 3D在展示書籍的正反面。 Amazon books","text":"自從學了CSS 3D後，就一直想嘗試使用在網頁上，但除了形象網頁外，使用CSS 3D的網站似乎不是很多，畢竟這不是必要的效果。而最近在Amazon Books的購物商城上，發現他們有用CSS 3D在展示書籍的正反面。 Amazon books 本篇重點試試看Amazon Books中的書籍展示效果，到底包含了些什麼CSS 語法。 效果展示這效果我是做在codepen 上，裡面的封面圖片是直接連結台灣博客來書店，所以如果掉圖就是…被下架了。 codepen連結 在滑鼠滑過書上方時，書本會呈現微開，這會讓使用者感覺書本可以點擊(在Amazon Books中，點擊書本就可以看書的簡介)；而在hover過下方的flip to back時，書會翻轉30度，如果點擊則會翻轉180度，這樣就可以看到書的背面。 語法結構題外話，最近我正在學slim，所以codepen上的html是用slim寫的，這邊就先介紹一下html的結構吧。 html結構&lt;div class=&quot;wrap&quot;&gt; &lt;div class=&quot;imgWrap&quot;&gt; &lt;img src=&quot;#...&quot; alt=&quot;&quot; class=&quot;first-child&quot;&gt; &lt;img src=&quot;#...&quot; alt=&quot;&quot; class=&quot;second-child&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;a href=&quot;#&quot; class=&quot;fliptoBack&quot;&gt;|flip to back&lt;/a&gt; .wrap 用途是來定位整體的位置 .imgWrap 書本的外圍架構，並且做翻轉書本的效果 img .first-child 書的正面 img .second-child 書的背面 Js在看CSS前，我想先說明js的部分，有些地方沒有辦法用css達成的，會用js去完成，避免等等css的誤解，先介紹一下我的script寫了什麼。 先取得第一張封面的寬高定義為w,h w = $(&apos;.first-child&apos;).width(); h = $(&apos;.first-child&apos;).height(); //將外框及第二張圖設定成相同的寬高 $(&apos;.imgWrap, .wrap, .second-child&apos;).width(w); $(&apos;.imgWrap, .wrap, .second-child&apos;).height(h); 滑過下方文字時，將書本套用&apos;.flip&apos;的class $(&apos;.fliptoBack&apos;).hover(function() { $(&apos;.imgWrap&apos;).toggleClass(&apos;flip&apos;); }); 點擊下方文字時，將書本套用&apos;.flip180&apos;的class $(&apos;.fliptoBack&apos;).click(function() { $(&apos;.imgWrap&apos;).toggleClass(&apos;flip180&apos;); }); CSS依慣例，我是用sass寫…，另外就是有點長。 $bookwidth: 60px //先定義書本的&quot;厚度&quot; .wrap +perspective(1200px) //3D的景深 position: relative margin: 40px auto 20px auto .fliptoBack //下方文字的位置 display: block text-align: center .imgWrap +transform-style(preserve-3d) //先定義成transform3d的模式 +transition(transform .5s ease) //針對transform進行動畫 position: absolute &amp;:before //這一塊是要假裝成書的內頁 content: &quot;&quot; position: absolute width: 100% height: 100% +border-right-radius(5px) background: black &amp;:after //這邊是書背 content: &quot;&quot; position: absolute left: 0 top: 0 height: 100% width: $bookwidth background: black +transform3d(rotateY(90deg)) +transform-origin(0) &amp;.flip //在滑鼠掠過下方文字時，套用的&apos;.flip&apos; +transform3d(rotateY(30deg)) //翻轉30度 &amp;.flip180 //點擊時套用的&apos;.flip180&apos;，用來翻轉180度 +transform3d(rotateY(180deg) translateZ($bookwidth)) //另外再翻轉180度後，必須調整書本的Z軸，讓他在視覺上位置不變 img //兩張圖片的設定 position: absolute top: 0 left: 0 border: #ccc 1px solid +transition(transform .3s ease) +backface-visibility(hidden) //不顯示背面 +border-right-radius(3px) +box-sizing(border-box) &amp;.first-child //定義第一張圖片，並且滑鼠滑過時旋轉30度 +transform3d(rotateY(0deg)) +transform-origin(0) z-index: 2 &amp;:hover +transform3d(rotateY(-30deg)) &amp;.second-child //讓封底一開始時就反轉到另一面 +transform3d(rotateY(-180deg) translateZ($bookwidth)) CSS 3D很有趣，只是看起來code有點長，但是玩一段時間會很有成就感。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"從CSS到Sass 學習分享","slug":"css-to-sass","date":"2014-01-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/01/22/css-to-sass/","link":"","permalink":"https://wcc723.github.io/css/2014/01/22/css-to-sass/","excerpt":"本身是視覺設計系所畢業，在學期間雖然有做過網站，但其實Html及CSS可以算沒有寫過，連html需要結尾都不知道。兩年前，進路職場還是相當依賴Dreavweaver，所以更別說Sublime text這麼潮的工具，我是根本連聽都沒聽過。 但到了現在，對於CSS及Sass已經可以和人侃侃而談，閒暇之餘還去參加鐵人賽分享一下CSS3的研究心得；而這當中，我覺得最重要的就是”開始”的行為，不論是從基礎的CSS，或者是利用Sass開發，只要跨出了第一步，剩下就容易許多了。","text":"本身是視覺設計系所畢業，在學期間雖然有做過網站，但其實Html及CSS可以算沒有寫過，連html需要結尾都不知道。兩年前，進路職場還是相當依賴Dreavweaver，所以更別說Sublime text這麼潮的工具，我是根本連聽都沒聽過。 但到了現在，對於CSS及Sass已經可以和人侃侃而談，閒暇之餘還去參加鐵人賽分享一下CSS3的研究心得；而這當中，我覺得最重要的就是”開始”的行為，不論是從基礎的CSS，或者是利用Sass開發，只要跨出了第一步，剩下就容易許多了。 如果已經跨出了第一步，剩下很容易就達成了。 基礎的學習 http://www.w3school.com.cn/css/ 當決定要學CSS時，就開始到處搜尋基礎的課程，相關的資源非常的多，只是怎樣的課程是好的課程，我當時的選擇是夠詳細且自己能夠理解的，上方這個就達到我的需求，這邊也推薦給大家。 這一個教程在CSS2的介紹算是非常全面且實用性很高，如果是有興趣的開發者或設計師，建議把此教程從頭看完。而其中我最推薦其中一個章節”CSS選取器”，這裡所介紹的基本選取器，許多CSS老手都不一定了解，詳讀之後必定會覺得功力大增。而本教程所不足的部分，建議可以參考以下連結，兩者都是W3C所提供的，內容其實大同小異，只是下方連結有更進階的CSS3教學。 http://www.w3schools.com/ 基礎非常的重要，馬步站的穩，怎樣也推不倒。 透過開發工具研究他人作品 基礎了解後，活用也是一個重點，但總不能憑空就能活用，所以可以透過平常的搜尋，發現不錯的網頁設計排版，就可以透過開發者工具去一層層的了解。 開發者工具推薦使用Chrome或是Firefox，尤其是前者目前有廣大的使用者支持，學習的重點可以放在： HTML的構造 CSS的語法 偽元素的運用 (pseudo-elements) 各種selector的運用 是否有結合javascript 至於開發者工具的使用技巧，就不在本篇的介紹囉～，最簡單的方法就是Chrome瀏覽器&gt;右鍵&gt;檢查元素 就可以開始玩了。 模仿是學習的開始。 廣泛的了解 除了自學外，要不斷地去了解新的動態，透過自己的搜尋探索，那簡直就是在黑暗中找物品，透過社群以及追蹤可以省去許多時間，只要一有新的動態，每個社群就會開始輪流發送，基本上不用擔心失去任何的訊息。這邊就推薦幾個活動力不錯的社群(台灣)： 高雄前端社群(這規定要放第一個) 為薄滴賽 = Web Design RGBA 網頁設計師社群 KSDG(高雄軟體社群超友情推薦) HTML5與CSS3在台灣(超專業社群) 一般的初學者，也可以透過以上順序當作入門的選擇(越上的越有親切感!?)，在進入社群後不只可以收到新的技術訊息、其他高手的協助，當有問題時在社群發問，也可以很迅速的獲得答案。 但要注意，社群雖然可以獲得許多的資源，但資源的篩選就是在個人。例如從社群可以知道Less、stylus、sass等CSS的進階語言，知道後就透過這些關鍵字去搜尋這些語言的相關資源，評估何種語言是最適合自己，再擇一去學習及精通。 俗話說：在家靠父母，出外靠朋友。 進階的學習 還是回到一開始所說的，跨出第一步是最重要的。Sass要從哪一個專案開始用？CoffeeScript要什麼開始學？想那麼多，不如下一個專案就開始吧，只要開始後，慢慢的學習，持之以恆的做下去，那麼這一個技能就是你的了。 就以Sass來說，其實我是在只會階層式語法就直接開始用了，反正編譯出來真的有問題(基本上也不會有什麼問題)，當CSS改也沒關係，最重要的事，我開始用sass了。只要有那個心，隨時都可以開始，但如果不斷的想下次再試試看，那就是永遠的下次。 一步一步慢慢走，持之以恆下去，目標就在眼前。 挑戰自己除了在專案上挑戰自己外，也可以再有空閒的時間嘗試新的技巧。2013年的鐵人賽對我影響很大，那時候正在挑戰每天發一篇文章，因為鐵人賽的關係，必須提升文章的品質，並且更深入的研究CSS3，在鐵人賽結束的時候，從本來不會CSS transform到可以運用許多transform 3D的技法。 到了現在，每天發文就是一個習慣，一段時間不發文就會有罪惡感-O-，而這到底是興趣還是被迫…？算興趣吧，但某方面來說已經變強迫症(笑)。 以上提到的，最重要還是一個”開始”，如果不知道怎麼開始，可以問問上方社群的人，不然就點畫面最下方有我的facebook，就來問我吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"在Jekyll中調整屬於自己的Template","slug":"jekyll-define-page","date":"2014-01-14T16:00:00.000Z","updated":"2016-10-12T06:28:55.000Z","comments":true,"path":"jekyll/2014/01/15/jekyll-define-page/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/15/jekyll-define-page/","excerpt":"會用jekyll有一部分是想要自己設計版型，我所擅長的是視覺設計、HTML、CSS，我就用這幾個技能設計自己的版型，當然這並不是那麼的一兩篇就可以介紹完。所以這篇會說明一個範例，介紹Jekyll中的版型運作邏輯，有興趣的使用者可以依據這概念設計屬於自己的blog。","text":"會用jekyll有一部分是想要自己設計版型，我所擅長的是視覺設計、HTML、CSS，我就用這幾個技能設計自己的版型，當然這並不是那麼的一兩篇就可以介紹完。所以這篇會說明一個範例，介紹Jekyll中的版型運作邏輯，有興趣的使用者可以依據這概念設計屬於自己的blog。 本篇重點調整jekyll bootstrap的版型，加入文章摘要於首頁，藉此了解jekyll bootstrap的運作方式。 參考：http://truongtx.me/tags.html#jekyll-ref 注意由於jekyll內不能連續輸入兩個大括號 或是 大括號+百分比，所以等等的大括號中間都會插入空白隔開，Copy時記得刪除….。 { { content } } ^ ^ //記得消除.. { % include JB/setup %} ^ //記得消除.. Jekyll bootstrap架構首先我們再來看一下網站架構，這邊列出可能會修改到的檔案。 |-- index.html #網站首頁 |-- _config.yml #網站設定檔 | |---/_includes #網站結構資料夾 | |--/JB #Jekyll-bootstrap 模組 | |--/themes #Jekyll-bootstrap 預設版型 | |---/_layouts #版型 | |---/_posts #文章資料夾 | |---/assets #CSS,JS 資料夾 前幾篇有介紹_config.yml，今天要介紹怎麼修改index.html的版型。 在傳統Jekyll架構中網站首頁的index.html可以透過設定檔去抓取_layouts內的版型，index.html設定參考如下： --- layout: default --- 而在Jekyll bootstrap內的_layouts會再去載入屬於它專有的版型，路徑就放在_includes/themes/twitter/內，而在layout內的default.html原始碼如下： 123456789---theme : name : twitter---&#123; % include JB/setup %&#125;&#123; % include themes/twitter/default.html %&#125;//前4行的是設定CSS的路徑//後2行是在載入include/themes/twitter/內的default.html 而最後的include/themes/twitter/default.html的結構就像是一般的html，而以上的內容會被放在default.html的{ { content } }內。 default.html的原始碼 而以上三個請參考這張圖，最左方的是跟目錄的index.html，透過一層一層的去取的Jekyll bootstrap版型。 開始上面的介紹有點抽象，接下來就來實際操作一次可能會更了解，請按照步驟慢慢地做下去。 步驟一首先打開include/themes/twitter/資料夾，並且創一個index.html檔案。 裡面程式碼請輸入以下(就這麼三行，剩下的他會去抓同層的default.html)： &lt;div class=&quot;content&quot;&gt; { { content } } &lt;/div&gt; 步驟二打開_layouts的資料夾，並且複製post.html於原位置，並且修改檔名為index.html。 打開index.html修改以下程式碼。 include themes/twitter/post.html 修改成 include themes/twitter/index.html 步驟三打開跟目錄的index.html，貼下以下程式碼。 程式碼：https://github.com/wcc723demo/wcc723demo.github.io/blob/master/index.html 接下來利用先前介紹的Ruby jekyll server來預覽看看網頁，應該會得到這樣的結果，他把目前頁面的前100字擷取了出來。 上面那一段的程式碼的內容如下(煩請自動補腦大括號)： for post in site.posts limit:10 //本站的10筆文章 post.title //等等會用來放置中文標題 if post.content contains &quot;&lt;!-- more --&gt;&quot; //如果內容包含&quot;&lt;!-- more --&gt;&quot; 就擷取到&quot;&lt;!-- more --&gt;&quot; //如果沒有就擷取100字 endfor,endif 語法結尾 步驟四 修改文章最後把/_posts/core-samples內的範例文章2011-12-29-jekyll-introduction.md打開，在文字中插入以下分隔語法。 &lt;!-- more --&gt; 最後在首頁就能看到文章的摘要，而如果增加文章，也會依這功能擷取摘要。 範例網站：http://wcc723demo.github.io/ 注意由於jekyll內不能連續輸入兩個大括號 或是 大括號+百分比，所以本文中的大括號中間都會插入空白隔開，Copy時記得刪除….。 { { content } } ^ ^ //記得消除.. { % include JB/setup %} ^ //記得消除..","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"在Jekyll設定自己的留言板","slug":"jekyll-disqus","date":"2014-01-13T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/14/jekyll-disqus/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/14/jekyll-disqus/","excerpt":"寫blog的作者，都會希望每篇文章都能有些回覆，所以一個留言機制是必要的，但是jekyll本身是屬於靜態網頁，並沒有資料庫，所以必須透過其他服務來做。在jekyll bootstrap內已經有包含disqus的留言板，而且設定容易，使用者也相當多，非常建議用disqus服務。","text":"寫blog的作者，都會希望每篇文章都能有些回覆，所以一個留言機制是必要的，但是jekyll本身是屬於靜態網頁，並沒有資料庫，所以必須透過其他服務來做。在jekyll bootstrap內已經有包含disqus的留言板，而且設定容易，使用者也相當多，非常建議用disqus服務。 本篇重點在jekyll bootstrap內建立屬於自己的留言板，主要會使用disqus，設定容易，使用方便。 Disqus許多網站，甚至是這次所建立的jekyll bootstrap，都應該有看過以下這個留言板，這是disqus的服務，不管是開發者或是使用者都相容易。他是用iframe嵌入在網站內，資料會存在disqus.com的server，所以開發者可以不用理會資料庫要怎麼建；而使用者可以用disqus或是facebook帳號登入就可以開始使用了。 http://disqus.com/ 開啟以上連結並先登入(我是用facebook)，上方有兩個選項For Websites 及 Using Disqus，Using Disqus是給一般使用者管理留言用，這次會用For Websites來增加到Jekyll網站。 點完就選擇Add Disqus to Your Site來增加到網站上吧。 這邊設定其實很容易，只要輸入一個site name就可以了，其他可以不設定，sitename這個值等等也需要回填到jekyll bootstrap上。 設定 _config.yml打開jekyll內的_config.yml，可以找到以下的內容。 comments : provider : disqus # 啟動的留言板服務，這邊就用預設即可 disqus : short_name : jekyllbootstrap # 將內容替換成剛剛在disqus上申請的site name livefyre : site_id : 123 intensedebate : account : 123abc facebook : appid : 123 num_posts: 5 width: 580 colorscheme: light 這部分就如上方所解說的一樣，把short_name修改成剛剛申請的site name。 comments : provider : disqus disqus : short_name : wcc723demo # 將內容替換成剛剛在disqus上申請的site name 之後只要和之前一樣上傳到github，就會發現留言板已經換成屬於自己的。 git add --all git commit -m &quot;disqus&quot; git push 完成 接下來回到網頁上，可以試著留言，而他的留言是依據網址，如果需要管理這些內容可以到disqus的後台(連Local都建了…)。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"在Winodws上運作jekyll","slug":"windows-jekyll-server","date":"2014-01-12T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/13/windows-jekyll-server/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/13/windows-jekyll-server/","excerpt":"Jekyll是在Ruby環境下運行，而Windows對於Ruby的支援性較差，所以在安裝時較為麻煩(Mac OS使用者可以直接參考官方網站)，並且會有些問題，有興趣的Windows user就來參考我這篇吧~(我至少從頭裝了5次!)。","text":"Jekyll是在Ruby環境下運行，而Windows對於Ruby的支援性較差，所以在安裝時較為麻煩(Mac OS使用者可以直接參考官方網站)，並且會有些問題，有興趣的Windows user就來參考我這篇吧~(我至少從頭裝了5次!)。 本篇重點介紹如何在Windows環境下安裝jekyll，並解決可能會遇到的問題，而Mac OSX使用者可以參考官方網站，如果在兩個環境都安裝一遍的情況下，會發現Mac OSX真的簡單太多了…。 Mac使用者可以從這裡開始閱讀 本篇適用於windows 7(64bit)、windows 8(64bit)，其他環境未測試。 Windows下安裝Ruby首先請打開以下連結，會看到不同版本的ruby installers，選定的Ruby版本等等會對應DevKit，如果沒有電腦內還沒有安裝Ruby的使用者，可以以參考本篇安裝2.0以上的 Ruby。 http://rubyinstaller.org/downloads/ 下載完後就開始安裝吧，語系也沒什麼好調的，只有英文跟日文= =。 接受License 路徑上可以用預設即可，如果在網路上搜尋問題，大部分的人也都是用預設路徑來回答。 安裝完成。 安裝完成後，在程式集內或是windows8的動態磚可以找到 Command Prompt with Ruby，而等等還要安裝DevKit。 安裝DevkitGem是Ruby的應用程序，而在windows中，許多的gem都需要透過DevKit才能夠使用，Jekyll也是，所以這邊要先安裝DevKit。 上一步驟的http://rubyinstaller.org/downloads/，從這邊下載DevKit，記得版本要對應上一步驟的Ruby版本，接下來如下解壓縮。 打開Command Prompt with Ruby 輸入以下指令 cd Devkit ruby dk.rb init 再輸入ruby dk.rb install，就可以完成Devkit安裝了。 ruby dk.rb install Mac OS使用者從這邊開始與Windows較為接近，可以從這邊開始閱讀。 安裝Jekyll剛剛的Command Prompt with Ruby，會一直使用，而Ruby的指令就直接輸入在這裏面，Mac OS的使用者就打開Terminal (終端機)吧。 首先升級gem。 gem update --system 接下來安裝jekyll。 gem install jekyll 接下來驗證jekyll是否有安裝完成，以及檢查版本 jekyll -v 啟用Jekyll辛苦建立的blog在這邊就可以看到了，在jekyll的資料夾下輸入jekyll server，就可以看到嚕。 jekyll server 這時候網址列只要輸入http://localhost:4000/，就可以看到剛剛建立的站台，注意：這個站台是在輸入jekyll server後產生的，如果檔案有修改，必須先停止jekyll server，再重新啟動才會看到新的修改 如果要停止只要按照說明按下Ctrl + C即可。 Windows 特有錯誤在我安裝過那麼多次，都一定會遇到的錯誤，就是Windows版 jekyll中文會有編碼的問題，只要輸入jekyll server就會出現以下錯誤。 這時候就要到Ruby裡的jekyll資料夾修改一些設定檔 在windows的Ruby安裝路徑找到convertible.rb這個檔案打開 C:\\Ruby200-x64\\lib\\ruby\\gems\\2.0.0\\gems\\jekyll-1.4.2\\lib\\jekyll\\convertible.rb 將convertible.rb裡的值如下修改，就可以修正這個問題 原 self.content = File.read_with_options(File.join(base, name), merged_file_read_opts(opts)) 改為 self.content = File.read(File.join(base, name),:encoding=&gt;&quot;utf-8&quot;) 接下來再輸入一次jekyll server試試看吧，這問題就會解決了。 Mac OS的優勢windows在每次修改完檔案後，都必須停止jekyll server，再重新啟動，網站才會更新；而Mac OS只要輸入jekyll server --watch，他就會自動偵測站台是否有儲存，只要有儲存動作就會更新網站。 jekyll server --watch 所以我喜歡在Mac OS寫文章…。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"利用Jekyll Bootstrap 快速建立Blog","slug":"jekyll-bootstrap","date":"2014-01-11T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/12/jekyll-bootstrap/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/12/jekyll-bootstrap/","excerpt":"Bootstrap是一套好用的framework，而jekyll就利用bootstrap的便利建立一套jekyll framework，稱作為Jekyll Bootstrap。除了版型外，還另外增加許多實用的模組，如Disqus、google analytic等等，本篇就來介紹如何在github上建立jekyll bootstrap。","text":"Bootstrap是一套好用的framework，而jekyll就利用bootstrap的便利建立一套jekyll framework，稱作為Jekyll Bootstrap。除了版型外，還另外增加許多實用的模組，如Disqus、google analytic等等，本篇就來介紹如何在github上建立jekyll bootstrap。 本篇重點接續前篇github的使用，請務必先參考前一篇的內容。而本篇會進一步的使用jekyll bootstrap，且建立在前篇所的github page，最後在介紹jekyll的發文方式及可能會遇到的問題。 安裝Jekyll bootstrap透過Jekyll bootstrap號稱可以從0開始到建立一個Blog只要3分鐘，但根據我的經驗…第一次建立應該要超過10分鐘，除非這流程已經練習好幾次了。 Jekyll bootrap 透過以上連結就可以到Jekyll bootrap的官方網站，詳細的介紹會放在文章的後半段，前半段會直接介紹如何安裝。再到Jekyll bootrap網站後，直接點選Code on Github。 到了github上，就把整個code下載到本機，而這邊我是直接Download zip。 下圖的左方是本機端(上次的github page資料夾)，右方則是下載的jekyll bootstrap，就把他們整個複製到本機端吧！ 接下來打開git shell，如果是mac os可以打開terminal，依序輸入以下git指令，將jekyll bootstrap上傳到github page伺服器。 git add --all git commit -m &quot;jekyll bootstrap&quot; git push 完成最後只要輸入username.github.io就可以看到以下的網站，這樣就代表成功了。 參考http://wcc723demo.github.io/ Jekyll設定在設定前，先了解Jekyll bootstrap的資料夾結構。 *僅列出部分* |-- index.html #網站首頁 |-- _config.yml #網站設定檔 | |---/_includes #網站結構資料夾 | |--/JB #Jekyll-bootstrap 模組 | |--/themes #Jekyll-bootstrap 預設版型 | |---/_layouts #版型 | |---/_posts #文章資料夾 所以在發文前，就先設定一下網站的名稱吧，打開_config.yml，可以找到title的設定，就把它改成自己的網站名稱，然後利用git push上傳吧。 在一段時間後，就可以看到網站的標題已經替換了。 發文發文我們這邊用它內建的文章做介紹，首先我們在以下路徑可以找到這篇文章，這篇使用教學。注意，jekyll的檔名上是有一定的規則年-月-日-標題.附檔名，副檔名則接受.md或是.html兩者都可以正常運作。 \\_posts\\core-samples\\2011-12-29-jekyll-introduction.md \\年-月-日-標題.md \\年-月-日-標題.html 接下來打開這篇文章，每篇文章的開始都需要一個yaml文件頭，用來設定一些數據，就如同資料庫的欄位一樣(注意：首行不能有空格)。他是利用’—‘來標記開始和結束。 --- layout: post #文章的版型 category: lessons #文章的資料夾 tagline: Supporting tagline #文章的標語 tags: #文章的tag - intro - beginner - jekyll - tutorial published: true #是否發佈 --- 所以在以上，應該有發現到沒有標題，因為標題要設定在檔名上，所以這邊不會有標題。這邊我就在文章的內部，用markdown加入一行字之後再用git push上傳。 接下來在github page上，看到內文有了改變。 參考連結 這時候可能會遇到的錯誤如果github page在此時如果編譯錯誤，他會發一封mail到用戶的信箱，如下圖，這是沒有驗證過的信箱…，要驗證後的信箱他才會正常的編譯。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"GitHub Page","slug":"jekyll-githubpage","date":"2014-01-05T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/06/jekyll-githubpage/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/06/jekyll-githubpage/","excerpt":"這一篇先介紹Github Page，這一個空間是每一個GitHub使用者都可以了解的地方，如果需要做一些DEMO給其他人看，可以試試看這方式，速度快，而且免費!","text":"這一篇先介紹Github Page，這一個空間是每一個GitHub使用者都可以了解的地方，如果需要做一些DEMO給其他人看，可以試試看這方式，速度快，而且免費! 本篇重點學會使用Github page，再參考本篇文章前，建議先有git基礎，而本篇是用git shell做demo，如果是mac OS使用者可以用terminal(還更簡單喔…)。 如果需要git shell，只要安裝github for windows就有附贈git shell了 申請 Github 帳號首先當然要先申請一個帳號，再申請的流程也不囉嗦，只要填入使用者名稱、E-mail、以及密碼即可。 新的儲存庫 (New repository)畫面的右方，應該可以找到如下的小框框，這邊會列出你所有的儲存庫，只要點其右上的New repository，就可以創立新的儲存庫。 這邊要特別注意了，因為是要for github page用，repository name要輸入username.github.io，剩下不需要特別設定，只要按下creat repository就創立了。 如果看到這個畫面，就代表已經創立成功，而他上方所顯示的https://github.com/username/...這一段等等會用到，可以先複製起來。 Push 一個文件檔首先先把儲存庫上的空儲存庫clone下來(我習慣這樣用)。 git clone https://github.com/username/.....剛剛那排 接下來建立一個index.html檔，內容如下。 &lt;!doctype html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Hello&lt;/title&gt; &lt;/head&gt; &lt;body&gt; Hi~大家好 &lt;/body&gt; &lt;/html&gt; 如果新的檔案建立好就依下方輸入git指令： git add --all git commit -m &quot;first commit&quot; 最後在push上去(如果有要輸入帳密，就輸入吧)。 git push -u origin master 在剛剛的網頁重新整理後，可以看到那一個index.html已經傳上去了。 等待這時候網址請輸入username.github.io，可能會看到如下的畫面。 http://wcc723demo.github.io/ 但請不要灰心，就不斷地一直按F5，10分鐘內應該就可以看到如下面的畫面。 後記到這部分github page就算是成功了，而接下來就會開始接觸到jekyll，如果用過github的使用者應該是相當容易上手的。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"},{"name":"github","slug":"github","permalink":"https://wcc723.github.io/tags/github/"},{"name":"git","slug":"git","permalink":"https://wcc723.github.io/tags/git/"}]},{"title":"Emmet Live Style 加減用啦~","slug":"emmet-livestyle","date":"2014-01-03T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"tools/2014/01/04/emmet-livestyle/","link":"","permalink":"https://wcc723.github.io/tools/2014/01/04/emmet-livestyle/","excerpt":"livereload for Windows因為是測試版，經常性的有問題，有時候還會不能使用，這時候可以試試Emmet LiveStyle，他主要會針對CSS的部分直接reload。來看看官方的影片吧。","text":"livereload for Windows因為是測試版，經常性的有問題，有時候還會不能使用，這時候可以試試Emmet LiveStyle，他主要會針對CSS的部分直接reload。來看看官方的影片吧。 安裝http://livestyle.emmet.io/install/ 安裝流程都是參考官方文件。而這是Sublime Text的擴充功能，所以一定要用Sublime Text，流程如下： 安裝Package Control 安裝LiveStyle 擴充功能 安裝Chrome的 LiveStyle 擴充功能 使用LiveStyle 安裝Package Control這部分只要開啟Sublime Text，按下ctrl+`並且貼上以下的code即可。 import urllib.request,os,hashlib; h = &apos;7183a2d3e96f11eeadd761d777e62404e330c659d4bb41d3bdf022e94cab3cd0&apos;; pf = &apos;Package Control.sublime-package&apos;; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( &apos;http://sublime.wbond.net/&apos; + pf.replace(&apos; &apos;, &apos;%20&apos;)).read(); dh = hashlib.sha256(by).hexdigest(); print(&apos;Error validating download (got %s instead of %s), please try manual install&apos; % (dh, h)) if dh != h else open(os.path.join( ipp, pf), &apos;wb&apos; ).write(by) 原諒我這段，這邊我懶得重裝了…，所以沒有圖。 安裝LiveStyle 擴充功能在Sublime Text上方的Preferences下找到Package Control。 選擇：Install Package 接下來輸入LiveStyle，就能安裝LiveStyle擴充功能 安裝Chrome的 LiveStyle 擴充功能打開這個網址Chrome Emmet LiveStyle，再加入倒Chomre就可以了。 使用 LiveStyleChrome的擴充元件，放在開發者工具裡，只要按下F12，就能看到開發者工具，找到LiveStyle並Enable LiveStyle for current page。 接下來開啟正在做的檔案(直接開就可以了) 修改CSS，不需要存檔，就會發現畫面上的CSS效果跟著改變囉。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"},{"name":"emmet","slug":"emmet","permalink":"https://wcc723.github.io/tags/emmet/"},{"name":"sublime text","slug":"sublime-text","permalink":"https://wcc723.github.io/tags/sublime-text/"}]},{"title":"Jekyll 介紹","slug":"what-is-jekyll","date":"2014-01-03T16:00:00.000Z","updated":"2016-10-12T06:05:20.000Z","comments":true,"path":"jekyll/2014/01/04/what-is-jekyll/","link":"","permalink":"https://wcc723.github.io/jekyll/2014/01/04/what-is-jekyll/","excerpt":"本篇開始會重頭介紹Jekyll，如果對jekyll有興趣的開發者，請先必備以下的技能。 熟悉 Git (至少要會git push) 熟悉 Html (修改 template 及 寫文章用)","text":"本篇開始會重頭介紹Jekyll，如果對jekyll有興趣的開發者，請先必備以下的技能。 熟悉 Git (至少要會git push) 熟悉 Html (修改 template 及 寫文章用) 為什麼會考慮Jykell在用之前，先說一下過去用過什麼類似的CMS好了。 首先，我購買了一個php空間，什麼都不會的情況下，就用Wordpress建立了第一個blog，就個剛開始來說，他是挺方便的，只要上傳到空間就建完了。但我在這之中遇到了幾個問題： 版型不好改(主要是要配合許多內建的元件及php語法，要花很多時間理解)。 慢(1000元的美國空間配合強大的CMS…)。 如果要在文章內放入自己的demo不方便。 文章寫不方便(除了不是markdown外，光loading就很慢) 接下來，我自己用ajax寫了第二個blog(?)，也是現在這blog的前生a share a day，做這個的原因，一部分是針對wordpress不方便做改進，另一部份是為了挑戰100天發文。但是自己寫的要和強大的CMS挑戰，就如同XX比雞腿一樣…。接下來就遇到了一些問題： 文章一多很難管理(純html) Google 等搜尋引擎搜不到內容(試著處理，但還是有問題) 在這期間logdown出了，真的是非常非常適合寫程式的人使用，簡單的介面、流暢的操作，但是這不是我要的blog，原因如下： 我的CSS demo很多，這點還是不方便 free template缺乏個性 後來就是現在的Jekyll blog，它有一些優點，是我喜歡的： 自己做版型很容易，輕鬆做出自己的個性 做demo容易 快 管理容易 markdown 混用 html Jykell Necessary Skills在學習前，還是有學習門檻，往後的內容會牽涉到許多git及html，只要熟悉這兩個技能，建立就不會太困難。 熟悉 Git (push 到 github page 用) 熟悉 Html (修改 template 及 寫文章用) 雖然寫文章是用markdown，但都會寫markdown的應該就精通html了吧-.-。 What is JekyllJekyll是基於Ruby Gem的解析引擎，能夠將樣板、liquid 語言、markdown轉換為”靜態網頁”的產生器。http://jekyllrb.com/ 特色 No more databases 不需要資料庫 Liquid Template 動態模板 Free hosting with GitHub Pages 只要學會git push 就可以丟到github page上 Markdown 好編寫 Jekyll 的相關技術Git, Github, Github PagesGit版本控制工具，Github是使用git版本控制項目的的虛擬主機服務(這邊不再詳述)http://pages.github.com/Github Pages是Github提供的服務，可以建立自己的靜態頁面，而他有提供額外的Jekyll解析服務，在每次的git push後會將markdown轉換為靜態的html，且不需要任何databases，是很適合建立blog的服務。 特色 快速 html靜態頁就是快速。 穩定 大廠牌”github” 就是穩定。 免費 free! 容量無限 只要會git commit、git push。 MarkdownMarkdown的目標是實現「易讀易寫」，他在編寫完後就像是一般的文字檔，而不會像是程式語言，並沒有許多的標籤及指令。其語法都是用標點符號組成，主要目的是用來作為網路內容的寫作語言。相關範例建議參考 http://markdown.tw/ Liquid TemplateJekyll所使用的樣板語言，如果熟悉html或是其他樣板語言將會比較容易上手。 Jekyll 運作流程這分為兩種，一種是預計要使用的在github page上的，另一種是要在本地端預覽用的。而在github page呈現前，建議能夠在本地端正常運作，在push到github page上市能夠正常顯示的。 本地端Local 建立好本地端的Liquid Template以及文章，透過Jekyll server，就能產生出靜態的頁面。 Github Page在push Liquid Template後，之後每次都只需要push文章就可以，而每次push到github上的文章及Template，都會透過Jekyll server轉換為靜態的網站。 ###後記 Jekyll loacl端建議使用Mac OSX，由於工作的關係，我會頻繁地在兩種系統交換使用，Windows是在安裝上的注意事項就可以寫一整篇了…，OSX就去看官網吧，三到四行貼完就結束了。 不過我一開始是在Windows上建立的，接下來的文章還是會介紹我所遇到的問題。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"font-family要怎麼玩","slug":"font-family","date":"2013-12-31T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2014/01/01/font-family/","link":"","permalink":"https://wcc723.github.io/css/2014/01/01/font-family/","excerpt":"在平面設計中，字型的運用是一門高深的學問，而網頁設計中雖然大多使用內建的字體，但如果沒有的仔細的去調整，就像是word直接用內建的字型一樣，會產生不協調感。 參考 Just Font","text":"在平面設計中，字型的運用是一門高深的學問，而網頁設計中雖然大多使用內建的字體，但如果沒有的仔細的去調整，就像是word直接用內建的字型一樣，會產生不協調感。 參考 Just Font 本篇重點了解font-family的設定值，以及參考其他知名網站的設定方式。 font-familyfont-family分為兩個部分，一個是指定字體”family-name”，另一種是泛用字”generic-family”。 Formal syntax: [ &lt;family-name&gt; | &lt;generic-family&gt; ]# 泛用字 generic-family首先介紹泛用字，泛用字簡單來說，就是系統的明體、黑體、捲曲字等預設值，並不是指定特定的字體，而也可稱為”字體集”、”統稱字體”、”泛用字集”、”通用字體集”等，泛用字的類型如下： 注意：並非所有瀏覽器及系統的預設泛用字是相同的 泛用字集 中文 English serif 明體 貳零壹肆 新年快樂 2014 Happy New Year. sans-serif 黑體 貳零壹肆 新年快樂 2014 Happy New Year. cursive 捲曲字體 貳零壹肆 新年快樂 2014 Happy New Year. fantasy 花俏字體 貳零壹肆 新年快樂 2014 Happy New Year. monospace 等寬字體 貳零壹肆 新年快樂 2014 Happy New Year. 一般來說定義font-family時，會將泛用字放在最後方，參考如下。 &quot;Lucida Grande&quot;,Helvetica,Arial,Verdana,sans-serif //最後方的是sans-serif(黑體) 指定字體 family-name這部分就相當容易理解，只要直接輸入字型名稱即可，但特別要注意的是如果字體名稱中有空白，就必須用&#39;&#39; 或 &quot;&quot; 將他括起來。 但有少部分的字體，設定時需要注意它的英文及中文名稱，個瀏覽器的解讀不同，如IE就能夠接受”Microsoft JhengHei”，而Chrome則不行。 字體 中文 English \"Microsoft JhengHei\" 貳零壹肆 新年快樂 2014 Happy New Year. 微軟正黑體 貳零壹肆 新年快樂 2014 Happy New Year. 另外在優先順序上，放在前方的字體會先被套用，如果不能才會套用次要的字體，也可以利用這方式來套用不同的字體在中英文上。 如下方的範例，先”Segoe UI”，其次是”微軟正黑體”，最後再放泛用字。 font-family: &quot;Segoe UI&quot;,&quot;微軟正黑體&quot;,sans-serif 字體 中文 English \"Segoe UI\" 貳零壹肆 新年快樂 2014 Happy New Year. \"Segoe UI\",\"微軟正黑體\" 貳零壹肆 新年快樂 2014 Happy New Year. 參考font-family在每個網頁的設定都不相同，在Mac OS以及Windows上所擁有的字型也都不相同，在設定上也必須考量到其他系統使用者的觀感，這邊就提供幾間不同公司的font-family設定值。 Apple (TW)http://www.apple.com/tw/ font-family: &quot;Lucida Grande&quot;,Helvetica,Arial,Verdana,sans-serif Apple 貳零壹肆 新年快樂 2014 Happy New Year. 微軟台灣http://www.microsoft.com/taiwan/ font-family: &quot;微軟正黑體&quot;, &quot;Microsoft JhengHei&quot;, &quot;Segoe UI Semibold&quot;, &quot;Segoe UI&quot;, &quot;Lucida Grande&quot;, Verdana, Arial, Helvetica, sans-serif Microsoft 貳零壹肆 新年快樂 2014 Happy New Year. Yahoo (US)http://www.yahoo.com/ font-family: &apos;Helvetica Neue&apos;,Helvetica,Arial,sans-serif Yahoo 貳零壹肆 新年快樂 2014 Happy New Year. Googlegoogle的設定值最泛用….。 https://www.google.com font-family: arial,sans-serif Google 貳零壹肆 新年快樂 2014 Happy New Year.","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"前端軟體-Prepos介紹","slug":"prepos-intro","date":"2013-12-26T16:00:00.000Z","updated":"2016-10-12T06:04:14.000Z","comments":true,"path":"tools/2013/12/27/prepos-intro/","link":"","permalink":"https://wcc723.github.io/tools/2013/12/27/prepos-intro/","excerpt":"情境當在進行前端設計的時候，如果想要分享Html給夥伴看看，有哪些方式呢？ 叫他過來看 截圖之後，傳line給他看 上傳到空間，丟網址給他看 今天介紹一個更快的方式，利用prepos免上傳，直接傳網址給他看。","text":"情境當在進行前端設計的時候，如果想要分享Html給夥伴看看，有哪些方式呢？ 叫他過來看 截圖之後，傳line給他看 上傳到空間，丟網址給他看 今天介紹一個更快的方式，利用prepos免上傳，直接傳網址給他看。 本篇重點Prepos的功能相當多，除了產生可以跨裝置的網址外，還可以編譯相當多語言，如LESS, Sass, SCSS, Stylus, Jade, Slim, Coffeescript, LiveScript, Haml and Markdown等等，另外還可以做圖檔優化。 這次就介紹Prepos這套軟體，從安裝到執行，一次搞定。注意：跨裝置限定區網 本篇範例使用prepos 4.0.1 安裝link: http://alphapixels.com/prepros/ 本篇是利用OSX做介紹，但是本套軟體在windows上也可以使用，操作基本上是接近的，所以不管是哪一個系統的使用者都可以快速上手。 在進入網站後，左方可以選擇下載的版本，大家就選擇要使用的版本下載吧(這次只會介紹他的免費版)。 下載後，只要就點兩下解壓縮 因為是網路上下載的，所以在prepos.app上按住cmd + 滑鼠左鍵 選擇打開 接下來會出現提示視窗，直接按打開就可以了。 另外他還有提供Install Chrome Extension的連結，可以安裝其Chrome擴充程式，但如果有安裝livereload，就可以不安裝它提供的擴充程式。 使用這套操作界面很直覺，如果有使用過fire.app等等軟體，相信很快就能上手。 這次就拿aShare的原始版型檔做範例吧，只要把資料夾整個拖曳到prepos裡就可以了。 丟進去後，他就會列出這個專案裡所有可以編譯檔案。 每一個檔案，還能單獨設定其編譯設定。另外在下方有一個地球的圖案(Live preview)，點擊後就會開啟瀏覽器，直接預覽網頁。 這邊就介紹我最喜歡的功能 跨裝置測試(Multi Device Testing)，點擊Prepos右上方功能列，類似手持裝置的符號。 接下來就可以獲得跨裝置的資訊，只要在其他裝置輸入以上網址，或者是利用qrcode就可以預覽這個專案。 輸入以上網址，就可以看到Prepos全部的專案 選擇專案就可以開始預覽，如果沒有錯誤，就把這個網址傳給夥伴吧～。注意：跨裝置限定區網 跨裝置測試這套軟體他的livereload和其他相似軟體不同之處，就是在跨裝置也可以livereload(免費版只能對於有編譯的檔案livereload)，以下就來直接做範例給大家看吧。 這個是手機版上所看到aShare版型 接下來把Sass中的色彩變數改成紅色 於是乎，手機上的色彩就會自動轉成編譯後的色彩 結語Prepos在概念上是很棒的一套軟體，在3.0.X版本的時候我就有接觸過，但是當時他經常性的編譯錯誤(有時候多按個save又編譯成功= =)，所以我在使用時，都是開fire.app，然後關閉prepos的auto compile，僅使用它的跨裝置功能。而最近他出4.0.1版，有空可以多拿來玩看看還有沒有類似的問題。","categories":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"https://wcc723.github.io/tags/tools/"}]},{"title":"簡易CSS transform 視差效果","slug":"css-transform","date":"2013-12-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/12/24/css-transform/","link":"","permalink":"https://wcc723.github.io/css/2013/12/24/css-transform/","excerpt":"在先前範例中可以得知，CSS transform 來做視覺特效，效能會比原始的CSS2還要好，所以本篇就利用css transform 以及hover來簡單做一個互動的效果吧！","text":"在先前範例中可以得知，CSS transform 來做視覺特效，效能會比原始的CSS2還要好，所以本篇就利用css transform 以及hover來簡單做一個互動的效果吧！ 本篇重點利用hover結合css transform來作出簡易互動效果，而本篇主要是CSS3，所以將會使用sass做範例。 Demo滑鼠移過下方的區域時，下方的兩個角色會靠近，另外在滑鼠在角色的圖片上時，角色會從模糊變成清楚。 圖片來源：英雄聯盟 原理在這範例用的是用CSS 3D，而在滑鼠移過時，會移動兩個角色的X軸，使其有簡易的視差效果。 .transform3d height: 500px +transform-style(preserve-3d) //如果要做3D效果，其外層必須要有transform-style(preserve-3d) &amp;:hover //滑鼠滑過時執行以下效果 .ez //左邊那個手指男 +transform(translate3d(50%,0,0)) //X軸向右位移50% .ziggs //右方的炸彈男 +transform(translate3d(-50%,0,0)) //軸向左位移50% 製作先來看看html結構，如果要使用transform 3d，記得其外層一定要有transform-style(preserve-3d)這個屬性transform3d這一個class就是這個用途，而span內分別包著一張角色圖片。 &lt;div class=&quot;demo&quot; data-demo=&quot;Hover me!&quot;&gt; &lt;div class=&quot;transform3d&quot;&gt; &lt;span class=&quot;ez&quot;&gt;&lt;img src=&quot;/images/2013-12-23-lol-f.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt; &lt;span class=&quot;ziggs&quot;&gt;&lt;img src=&quot;/images/2013-12-23-lol-zig.png&quot; alt=&quot;&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; 完整sass大部份的功能，都直接寫在註解裡，這樣比較容易理解，另外filter是比較耗效能，建議不要結合transition(等等下方會有範例)。 .demo position: relative //定位角色初始位置 .transform3d height: 500px +transform-style(preserve-3d) //如果要做3D效果，其外層必須要有transform-style(preserve-3d) &amp;:hover //滑鼠滑過時執行以下效果 .ez //左邊那個手指男 +transform(translate3d(50%,0,0)) //X軸向右位移50% .ziggs //右方的炸彈男 +transform(translate3d(-50%,0,0)) //軸向左位移50% span //定義角色共通屬性 width: 40% display: block position: absolute bottom: 0 +transition(transform 1s ease-in-out) //動態轉場效果(僅對transform有效) img +filter(blur(5px)) //模糊濾鏡 width: 100% &amp;:hover +filter(blur(0)) .ez //手指男靠左 left: 0 .ziggs //炸彈男靠右 right: 0 再一次demo 增加filter 效果這部分在增加一個filter的drop-shadow效果，這樣會更有層次，但是效能會更差一點。而這邊要表現的效果，就是角色後方的陰影，會因為hover而改變位置。因filter效能不好，較好的方式還是在後方增加一層圖片，然後再用transform去改變其位置。 .ez +filter(drop-shadow(-5px 0 0 rgba(black ,.5))) .ziggs +filter(drop-shadow(5px 0 0 rgba(black ,.5))) &amp;:hover .ez +transform(translate3d(50%,0,0)) +filter(drop-shadow(5px 0 0 rgba(black ,.5))) .ziggs +transform(translate3d(-50%,0,0)) +filter(drop-shadow(-5px 0 0 rgba(black ,.5)))","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"效能更好的banner animation","slug":"banner-animation-2","date":"2013-12-18T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/12/19/banner-animation-2/","link":"","permalink":"https://wcc723.github.io/css/2013/12/19/banner-animation-2/","excerpt":"之前有一篇介紹利用background-position製作動態的banner，不久後就接到效能不好的問題，所以我就重新用另一種方式製作，發現效能有明顯的提升，也很有成就感，本篇就介紹不同的動態banner作法。","text":"之前有一篇介紹利用background-position製作動態的banner，不久後就接到效能不好的問題，所以我就重新用另一種方式製作，發現效能有明顯的提升，也很有成就感，本篇就介紹不同的動態banner作法。 本篇重點利用css transform的方式，去改善動態banner的效能。(由於本篇主要是CSS3，所以會用sass作範例。) Demoiframe 連結 原理這是利用transform配合animation來進行位移。 +keyframes(&quot;banner-slider&quot;) //建立一個keyframe from +transform(translate3d(0, 0, 0)) //起始點 to +transform(translate3d(image-width(&quot;banner-01.png&quot;), 0, 0)) //位移x，值為圖片的寬度 而如果直接套用，則會有另一個問題，就是圖片是位移了，但是不夠大。如下圖，紅框假設是使用者所見到的位置，淺色的部分是目前的圖片，黑色是期望有出現，但並沒有的顯示的圖片；因為這個問題，所以需要另外再補上一張圖片。 在這邊我是利用偽元素:pseudo-element來複製出所需要的圖片，目的就是要在目前的左方先補上一張相同的圖片。 製作由於製作方式不同，所以html的結構也有所改變，目前的html如下。 &lt;div class=&quot;banner&quot;&gt; &lt;div class=&quot;banner-wrap&quot;&gt; &lt;span&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; class=”banner” 主要是用來定位，以及裁切多餘的部分 class=”banner-wrap” 主要用來做動畫 span 圖片的位置 Sass首先製作keyframe的部分 //由於compass 目前沒有animation，所以可以自己做animation的功能 =keyframes($name) //keyframes @mixin @-webkit-keyframes #{$name} @content @-moz-keyframes #{$name} @content @-ms-keyframes #{$name} @content @keyframes #{$name} @content =animation($content) //animation @mixin -webkit-animation: $content -moz-animation: $content -o-animation: $content animation: $content +keyframes(&quot;banner-slider&quot;) //建立一個keyframe from +transform(translate3d(0, 0, 0)) //起始點 to +transform(translate3d(image-width(&quot;banner-01.png&quot;), 0, 0)) //位移x，值為圖片的寬度 //這部分我原本是用translate3d去做 //後來改成2D效果及效能也是差不多的 class的樣式如下 .banner position: relative min-height: $headerHeight width: 100% overflow: hidden //超出範圍的部分不顯示 .banner-wrap +animation(banner-slider 180s infinite linear) //載入剛剛的動畫keyframe span,span:after //span以及其偽元素的樣式 display: block min-height: $headerHeight width: 100% background: image-url(&quot;banner-01.png&quot;) top left repeat-x //top left的功能是要讓圖片從左邊開始 span:after //補上偽元素所需要的屬性 background-position: top right //偽元素從右邊開始，使其可以左右相接 content: &quot;&quot; +transform(translate(-100%, 0)) //將偽元素移到目前位置左方 效能原本的background-position作法我在測試時都是用不太差的桌上型主機做測試，所以完全沒注意到效能的問題，但經過反映以後，利用chrome去測試，效能真的不好。 background-position的效能 transform的效能(幾乎沒有感覺啊!!) 本篇是用sass做介紹，如果想了解所產生的css，可以參考http://codepen.io/Wcc723/pen/wFrCn。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"jQuery step by step 教學","slug":"jquery-step-by-step","date":"2013-12-17T16:00:00.000Z","updated":"2016-10-12T06:16:05.000Z","comments":true,"path":"jquery/2013/12/18/jquery-step-by-step/","link":"","permalink":"https://wcc723.github.io/jquery/2013/12/18/jquery-step-by-step/","excerpt":"不久前在高雄前端社群有介紹jquery教學，我的部分盡量做成一個步驟一個步驟，且就算沒有人教，也可以看著講義做下去。","text":"不久前在高雄前端社群有介紹jquery教學，我的部分盡量做成一個步驟一個步驟，且就算沒有人教，也可以看著講義做下去。 本篇重點jQuery和純javascript而言相對容易非常多，而網頁設計師如果需要一些效果，不妨先試試看jQuery來做看看，而透過以下範例，一步步的學會jquery的一些效果(本篇”不”適合用手機看)。 教學頁面下面的頁面裡，每一個效果都有另一個空白試題，透過空白試題更能輕鬆地了解每個效果的寫法。 iframe 連結","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"}]},{"title":"純 \"CSS\" Banner animation教學","slug":"banner-slider","date":"2013-12-15T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/12/16/banner-slider/","link":"","permalink":"https://wcc723.github.io/css/2013/12/16/banner-slider/","excerpt":"在座這網站的時候，上方有保留一塊區域打算放banner，一般來說banner都會用jquery跑馬燈的方式去做，但是對我來說那要做好幾張圖…好麻煩，所以我就做一張連續圖片(左右可以相連的圖片)，讓他不斷的向右移動。","text":"在座這網站的時候，上方有保留一塊區域打算放banner，一般來說banner都會用jquery跑馬燈的方式去做，但是對我來說那要做好幾張圖…好麻煩，所以我就做一張連續圖片(左右可以相連的圖片)，讓他不斷的向右移動。 本篇重點本篇會介紹如何用css寫出類似本站上方的banner。 CSS範例 準備圖片一開始當然要先做一張圖，圖的重點是左右方可以相連的，如下圖最左方的chrome是被切一半，和右方的另一半chrome剛好可以接起來。另外這banner的寬度是”1122px”，等等會用到這寬度。 CSS直接介紹CSS的寫法，會比較容易了解其原理，這是利用css3 Animation的語法製作，Animation 包含keyframes 及 animation，前者是物件運動的時間軸，相當於劇本；後者是keyframes所呈現的方式(directive)，這兩者都是必要的，缺一不可。 首先介紹keyframes @keyframes banner-slider { /*banner-slider 是自訂義命名，本篇命名為banner-slider*/ from { /*開始*/ background-position: 0 0; } to { /*結束，在結束時background-position的x移動了1122px*/ background-position: 1122px 0; } } 介紹animation animation: banner-slider 180s infinite linear; /*banner-slider 是keyframe的名稱*/ /*180s 是整段keyframes的時間*/ /*infinite 無限次輪播*/ /*linear 播放速率是固定的(線性)*/ 完成CSS3是很麻煩的語法，要依瀏覽器寫入對應的前輟詞，如果有興趣的設計師，可以直接複製下方CSS，然後把圖片略做修改就可以玩看看囉。 .banner { background: url(&apos;/images/banner-01.png&apos;) center repeat-x; min-height: 300px; -webkit-animation: banner-slider 180s infinite linear; -moz-animation: banner-slider 180s infinite linear; -o-animation: banner-slider 180s infinite linear; animation: banner-slider 180s infinite linear; } @-webkit-keyframes banner-slider { from { background-position: 0 0; } to { background-position: 1122px 0; } } @-moz-keyframes banner-slider { from { background-position: 0 0; } to { background-position: 1122px 0; } } @-ms-keyframes banner-slider { from { background-position: 0 0; } to { background-position: 1122px 0; } } @keyframes banner-slider { from { background-position: 0 0; } to { background-position: 1122px 0; } } 如果本篇有任何疑問，也歡迎在下方留言。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"aShare使用技術","slug":"ashare-technology","date":"2013-12-13T16:00:00.000Z","updated":"2016-10-12T06:01:22.000Z","comments":true,"path":"jekyll/2013/12/14/ashare-technology/","link":"","permalink":"https://wcc723.github.io/jekyll/2013/12/14/ashare-technology/","excerpt":"上一篇簡單介紹了本站為什麼選擇jekyll，但是這其中並不是只有這一項技術就可以達成，其中除了我已經很熟悉的html、css、sass外，必須要了解Git、Liquid、Markdown等等的技術，當然其中會有許多困難，但是不斷的突破困境是進步最快的方式。 本站所使用的技術如下 Jekyll Liquid github github page Markdown Sass compass fire.app","text":"上一篇簡單介紹了本站為什麼選擇jekyll，但是這其中並不是只有這一項技術就可以達成，其中除了我已經很熟悉的html、css、sass外，必須要了解Git、Liquid、Markdown等等的技術，當然其中會有許多困難，但是不斷的突破困境是進步最快的方式。 本站所使用的技術如下 Jekyll Liquid github github page Markdown Sass compass fire.app 為何要建立一個使用這麼多技術的blog雖然這些技術看起來非常的多，但有一半已經是經常使用的，而另一部份是應該去學習，卻一直沒有機會，如果可以透過建立blog的方式順便學習，還真的是挺划算的。 Jekyll Jekyll是這個blog的核心，它是一個靜態網站的生成器，還多裡面運行了Textile、Markdown或Liquid的編譯器，透過這些功能可以產生一個完整的靜態網站。 光是這樣介紹真的很模糊，未來的章節會介紹如何建置jekyll靜態網站。 Liquid本站上主要的版型模組都是用Liquid建置，像是右邊的Related Posts、Recent Posts、Tags等等。而這我並不是很擅長，但也不是很難…，只要看得懂html，大部分都是複製、貼上，重新修改就可以了。 Git &amp; Github &amp; Github page 這三個有連帶關係，因為我是放在github page上，所以要用github，因為要用github所以一定要用git。git是版本控管的工具。任何專案保存的過程中，其演進的歷程及紀錄都是非常重要的，而git就是紀錄這些的工具。 github則是git的大型線上儲存庫，讓使用者可以透過雲端的管理，在不同的地方都可以進行作業(git相當複雜，有興趣可以參考保哥的介紹)。 github page，是github提供的額外服務，他可以將push到github上的檔案，透過jekyll轉換成靜態頁，github page優勢如下： 快速 html靜態頁就是快速。 穩定 大廠牌”github” 就是穩定。 免費 free! 容量無限 只要會git commit、git push。 MarkdownMarkdown的主要目的就是要拿來寫作用，由於html的標籤有一點點混亂，所以在編寫時有一點點麻煩，Markdown簡化了許多寫法。 Markdown範例 12345html的寫法&amp;lt;h1&amp;gt;Markdown&amp;lt;/h1&amp;gt;Markdown的寫法# Markdown 它就是簡化寫法的語言而已，不過如果沒用Markdown，純html寫blog找段文字都會看到眼瞎是真的。 Sass &amp; Compass &amp; Susy sass是CSS的高階語言，透過sass可以一行抵三行，有效率的編寫及管理CSS，說實在沒用這類型的東西，我不知道該怎麼寫好CSS了。 而Compass是sass的擴充framework，compass有許多擴充功能如css3 前輟詞以及提供許多@mixin以供使用者運用。 另外的susy是基於sass、compass的版型framework，優勢在於可以快速建立responsive web，和其他grid system (ex:bootstrap)不同的是html乾淨、自由、class 語意化，熟悉susy的使用者在建立responsive web可以比bootstrap更快速。 製作小心得本站在結束ashareaday後大概兩周就大致完成了，第一周花了很多時間在學習git以及測試jekyll，只會用github for windows的情況下開始學，到現在主要都用github shell或是mac 終端機在作業了，以上是題外話…。 測試jekyll時遇到超多的問題，之後再介紹jekyll時會有詳細的介紹，而剛開始我是用jekyll bootstrap做測試，在許多的問題都克服(如中文、編譯錯誤等)以後，才開始正式執行。 第一周測試完後，第二周開始製作版型，說實在sass、compass、susy加起來真的太快了(大推…)，配合自己平常準備的模組，一個早上就完成大部分的。而這個網站在設計上，當然就是走現在主流的扁平化設計，簡單且沒有太多的裝飾。 在版型完成後，就替換掉jekyll bootstrap，把原本的html css抽換，保留許多的Liquid模組，就大致完成了aShare，而許多不足的地方，就是不斷地搜尋及測試。 ashareaday是在2013/11/30結束，它讓我學習太多了，而這個網站會保留其大部分文章，且會以更精緻的方式執行下去。","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"intro","slug":"intro","permalink":"https://wcc723.github.io/tags/intro/"},{"name":"beginner","slug":"beginner","permalink":"https://wcc723.github.io/tags/beginner/"},{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"Just Another Beginner~","slug":"just-another-beginner","date":"2013-12-09T16:00:00.000Z","updated":"2016-10-12T05:59:44.000Z","comments":true,"path":"jekyll/2013/12/10/just-another-beginner/","link":"","permalink":"https://wcc723.github.io/jekyll/2013/12/10/just-another-beginner/","excerpt":"告別了一百多天的aShareaDay，在這裡即將有新的開始。在結束aShareaDay前一直在思考要用什麼樣的平台繼續寫文章，其中的選項有： 目前超夯的logdown 自由簡單的wordpress 以及jekyll 當然，看到我這網站的位置，就是使用Jekyll in Github page，本篇就是要說明我用jekyll的原因。","text":"告別了一百多天的aShareaDay，在這裡即將有新的開始。在結束aShareaDay前一直在思考要用什麼樣的平台繼續寫文章，其中的選項有： 目前超夯的logdown 自由簡單的wordpress 以及jekyll 當然，看到我這網站的位置，就是使用Jekyll in Github page，本篇就是要說明我用jekyll的原因。 aShareaDay 的問題在很久之前有參加一次KSDG的活動(忘記活動名稱了..，大約是半年前吧)，那次是介紹github page，也在那一次聽說了jekyll，那次只是個開始。約幾個月後，我開始寫aShareaDay，aShareaDay是利用ajax撈其他頁面的資料，而每天的post都是一個html檔，利用ajax載入，這樣可以做出類似CMS的管理效果，但是…我的js並不是很強，所以aShareaDay其實並不完美，尤其是google analytic一直沒有辦法完整的分析，以及搜尋工具無法搜尋到aShareaDay的文章資料。 aShareaDay的優缺點優點： 會寫html就可以上傳文章 做demo超方便(如果是用codepen寫demo有連續性的問題) ftp輕鬆上傳，輕鬆改 缺點： 沒有留言功能…(這樣就沒有回饋) google搜尋不到文章內容(我試過了，最多我只能讓他搜尋到ajax的menu…) 在aShareaDay快結束前，我開始尋找其他解決方案，列入考慮的就是摘要所提的那三點(logdown、wordpress、jekyll)。 logdown 目前來說，這是一個很夯的blog，markdown、拖曳上傳這些方式都能有效的減少文章編寫的時間，如果硬要說他的缺點就是 1.不好做demo，2.內建的樣板……真的….讓人沒有付費的勇氣。 wordpress 其實，他除了樣板多及可以架在自己的server上缺點還挺多的…，除了logdown的不好做demo缺點外它還有幾個缺點 1.寫文章很困難，2.高流量的問題，3.有點慢。 jekyll 我不能說它能解決所有的問題，畢竟我還是在測試中，它至少可以解決原本aShareaDay的問題，以及保有aShareaDay的優缺點的優點，所以我目前考慮用jekyll。 Jekyll透過 Jekyll 可以將靜態 html 或是 markdown 快速生成一個blog，而他所產生的blog是沒有包含資料庫的純靜態html網頁，在技術上的好處當然就是速度快、簡單，缺點就是留言等功能必須仰賴DISQUS等。 Github 提供靜態網頁的服務，稱作為github page，而他也支援jekyll(如何使用在未來有機會在介紹)，兩個在一起就是無線流量、容量的blog，只要寫好新的文章commit就可以post新的文章。 缺點：馬的，明明就很難 !","categories":[{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/categories/jekyll/"}],"tags":[{"name":"intro","slug":"intro","permalink":"https://wcc723.github.io/tags/intro/"},{"name":"beginner","slug":"beginner","permalink":"https://wcc723.github.io/tags/beginner/"},{"name":"jekyll","slug":"jekyll","permalink":"https://wcc723.github.io/tags/jekyll/"}]},{"title":"jQuery Mobile 載入google map顯示不完全的問題","slug":"jqm-and-google-map","date":"2013-11-08T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/09/jqm-and-google-map/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/09/jqm-and-google-map/","excerpt":"Jquery Mobile的頁面載入google map會有一個bug(如第一個Go map button)，這一個bug會造成map只有顯示一小塊(如果螢幕大一點的裝置，就真的是很小一塊了)。","text":"Jquery Mobile的頁面載入google map會有一個bug(如第一個Go map button)，這一個bug會造成map只有顯示一小塊(如果螢幕大一點的裝置，就真的是很小一塊了)。 問題 會這樣的原因是jquery mobile在未載入的頁面會是display: none，所以在載入google map時就會有空間不夠大的問題，這邊有兩種解決方式提供給大家參考。 initialize() //這是載入地圖的function google map api參考：https://developers.google.com/maps/documentation/javascript/examples/map-simple 關閉轉場動畫 效果參考Go Map2 (no transition)的按鈕。 $('#Map2').on('click',function(){ $.mobile.changePage( \"#map\", { transition: \"none\", changeHash: true }); //把換頁的動畫設成none initialize(); }); 延遲執行 效果參考Go Map3 (time out function)的按鈕。 var mytimeout; $('#delayMap').on('click',function(){ mytimeout = window.setTimeout(initialize, 500); //延遲載入地圖的時間 }); JS Bin","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"},{"name":"mobile","slug":"mobile","permalink":"https://wcc723.github.io/tags/mobile/"}]},{"title":"利用json取得公開資料(3) 並繪製圖表","slug":"js-json4","date":"2013-11-05T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/06/js-json4/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/06/js-json4/","excerpt":"上次已經把資料放進表格內，接下來我們可以透過一些圖表功能來視覺化這些資料，這邊可以透過一些線上資源來繪製圖表。 圖表plugin：http://www.open-open.com/ajax/ajax20090708091447.htm","text":"上次已經把資料放進表格內，接下來我們可以透過一些圖表功能來視覺化這些資料，這邊可以透過一些線上資源來繪製圖表。 圖表plugin：http://www.open-open.com/ajax/ajax20090708091447.htm 圖表 上面有我找到的一個圖表插件，就來試試看吧。不過在做之前要先注意到，json在取得之後並且放入表格是需要時間的，而圖表匯製的function也必須要在表格完成後執行，所以繪製的function必須放在json載入並寫入表格後執行。 上一次的資料不適合繪製圖表，所以換成\"空氣汙染\"的。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/AQX/?$orderby=SiteName&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '台南市' $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ list = ''+ item.SiteName+''+ item.PSI+''+ item.SO2+''+ item.NO2+''+ item.O3+''; $('.itemlist').append(list); }; }); //$('#chartData').visualize({type: 'pie', pieMargin: 10, title: '2013 台南區 PSI圓餅'}); $('#chartData').visualize({type: 'line'}); //$('#chartData').visualize({type: 'area'}); }); })(); //記得先載入以下的js 及 CSS //visualize.jQuery.js //visualize.jQuery.css (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/AQX/?$orderby=SiteName&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '台南市' //地點換成台南市 $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ list = '&lt;tr&gt;&lt;th&gt;'+ item.SiteName+'&lt;/th&gt;&lt;td&gt;'+ item.PSI+'&lt;/td&gt;&lt;td&gt;'+ item.SO2+'&lt;/td&gt;&lt;td&gt;'+ item.NO2+'&lt;/td&gt;&lt;td&gt;'+ item.O3+'&lt;/td&gt;&lt;/tr&gt;'; //表格列結構及資料 $('.itemlist').append(list); //將表格列插入table }; }); $('#chartData').visualize({type: 'line'}); //繪製圖表的function }); })(); 二氧化硫濃度 一氧化碳 二氧化氮 臭氧濃度","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"利用json取得公開資料(2)","slug":"js-json3","date":"2013-11-04T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/05/js-json3/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/05/js-json3/","excerpt":"在上回已經取得資料，這次就來把取回來的資料放入到表格內。","text":"在上回已經取得資料，這次就來把取回來的資料放入到表格內。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '高雄市' $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ list = ''+ item.SiteName+''+ item.PublishTime+''+ item.TWD97Lon+''+ item.UVI+''; $('.itemlist').append(list); }; }); }); })(); $.each 取回的資料是很多個物件，物件內還有著陣列，陣列內都包含著一個名稱及一個值(如下圖)，物件內包含著\"SiteName\"的名稱及\"嘉義\"等地名的值，首先要把每一個物件拆開，就需要用到$.each。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { //把每一個物件拆開來執行一次function console.log(item); }); }); })(); 接下來的console(item)就會看到上面那張圖的內容。 取出個別的資料 這份資料相當的多，所以要先做個過濾，從上面得知的結果，他有一個county的名稱，裡面有不同的縣市名稱，試試看取出高雄市的資料就好。先定義一個變數\"_DefaultContry\"其值為高雄市。 另外在資料可以用item.SiteName的方式取出，等等就一次做完吧~。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; var list = '' _DefaultContry = '高雄市' //定義高雄市的變數 $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { $.each( data, function( i, item ) { console.log(item); if(item.County == _DefaultContry){ //假設是高雄市才執行 list = ''+ item.SiteName+''+ item.PublishTime+''+ item.TWD97Lon+''+ item.UVI+''; //利用item.值，把每一個值取出，並寫成一個html存在list的變數內 $('.itemlist').append(list); //最後把剛剛的html放到表格內 }; }); }); })(); 最後就會產生如下的結果(如果沒有失聯的話，下面是有內容的...)。 測站名稱 發布時間 經度(TWD97) 紫外線指數","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"利用json取得公開資料","slug":"js-json2","date":"2013-11-03T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/04/js-json2/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/04/js-json2/","excerpt":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。 今天就來試試看抓政府的公開資料吧。","text":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。 今天就來試試看抓政府的公開資料吧。 找一個公開的json資料 政府現在有許多公開資料，是使用json格式，而最近工作的關係，剛好知道環保署有提供公開資料。 環境資源資料開放平台：http://opendata.epa.gov.tw/ 紫外線即時監測資料http://opendata.epa.gov.tw/Data/Contents/UV/ 資料非常多，就找一個較短的來做測試，所以就用紫外線資料來做測試吧。 取得資料 我們把jquery官網上所提供的API拿過來改看看，看看能不能得到我們想要的資料。 (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { console.log(data); //$.each( data.items, function( i, item ) { // console.log(item) //}); }); })(); (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json\"; $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { console.log(data); }); })(); 把上面的code改完以後，看一下console的結果，會發現下面的回應。而主要原因是javascript不能夠跨網域，所以必須做一些調整。 XMLHttpRequest cannot load http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json. Origin http://127.0.0.1:24681 is not allowed by Access-Control-Allow-Origin. 在網址的後方加上&callback=?，這樣js就可以進行跨網域的請求。 參考：http://blog.johnsonlu.org/javascript%E9%80%8F%E9%81%8Ejsonp%E5%AE%8C%E6%88%90%E8%B7%A8%E7%AB%99%E8%AB%8B%E6%B1%82/ (function() { var epaAPI = \"http://opendata.epa.gov.tw/ws/Data/UV/?$orderby=PublishAgency&$skip=0&$top=1000&format=json&callback=?\"; //加上&callback=? $.getJSON( epaAPI, function(){ format: \"json\" }).done(function(data) { console.log(data); }); })(); 如果可以傳回像下面這些物件資料，就已經算是取得資料了，而把物件點打開，就可以得到各縣市的空氣品質資料，再配合環保局所提供的API，可以了解個欄位所代表的意義。 [Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object, Object] County: \"嘉義市\" PublishAgency: \"中央氣象局\" PublishTime: \"2013-11-04 08:00\" SiteName: \"嘉義\" TWD97Lat: \"23,29,52\" TWD97Lon: \"120,25,28\" UVI: \"0\"","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"試試看Json","slug":"js-json","date":"2013-10-31T16:00:00.000Z","updated":"2016-10-12T03:41:12.000Z","comments":true,"path":"jquery/2013/11/01/js-json/","link":"","permalink":"https://wcc723.github.io/jquery/2013/11/01/js-json/","excerpt":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。","text":"之前寫了很久的CSS，很久都沒機會碰js，原本就沒多厲害的js又變得更生疏了...，最近正在學json就來稍微介紹一下吧。 Json http://zh.wikipedia.org/zh-tw/JSON 如果需要看簡介，可以看wiki的介紹，不過要特別注意的就是他的結構。 //物件 （object） //利用{}所包起來的 {name:value} //陣列 Array //利用[]所包起來的 [collection, collection] 如果對js有一咪咪概念的話，相信會對後面的介紹很容易了解。 Jquery 小朋友都愛寫jQuery，因為比較簡單，所以在這就用jQuery介紹json。 http://api.jquery.com/jQuery.getJSON/ 如果打開jQuery介紹json的網頁，可以會得到向下面的code，只要把下面的code貼到網頁的script內，再新增一個id=\"images\"的容器，就可以看到載入幾張flicker的圖片。 (function() { var flickerAPI = \"http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?\"; $.getJSON( flickerAPI, { tags: \"mount rainier\", tagmode: \"any\", format: \"json\" }) .done(function( data ) { $.each( data.items, function( i, item ) { $( \"&lt;img&gt;\" ).attr( \"src\", item.media.m ).appendTo( \"#images\" ); if ( i === 3 ) { return false; } }); }); })(); &lt;div id=&quot;images&quot;&gt;&lt;/div&gt; (function() { var flickerAPI = \"http://api.flickr.com/services/feeds/photos_public.gne?jsoncallback=?\"; $.getJSON( flickerAPI, { tags: \"mount rainier\", tagmode: \"any\", format: \"json\" }) .done(function( data ) { $.each( data.items, function( i, item ) { console.log(item) $( \"\" ).attr( \"src\", item.media.m ).appendTo( \"#images\" ); if ( i === 3 ) { return false; } }); }); })(); Console.log 利用console.log()可以將javascript的值輸出到browser的開發者工具，藉此來偵錯或是了解值的結構。 如以下範例，在剛剛的script中插入console.log(item)，就可以看到範例所抓取的json有什麼樣的資料，藉此能夠了解如何運用這些資料。 $.each( data.items, function( i, item ) { console.log(item) $( \"&lt;img&gt;\" ).attr( \"src\", item.media.m ).appendTo( \"#images\" ); if ( i === 3 ) { return false; } 從他所產生的結果，其實可以了解這範例僅有取用media的圖檔位置而已，其實還有許多值還沒有用到，有興趣的人可以把它其他的值抓出來玩玩看，或許可以讓內容豐富更多~。","categories":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/categories/jquery/"}],"tags":[{"name":"jquery","slug":"jquery","permalink":"https://wcc723.github.io/tags/jquery/"},{"name":"javascript","slug":"javascript","permalink":"https://wcc723.github.io/tags/javascript/"}]},{"title":"Transform3D 翻牌效果","slug":"css3-180-flip","date":"2013-10-30T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/31/css3-180-flip/","link":"","permalink":"https://wcc723.github.io/css/2013/10/31/css3-180-flip/","excerpt":"再經過一連串的CSS3苦練之後...，發現我對CSS transform3D挺有興趣的，但是一個3D的Demo都要花很多的時間才做得出來...，如果不嫌棄就先看一些以前做的吧~。","text":"再經過一連串的CSS3苦練之後...，發現我對CSS transform3D挺有興趣的，但是一個3D的Demo都要花很多的時間才做得出來...，如果不嫌棄就先看一些以前做的吧~。 翻牌效果 翻牌效果是CSS3中算比較容易的，但是在定位就比較麻煩一些，由於要先將兩張圖重疊，所以用的是position: absolute，剩下的部分就直接在sass code中介紹吧。 //sass code @mixin turn180($zIndex: 10) position: relative //因為要用 absolute定位，所以外圍當然要用relative囉~ +perspective(1000) //透視 .flipper +transform-style(preserve-3d) //transform3D必要 +transition(all 0.8s) //動畫轉換效果 &:hover +transform(rotateY(180deg)) //滑入之後，整體旋轉180度 &:first-child //這邊是要將兩張圖的前後位置對調 z-index: $zIndex + 1 & + * //相鄰的第二張圖要放在前方 z-index: $zIndex + 2 & > * //這邊用全域選取器，也可以換成其他的~ position: absolute top: 0 +transform-style(preserve-3d) &:first-child //這邊就是先將第一張圖放在前方 z-index: $zIndex + 2 left: 0 +backface-visibility(hidden) //CSS3D 不顯示背面的圖 & + * //相鄰的第二個元素 z-index: $zIndex + 1 right: 0 +transform(rotateY(180deg)) //第二張圖先反轉到背面 +backface-visibility(hidden) .turn180 +turn180 //include上面那個@mixin backface-visibility backface-visibility是用來決定transform3D的元素背面是否顯示，預設值是顯示。沒有將背面隱藏，會類似下面的效果(下方範例只有一張圖)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS - pure CSS 星球公轉(3D)","slug":"solar-system","date":"2013-10-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/29/solar-system/","link":"","permalink":"https://wcc723.github.io/css/2013/10/29/solar-system/","excerpt":"有些時候技術光學習還不夠，必須想一些作品來實作，而這邊我要展示一個星球公轉效果，接下來介紹一些這當中所遇到的問題。","text":"有些時候技術光學習還不夠，必須想一些作品來實作，而這邊我要展示一個星球公轉效果，接下來介紹一些這當中所遇到的問題。 2D 公轉 在製作成3D公轉前，可以先做一個2D公轉，這兩者基本上是很類似的，最大的問題會是在轉換成3D，而這部份我就不另外提供CSS，大家可以用開發者工具看看這結構是如何(如果真的沒寫好，請指教>","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 Flex的對齊","slug":"css-flex-3","date":"2013-10-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/26/css-flex-3/","link":"","permalink":"https://wcc723.github.io/css/2013/10/26/css-flex-3/","excerpt":"今天參加了MOPCON，所以來介紹簡單一點的。承前篇，Flex是為了改善過去的CSS2排版模式所衍生出的新語法，本章則要介紹他的對齊方式。 大量參考：http://www.w3.org/html/ig/zh/wiki/Css3-flexbox","text":"今天參加了MOPCON，所以來介紹簡單一點的。承前篇，Flex是為了改善過去的CSS2排版模式所衍生出的新語法，本章則要介紹他的對齊方式。 大量參考：http://www.w3.org/html/ig/zh/wiki/Css3-flexbox align-items 名稱： align-items 值： flex-start | flex-end | center | baseline | stretch 對其物件的垂直點，上面是其對應的參數，而下方式示意圖。 stretch，也是預設值，把整個拉開來。 100px 200px flex: 1 flex-start 100px 200px flex: 1 flex-end 100px 200px flex: 1 center 100px 200px flex: 1 baseline，這是比較特例的，可以配合文字的行高(line-height)，將元素第一行文字對齊。 100px 200px flex: 1 justify-content 水平的對齊方式，配合以下的這張圖和下面的範例可以了解其功能。 名稱： justify-content 值： flex-start | flex-end | center | space-between | space-around center 100px 200px 100px flex-start 100px 200px 100px flex-end 100px 200px 100px space-between 100px 200px 100px space-around 100px 200px 100px","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 Flex的排版方式","slug":"css-flex-2","date":"2013-10-24T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/25/css-flex-2/","link":"","permalink":"https://wcc723.github.io/css/2013/10/25/css-flex-2/","excerpt":"flex是用來排版的CSS屬性，在本章就用所了解的flex來排版看看，並且在介紹幾個flex屬性。","text":"flex是用來排版的CSS屬性，在本章就用所了解的flex來排版看看，並且在介紹幾個flex屬性。 flex-wrap: wrap Flex-wrap的功能其實就是把超過100%的元素換行，這邊就直接來做個實驗就可以了解。 //以下兩個html範例結構如下 &lt;div class=&quot;container&quot;&gt; &nbsp; &nbsp; &lt;menu&gt;Menu&lt;/menu&gt; &nbsp; &nbsp; &lt;nav&gt;Nav&lt;/nav&gt; &nbsp; &nbsp; &lt;article&gt;Article&lt;/article&gt; &nbsp; &nbsp; &lt;footer&gt;Footer&lt;/footer&gt; &lt;/div&gt; //sass code header,menu,footer width: 100% nav width: 120px article flex: 1 Header Menu Nav Article Footer 如果沒有加上flex-wrap: wrap，以上的元素就會像是車禍一樣撞在一起，原因就是所有元素都被排成一排；只要加上了flex-wrap: wrap，超過100%的元素將會被換行。 .container display: flex flex-wrap: wrap Header Menu Nav Article Footer 接下來也可以是著加上一些內容看看。 Header Menu 為什麼 這邊 也會 有選單 ? 內容標題 「圓仔」喝媽媽的乳汁越長越大，「圓圓」呵護備至，常常攬在懷裡，但「圓仔」也有回饋，因為牠的便便可說是「圓圓」的營養劑。 台北市立動物園今天說，「圓仔」一百零九日齡大，體重已經突破七千兩百四十六公克。目前「圓仔」唯一的食物就是媽媽「圓圓」的乳汁，儘管觀察到「圓圓」一天只有哺乳一至兩次，但「圓仔」的體重穩定上升。 Footer Order 這是定義元素的排列位置，下面有一個簡單的範例，只要點選的元素，該元素的order會被定義成-1，這樣他就會被排到最前面。 //sass code //這是用純css製作的範例，可以參考之前的Checkbox的妙用 input:checked & + label order: -1 background: #375F99 1 2 3 4 垂直水平置中 在過去的CSS都要用盡各種奇怪的方式才能垂直水平置中(table、light-height等等)，現在可以容易達到垂直水平置中(還不只一種方式噢～) Margin 置中 方法和以前差不多，只要設定margin: auto即可。 div margin: auto this is away center. Align-items & justify-content 簡單來說，就是從外層去設定內層物件的置中，在flex外層的對齊設定相當多樣，下一章會繼續介紹。 .container align-items: center justify-content: center this is away center.","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 display:flex","slug":"css-flex-1","date":"2013-10-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/24/css-flex-1/","link":"","permalink":"https://wcc723.github.io/css/2013/10/24/css-flex-1/","excerpt":"display: box及display: flex，兩者是類似的伸縮排版語法但現在已經改成display: flex。 display: box; is a version of 2009. display: flexbox; is a version of 2011. display: flex; is the actual version. display: box是存在的版本，但是它是過去的，現在使用的是display: flex。 目前compass的核心也還是使用display: box","text":"display: box及display: flex，兩者是類似的伸縮排版語法但現在已經改成display: flex。 display: box; is a version of 2009. display: flexbox; is a version of 2011. display: flex; is the actual version. display: box是存在的版本，但是它是過去的，現在使用的是display: flex。 目前compass的核心也還是使用display: box display: flex 這是相當正式的版本，以我目前手上的firefox及chrome都是不需要前輟詞就可以運作。 //sass code .display-box display: flex width: 100% 和display: box設定其實差不多，外層設定只是把box換成了flex，且不需要前輟詞(目前我測試chrome & Firefox是可以正常顯示，IE10不行，safari不行)。 //sass code .flex3 flex: 3 .flex5 flex: 5 內層只要設定flex加上值就可以，下面的結果就是左邊的1加上右邊的3得到4，左邊就會顯示1/4的黃色，右邊則是3/4的深藍色。 flex: 1 flex: 3 一樣可以插入更多的flex，如以下範例就是被分成九等份，再由三個flex去分配。 flex: 1 flex: 3 flex: 5 與固定值共用 接下來，我們插入一個固定值200px，那麼空間會保留200px的大小，剩於的再由flex去分攤，flex依然會在剩下的空間分為四等分(如下範例)。 200px flex: 1 flex: 3 混合使用 在過去這樣的問題相當難解決，透過CSS3我們可以將許多種單位混用，如下範例，可以先切200px，在切20%，剩餘的區域在分為1/4與3/4。 20% flex: 1 flex: 3 200px flex-direction flex-direction等於box-direction的強化版，可以決定垂直排列及反轉排列。 名稱： flex-direction 值： row | row-reverse | column | column-reverse 正常版 預設值就是flex-direction: row，水平由左至右排列。 flex: 3 flex: 1 flex: 5 水平反轉 flex-direction: row-reverse，就可以水平反轉排列。 flex: 3 flex: 1 flex: 5 垂直柱狀 而將值設定為column，就可以垂直排列(如果換成column-reverse就可以垂直反轉噢～)。 flex: 3 flex: 1 flex: 5 在柱狀排列下，也可以設定百分比排列(box-flex的情況，firefox不支援垂直百分比。) flex: 3 flex: 1 height: 50%","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS3 垂直文字書寫","slug":"Vertical-write","date":"2013-10-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/20/Vertical-write/","link":"","permalink":"https://wcc723.github.io/css/2013/10/20/Vertical-write/","excerpt":"html最早都是應用於拉丁文上，而拉丁文主要是水平由左到右的書寫方式，而到了其他的語系國家，文字也只能用水平由左到右的書寫方式；而漢字是屬於垂直書寫由右到左的書寫方式，現在也能透過CSS的writing-mode改變，就來看一下範例吧。","text":"html最早都是應用於拉丁文上，而拉丁文主要是水平由左到右的書寫方式，而到了其他的語系國家，文字也只能用水平由左到右的書寫方式；而漢字是屬於垂直書寫由右到左的書寫方式，現在也能透過CSS的writing-mode改變，就來看一下範例吧。 正常版 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 這是最正常的水平書寫方式，但我們都知道古詩還是直行的比較習慣。 Writing-mode 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 -webkit-writing-mode: vertical-lr writing-mode: vertical-lr 透過writing-mode，值設定為 vertical-lr，就可以把文字改為直書，透過小學課本我們可以了解不只是直書還要由右到左。 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 -webkit-writing-mode: vertical-rl writing-mode: vertical-rl 再把值改為vertical-rl，就可以直書且由右到左。 床前明月光 疑是地上霜 舉頭望明月 低頭思故鄉 如果還不夠，可以把字體換成標楷體...，就可以重現小學課本上的古詩了...。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Animation 的各項設定值","slug":"css-animation-setting","date":"2013-10-17T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/18/css-animation-setting/","link":"","permalink":"https://wcc723.github.io/css/2013/10/18/css-animation-setting/","excerpt":"和其他屬性一樣，animation有許多屬性可以設定，當然也可以用一個animation涵蓋全部，以下會分別介紹以下屬性的用途。 來源：http://css.doyoe.com/ [ animation-name ]：設置物件所應用的動畫名稱(必填) [ animation-duration ]：檢索或設置對象動畫的持續時間(必填) [ animation-timing-function ]：檢索或設置物件動畫的過渡類型 [ animation-delay ]：檢索或設置對象動畫延遲的時間 [ animation-iteration-count ]：檢索或設置物件動畫的迴圈次數 [ animation-direction ]：檢索或設置物件動畫在迴圈中是否反向運動","text":"和其他屬性一樣，animation有許多屬性可以設定，當然也可以用一個animation涵蓋全部，以下會分別介紹以下屬性的用途。 來源：http://css.doyoe.com/ [ animation-name ]：設置物件所應用的動畫名稱(必填) [ animation-duration ]：檢索或設置對象動畫的持續時間(必填) [ animation-timing-function ]：檢索或設置物件動畫的過渡類型 [ animation-delay ]：檢索或設置對象動畫延遲的時間 [ animation-iteration-count ]：檢索或設置物件動畫的迴圈次數 [ animation-direction ]：檢索或設置物件動畫在迴圈中是否反向運動 以下範例都是用相同的keyframes作介紹，僅調整animation的屬性。 +keyframes(ifinityCircles) from +transform(rotate(0)) to +transform(rotate(360deg)) Name 及 Duration 就像上面所說的，就算是每個屬性可以分開設定，但其實也是可以用一個animation寫一起，以下的範例都是寫一起，就不分開設定了。 Name和Duration都是必填屬性，所以必須一起介紹，在這邊都是引用上面的那一組keyframe。 +animation(ifinityCircles 3s) //ifinityCircles 是 keyframe的name //3s 是duration 除了name相同外，我們改變時間，動畫時間會明顯的變長。 +animation(ifinityCircles 8s) Timing-function 速率的timing-function可以參考: /css/2013/08/24/css-transtion-speed/ 建議可以參考上面的範例，animation和transition所使用的timing-function是相同的，所以可以先把常用的記起來~。 +animation(ifinityCircles 3s ease) //ease就是 timing-function的預設值 在這種旋轉的動畫，我喜歡設定線性(linear)的timing-function。 +animation(ifinityCircles 3s linear) Delay 如同字義的意思，就是延遲撥放動畫，有些時候可以用這效果讓多個動畫做出層次感。 +animation(ifinityCircles 3s) //沒有delay +animation(ifinityCircles 3s 1.5s) //第二個秒數設定，會被判定為delay Iteration-count 動畫重複的次數，預設值是1次，如果要多次直接輸入次數即可，而無限次數就要輸入infinite。 +animation(ifinityCircles 1.5s 2) //重複2次 +animation(ifinityCircles 1.5s infinite) //重複無限次 Direction 決定動畫順轉或是逆轉的模式，這邊的範例用無限次撥放比較好說明。 +animation(ifinityCircles 1.5s reverse infinite) //一直保持逆轉的模式 +animation(ifinityCircles 1.5s alternate-reverse infinite) //先逆轉，然後再順轉回去 +animation(ifinityCircles 1.5s alternate infinite) //首先是順轉，會在逆轉回去","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Animation 和 keyframe","slug":"css-animation-keyframe","date":"2013-10-16T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/17/css-animation-keyframe/","link":"","permalink":"https://wcc723.github.io/css/2013/10/17/css-animation-keyframe/","excerpt":"CSS的Animation分為兩個部分，一個是決定動畫該如何跑的Keyframe，另一個是將動畫載入元素的Animation。簡單來說，就是先製作一個keyframe來決定動畫的影格動作，在將動作載入元素，而這兩個都是必要的。","text":"CSS的Animation分為兩個部分，一個是決定動畫該如何跑的Keyframe，另一個是將動畫載入元素的Animation。簡單來說，就是先製作一個keyframe來決定動畫的影格動作，在將動作載入元素，而這兩個都是必要的。 Sass中 Keyframe , Animation的@mixin Compass目前版本似乎沒有支援animation，首先要先準備兩個mixin，一個是keyframe，另一個是animation。 參考：https://gist.github.com/ericam/1607696 //@mixin for keyframe =keyframes($name) @-webkit-keyframes #{$name} @content @-moz-keyframes #{$name} @content @-ms-keyframes #{$name} @content @keyframes #{$name} @content //@mixin for animation =animation($content) -webkit-animation: $content -moz-animation: $content -o-animation: $content animation: $content 如果沒有意外，這些sass就可以對應各種瀏覽器的前輟詞，現在就立馬做一個簡單的demo吧！ Demo %box height: 100px width: 100px margin: 0 auto background: orange +keyframes(ifinityCircles) from +transform(rotate(0)) to +transform(rotate(360deg)) div @extend %box +animation(ifinityCircles 3s infinite linear) 就這樣馬上就能完成animation，輕鬆愜意～ Keyframe Keyframe在設定上也很容易，我們直接看下面的demo就可以了。 keyframe設定 //sass code //我們製作兩款keyframe樣式，一款是from to，另一款就是百分比。 //這一款from to 其實就是0%~100%的意思 +keyframes(ifinityCircles) from +transform(rotate(0)) //不管事百分比或是from to，都可以直接在這邊設定每個階段的動作 to +transform(rotate(360deg)) //如果另外設定百分比，就可以設定更細節的設定 +keyframes(ifinityCircles2) 0% +transform(rotate(0)) 50% +transform(translateX(-100%) rotate(180deg)) 100% +transform(translateX(100%) rotate(360deg)) 元素的animation設定 .box +animation(ifinityCircles 3s infinite linear) //這邊可以就可以直接引用剛剛的keyframe //ifinityCircles : keyframe自訂義名稱 //3s : 持續時間 //infinite : 反覆次數(無限) //linear : 動畫曲線(速率一致就對了) .box1 +animation(ifinityCircles2 3s infinite linear alternate) //alternate : 動畫在結束時，會反轉回去","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 鐵人賽不是開始，也不是結束","slug":"css-ironman","date":"2013-10-14T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/15/css-ironman/","link":"","permalink":"https://wcc723.github.io/css/2013/10/15/css-ironman/","excerpt":"在鐵人賽前一個月，我在進行一個計劃，就是挑戰100天發文，內容以前端為主，雖然每天都有新的文章，但我都不會特別去核對文章的內容。而鐵人賽開始後，將主題調整為CSS為主，內容也不是只將demo貼上後隨便貼個原始碼就結束了，許多內容都必須去尋找相關的資料，讓主題及內容更加可看性，這過程中也讓CSS的基礎更上一層樓...。","text":"在鐵人賽前一個月，我在進行一個計劃，就是挑戰100天發文，內容以前端為主，雖然每天都有新的文章，但我都不會特別去核對文章的內容。而鐵人賽開始後，將主題調整為CSS為主，內容也不是只將demo貼上後隨便貼個原始碼就結束了，許多內容都必須去尋找相關的資料，讓主題及內容更加可看性，這過程中也讓CSS的基礎更上一層樓...。 這三十天還有很多CSS3沒有介紹到，也有沒補足的地方，像是animation、flex layout等等，有興趣的人可以繼續關注http://ashareaday.wcc.tw/，我會持續發表和CSS及前端有關的文章。現在已經移到http://wcc723.github.io/囉～(2013/12/25) 每天文章的開始 起因 http://jenniferdewalt.com/ 中文介紹 http://techorange.com/2013/08/01/i-am-making-one-website-a-day-for-180-days/ 幾個月前我看到上面這個網站，他的目標就是在180天做180個網站(後來挺精彩的...)，用這個方式來精進自己的技術，因此我也挑戰每天發文，由於每日都需要有不同的內容，有時想要新的挑戰，必須不斷地思考及尋找新的資料，這樣果真進步神速...。 A share a day的架構是用靜態html配合ajax，沒有資料庫，主要原因是為了在製作demo更容易，以及方便上傳更新。 A share a day 還沒結束 A share a day 在鐵人賽前已經進行了約30日，所以在鐵人賽後離目標的100日還有40日左右，許多在鐵人賽中沒有介紹到的內容還會繼續地進行，另外主題也會回到以前的多種前端技術，並不會侷限於CSS。雖然在這過程中有許多新的想法，但不能因此中斷每日的計劃！ 接下來的規劃 A share a day 並不是一個好的架構，他連SEO都有問題，只是在DEMO上真的很方便。所以除了繼續進行下去外，也會開始尋找合適的方式記錄這些文章(我原本是用wordpress，我認為還是不方便)，可能會是logdown吧～ 另外會開始挑戰用CSS做更有趣的作品，就像是Codepen上的一樣，但...應該要再過個幾週後吧...。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS 的相關資料","slug":"css-collection","date":"2013-10-13T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/14/css-collection/","link":"","permalink":"https://wcc723.github.io/css/2013/10/14/css-collection/","excerpt":"今天沒有要介紹任何效果，是要介紹這些CSS資料是從何處獲得的。","text":"今天沒有要介紹任何效果，是要介紹這些CSS資料是從何處獲得的。 前端社群 台灣的前端社群也是高手雲集的地方，如果想要知道最新的技術資訊，從社群進入是最快的方式，這邊就簡單介紹幾個與CSS有關的Facebook社群。 HTML5 與 CSS3 :https://www.facebook.com/groups/htmlfive/ Front-End Developers Taiwan :https://www.facebook.com/groups/521085554595481/ RGBA :https://www.facebook.com/groups/rgba.tw/ RGBA 資源 :https://www.facebook.com/rgba.tw?fref=ts 高雄前端社群 :https://www.facebook.com/groups/358503154261390/ 靈感來源 在不清楚CSS可以做些什麼之前，我們可以先四處蒐集靈感，有好的範例後，我們可以從中拆解學習其CSS的效果組成原理，並且轉化成日後專案的利器。 Codepen :http://codepen.io/ Codrops :http://tympanus.net/codrops/ Codepen 這網站上有很多高手實驗性的作品，本站的很多效果也是參考其中實驗性的作品。 Codrops 這邊會蒐集許多細膩的前端效果，許多不只創新，還相當有質感。 前端字典 找到了效果後，在拆解的過程中如果有不了解的問題，一定要追根究柢，所以字典是非常重要的，當然這邊也是介紹和CSS有關的字典。 Devdocs : http://devdocs.io/ Overapi : http://overapi.com/css/ Devdocs 這是我主要查詢程式碼的網站，內容詳盡，且有標示相關來源，值得推薦。 Overapi 主要是清單列表相當清楚，配合ctrl+f很快可以找到要的屬性。 優秀的設計網站 除了實驗性的效果，我們也可以看看大家是怎們把效果實作在產品上。以下都是相當棒的網站，就不一一介紹了，而Media Queries和其他比較起來是較中規中矩，但每一個網站都符合各裝置，且品質都相當具有指標性。 Flatdsgn : http://flatdsgn.com/ CSS Winner : http://www.csswinner.com/ CSS Design awards : http://www.cssdesignawards.com/ Awwwards : http://www.awwwards.com/ Media Queries : http://mediaqueri.es/ Flatdsgn CSS Winner CSS Design awards Awwwards Media Queries 網路上的資源絕對不止這些，但以上所挑選的網站都是會不斷地更新資料，如果有興趣的朋友可以不定期的看這些網站。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - pure CSS 專輯列表效果","slug":"css-album-list","date":"2013-10-11T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/12/css-album-list/","link":"","permalink":"https://wcc723.github.io/css/2013/10/12/css-album-list/","excerpt":"鐵人賽快要結束了，今明兩天會介紹純CSS可以做些什麼特別的效果。今天要介紹的是專輯相簿的效果。","text":"鐵人賽快要結束了，今明兩天會介紹純CSS可以做些什麼特別的效果。今天要介紹的是專輯相簿的效果。 來源 : http://codepen.io/anon/pen/hixjL 建立html 為愛而生 遠端遙控器 &lt;div class=&quot;cover&quot;&gt; &lt;div class=&quot;coverflow-list&quot;&gt; &lt;input type=&quot;checkbox&quot; name=&quot;cover-item&quot; id=&quot;cover-1&quot;&gt; &lt;div class=&quot;coverflow-item&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt; &lt;figure class=&quot;album-cover&quot;&gt; &lt;img src=&quot;/images/mayday/001.jpg&quot; alt=&quot;&quot;&gt; &lt;/figure&gt; &lt;figcaption class=&quot;album-name&quot;&gt;為愛而生&lt;/figcaption&gt; &lt;/label&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;controllor&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt;遠端遙控器&lt;/label&gt; &lt;/div&gt; 首先準備好需要的html，有些重點可以讓大家了解。 checkbox 中的id記得設定 id是唯一的 label中的for的值會對應到checkbox的id label可以重複使用，for的值對應相同ID即可 設定基本樣式 這一部分只是先設定基本樣式，就不多闡述了。 為愛而生 遠端遙控器 .coverflow-item display: inline-block position: relative margin: 0 auto text-align: center .album-cover height: 150px width: 150px img opacity: 0.5 .album-name text-align: center display: block color: #777 label display: block 設定3D樣式 在先前的文章有依序介紹許多transform的樣式設定，如果仔細看其實都是前幾個章節介紹的。 為愛而生 遠端遙控器 .coverflow-list +perspective(900px) //設定3D景深距離 +transform-style(preserve-3d) +perspective-origin(100% 30%) //3D透視的視點 .coverflow-item +transition(all .3s ease) //transition動畫 +transform(rotateY(45deg)) //y軸旋轉45度，這邊都是用中心點都軸心 套用checkbox效果 這步驟有兩個重點一個是checked(被選取)另一個則是+(相鄰)，所以要進行變化的元素必須緊貼著checkbox元素。 為愛而生 遠端遙控器 input[type=\"checkbox\"] display: none //隱藏checkbox &:checked //如果被選取時的效果 &+.coverflow-item //如果被選取時 其他相鄰元件效果 +transition(all .3s ease) +transform(rotateY(0.1deg)) margin: 0 auto img opacity: 1 .album-name color: #333 只要善用label中的for對應input的ID，無論多遠的距離的可以控制，接下來只要就是控制checkbox的相鄰物件狀態，就可以達到這樣的效果。 Demo 為愛而生 我們是五月天 神的孩子都在跳舞 後青春期的詩 人生海海 神的孩子都在跳舞 1 2 3 4 5 6 這一個部分是用html+CSS構成，而其中的重點是上面所介紹的label及checkbox，在本區雖然把checkbox換成了radio，但概念上是差不多的；另外一個重點則是Css selector中的~，他可以選取目前元素後方所有同層級的元素，讓這一個CD相簿有三種角度。 Html 原始碼 原始碼相當的長，我就只擷取部分作為範例。 &lt;div class=&quot;test&quot;&gt; &lt;div class=&quot;cover&quot;&gt; &lt;ul class=&quot;coverflow-list&quot;&gt; &lt;input type=&quot;radio&quot; name=&quot;cover-item&quot; id=&quot;cover-1&quot;&gt; &lt;li class=&quot;coverflow-item&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt; &lt;figure class=&quot;album-cover&quot;&gt; &lt;img src=&quot;/images/mayday/001.jpg&quot; alt=&quot;&quot;&gt; &lt;/figure&gt; &lt;figcaption class=&quot;album-name&quot;&gt;為愛而生&lt;/figcaption&gt; &lt;/label&gt; &lt;/li&gt; ...略 &lt;/ul&gt; &lt;/div&gt; &lt;div class=&quot;controllor&quot;&gt; &lt;label for=&quot;cover-1&quot;&gt;1&lt;/label&gt; &lt;label for=&quot;cover-2&quot;&gt;2&lt;/label&gt; &lt;label for=&quot;cover-3&quot;&gt;3&lt;/label&gt; &lt;label for=&quot;cover-4&quot;&gt;4&lt;/label&gt; &lt;label for=&quot;cover-5&quot;&gt;5&lt;/label&gt; &lt;label for=&quot;cover-6&quot;&gt;6&lt;/label&gt; &lt;/div&gt; &lt;/div&gt; 如果有少Div結尾，請不要太在意，只是我沒copy到而已... 這一段html和上次比較不同的地方，就是把checkbox改成了radio，radio在用法上是屬於單選題，而checkbox是屬於多選題；只要input屬性name都是相同的，都算是一個群組，而這一個群組就只能一個被選擇。 Sass .coverflow-item display: inline-block position: relative margin: 0 auto text-align: center margin: 0 -45px background-color: white .album-cover height: 150px width: 150px -webkit-box-reflect: below 22px -webkit-linear-gradient(rgba(255,255,255,0)85%, white 150%) box-reflect: below 22px linear-gradient(rgba(255,255,255,0) 85%, white 150%) //專輯反射 img opacity: 0.5 .album-name text-align: center display: block color: #777 label display: block .coverflow-list +perspective(900px) +transform-style(preserve-3d) +perspective-origin(100% 30%) .coverflow-item +transition(all .3s ease) +transform(rotateY(45deg)) input[type=\"radio\"] display: none &:checked &+.coverflow-item +transition(all .3s ease) +transform(rotateY(0.1deg)) margin: 0 auto img opacity: 1 .album-name color: #555 &~.coverflow-item +transform(rotateY(-45deg)) //重點語法 將被選取的Radio後方全部都反方向轉45度 .controllor margin-top: 40px label cursor: pointer color: #999 padding: 8px border: 1px solid #ccc background-color: #fafafa +transition(all .3s) &:hover color: #555 border: 1px solid #555 這一部分可以著重的重點就是放在CSS selector的~語法，再被選取的radio後方，進行反向Y軸旋轉的動作。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform-3D的透視(perspective)","slug":"css-perspective","date":"2013-10-10T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/11/css-perspective/","link":"","permalink":"https://wcc723.github.io/css/2013/10/11/css-perspective/","excerpt":"本篇介紹的transform 3D的透視，如果沒有設定透視(perspective)，transform 3D就會像平面一樣呈現。所以在3D的物件上，一定要設定好\"適合\"的透視，怎樣是適合，來看看以下範例就能夠了解。","text":"本篇介紹的transform 3D的透視，如果沒有設定透視(perspective)，transform 3D就會像平面一樣呈現。所以在3D的物件上，一定要設定好\"適合\"的透視，怎樣是適合，來看看以下範例就能夠了解。 重要性 本篇文章都是用同一個正方形，設定值也都相同，大家依序看下去就可以了解透視對transform 3D 的影響。 上面這一個方塊並沒有設定透視，他確實也是3D，由於沒有透視所以也感覺不到它是個立方體。 +perspective(500px) perspective的設定值只要設定距離長度即可，其屬性也只需要設定在父元素。上面這範例perspective的值就設定500px，這樣也就能獲得簡單的透視效果。 各種設定 +perspective(1500px) 而perspective的值我們可以想像成物件距離螢幕的距離，如果值越大代表越遠。 +perspective(250px) 反之，數值越小代表離螢幕越近，而越貼近則會有透視越強烈的感覺，在適當的時候，這麼貼近的視覺效果也是不錯的表現手法。 +perspective(500px) +perspective-origin(center 0%) 除了距離外，也可以設定視點的位置；如上範例，紅點是虛擬的視點，由正方形的頂端往下看，就不會看到正方形上面的面，下面的那一塊感覺也會比平常的大些。 設定視點的屬性就是用perspective-origin，預設值也是center center，也就是正中央。 +perspective(500px) +perspective-origin(right bottom) 而把視點放在下方底部，可以凸顯出圖形的氣勢，如果需要有張力的表現，也可以試試看把視點放在下方。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform-origin","slug":"css-transform-origin","date":"2013-10-09T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/10/css-transform-origin/","link":"","permalink":"https://wcc723.github.io/css/2013/10/10/css-transform-origin/","excerpt":"本篇介紹transform的起始點，一般來說變形的起始點都在物件的中心點，但如果需要像時鐘的分秒針一樣，中心點並不再物件的中心，就需要靠transform-origin去設定物件變形的起始點。","text":"本篇介紹transform的起始點，一般來說變形的起始點都在物件的中心點，但如果需要像時鐘的分秒針一樣，中心點並不再物件的中心，就需要靠transform-origin去設定物件變形的起始點。 x-50pxy-100px 在html裡的基準點都是從左上開始，從水平開始往右稱為x軸，垂直往下稱為y軸，CSS在編寫習慣上也是先寫x軸再寫y軸，如50px 100px，結果會是x軸向右50px，y軸垂直向下100px。而tranaform的屬性中，坐標將是相當重要的關鍵。 Rotate .rotate +transform(rotate(30deg)) 在這一個demo中，只有設定rotate旋轉50度，並沒有設定起始點。因為此時的物件預設值坐標是50% 50%， .rotate2 +transform(rotate(30deg)) +transform-origin(0,0) 在設定玩起始點後，2D變形物件會依起始點開始作變形，如範例中就是從x-0 y-0，左上角開始跑，所以在設定transform必須要清楚瞭解到要變型物件的起始點。 Scale Scale是屬於transform2D的縮放變形效果，值為x軸及y軸倍率，而他一樣會受物件起始點的影響。 .scale +transform(scale(1.5, 1.5)) .scale2 +transform(scale(1.5, 1.5)) +transform-origin(0,0) 由上面兩個scale範例中可以瞭解到基準點對於變形的重要性，而這將會影響版面的規劃以及其他物件之相對關係。 Rotate 3D .rotate3 @extend .box +transform-style(preserve-3d) +transform(rotateY(0deg)) +transform-origin(0,0) &:hover +transform(rotateY(90deg)) .rotate4 @extend .box +transform-style(preserve-3d) +transform(rotateY(0deg)) +transform-origin(100%,0) &:hover +transform(rotateY(-90deg)) 當然3D也不例外，如果設定好基準點，物件才能依設定的軸心旋轉，如果把軸心放在最左邊及最右邊，就可以向上方這開門的效果。 旋轉吧 時鐘 就如同最開始所說的，如果設定好起始點，畫一個時鐘也不是問題。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform 軸線的謊言","slug":"css-transform-mistake","date":"2013-10-08T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/09/css-transform-mistake/","link":"","permalink":"https://wcc723.github.io/css/2013/10/09/css-transform-mistake/","excerpt":"從小上數學課，都會知道X軸是左右，Y軸是垂直，看起來就是這麼容易，但是一到了CSS上卻是常常分不清楚，而其中最大的陷阱就是旋轉(rotate)。這篇會用簡單的動態效果，讓大家了解旋轉與軸線之間的關係(本篇都是使用sass)。","text":"從小上數學課，都會知道X軸是左右，Y軸是垂直，看起來就是這麼容易，但是一到了CSS上卻是常常分不清楚，而其中最大的陷阱就是旋轉(rotate)。這篇會用簡單的動態效果，讓大家了解旋轉與軸線之間的關係(本篇都是使用sass)。 先了解軸線的方向 X軸線就是左右，很容易，但別急，我們慢慢看下去。 Y軸線就是垂直，也是很容易。 這邊我把平面旋轉了Y軸(垂直軸)，讓大家了解Z軸的位置，而Z軸就是垂直於剛剛的平面之上，這在transform3D會使用到。 增加些動態吧 水平移動 接下來我用translate的語法，讓這個方塊水平移動。 &:hover .box +transform(translateX(100%)) //滑鼠滑入時，沿著X軸移動100% 先移動在旋轉 接下來我們讓這個物件移動並且旋轉，這邊就是陷阱的開始，目前還沒有異樣。 &:hover .box +transform(translateX(100%) rotate(30deg)) //在位移的語法後方增加上旋轉 先旋轉在移動 雖然這部分我是做成animation，但其實結果是一樣的，只是要讓大家容易了解。 如果將旋轉的語法放在前面，那麼物件的X軸也會跟著變化，所以CSS的transform是以物件為基準點，當物件旋轉時，物件的基準點也會跟著改變。 @-webkit-keyframes Rline 0% 30% +transform(rotate(30deg)) 100% +transform(rotate(30deg) translateX(200px)) 同樣的理論，我們來看看3D 首先旋轉Y軸(垂直軸)90度，然後以物件為基準朝向Z軸移動。 &:hover .box +transform(rotateY(90deg) translateZ(500px)) //維持原本的90度Y軸旋轉，並且朝向Z軸移動 和剛剛一樣，先加入旋轉在移動物件。 @-webkit-keyframes Zline 30% +transform(rotateY(90deg) rotateX(-10deg)) //維持90度Y軸旋轉，然後在旋轉X軸10度 100% +transform(rotateY(90deg) rotateX(-10deg) translateZ(500px)) //在旋轉後，往Z軸的方向移動 經過以上的實驗，相信會更了解物件的軸線吧(!?)。了解後，對於學習CSS transform也會有很大的幫助，接下來會介紹transform的基準點，敬請期待。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS transform 概觀","slug":"css-transform","date":"2013-10-07T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/08/css-transform/","link":"","permalink":"https://wcc723.github.io/css/2013/10/08/css-transform/","excerpt":"接下來要介紹CSS transform，CSS3許多新功能中，我認為transform和animation是相當有難度的，但也是最有趣的，尤其在兩者搭配後，能夠展現出類似過去flash的動態效果，但卻能保持html原有的互動性。 而在接下來的四至五天會分享transform相關的屬性運用。","text":"接下來要介紹CSS transform，CSS3許多新功能中，我認為transform和animation是相當有難度的，但也是最有趣的，尤其在兩者搭配後，能夠展現出類似過去flash的動態效果，但卻能保持html原有的互動性。 而在接下來的四至五天會分享transform相關的屬性運用。 transform概觀 本篇不會介紹以下範例的原始碼，主要會介紹transform有哪些特色，相關的原始碼會在後面的文章依序介紹。 增加網頁的動態視覺效果 過去的動態效果主要會以flash呈現，主因當然是因為html早期屬於靜態畫面呈現，如果說要吸引使用者的目光就會用些flash的效果；但在近幾年由於行動裝置的崛起，flash的應用在網頁上已經逐漸減少，如果要用動態效果可以來試試看transform吧 +transform (rotate(360deg)) 使動態更為流暢 動態效果除了CSS外，js也能夠達到，但其實js的動態效果也是基於CSS上，所以執行的效率上，還是CSS優於js。 CSS transform3D能夠開啟GPU硬體加速以提升效能(2013-12-25)。 +transform (scale(2,2)) 3D的呈現 transform除了2D外，現在也有3D的效果(點擊以下方塊)。 有趣的視覺動態 不論是2D或是3D，都有著相當豐富的參數，在這些參數混合使用下，它能夠達到許多豐富的效果，我們可以試試看用這些有趣的效果來迷惑使用者的眼睛~。 1 3 5 6 4 2 1 2 3 4 5 6 不只有趣 還可以實用 說了那麼多，不如就慢慢地套用一些效果在我們的網站上吧。 Menu 01 Menu 02 Menu 03 這篇文章或許不長，但是Demo做超久的...，主要還是想讓大家知道transform有很多有趣的地方(還有順便準備後面章節的內容...)，這周就來一起研究transform吧~。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Checkbox的妙用","slug":"css-chechbox","date":"2013-10-06T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/07/css-chechbox/","link":"","permalink":"https://wcc723.github.io/css/2013/10/07/css-chechbox/","excerpt":"CSS3 新增了:checked的偽元素，它可以判斷目前的checkbox 及 radio 是否有被選核，這樣html就能夠做出基本的點擊功能；並且結合label標籤，label標籤能夠讓樣式的套用更為自由，藉此增加畫面的豐富性。","text":"CSS3 新增了:checked的偽元素，它可以判斷目前的checkbox 及 radio 是否有被選核，這樣html就能夠做出基本的點擊功能；並且結合label標籤，label標籤能夠讓樣式的套用更為自由，藉此增加畫面的豐富性。 Selector \"~\" 在介紹checked之前，先介紹另一個selector \"~\"，許多人應該都有用過\"+\"這一個selector，它的功能是選擇相鄰的下一個元素，而\"~\"的功能是選擇同層級的後方元素，下面來看個簡單範例。 //html code &lt;div class=&quot;demo1&quot;&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;div&gt;&lt;/div&gt; &lt;/div&gt; //sass code div &:hover background: orange &:hover ~ div background: #B0095C 它的功能就像上面所顯示一樣，可以選取後方複數以上的同層級元素，而在結合:hover等等偽元素，它能有更多的效果，而等等就會拿來結合:checked。 :checked //html code &lt;input type=&quot;checkbox&quot; id=&quot;a1&quot;&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; //sass code [type=\"checkbox\"] &:checked ~ label //當checkbox被選取時，改變label顏色 background: #B0095C &:before content: \"Checkbox is checked.\" 上面有兩個元素，一個是checkbox，另一個是label，不管點哪一者都會得到一樣的結果，其原理是用 label for 對應checkbox的id，這樣兩者就會產生連動效果(html 的概念)；再利用CSS的選取器\"~\"改變label的樣式。 複數 label也可以執行 //html code &lt;input type=&quot;checkbox&quot; id=&quot;a1&quot;&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; &lt;label for=&quot;a1&quot;&gt;&lt;/label&gt; 在html的規定id是不能夠重複的，但是label for是可以重複使用。 隱藏checkbox &lt;input type=&quot;checkbox&quot; id=&quot;a3&quot;&gt; &lt;label for=&quot;a3&quot;&gt;&lt;/label&gt; &lt;div class=&quot;circles&quot;&gt;&lt;/div&gt; &lt;div class=&quot;circles&quot;&gt;&lt;/div&gt; //sass code .demo3 [type=\"checkbox\"] display: none //隱藏checkbox &:checked + label background: #B0095C //當checkbox被選取時，和checkbox相鄰的 label改變顏色 &:before content: \"Checkbox is checked.\" & ~ .circles //和checkbox同層的元素，開始進行animation animation: ifinityCircles 3s linear infinite -webkit-animation: ifinityCircles 3s linear infinite 剛剛有提到，label可以讓樣式設定更為容易，所以我們可以把checked隱藏起來，讓使用者只有看到label，這樣在畫面的設計上會更為自由。 而這互動效果，在後面的章節會有更豐富的運用，敬請期待!","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3 Fliter 效果","slug":"css-fliter","date":"2013-10-05T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/06/css-fliter/","link":"","permalink":"https://wcc723.github.io/css/2013/10/06/css-fliter/","excerpt":"假日都來介紹些單篇的主題吧~，今天要介紹的是filter。","text":"假日都來介紹些單篇的主題吧~，今天要介紹的是filter。 box-shadow 圖片來源：火影忍者 box-shadow在先前介紹過，他是\"盒狀\"元素的陰影，所以稱作為\"box\" shadow，所以應用在圖片上，它自然就是以整個圖片的外框做陰影，這固然是正確的，但不一定是我們所想要的；上面這一張是png圖片，如果想要只在人物外框增加陰影，勢必要另外做一張圖了。 Filter filter是一種濾鏡效果，就像是繪圖軟體的濾鏡，他會以目前畫面上的圖形來套用效果，因此透明的區域就不會有效果。 參考：http://devdocs.io/css/filter drop-shadow //sass code img +filter(drop-shadow(5px 5px 5px rgba(black,.5))) 我們把類似box-shadow效果的drop-shadow同樣套用在這張圖上，它不再是以圖片外框來做陰影，而是以圖片的內容套用濾鏡陰影效果。 contrast img +filter(contrast(300%)) 目前他提供約10種的濾鏡，像這就是提高對比。 grayscale img +filter(grayscale(100%)) 很多圖片預覽也可以像這樣做成灰色的，然後在滑鼠hover時在轉換為彩色，在過去須配合js或是兩張的圖片，如果使用filter也可以達到這樣的效果。 hue-rotate img +filter(hue-rotate(180deg)) 這簡直就像簡易版的photoshop，旋轉色相這效果也有! blur img +filter(blur(10px)) 如果大家是用-webkit-瀏覽器，應該就能感受到這些豐富的效果，如果是firefox、IE10等等瀏覽器，如果沒看到以上效果應該就能了解到了吧，這些效果固然非常有趣，但目前只有-webkit-有支援，相信firefox等瀏覽器在不久的未來都會支援這些效果。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"自己做web fonts icons","slug":"web-fonts-2","date":"2013-10-04T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/05/web-fonts-2/","link":"","permalink":"https://wcc723.github.io/css/2013/10/05/web-fonts-2/","excerpt":"承上一篇，本篇會介紹自己做web fonts icons，讓會手癢的設計師可以自行設計web font icon。","text":"承上一篇，本篇會介紹自己做web fonts icons，讓會手癢的設計師可以自行設計web font icon。 先看看成品 @font-face { font-family: \"drangon\"; src: url('/demoFile/css/fonts/normal'); src: url('/demoFile/css/fonts/normal?#iefix') format('eot'), url('/demoFile/css/fonts/icomoon.eot') format('embedded-opentype'), url('/demoFile/css/fonts/icomoon.ttf') format('truetype'), url('/demoFile/css/fonts/icomoon.woff') format('woff'), url('/demoFile/css/fonts/icomoon.svg') format('svg'); font-weight: normal; } g 這次的目標是做出七龍珠裡的一星球，使用的繪圖軟體是illustrator，而製作成web font是http://icomoon.io/app 這個網站。 步驟 繪製向量檔 這是illustrator的畫面，用哪套軟體倒是沒什麼關係，只要能夠轉SVG就可以了，但另外有一個重點，如果有用到線段要記得展開，轉SVG比較不會有問題。 存檔的時候，就選SVG就對了。 SVG選項請調整成SVG Tiny。 開始製作webfont 第一個步驟，就是先打開http://icomoon.io/app 的網頁 把剛剛的檔案匯入到這個網站，選import或是直接拖曵檔案到網頁裡皆可。 SVG都匯入後，就可以點網頁下方的Font，這邊就只有一顆一星球。 接下來可以為每個一icon指定一個符號、英文或是數字，在這邊可以注意到我設定的是g，都確定後就點Download吧。 下載後的壓縮檔裡面有完整的範例檔，基本上只要按照範例檔去設定就可以了。 使用自己做的Web font Icon 由他所提供的範例檔可以得知，它的使用方式有兩種，一種是設定data，而另一種是設定Class。而不論是哪一種都必須載入他所提供的@font-face。 /*@font-face 設定*/ @font-face { font-family: 'icomoon'; src:url('fonts/icomoon.eot'); src:url('fonts/icomoon.eot?#iefix') format('embedded-opentype'), url('fonts/icomoon.woff') format('woff'), url('fonts/icomoon.ttf') format('truetype'), url('fonts/icomoon.svg#icomoon') format('svg'); font-weight: normal; font-style: normal; } 利用Data-icon設定 [data-icon]:before { font-family: 'icomoon'; content: attr(data-icon); speak: none; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } 這一個的原理是利用CSS的屬性選取器，選則html標籤裡有data-icon屬性的元素，並利用偽元素新增content，而content的內容會對應data-icon的值。如範例我的data-icon的值為\"g\"，就是當時設定的一星球。 利用Class設定 .icon-dragonBall { font-family: 'icomoon'; speak: none; font-style: normal; font-weight: normal; font-variant: normal; text-transform: none; line-height: 1; -webkit-font-smoothing: antialiased; } .icon-dragonBall:before { content: \"\\67\"; } 這是他所提供的另一個方式，設定Class他就能將指定的圖形載入，這作法也是比較基本且容易的。 g 而我們也可以單獨把上面的Class拆出來用，直接輸入\"g\"一樣有效果。 g 相容性誤解 在上一篇的時候，我有說明到 web-font icon的相容性，在此可能要重新說明一下。上一篇所使用的 web font(ligature_symbols) 和本篇的 web font(icomoon.io) 有些不同。ligature_symbols的web font有再利用CSS3的語法(text-rendering)讓單字可以轉為icon；而本篇(icomoon)的是屬於基本款的web font，大部分的瀏覽器都有支援，造成誤會敬請見諒。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Web-font & icons","slug":"web-fonts","date":"2013-10-03T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/10/04/web-fonts/","link":"","permalink":"https://wcc723.github.io/css/2013/10/04/web-fonts/","excerpt":"本篇所用的範例是Ligature Symbols，它所提供的的icons非常多，而且簡單易用。","text":"本篇所用的範例是Ligature Symbols，它所提供的的icons非常多，而且簡單易用。 @font-face { font-family: \"LigatureSymbols\"; src: url('/demoFile/css/fonts/normal'); src: url('/demoFile/css/fonts/normal?#iefix') format('eot'), url('/demoFile/css/fonts/LigatureSymbols-2.05.eot') format('embedded-opentype'), url('/demoFile/css/fonts/LigatureSymbols-2.05.ttf') format('truetype'), url('/demoFile/css/fonts/LigatureSymbols-2.05.woff') format('woff'), url('/demoFile/css/fonts/LigatureSymbols-2.05.svg#LigatureSymbols') format('svg'); font-weight: normal; } .lsf { font-family: \"LigatureSymbols\"; font-size: 300%; -webkit-text-rendering: optimizeLegibility; -moz-text-rendering: optimizeLegibility; -ms-text-rendering: optimizeLegibility; -o-text-rendering: optimizeLegibility; text-rendering: optimizeLegibility; -webkit-font-smoothing: antialiased; -moz-font-smoothing: antialiased; -ms-font-smoothing: antialiased; -o-font-smoothing: antialiased; font-smoothing: antialiased; -webkit-font-feature-settings: \"liga\" 1, \"dlig\" 1; -moz-font-feature-settings: \"liga=1, dlig=1\"; -ms-font-feature-settings: \"liga\" 1, \"dlig\" 1; -o-font-feature-settings: \"liga\" 1, \"dlig\" 1; font-feature-settings: \"liga\" 1, \"dlig\" 1; } Ligature Symbols 本篇所用的範例是Ligature Symbols，它所提供的的icons非常多，而且簡單易用。 http://kudakurage.com/ligature_symbols/ 首先當然是先下載他們所提供的檔案，解壓縮後有完整的html以及CSS範例，先找到LigatureSymbols-2.05.ttf的字型檔，將字型檔放在本地端的資料夾，本範例會放在sylesheets的fonts資料夾內。 在他們的網頁下方有提供完整的CSS，包含@font-face以及.class的設定，基本上直接拷貝即可；這邊將會用sass作範例。 //sass code //compass 的font-face@include，而其中的format在compass是不需要設定的 +font-face(\"LigatureSymbols\",font-files(\"LigatureSymbols-2.05.eot\",\"LigatureSymbols-2.05.ttf\",\"LigatureSymbols-2.05.woff\",\"LigatureSymbols-2.05.svg#LigatureSymbols\"),normal,normal) .lsf font-family: 'LigatureSymbols' font-size: 300% -webkit-text-rendering: optimizeLegibility -moz-text-rendering: optimizeLegibility -ms-text-rendering: optimizeLegibility -o-text-rendering: optimizeLegibility text-rendering: optimizeLegibility //文字的渲染方式 -webkit-font-smoothing: antialiased -moz-font-smoothing: antialiased -ms-font-smoothing: antialiased -o-font-smoothing: antialiased font-smoothing: antialiased //文字的平滑模式 -webkit-font-feature-settings: \"liga\" 1, \"dlig\" 1 -moz-font-feature-settings: \"liga=1, dlig=1\" -ms-font-feature-settings: \"liga\" 1, \"dlig\" 1 -o-font-feature-settings: \"liga\" 1, \"dlig\" 1 font-feature-settings: \"liga\" 1, \"dlig\" 1 //在OpenType 有更進階的設定，但這邊沒有特別研究 //html &lt;div class=&quot;lsf&quot;&gt;twitter&lt;/div&gt; 查詢一樣在這邊：http://kudakurage.com/ligature_symbols/ 接下來只要輸入對應的class，然後再到該頁面查詢對應的單字就可以套用，如範例我只要輸入class，在class內在填入twitter就可以獲得twitter的icon。 Web font icon有什麼優點? 1.可以被搜尋 如以下範例，使用者可以在瀏覽器(Ctrl+f)搜尋twitter，然後選取到以下圖形。 twitter 2.可以改變大小不失真 他是個文字，只要調整font-size，就可以改變其大小。 font-size: 50px twitter 3.可以改變顏色(單色為主) 同上，它是個文字，只要改變color就可以改變顏色。 color: #00ACEE twitter 3.各種CSS文字屬性 當然它可以套用任何文字效果，如italic。 font-style: italic twitter 4.陰影 在web-font icon下，text-shadow會更適合。 text-shadow: 1px 1px 5px rgba(black,.5) twitter 5.動態效果不失真 由於它不是點陣圖形，再放大縮小等動態效果，並不會有模糊及解析度不夠的問題。 .demo6 font-size: 40px +transition(all .5s) ... &:hover font-size: 50px twitter 6.各種文字的效果混合使用 這是我之前做的立體文字效果，當然它也能夠套用在web-font icon上。 //立體文字的mixin @mixin text-cubicStyle($lenght: 15,$rgb: #dfdfdf) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,darken($rgb,$i/1.6)),comma) text-shadow: $all,$lenght+1px $lenght+1px 1px rgba(0,0,0,.3),$lenght+2px $lenght+2px 10px rgba(0,0,0,.6) //@include 上面的立體效果 .demo5 +text-cubicStyle ... twitter 缺點 注意，這會有支援性的問題。 明天將會介紹怎麼做web-font icon，敬請期待!!","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Transition 實作波動拳動圖","slug":"transition","date":"2013-10-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/10/02/transition/","link":"","permalink":"https://wcc723.github.io/sass/2013/10/02/transition/","excerpt":"CSS3除了有更多的樣式外，其中一個重點就是動態，而transition是動態效果最容易達成的；所以本篇主要要介紹的是transition，以及transition的timing-function。","text":"CSS3除了有更多的樣式外，其中一個重點就是動態，而transition是動態效果最容易達成的；所以本篇主要要介紹的是transition，以及transition的timing-function。 小範例 .demo{ background: red; -webkit-transition: background 1s; -moz-transition: background 1s; -o-transition: background 1s; transition: background 1s; ... } .demo:hover { background: blue; } 如果要做一個hover的動態效果，只要在原物件上新增transition語法，並且在隨後的hover新增改變後的效果即可(如上範例)，而其中必填的參數為1.運動屬性 及 2.運動秒數。 而在本篇另外介紹timing-function，此屬性是改變動態效果的時間曲線(參考http://devdocs.io/css/timing-function)，善用timing-function，可以獲得更豐富的效果。 參考 : http://www.w3schools.com/cssref/css3_pr_transition-timing-function.asp http://devdocs.io/css/transition-timing-function Demo中的共通sass div width: 50px height: 50px background: red +transition-property(margin-left) +transition-duration(5s) .demo:hover > div margin-left: calc(100% - 50px) timing-function 各種transition-timing-function的效果，主要有以下幾種屬性。 +transition-timing-function(ease) //緩慢的開始，中間變快，又變慢慢結束。相當於cubic-bezier(0.25,0.1,0.25,1)。 +transition-timing-function(ease-in) //ease-in：緩慢的開始。相當於cubic-bezier(0.42,0,1,1)。 +transition-timing-function(ease-out) //ease-out：緩慢的結束。相當於cubic-bezier(0,0,0.58,1)。 +transition-timing-function(ease-in-out) //ease-in-out：緩慢的開始和結束。相當於cubic-bezier(0.42,0,0.58,1)。 +transition-timing-function(linear) linear：表示從開始到結束的速度一致。相當於cubic-bezier(0,0,1,1)。 +transition-timing-function(cubic-bezier(0.1, 0.7, 1.0, 0.1)) cubic-bezier(n,n,n,n)：自由定義cubic-bezier函數，每個值為0到1之間的數字。 cubic-bezier +transition-timing-function(step-start) +transition-timing-function(step-end) //這兩個....是來鬧得? +transition-timing-function(steps(4, end)) //分為4個階段 Togather! ease ease-in ease-out ease-in-out linear cubic-bezier step-start step-end steps(4, end) 波動拳動圖 這邊先準備快打旋風的圖，裡面有14張的龍發動波動拳的姿勢，而這不是一張Gif，而是一連串動作組成的png。 .ryu +transition(background 1s) +transition-timing-function(steps(13, end)) background: url(\"images/20131002.png\") left bottom no-repeat ... &:hover background-position: right bottom 然後利用階段性的function來實作動圖的效果，把背景圖設定transition動態，並且設定13階段的timing-function，最後只要將hover的結果設定在最後一張動作位置就完成囉。 如果用animation做更棒喔! 不過這似乎不是本篇重點...，在後面的文章會再另外介紹animation~，本篇就先到此為止。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"用sass 做long shadow","slug":"sass-long-shadow","date":"2013-09-30T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/10/01/sass-long-shadow/","link":"","permalink":"https://wcc723.github.io/sass/2013/10/01/sass-long-shadow/","excerpt":"網頁設計的趨勢從擬物轉換為扁平化，而扁平化顧名思義就是較扁、較平，去除了真實化實體，扁平化也延伸出許多的視覺風格，而long shadow就是其中一種，讓扁平的世界裡，增添一些的立體感。","text":"網頁設計的趨勢從擬物轉換為扁平化，而扁平化顧名思義就是較扁、較平，去除了真實化實體，扁平化也延伸出許多的視覺風格，而long shadow就是其中一種，讓扁平的世界裡，增添一些的立體感。 B 先了解基本的原理 B text-shadow: 1px 1px 0 rgba(239, 89, 54, 0.95), 2px 2px 0 rgba(239, 89, 54, 0.5), 3px 3px 0 rgba(239, 89, 54, 0.35), 4px 4px 0 rgba(239, 89, 54, 0.275), 5px 5px 0 rgba(239, 89, 54, 0.23), 6px 6px 0 rgba(239, 89, 54, 0.2), 7px 7px 0 rgba(239, 89, 54, 0.17857), 8px 8px 0 rgba(239, 89, 54, 0.1625), 9px 9px 0 rgba(239, 89, 54, 0.15), 10px 10px 0 rgba(239, 89, 54, 0.14), 11px 11px 0 rgba(239, 89, 54, 0.13182), 12px 12px 0 rgba(239, 89, 54, 0.125), 13px 13px 0 rgba(239, 89, 54, 0.11923), 14px 14px 0 rgba(239, 89, 54, 0.11429), 15px 15px 0 rgba(239, 89, 54, 0.11), 16px 16px 0 rgba(239, 89, 54, 0.10625), 17px 17px 0 rgba(239, 89, 54, 0.10294), 18px 18px 0 rgba(239, 89, 54, 0.1), 19px 19px 0 rgba(239, 89, 54, 0.09737), 20px 20px 0 rgba(239, 89, 54, 0.095), 21px 21px 0 rgba(239, 89, 54, 0.09286), 22px 22px 0 rgba(239, 89, 54, 0.09091), 23px 23px 0 rgba(239, 89, 54, 0.08913), 24px 24px 0 rgba(239, 89, 54, 0.0875), 25px 25px 0 rgba(239, 89, 54, 0.086), 26px 26px 0 rgba(239, 89, 54, 0.08462), 27px 27px 0 rgba(239, 89, 54, 0.08333), 28px 28px 0 rgba(239, 89, 54, 0.08214), 29px 29px 0 rgba(239, 89, 54, 0.08103), 30px 30px 0 rgba(239, 89, 54, 0.08), 31px 31px 0 rgba(239, 89, 54, 0.07903), 32px 32px 0 rgba(239, 89, 54, 0.07813), 33px 33px 0 rgba(239, 89, 54, 0.07727), 34px 34px 0 rgba(239, 89, 54, 0.07647), 35px 35px 0 rgba(239, 89, 54, 0.07571), 36px 36px 0 rgba(239, 89, 54, 0.075), 37px 37px 0 rgba(239, 89, 54, 0.07432), 38px 38px 0 rgba(239, 89, 54, 0.07368), 39px 39px 0 rgba(239, 89, 54, 0.07308), 40px 40px 0 rgba(239, 89, 54, 0.0725); CSS製作的long shadow是利用CSS的box-shadow，然後不斷的重複，每一個像素都產生一個新的陰影，產生出延長的視覺效果，所以如果用CSS寫會非常的壟長，且每個階段的透明度也不同，如果20階會有點想哭哭，如上範例。 box-shadow B //新增一個mixin，名稱為box-longShadow，並且新增兩個變數。 @mixin box-longShadow($lenght: 20,$rgb: #000) $all: () //先準備一個空的變數 @for $i from 1 through $lenght //利用for 迴圈決定長度 $all: append($all, append(#{$i}px #{$i}px 0 ,rgba(darken($rgb,10%),1/$i)),comma) //將陰影的效果利用迴圈的方式不斷的增加到$all +box-shadow($all) //將$all的變數增加到box-shadow裡 這是box部分的mixin，其中可以注意的就是我把長度($lenght)和顏色($rgb)提出來，讓每次使用都可以重新調整色彩。 .test +box-longShadow($lenght: 80,$rgb: #ef5936) //增加到sass樣式 margin: 25px auto background: #25aae2 width: 1em height: 1em padding: 0.1em text-align: center +border-radius(5px) overflow: hidden box-longShadow增加到CSS裡。 text-shadow B //這部分和box幾乎相同，只有在最後一行改成text-shadow @mixin text-longShadow($lenght: 20,$rgb: #000) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,rgba($rgb,0.9/$i + 0.05)),comma) text-shadow: $all .test +text-longShadow($lenght: 40,$rgb: #578199) text-shadow和box上較為接近，只是在使用時要特別注意文字，如果較細的字體，效果沒那麼好，所以使用的時候可以試試看許多不同的字體。 Finish(動畫版) B 而這只是靠兩種CSS3語法就能達到的效果，再結合更多的語法，也會有更豐富的變化，所以CSS是沒有極限的!!","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3 :target選取器","slug":"css-target","date":"2013-09-28T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/29/css-target/","link":"","permalink":"https://wcc723.github.io/css/2013/09/29/css-target/","excerpt":"CSS3多了相當多的selectors，而:target是其中一個，它可以讓html的id被套用上新的樣式，而這功能也可以讓html的互動性更高。","text":"CSS3多了相當多的selectors，而:target是其中一個，它可以讓html的id被套用上新的樣式，而這功能也可以讓html的互動性更高。 :target 按我開始旋轉 點我可以停 //html &lt;a href=&quot;#test1&quot; &gt;按我開始旋轉&lt;/a&gt; //這個a的重點在於#test1，目標會因為這個ID被啟動 &lt;a href=&quot;#2013-09-29&quot; class=&quot;circles&quot; id=&quot;test1&quot;&gt;&lt;span&gt;點我可以停&lt;/span&gt;&lt;/a&gt; //class = circles 是他的樣式設定 //id = test1 是他被啟動的名字 /CSS 重點code .circles:target animation: ifinityCircles 3s linear infinite 當.circles的id被啟動時，就會開始旋轉 .circles //其他樣式設定 簡單來說它是利用class來做基本樣式的設定，透過連結讓ID被啟用新的樣式，新的樣式會被寫在.circles:target；而要將:target的效果關閉，只要其他的id被啟動即可。 lightbox 來源：http://devdocs.io/css/:target 五月天 lightBox //html &lt;a class=&quot;lightbox d0929&quot; id=&quot;example1&quot; href=&quot;#2013-09-29&quot;&gt; //利用a作為外框，是為了讓使用者點任何區域，都可以關閉:target的效果 &lt;figure&gt; &lt;figcaption&gt; &lt;img src=&quot;/images/mayday/009.JPEG&quot; alt=&quot;&quot;&gt; &lt;/figcaption&gt; &lt;/figure&gt; &lt;/a&gt; //sass &.lightbox:target //樣式啟動 display: table &.lightbox position: fixed left: 0 top: 0 width: 100% height: 100% z-index: 20 background: rgba(00,00,00,.8) display: none //這一段是為了做出淺黑色的底 figure display: table-cell vertical-align: middle text-align: center //這邊是要讓lightbox完全置中 figcaption display: inline-block margin: auto padding: 15px background: rgba(00,00,00,.6) +border-radius(5px) //而這就是五月天所登場的樣式了 這功能可以做出簡單的 nojs版本的lightbox，而註解我都寫在程式碼中，這邊就不再另述了。不過根據所查詢到的資料，:target要ie10才能夠run(哭哭)。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS藏頭詩 Selection","slug":"css-selection","date":"2013-09-27T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/28/css-selection/","link":"","permalink":"https://wcc723.github.io/css/2013/09/28/css-selection/","excerpt":"這是一個很簡單的技術，就是可以改變文字反選後的樣式，而支援的樣式並不多，目前僅有Color、background、background-color、text-shadow在內。","text":"這是一個很簡單的技術，就是可以改變文字反選後的樣式，而支援的樣式並不多，目前僅有Color、background、background-color、text-shadow在內。 這是一段文章，知情人士已透露，除了價格的競爭，蘋果將推出低價iPhone，以及iPhone 5升級版。 上面這一段，是正常版本的，只是做個陰影，沒有任何效果，只是要做個對照。 正式開始 這是一段文章，知情人士已透露，除了價格的競爭，蘋果將推出低價iPhone，以及iPhone 5升級版。 上面這一段讓底色可以變黑，文字變成白色，但是我們可以注意到陰影在反白後，會影響閱讀。 div &::-moz-selection background: black color: white &::selection background: black color: white 建議移除text-shadow效果 這是一段文章，知情人士已透露，除了價格的競爭，蘋果將推出低價iPhone，以及iPhone 5升級版。 像是這一段，另外再把text-shadow移除，是不是更好閱讀呢? div &::-moz-selection background: red color: white text-shadow: none &::selection background: red color: white text-shadow: none ::selection可以玩什麼 來源https://54.sp88.tw/poetry_list.php?page=1&so=1&keyname=po_ti&keyword=%E9%99%B3%E8%88%8A%E4%BD%A0%E6%88%91 英式濃茶的濃郁芬芳 經久不息的牽連妳我 那時妳同我烘焙釀造 陳舊了這紅銅色回憶 一個又一個鏽在我心 妳如壺中泉水的溫熱 再次纏繞如那母愛般 溶消極冰浮沈於腦海 而被溫順開展的那 萎縮的葉 是在極光下 畏縮的我 在我思考了很久之後，看來它只能玩藏頭詩...。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS的新\"文字\"及\"尺寸\"單位","slug":"new-size-unit","date":"2013-09-26T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/27/new-size-unit/","link":"","permalink":"https://wcc723.github.io/css/2013/09/27/new-size-unit/","excerpt":"CSS3 新的文字單位 大多數網站在文字的單位都是使用px，尤其在台灣多數使用者都是用windows系統，不管是什麼瀏覽器，在windows下都是以單數px是較為清楚的，如13xp．15px等，而px在建立網站時也是較為方便及準確的，但他的彈性是比較差的。","text":"CSS3 新的文字單位 大多數網站在文字的單位都是使用px，尤其在台灣多數使用者都是用windows系統，不管是什麼瀏覽器，在windows下都是以單數px是較為清楚的，如13xp．15px等，而px在建立網站時也是較為方便及準確的，但他的彈性是比較差的。 font-size:12px font-size:13px font-size:14px font-size:15px 彈性差的部分就來做一個實驗，就是將他們的外層在增加一個放大的文字屬性。 font-size: large font-size:12px font-size:13px font-size:14px font-size:15px EM 而用另一個文字單位em，em隨著外圍的文字大小調整，當然這是他的優點，也是他的缺點。 本站預設為13px。 font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em 我們可以調整外圍的font-size，就可以影響到內部的文字大小，但是要注意，如果外層也有設定em他也會繼承下去(GG)。 font-size: 15px font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em font-size: 1.4em font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em font-size: 1.4em font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em 由上面的範例可得知，一不小心還是會失控的。 REM rem是新的文字單位，他和em用法類似，但是他不會繼承，只會受最根部的單位影響，html的font-size(優點是ie需要9以上才支援)。 font-size: 1.4em font-size:1.1rem font-size:1.2rem font-size:1.3rem font-size:1.4rem font-size:1.1em font-size:1.2em font-size:1.3em font-size:1.4em html font-size: 13px .f2rem font-size: 1.2rem .f3rem font-size: 1.3rem .f4rem font-size: 1.4rem 注意在使用時，它只會受html的font-size影響，body以下的都不會影響。 CSS3 新的尺寸單位 不久前我有一個問題，就是在自適應的情況下，正方形的CSS語法該如何寫。直接寫px然後配合media query似乎是一個辦法，但如果我的水平都要保持三個等\"百分比\"的正方形，似乎就不太可能了。 vh vw vh vm是CSS3新單位，是指裝置的畫面高度及畫面的寬度百分比。 .vw width: 10vw height: 10vw margin: 0 8px 這個部分我就單只用vw做範例，建議大家也可以調整瀏覽器大小並重新整理看看，下方是比較小畫面的螢幕截圖，這時的正方形其實和上方的100px大小差不多。 這時我把視窗拉滿了16:9的寬度，正方形明顯大很多。 我又繼續拉滿兩個16:9的螢幕，正方形已經突破天際了。 vmin 除此之外，還有一個單位稱為vmin，是裝置中寬度or高度較小的那個值，如果使用者裝置轉來轉去就很有效果!? 以上是不錯的新單位，但在目前還有許多瀏覽器不支援(android內建browser不支援)，使用前請先注意，","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS的運算","slug":"css-calc","date":"2013-09-25T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/26/css-calc/","link":"","permalink":"https://wcc723.github.io/css/2013/09/26/css-calc/","excerpt":"今天來介紹CSS最犯規的function calc，通常會用來做數值的運算，尤其是針對於長寬等等，而他最特別的是運算的數值\"不需要\"相同單位。","text":"今天來介紹CSS最犯規的function calc，通常會用來做數值的運算，尤其是針對於長寬等等，而他最特別的是運算的數值\"不需要\"相同單位。 基本運算 簡單來說就是css具有運算的功能，包含了基本的加減陳除。詳細介紹 這是一段範例，這段寬100% - 80px。 //html的code &lt;p class=&quot;test2&quot; &gt; 這是一段範例，這段寬100% - 80px。&lt;/p&gt; //sass的重點code .test2 width: calc(100% - 80px) 由這範例可得知，他的運算方式是不需要相同的\"單位\"，在這樣的情況下可以有相當多的變化。 這是一段範例，這段寬100% / 6。 .class width: calc(100% / 6) 有了基本的運算，100%/6就會出現六分之一的結果。 這是一段範例，這段left: calc(10% + 20px)。 這個運算方式就是這麼豐富，但是殘酷的來了...，calc須ie9以上。 排版 width: calc(100% - 200px - 1em) width: 200px 稍微拉動視窗看看 &lt;div class=&quot;test6&quot;&gt; &lt;div class=&quot;all1&quot;&gt;width: calc(100% - 200px - 1em)&lt;/div&gt; &lt;div class=&quot;w300&quot;&gt;width: 200px&lt;/div&gt; &lt;/div&gt; //sass .w200 width: 200px float: right .all1 width: calc(100% - 200px - 1em) //1em是間距的距離 100pxwidth: calc(100% - 200px)100px &lt;div class=&quot;test6&quot;&gt; &lt;div class=&quot;wl100&quot;&gt;100px&lt;/div&gt; &lt;div class=&quot;all2&quot;&gt;width: calc(100% - 200px - 2em)&lt;/div&gt; &lt;div class=&quot;wr100&quot;&gt;100px&lt;/div&gt; &lt;/div&gt; //sass .wr100 float: right width: 100px .wl100 float: left width: 100px .all2 width: calc(100% - 200px - 2em) //間距的距離 margin: 0 1em //間距的距離 Calc的好處就是彈性很大，所以再版型的規劃上，不再限定那麼多，所以在範例上可以了解，這樣的方式兩欄或是三欄都是難不倒它的，相信這屬性，在未來的RWD(自適應網頁)是有很多的幫助。 Toy 來源：http://codepen.io/th61855/pen/tAzBC .demo div width: calc(100% - 4em) height: calc(100% - 4em) +border-radius(50%) 而這是一個等距離的圓圈，利用的就是calc(100% - 4em)，做出的等距離效果，而他的動畫，根本次要說明的範例毫無關係>","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 意想不到的background-attachment","slug":"background-att","date":"2013-09-24T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/25/background-att/","link":"","permalink":"https://wcc723.github.io/css/2013/09/25/background-att/","excerpt":"background-attachment是背景固定模式的屬性，而不同的固定方式就能夠有不同的視覺效果，而人類的視覺是很容易欺騙的，適當的利用可以有意想不到的效果。","text":"background-attachment是背景固定模式的屬性，而不同的固定方式就能夠有不同的視覺效果，而人類的視覺是很容易欺騙的，適當的利用可以有意想不到的效果。 scroll background-attachment: scroll scroll模式也是預設值，背景圖會隨著外圍頁面滾動而移動。 fixed background-attachment: fixed fixed模式，不管外面、裡面怎麼滾，他都是不會動的。 local (new) background-attachment: local local模式，主要的特色就是，自己的區塊內如果滾動時，背景圖也會跟著移動。 利用local + scroll做出的效果 (想不出名字...) 參考來源：http://lea.verou.me/more-css-secrets/#background-attachment 請滾動畫面中卷軸、請滾動畫面中卷軸 麻煩 請 捲動 旁邊 的卷軸 謝謝。 麻煩 請 捲動 旁邊 的卷軸 謝謝。 //css .class{ background: linear-gradient(white 30%, hsla(0,0%,100%,0)), linear-gradient(hsla(0,0%,100%,0), white 70%) bottom, radial-gradient(at top, rgba(0,0,0,.2), transparent 70%), radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom; background-repeat: no-repeat; background-size: 100% 40px, 100% 40px, 100% 14px, 100% 14px; background-attachment: local, local, scroll, scroll; } 在這效果下，我們可以做出向上或是向下未讀完錯覺(請滾動畫面中卷軸)，而簡單來說他利用了兩種模式的交叉運用，做出的視覺效果。 Scroll 層 background: radial-gradient(at top, rgba(0,0,0,.2), transparent 70%), radial-gradient(at bottom, rgba(0,0,0,.2), transparent 70%) bottom background-repeat: no-repeat background-size: 100% 18px, 100% 18px background-attachment: scroll, scroll 我們先看scroll層，上下都有著固定的陰影，在那邊不會移動，就算到了最上層及最底層也不會有變化。 Local 層 background: linear-gradient(black 30%, rgba(black,0)), linear-gradient(rgba(black,0), black 70%) bottom background-repeat: no-repeat background-size: 100% 40px, 100% 40px background-attachment: local, local 這一段把local層改成了黑色，可以看得比較清楚，可以發現local層是到了最上層及最底層後才會出現，利用這個方式蓋住上一層。當然到時候要記得改回白色。 在完成一次的demo 麻煩 請 捲動 旁邊 的卷軸 謝謝。 麻煩 請 捲動 旁邊 的卷軸 謝謝。 參考來源：http://lea.verou.me/more-css-secrets/#background-attachment","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3的漸層","slug":"css-background","date":"2013-09-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/24/css-background/","link":"","permalink":"https://wcc723.github.io/css/2013/09/24/css-background/","excerpt":"本篇介紹CSS3的漸層，而就漸層這功能聽起來，似乎沒有什麼樣的變化，但其實透過復合式的背景可以堆疊出相當多的變化。","text":"本篇介紹CSS3的漸層，而就漸層這功能聽起來，似乎沒有什麼樣的變化，但其實透過復合式的背景可以堆疊出相當多的變化。 漸層 .gradient { background: #bf2c73; background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #ff3b99), color-stop(100%, #7f1d4d)); background-image: -webkit-linear-gradient(#ff3b99, #7f1d4d); background-image: -moz-linear-gradient(#ff3b99, #7f1d4d); background-image: -o-linear-gradient(#ff3b99, #7f1d4d); background-image: linear-gradient(#ff3b99, #7f1d4d); } CSS3漸層在各個瀏覽器的前輟詞並不相同，但在這邊不會特別介紹，主要會利用sass做範例(必須承認，不用sass寫那些前輟詞真的很痛苦...) +background-image(linear-gradient(left, #E80C7A,rgba(#E80C7A,.5), #E85D2D)) +background-image(linear-gradient(bottom, #E80C7A,rgba(#E80C7A,.5), #E85D2D)) //從下方開始 +background-image(linear-gradient(-35deg, #E80C7A,rgba(#E80C7A,.5), #E85D2D)) //旋轉 這是最基本的漸層，除了垂直之外也可以改成水平甚至是有角度的。 +background-image(radial-gradient(#E80C7A,rgba(#E80C7A,.5), #E85D2D)) //放射狀 另外還有放射狀的漸層。 多重背景 +background-image(linear-gradient(left, rgba(#E80C7A,.5) 20%, transparent 50%)) +background-image(linear-gradient(top, rgba(#E80C7A,.5), transparent 70%)) 這邊是兩個不同方向的漸層，下面要將他們合併。 +background(linear-gradient(left, rgba(#E80C7A,.5) 20%, transparent 50%),linear-gradient(top, rgba(#E80C7A,.5), transparent 70%)) //兩個漸層只要用逗點隔開即可，這樣就可以做出多層次的漸層 在CSS3中背景可以做兩層以上，而不只是漸層，所有的背景圖案都可以，只要用逗點隔開就可以一直堆疊下去；所以在這邊我們只要把漸層語法用逗點隔開，就可以堆疊漸層。 圖樣背景 來源：http://codepen.io/html5web/pen/HDCrK +background-image(linear-gradient(-45deg, #000 5px, transparent 50px)) background-size: 50px 50px //利用background-size去控制每個背景的大小 如果要做類似圖樣的背景，我們可以設定背景的大小background-size，就可以做出一塊一塊的圖樣。 +background-image(radial-gradient(#fff 3px, transparent 5px, #fff 7px, transparent 9px, #fff 11px, transparent 13px, #fff 15px, transparent 17px, #fff 19px, transparent 21px, #fff 23px, transparent 25px, #fff 27px, transparent 29px, #fff 31px, transparent 33px)) background-color: #111 background-size: 30px 30px //漸層還可以設定每個顏色的距離，只要在顏色後方輸入數值 漸層還可以設定每個顏色的區段距離，只要在色彩後方輸入數值就可以了。 旋轉吧漸層 來源：http://codepen.io/agriboz/pen/izLak +background(linear-gradient(45deg, #557777 50%, transparent 50%),linear-gradient(90deg, #ee6655 100%, transparent 100%),linear-gradient(135deg, #ffeebb 50%, transparent 50%) 100% 0%,linear-gradient(180deg, #ffcc55 100%, transparent 100%) 100% 0%,linear-gradient(225deg, #ffaa22 50%, transparent 50%) 100% 100%,linear-gradient(270deg, #ccddaa 100%, transparent 100%) 100% 100%,linear-gradient(315deg, #77aa88 50%, transparent 50%) 0% 100%,linear-gradient(360deg, #99cc99 100%, transparent 100%) 0% 100%) //很抱歉，這顏色就是那麼的....長 background-repeat: no-repeat background-size: 50% 50% +border-radius(50%) margin: 0 auto width: 150px height: 150px border: 1em solid tomato +transition(all, 3s) //加點動態 &:hover +transform(rotate(3600deg)) 甚至結合其他語法，可以有更豐富的玩法，像是這結合了border-radius、transition、transform等等，讓這個元素像是轉盤一樣在旋轉。 +background(linear-gradient(45deg, #557777 50%, transparent 50%),linear-gradient(90deg, #ee6655 100%, transparent 100%),linear-gradient(135deg, #ffeebb 50%, transparent 50%) 100% 0%,linear-gradient(180deg, #ffcc55 100%, transparent 100%) 100% 0%,linear-gradient(225deg, #ffaa22 50%, transparent 50%) 100% 100%,linear-gradient(270deg, #ccddaa 100%, transparent 100%) 100% 100%,linear-gradient(315deg, #77aa88 50%, transparent 50%) 0% 100%,linear-gradient(360deg, #99cc99 100%, transparent 100%) 0% 100%) background-repeat: no-repeat background-size: 50% 50% //移除動態及一些其他設定，僅保留重要的設定值 而這個效果很特別他每個漸層顏色是設定50%有色彩，另外50%是透明，然後每45度做一次顏色。 +background(linear-gradient(45deg, #557777 50%, transparent 50%),linear-gradient(90deg, #ee6655 100%, transparent 100%),linear-gradient(135deg, #ffeebb 50%, transparent 50%) 100% 0%,linear-gradient(180deg, #ffcc55 100%, transparent 100%) 100% 0%,linear-gradient(225deg, #ffaa22 50%, transparent 50%) 100% 100%,linear-gradient(270deg, #ccddaa 100%, transparent 100%) 100% 100%,linear-gradient(315deg, #77aa88 50%, transparent 50%) 0% 100%,linear-gradient(360deg, #99cc99 100%, transparent 100%) 0% 100%) background-repeat: no-repeat //在移除background-size: 50% 50% 並且每個漸層色只有50%*50%的大小，就是1/4的區域，如果沒有background-size: 50% 50%，他就會像上面這範例這樣。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - text-shadow初試身手","slug":"css-text-shadow","date":"2013-09-22T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/23/css-text-shadow/","link":"","permalink":"https://wcc723.github.io/css/2013/09/23/css-text-shadow/","excerpt":"text-shadow算是CSS3中較早出現的語法，而且不需要打前輟詞就能夠執行。","text":"text-shadow算是CSS3中較早出現的語法，而且不需要打前輟詞就能夠執行。 text-shadow的原理 入陣曲 &lt;div class=&quot;text1&quot;&gt;入陣曲&lt;/div&gt; .text1 { color: red; text-shadow: 4em 0 0 gray; } 由上範例可得知，紅色的文字是html的純文字，另外灰色的文字就是text-shadow所產生的新元素。 所以探究text-shadow的原理，其實他是從原本的文字衍伸出相同的元素，並且額外調整其衍伸出的外觀屬性，調整位置、透明度以及調整模糊的程度。而他的語法結構text-shadow: X值 Y值 blur值 色彩。 text-shadow的範例 來源參考：http://www.w3cplus.com/blog/52.html 當一座城牆 只為了阻擋 所有自由渴望 文字來源 五月天 入陣曲 //html &lt;div class=&quot;text&quot;&gt;當一座城牆 只為了阻擋 所有自由渴望&lt;/div&gt; 這一部分都是用同一段文字作為範例。 一般模式 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 1px 1px 5px gray; 這是最正常的版本，就只是當作一般的陰影在使用，但是這種版本其實會影響閱讀，所以建議不使用。 小陰影 當一座城牆 只為了阻擋 所有自由渴望 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 1px 1px 0 white; text-shadow: -1px -1px 0 white; 在陰影的blur值設定為0，和底色的顏色只要做一點點的落差，就能適度的提升閱讀性。而這樣的效果，也會有凹陷的視覺感。 立體字 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ color: #ccc; text-shadow: -1px -1px 0 white, 1px 1px 0 #333,1px 1px 0 #444; text-shadow不只可以使用一次，可以利用逗點分隔，不斷地增加新的陰影屬性，而立體字就是這樣的效果。 光暈 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 0 0 20px orange color: white 也可以將文字做成白色，然後將陰影的模糊程度調高，製造類似光暈的效果。 霓虹燈 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ color: white text-shadow: 0 0 5px white,0 0 10px white,0 0 15px white,0 0 40px #ff00de,0 0 70px #ff00de 同上效果，但是不斷的堆疊層次，內層先使用白色，外層堆疊高彩度的色彩，製造出類似霓虹燈的效果。 復古字 當一座城牆 只為了阻擋 所有自由渴望 /*CSS*/ text-shadow: 3px 3px 0 #555, 5px 5px 0 white color: white 是利用兩個陰影堆疊出來的，可惜的是第一個陰影必須與背景相同顏色。 而其實text-shadow是一個很簡單的效果，但是可以有非常多的變化，以上範例只是一小部分，而說不定現在正在看的各位，已經有新的想法，可以做出新的效果，有機會就分享來給大家知道喔~!","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 別忘了偽元素","slug":"css-pseudo-element","date":"2013-09-21T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/22/css-pseudo-element/","link":"","permalink":"https://wcc723.github.io/css/2013/09/22/css-pseudo-element/","excerpt":"偽元素在IE8之後全面都有支援，而這樣功能在CSS3可以創造出更多的效果。","text":"偽元素在IE8之後全面都有支援，而這樣功能在CSS3可以創造出更多的效果。 偽元素介紹 圖片來源：動畫 火影忍者 在火影忍者中的鳴人，在劇情開始不久學會了強大的影分身術，透過影分身術這個忍術，鳴人可以額外創造出有戰鬥力的分身。而偽元素也是類似影分身術，在一個html的標籤內在新增至多兩個元素，透過這個元素我們可以做許多額外的變化，就像上面這個範例，鳴人是一個元素，在hover後可以再產生兩個元素，並且利用動畫來增加視覺效果。 偽元素的用法 &lt;!--HTML--&gt; &lt;div class=&quot;naruto&quot;&gt;&lt;/div&gt; 鳴人這一個範例中，只使用了一個div標籤，而左右兩個鳴人是是利用偽元素產生，如果需要使用偽元素，content: \"\"屬性則是重點，他可以產新的元素來使用。 /*重點css code/* .naruto{ background-image: url(\"/images/naruto.png\") position: relative; /*相對位置*/ ... } .naruto:before,.naruto:after{ /*選取.naruto的前方偽元素及後方偽元素*/ content: \"\"; /*產生一個空的元素*/ position: absolute; /*利用absolute定位*/ left: 150px; /*調整位置*/ background-image: (...) /*插入圖片*/ ... } 偽元素的位置 心未涼 歌詞引用自：五月天 入陣曲 &lt;!--HTML--&gt; &lt;div class=&quot;mayday&quot;&gt;心未涼&lt;/div&gt; 在這個部分我用純文字作範例，偽元素我們可以假想它是在div標籤中新增before及after標籤，而它的位置會是在div標籤內的最前方及最後方，所以在使用必須切記它的位置，或者是用position: absolute，來忽略它所存在的位置。 &lt;div class=&quot;mayday&quot;&gt; &lt;before&gt;淚未乾 &lt;/before&gt; 心未涼 &lt;after&gt; 是什麼依然在滾燙&lt;/after&gt; &lt;/div&gt; 偽元素的範例 如此區塊下的陰影。 幼無糧 民無房 誰在分贓 //對話框 //sass code $color: #f74b48 .box-withArrow background: $color color: white +border-radius(5px) position: relative ... &:after content: \"\" width: 0 height: 0 position: absolute left: 10px bottom: -20px border: transparent 10px solid border-top: $color 10px solid //繪製小箭頭，並且定位置左下方 //讓這一個框框就像是對話框呈現 歌詞引用自：五月天 入陣曲 偽元素的用途多不勝數，且只要在ie8以上就能夠執行，而在本篇會特別提及的原因，就是偽元素能夠過CSS3做相當多的變化，例如旋轉、陰影、漸層色甚至是結合動態效果，且偽元素也能適當的減少html的標籤使用，讓html的維護更輕鬆。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS3的色彩","slug":"css-color","date":"2013-09-20T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/21/css-color/","link":"","permalink":"https://wcc723.github.io/css/2013/09/21/css-color/","excerpt":"在過去我們只要使用色碼來表示顏色，色碼是用三組十六進制數位表示，每位元組從00到FF，相當十進位數位從0到255...，而現在我們有了新的屬性alpha(透明度)。","text":"在過去我們只要使用色碼來表示顏色，色碼是用三組十六進制數位表示，每位元組從00到FF，相當十進位數位從0到255...，而現在我們有了新的屬性alpha(透明度)。 RGBA RGB在色彩學上定義為色光三原色，分為紅、綠、藍三色，而其混色模式為加法混色，在三種顏色相加後會變成白色；而另一種混色模式為印刷色料，是屬於減法混色，由CMYK四色組成，顏色在混和後會變成黑色。三原色的呈現主要適用於電視及電腦的顯示器，因此網頁也是利用RGB三原色。 圖片來源 http://zh.wikipedia.org/wiki/RGB_%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4 RGB相信對於一般視覺設計師來說非常的熟悉，是開啟繪圖軟體後經常會使用的色彩模式之一，其數值為0~255之間，三種數值如果都為255會顯示白色；如果三種顏色都為0則會是黑色。 圖片來源 Illustrator 在CSS3中新增了一個新的屬性alpha，alpha一般用作不透明度參數，數值從0~1之間，0是透明，而1代表不透明。 /css .rgba1 { background: rgba(232, 12, 122, 0.2); } .rgba2 { background: rgba(232, 12, 122, 0.4); } .rgba3 { background: rgba(232, 12, 122, 0.6); } .rgba4 { background: rgba(232, 12, 122, 0.8); } .rgba5 { background: #e80c7a; } 編寫方式為屬性：rgba(R值,G值,B值,alpha值)。 HSLA HSL是由色相(H)、飽和度(S)、亮度(L)組成，飽和度以及明度的值為0~100%，而色相是利用色彩學的色相環概念(如下圖的H)，所以值是由0~360，他所表現的也是一個圓環上的各個顏色。 圖片來源 http://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4 如上圖，和HSL類似的色彩模式為HSV，主要差異為明度(V)換成了亮度(L)，而CSS3所採用的色彩模式為HSL，兩者比較可以參考 http://zh.wikipedia.org/wiki/HSL%E5%92%8CHSV%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4。 僅調整色相(H)的效果 //利用sass調整其色相(H)的數值 @for $i from 1 through 6 //分為6階 .h#{$i} //class h1~h6 background: hsla(60 * $i,100%,50%,1) //色相(H)60為1階，乘以6階，飽和度100，明度50，alpha為1(不透明) 僅調整飽和度(S)的效果 //利用sass調整其飽和度(S)的數值 @for $i from 1 through 6 .s#{$i} background: hsla(120,(20% * $i - 20),50%,1) //色相(H)為120，飽和度20為1階分為6階，明度50，alpha為1(不透明) 僅調整明度(L)的效果 //利用sass調整其飽和度(S)的數值 @for $i from 1 through 6 .l#{$i} background: hsla(120,100%,(20% * $i - 20),1) //色相(H)為120，飽和度100，明度20為1階分為6階，alpha為1(不透明) Hsla編寫方式為屬性：hsla(h值,s值,l值,alpha值)。 Kuler https://kuler.adobe.com 這是Adobe公司所出的顏色工具，不管事RGB或是色碼都可方便轉換及調整。 支援程度 主要會有支援問題的是alpha屬性，所以在使用時須考慮替代方案，如先設定好沒有alpha的色彩，在設定有alpha屬性的色彩。 Feature Chrome Firefox (Gecko) Internet Explorer Opera Safari (WebKit) keywords colors 1.0 1.0 (1.0) 3.0 [*] 3.5 1.0 (85) #RRGGBB | #RGB 1.0 1.0 (1.0) 3.0 3.5 1.0 (85) rgb() 1.0 1.0 (1.0) 4.0 3.5 1.0 (85) hsl() 1.0 1.0 (1.5) 9.0 9.5 3.1 (525) rgba() 1.0 3.0 (1.9) 9.0 10.0 3.1 (525) hsla() 1.0 3.0 (1.9) 9.0 10.0 3.1 (525) currentColor 1.0 1.5 (1.8) 9.0 9.5 4.0 (528) transparent 1.0 3.0 (1.9) 9.0 [**] 10.0 3.1 (525)","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Sass 與 Compass(2)","slug":"compass-2","date":"2013-09-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/20/compass-2/","link":"","permalink":"https://wcc723.github.io/css/2013/09/20/compass-2/","excerpt":"承上篇，上一篇主要是介紹Sass和Compass是什麼，而本篇會介紹Sass和Compass究竟對CSS的撰寫有什麼樣的影響，讓許多工程師及設計師都說已經回不去了(回不去CSS)，現在就讓大家瞧瞧，它是多麼的強大吧(本篇介紹主要語法將會以Sass為主，並非使用Scss)。","text":"承上篇，上一篇主要是介紹Sass和Compass是什麼，而本篇會介紹Sass和Compass究竟對CSS的撰寫有什麼樣的影響，讓許多工程師及設計師都說已經回不去了(回不去CSS)，現在就讓大家瞧瞧，它是多麼的強大吧(本篇介紹主要語法將會以Sass為主，並非使用Scss)。 小試牛刀 - 巢狀 我最愛 在單槓上 練劈腿 /*CSS*/ ul { color: #e80c7a; } ul li { border-bottom: #cccccc solid 1px; } /*sass*/ ul color: #E80C7A li border-bottom: #ccc solid 1px 向這樣的巢狀寫法，父層的selector只需要寫一次，子層的只要縮排依序寫下去，在編譯後就會編譯成如上方的CSS，這樣的功能尤其是在menu及Table特別有感...。且在父層Selector需要改變時，也只要改變一次父層Selector。 小試牛刀 - 變數 /*sass*/ $color: #E80C7A ul color: $color li border-bottom: #ccc solid 1px 變數在sass使用頻率相當高，對於設計師來說，可以將變數設想為Illustrator的色票，可以不斷地重複使用。而在往後如果變數需要修改，所有引用此參數的屬性也可套用新的變數，可有效減少修改的時間。 來點厲害的 - 數學運算 150 + 10 + 10 = 170px 太寬了~ 150 - 10 * 2 = 120px 這才是想要的 這邊以box來作範例，假設我們需要150px X 150px的div，但一般來說border會增加在所設定的寬度外圍，所以box的寬高會如上圖左，在sass中我們可以如下編寫方式得到我們想要的寬高，而優點當然是不用每次修改都手動重新計算數值。 $boxSize: 150px $boxBorder: 10px .box2 border: $color solid $boxBorder //border寬度 width: $boxSize - $boxBorder*2 //div的寬度減掉左右邊的border寬 height: $boxSize - $boxBorder*2 //記得 先乘除後加減... ... 來點厲害的 - 色彩運算 background: #E80C7A background: #b80961 設計師應該會都聽過一句話：顏色在深一點點，而顏色在深一點點，在繪圖軟體上好辦事，但是這六個號碼的色碼，就好像是馬賽克一樣，怎麼樣都令人摸不清。而sass的色彩運算可以將顏色加深、調淡，甚至是旋轉色相、調整飽和度等功能。 $color: #E80C7A .box background: darken($color,10%) 來點厲害的 - Mixin 標題 標題 標題 內容 內容 內容 標題 標題 標題 內容 內容 內容 mixin在sass是相當重要的功能，其功能是將CSS模組化，並且可將變數另外設定，讓引用mixin時去做變數的調整。而對於設計師來說，可以將mixin設想為Flash的元件或是Illustrator的圖樣功能，只要設定一次，在後面可以重複性的使用。 //設定mixin，並且將背景色設定為變數 @mixin table-base($color: #E80C7A) border-collapse: collapse width: 100% th text-align: center background: $color color: white td,th padding: 6px border: 1px solid #ccc table.table1 +table-base //mixin匯入，只需要輸入@include mixin名稱 //或者在.sass可以輸入+mixin名稱 table.table2 +table-base($color: #9d6bda) //mixin匯入後，重新設定變數 Compass 一起來吧 Compass內建CSS3的mixin，所以在導入CSS3是相當方便的。 /sass $color: #E80C7A .box +background-image(linear-gradient($color,darken($color,20%))) //漸層色效果 ... //CSS .box{ background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #e80c7a), color-stop(100%, #870747)); background-image: -webkit-linear-gradient(#e80c7a, #870747); background-image: -moz-linear-gradient(#e80c7a, #870747); background-image: -o-linear-gradient(#e80c7a, #870747); background-image: linear-gradient(#e80c7a, #870747); ... } Sass + Compass 標題 標題 標題 內容 內容 內容 而在sass及compass合體後，就能明顯增加工作效率，而多餘的時間將能夠開發更多的CSS效果，以提升專案的品質。 //將mixin 導入CSS3 @mixin table-base2($color: #E80C7A) border-collapse: collapse width: 100% th text-align: center background: $color +background-image(linear-gradient($color,darken($color,20%))) color: white td,th padding: 6px border: 1px solid #ccc table.table3 +table-base2 //在引用後，會自動計算漸層色彩 本篇所介紹的Sass和Compass的功能只是其中一部份，但其實在使用上已經很充足，畢竟Sass也是屬於一種工具，與其學的精，不如先發揮其所能，希望有興趣的朋友們，來一起嘗試看看吧。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - Sass 與 Compass(1)","slug":"compass-1","date":"2013-09-18T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/19/compass-1/","link":"","permalink":"https://wcc723.github.io/css/2013/09/19/compass-1/","excerpt":"在先前的幾篇，有提過好幾次的Sass以及Compass、Fire.app等工具，在這邊就來釐清這些是什麼樣的工具。 Sass官方網站：http://sass-lang.com/","text":"在先前的幾篇，有提過好幾次的Sass以及Compass、Fire.app等工具，在這邊就來釐清這些是什麼樣的工具。 Sass官方網站：http://sass-lang.com/ Q1:他是類似Dreamweaver或是什麼樣的軟體嗎? 為何有這樣的問題呢?因為一開始我真的這麼認為。我以為它是XX軟體或是XX軟體的外掛元件，只要下載安裝就可以了，而到了Sass官網，我找不到Download或是我能理解的安裝方法，發現我真的無法理解...。 以上是題外話，Sass並不是一套軟體，它算是CSS的進階語言，透過Ruby環境編譯成一般CSS，而在編寫的過程中Dreamweaver、Sublime text、Visual Studio、記事本只是編寫的工具，並不會影響到編譯後的結果。 建議對Sass有興趣的設計師或工程師，請繼續看下去，Sass是非常優秀的CSS進階語言，而入門並沒有想像中的困難。 Q2:Ruby又是什麼? 是一種程式語言，而Sass就是用Ruby所編寫，所以在Sass編譯時需要有Ruby的編譯能力。 Ruby繁體中文 Q3:Sass，為何又有人說scss? 兩者都屬於sass，而差在附檔名以及編寫方式的不同。 .sass是屬於原生的sass語法，明顯的特徵是利用縮排取代大括號。.scss後來衍生出來的語法，為了讓新一代的設計師可以承受較少的痛學習sass，所以在結構上相當類似CSS。 /*CSS Code*/ .error { border: 1px #f00; background: #fdd; } /*SCSS Code*/ .error { border: 1px #f00; background: #fdd; } /*Sass Code*/ .error border: 1px #f00 background: #fdd 由以上範例可以看出SCSS其實和CSS幾乎是一樣的，而Sass就少了大括號以及分號。而我喜歡sass的簡潔，尤其是少了大括號可以增加CSS的閱讀性，但如果在專案進行時，建議與同伴們討論好要以哪一種語法執行，避免造成日後維護的困擾。 Q4:Less 又是什麼? 他也是類似sass的CSS擴充語言，不同的是sass是在Ruby環境下，而less是Javascript library。本篇不太會介紹到Less，如知詳情請參考此比較網站(http://www.hongkiat.com/blog/sass-vs-less/)。 Q5:sass 可以運用在現在的專案嗎? 由於前方有介紹到Scss的語法結構與CSS類似，只要有編譯環境後，將CSS的副檔名修改成.scss就可以開始嘗試了，而從現有的專案開始練習，也可以快速了解其優點。 Q6:Compass又是什麼? Compass是sass的擴充語言，而其中最常使用的就是CSS3的mixin(在下一篇會介紹mixin)。 /*SCSS Code*/ .demo{ @include border-radius(5px); ... } /*Sass Code*/ .demo +border-radius(5px) ... /*CSS code*/ .demo{ -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; ... } 由以上範例可得知，寫一行抵別人寫5行，怎麼可能會輸? Q7:該怎麼開始? 以正常流程來說，首先需要有Ruby環境，然後安裝Sass、Compass等等，而在這邊我推薦使用Fire.app (http://fireapp.handlino.com/)，可以讓使用者快速進入Sass。當然，Sass在學習時需要許多的耐心與愛心，需要慢慢地去理解，接著去尋找其他人所了解的答案，最後在自己的能力範圍內去教導其他人使用。 以下為相關入門文章(網路文章非常非常的多，請選擇自己容易理解的去閱讀) 環境建立------ 安裝ruby及sass環境 http://ashareaday.wcc.tw/#2013-09-02 使用Fire.app http://ashareaday.wcc.tw/#2013-09-03 使用Fire.app http://demo.tc/Post/757 語法教學------ 30天挑戰Sass http://ithelp.ithome.com.tw/profile?id=20040221 ashareaday天天都分享ashareaday 其他相關文章------ 利用 Compass / Sass 快速開發版型 http://www.slideshare.net/kurotanshi/compass-sass?ref=http://127.0.0.1:24681/","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - 瀏覽器的戰爭","slug":"css-web","date":"2013-09-17T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/18/css-web/","link":"","permalink":"https://wcc723.github.io/css/2013/09/18/css-web/","excerpt":"承上篇，瀏覽器的數量越來越多，有許多需要克服。如老不死的IE瀏覽器、各式各樣的瀏覽器前輟詞、各種CSS語法的支援程度，都是需要去注意的。","text":"承上篇，瀏覽器的數量越來越多，有許多需要克服。如老不死的IE瀏覽器、各式各樣的瀏覽器前輟詞、各種CSS語法的支援程度，都是需要去注意的。 CSS hack CSS hack，在學習網頁設計的這一個年頭，感謝他一直陪伴著我，深信著他還會繼續陪伴我...在這幾年...。 需要進行hack的瀏覽器，主要是以舊版的IE為主，雖然許多國際的公司已不再支援IE7以下的瀏覽器(ie7,ie6)，但就我所了解，目前台灣還有許多的使用者是使用IE7的瀏覽器。而IE的使用者中，有很大的部分是不清楚瀏覽器的分別，更別說哪一種速度快、安全性高等等，對這些使用者來說，點兩下出現的那個瀏覽器就是正確的瀏覽器，而除非所需要製作的網站沒針對這些使用者的需求，不然IE這部分也是需要考慮的。 .class{ background-color:red\\0; /* ie 8/9*/ background-color:blue\\9\\0; /* ie 9*/ *background-color:#dddd00; /* ie 7*/ _background-color:#CDCDCD; /* ie 6*/ } 參考：http://www.css88.com/archives/3746 上方的CSS範例簡單介紹CSS在IE上常用的hack，以大部分瀏覽器來說，會看到的結果為橘色，而在ie6會看到灰色，ie7為黃色，ie8為紅色，ie9為藍色。就我的習慣，在進行專案時版面的編排會盡力符合ie8，必要時再使用hack配合ie7，其他酷炫的效果，在不影響編排的情況下慢慢的增加上去。這就像是電扶梯理論，電扶梯再有電的時候可以讓人輕鬆的上下樓，而就算沒電了，他還是能夠讓行人行走。 Can I use 而在加裝電扶梯的時候，也要先確認要裝設的建築物是否可以架設電扶梯；CSS也是如此，在增加效果時可以先查詢有哪些瀏覽器可以顯示該效果。 http://caniuse.com/ http://devdocs.io/ 這邊推薦兩個網站用來查詢CSS對於瀏覽器的相容性，caniuse用表格及顏色顯示各個瀏覽器以及版本的相容性，如上圖如果需要知道IE8是否支援@font-face就會知道只有部分支援，藉此來考慮是否用@font-face語法；而devdocs則會列出CSS語法的各項細節的相容性，並且會詳細介紹該語法的使用方法、支援的值等等。 確認好專案的版本 而有些細節，需要痛過過才會記住，就如同display: inline-block，有些文件寫支援ie7，而有些是寫支援ie8；主要原因是ie7的inline-block必須要行內樣式才能夠執行，行內樣式就如a、em、span等等，而塊級元素如div就不能套用。 http://yui.github.io/gridbuilder/ purecss是Yahoo所提供的framework，而他的grid網格系統就是利用inline-block來進行排版，所以如果有ie7的需求，在執行時就要多注意這個問題。 IE的測試 而一直提到ie789，但是一台電腦通常只有一種版本的ie，這時候我們可以使用ie的F12開發人員工具(很明顯是按F12可以叫出來)，同時調整工具列中的瀏覽器模式及文件模式的版本(僅能向下支援，且並不是完全相同)，就可以預覽該版本的CSS渲染結果(如下圖)。 IE10 模擬IE7，等等...這怎麼回事，這不是微軟的MSN台灣首頁嗎? CSS3前輟詞 談論ie的話題就到這邊為止了，本篇的重點還是會偏向於CSS3。目前許多瀏覽器對於CSS3的支援度都有明顯的改進，但是還有一個問題，就是麻煩的前輟詞。 .class{ -webkit-border-radius: 5px; -moz-border-radius: 5px; -ms-border-radius: 5px; -o-border-radius: 5px; border-radius: 5px; } border-radius是一個圓角的語法，正常的情況下應該就是border-radius: 值;，但許多的瀏覽器必須加上前輟詞才能正常瀏覽這個效果。在上一集有提過瀏覽器的核心，而-webkit-就是其中一種，不同的核心有不同的渲染方式，Chrome與Safari正是用webkit核心；-moz-則是Mozilla公司的縮寫(Gecko核心)，代表瀏覽器為Firefox；-o-是Opera瀏覽器的縮寫(Presto核心)；-ms-微軟的縮寫...，代表瀏覽器是ie。 雖然目前部分瀏覽器不需要寫前輟詞就能瀏覽CSS3，但為了能夠在大部分瀏覽器正常瀏覽，還是建議補上。 CSS3是很炫，不過還要注意到替代方案 CSS3雖然很炫，但要注意並不是所有瀏覽器都支援CSS3，所以新的效果前，請將CSS3語法前補上CSS2語法。如以下範例： 假設 不支援CSS3瀏覽器 支援CSS3瀏覽器 background: #bf2c73; /*不支援CSS漸層的瀏覽器，將會顯示此色彩*/ background-image: -webkit-gradient(linear, 50% 0%, 50% 100%, color-stop(0%, #ff3b99), color-stop(100%, #7f1d4d)); background-image: -webkit-linear-gradient(#ff3b99, #7f1d4d); background-image: -moz-linear-gradient(#ff3b99, #7f1d4d); background-image: -o-linear-gradient(#ff3b99, #7f1d4d); background-image: linear-gradient(#ff3b99, #7f1d4d); 這是CSS3漸層效果，為了避免不支援的瀏覽器看不到顏色，請先將background: #bf2c73;放在CSS3語法前方，讓不支援CSS3的瀏覽器也能看到單一的色彩，而支援的瀏覽器將會依條件顯示正常的漸層色彩。 往後的內容將會越來越精彩，敬請期待>O","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS沒有極限 - CSS 的改變","slug":"css-change","date":"2013-09-16T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/17/css-change/","link":"","permalink":"https://wcc723.github.io/css/2013/09/17/css-change/","excerpt":"本篇內容同步發表於http://ashareaday.wcc.tw/#2013-09-17 (建議使用Chrome瀏覽器) CSS是用來決定網頁的顏色、字型、排版等顯示的特性，現在除了以上功能外，CSS3增加了更多的效果，不僅可以增加網頁的閱讀性，還可以吸引使用者的目光。而許多的改變，正在影響著CSS的進化。","text":"本篇內容同步發表於http://ashareaday.wcc.tw/#2013-09-17 (建議使用Chrome瀏覽器) CSS是用來決定網頁的顏色、字型、排版等顯示的特性，現在除了以上功能外，CSS3增加了更多的效果，不僅可以增加網頁的閱讀性，還可以吸引使用者的目光。而許多的改變，正在影響著CSS的進化。 裝置的改變 圖片來源 : http://johnpolacek.github.io/scrolldeck.js/decks/responsive/ 自從蘋果發表了第一台iphone以來，就代表了行動裝置的時代的來臨。每個使用者都很開心地在小小的畫面上滑來滑去，但每次的滑動，都是工程師的心血。而在幕後的工程師，小心翼翼的測試每一種的裝置，是否可以正常的瀏覽所設計的頁面，深怕使用者在使用時說了一聲：「靠杯，怎麼看不到。」，就再也不回頭欣賞這心血的結晶。 過去網頁製作只要桌上型個人電腦即可，到現在除了桌上型還有Tablet、smart phone，雖然隨著經驗的累積，可以不斷的衍伸各種製作方式，但...，新的裝置不斷的出，每次Size都不一樣，有的還越來越長...。 瀏覽器的多樣化 早期的瀏覽器多以IE為主，直到Mozilla 維持網路自由選擇、確保網路科技不斷創新的理念下，創造了Firefox瀏覽器，自此瀏覽器進入了戰國時代...，如下圖。 圖片來源 : http://evolutionofweb.appspot.com/?hl=zh 瀏覽器的增加，對使用者來說，有了更多的選擇，但對工程師來說，卻有了大問題...。目前主流的瀏覽器有Google的Chrome、Apple的Safari、Mozilla的Firefox、微軟的IE，以上都有著不同的瀏覽器核心(參考)，而同樣的CSS語法在不同的核心下，所渲染出來的畫面不同。如下圖，每位美女的需求喜好不同，如果要達到每位美女的需求，勢必要一位一位地去了解，才能獲得他們的芳心。 圖片來源：http://pashutaphotography.blogspot.tw/2013/08/what-if-girls-were-internet-browsers.html 工具的改變 圖片來源：http://fireapp.handlino.com 新的工具出現，大大的縮短工作的時程，有效的增加工作效率，這邊以Fire.app為例(連結)，它包含了Sass、Compass、livereload等CSS工具。 Sass是屬於CSS高階語法，包含了變數、運算、function等等，就像是網路遊戲中玩家從1級升級到了60級的改變。但老玩家應該都清楚，只有高的等級是不夠的，更重要的是裝備，而Compass就是Sass的傳奇裝備，這兩個工具在後面的章節會有獨立的介紹。 livereload是可以自動重新整理瀏覽器頁面，減少F5的磨損(參考)。透過以上的工具，可以有效的工作效率外，也可以有效率的研究新效果，並且結交新朋友(疑!?不過這也是實話...)。 新增的功能 過去的網頁，主要是在表格內製作，所以內容很多會局限在垂直與水平的格線內，到了CSS3已經可以突破在垂直與水平的空間內，並且新增許多如圓角、變形、漸層、透明...等許多的效果，而我們將會透過這些新的效果來完成更豐富的作品。 功能的強化 This is The Girl Next Door. CSS是透過「選擇器」（selector）、「屬性」（property）和「值」（value）組成，而CSS3不僅保留之前的語法，並且新增更多。如以上範例，font-family不僅可以定義字型，還可以透過font-face來自定義字型，讓支援CSS3的瀏覽器都能夠統一字型，達到設計的統整性。 運動的物件 及 3D 參考：http://desandro.github.io/3dtransforms/examples/cube-01-steps.html 在Flash流行的年代，運動的物件多會靠flash去執行，現在已經不需要依靠flash就可以達到許多相同的效果，如以上的範例，主要透過transition及transform完成。 而以上的效果，在剩下的28篇文章會有更詳細的介紹，讓網頁一起動起來吧~。","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"網頁設計 技能樹!","slug":"web-skill","date":"2013-09-14T16:00:00.000Z","updated":"2016-10-12T03:37:37.000Z","comments":true,"path":"html/2013/09/15/web-skill/","link":"","permalink":"https://wcc723.github.io/html/2013/09/15/web-skill/","excerpt":"每天分享一篇文章，到今天差不多一個月了。剛好，明天開始是IT邦的鐵人賽，而這邊我會希望和鐵人賽的文章同步，不只整理過去的文章，並且以更細膩的文字去描述CSS的語法。","text":"每天分享一篇文章，到今天差不多一個月了。剛好，明天開始是IT邦的鐵人賽，而這邊我會希望和鐵人賽的文章同步，不只整理過去的文章，並且以更細膩的文字去描述CSS的語法。 而在建立這網頁後，不斷(偶爾)的調整與修改頁面風格，以及每日的上傳新的分享，可以更確定自己想要的是什麼，還有缺乏的是什麼。持續的去執行，才會瞭解過程中的問題。 而很剛剛好地，這幾天發現了一個有趣的玩具，它是模仿RPG遊戲的技能樹，改變成網頁開發者的技能樹。 http://www.dungeonsanddevelopers.com/ 目標天賦 而不斷的挑戰自己，就是朝目標前進最快的方式，保持著一樣的心情，迎接明天新的篇章。","categories":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"},{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"立體字風格","slug":"cubic-font","date":"2013-09-05T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/09/06/cubic-font/","link":"","permalink":"https://wcc723.github.io/sass/2013/09/06/cubic-font/","excerpt":"今天在Fb上看到justfont發了一篇文，就是他們官網上的字可以做立體的風格，我看到這個立體字，突然想到和之前long-shadow有一點點像，所以我決定來試試看sass版本的立體字。","text":"今天在Fb上看到justfont發了一篇文，就是他們官網上的字可以做立體的風格，我看到這個立體字，突然想到和之前long-shadow有一點點像，所以我決定來試試看sass版本的立體字。 先用上次的long-shadow套看看 很明顯，不是這樣。 如果仔細看，其實立體字的背景不是透明的，他是白色到淺灰色，所以要先把套明改掉。 立體字風格 .class $all: () $lenght: 20 $rgb: #000 @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,rgba($rgb,0.9/$i + 0.05)),comma) text-shadow: $all 調整成不透明版本 恩~，有立體一點點了，但是還少了陰影。 立體字風格 .class $all: () $lenght: 20 $rgb: #fff @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,darken($rgb,$i/1.6)),comma) text-shadow: $all 完成 立體字風格 恩...，由於windows預設是明體...，有興趣還是可以自行拿去套信黑體。當然還是要送給大家@mixin。 @mixin text-cubicStyle($lenght: 15,$rgb: #dfdfdf) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,darken($rgb,$i/1.6)),comma) text-shadow: $all,$lenght+1px $lenght+1px 1px rgba(0,0,0,.3),$lenght+2px $lenght+2px 10px rgba(0,0,0,.6)","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS的小箭頭","slug":"css-arrow","date":"2013-09-03T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/09/04/css-arrow/","link":"","permalink":"https://wcc723.github.io/css/2013/09/04/css-arrow/","excerpt":"常常在很多網站會看到小三角形箭頭，當期都是使用圖片去製作，而時代的改變，就是要用寫的比較潮，為了趕上流行，所以在這分享小箭頭的製作方法。","text":"常常在很多網站會看到小三角形箭頭，當期都是使用圖片去製作，而時代的改變，就是要用寫的比較潮，為了趕上流行，所以在這分享小箭頭的製作方法。 用Border畫箭頭 我們先來看上面的demo，他是一個div，寬及高都是0，而上面的四個顏色都是border組成的，利用四個邊都是20px寬的border，且在不同的色彩下，他就會造成這樣的結果。 .arrow width: 0 height: 0 border-top: red 20px solid border-right: orange 20px solid border-bottom: blue 20px solid border-left: green 20px solid 再由程式碼得知，上右下左的色彩對應，如果我們想要一個向上、藍色的箭頭，我們就需要bottom的border。 正式開始 冤冤相報何時了，往事知多少。 我們需要先來一個文字方塊，它的CSS裡面一定需要position: relative，等等會用position: absolute去控制箭頭的位置。 冤冤相報何時了，往事知多少。 .bottomarrow width: 0 height: 0 position: absolute left: 10px bottom: -20px border: transparent 10px solid border-top: $color 10px solid 接下來我們把箭頭加上去，border可以先全部設定transparent 10px solid，最後再補上需要的部分。利用position: absolute去控制位置，另外需要注意的是如果箭頭要增加在下面，bottom的距離，需要是border的兩倍。 偽元素 冤冤相報何時了，往事知多少。 當然，我們也可以用偽元素去增加箭頭，做法是一樣的。 &:after content: \"\" width: 0 height: 0 position: absolute left: 10px bottom: -20px border: transparent 10px solid border-top: $color 10px solid","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"開始使用fire.app","slug":"start-fire-app","date":"2013-09-02T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/09/03/start-fire-app/","link":"","permalink":"https://wcc723.github.io/sass/2013/09/03/start-fire-app/","excerpt":"上一篇介紹ruby的安裝並使用它來編譯sass，本篇就要介紹如何開始使用fire.app。 官方網站 : http://fireapp.handlino.com/","text":"上一篇介紹ruby的安裝並使用它來編譯sass，本篇就要介紹如何開始使用fire.app。 官方網站 : http://fireapp.handlino.com/ Fire.app的功能 Sass + Compass 這部分介紹了許多次，所以不再重複介紹了~。 Template languages 樣板語言，內建了Haml/Slim/ERB/Markdown格式，這些樣板功能在視覺設計師眼裡就像是indesign的主板功能，他可以定義很多預設樣式，可以有效改善編輯時的效率，而在程式設計師眼中就像是include的功能。 CoffeeScript CoffeeScript讓javascript寫起來更直覺容易。 Auto Refresh 這功能就是同Livereload，在每次修改檔案他都會自動重新整理瀏覽器，少去了按f5的時間，減少鍵盤f5的故障率。 Build Project 在開發新專案時可以立即的建立基礎專案模板，並且在之後開啟只要輕輕點擊一下，就可以到該專案。 Cross-Platform Fire.app可以在各系統上使用，mac、windows、Linux，都可以輕鬆執行。 正式開始 在開始之前，可能還是要花點小錢($14USD)，在購買後不久就能收到軟體。本軟體不需要安裝，只要解壓縮就可以用，但建議還是解壓縮在英文目錄下比較穩定。 在一開始打開時，會出現在畫面的右下角，並且是黑色的，對他點右鍵。 選擇第一個Watch a Folder，可以試試看目前已經執行的專案，或者是簡單先做一個靜態的網頁。 在開啟後，右下角的火球會變成彩色，並且選單會有所改變，如果需要停止，只要點第一個stop XXX就可以了。 接下來馬上來測試有沒有成功，只要在網址列上輸入http://127.0.0.1:24681/的網址，如果有出現目前的網頁就算是成功了。 Auto Refresh 這功能可以在每次存檔時重新整理瀏覽器網頁，這和livereload相同，在使用之前建議先在瀏覽器安裝擴充套件(限定chrome,firefox)，本篇將用chrome做範例。 首先先到chrome線上應用程式商店，尋找LiveReload，並且安裝。 回到剛剛http://127.0.0.1:24681/的頁面，如果點擊右上方的圓圈，可以如圖呈現黑色，就恭喜你成功了。接下來在修改網頁後的每次存檔，你的chrome都會自動重新整理網頁。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"fire.app","slug":"fire-app","permalink":"https://wcc723.github.io/tags/fire-app/"}]},{"title":"安裝ruby以及sass環境","slug":"start-ruby","date":"2013-09-01T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/09/02/start-ruby/","link":"","permalink":"https://wcc723.github.io/sass/2013/09/02/start-ruby/","excerpt":"使用sass前的準備分為兩個部分: 文字編輯器 編譯環境 文字編輯器對於視覺設計師有Dreamweaver，而對於程式設計師則有vim、Visual studio等，除了以上之外這邊還會推薦使用sublime text，但本篇主要會先介紹編譯環境，所以在此不多敘述。 編譯環境是踏入sass最困難的一步，先前有提過sass是透過ruby所編譯的，所以在編譯前還需要有ruby，本篇會從如何建立ruby環境到sass的安裝。 說實在，本篇範例不建議使用，編譯sass並沒有這麼困難，但會讓大家了解ruby是怎樣的東西，這安裝流程是怎麼樣的，這有助於更了解sass，後面會介紹其他編譯sass的方式。","text":"使用sass前的準備分為兩個部分: 文字編輯器 編譯環境 文字編輯器對於視覺設計師有Dreamweaver，而對於程式設計師則有vim、Visual studio等，除了以上之外這邊還會推薦使用sublime text，但本篇主要會先介紹編譯環境，所以在此不多敘述。 編譯環境是踏入sass最困難的一步，先前有提過sass是透過ruby所編譯的，所以在編譯前還需要有ruby，本篇會從如何建立ruby環境到sass的安裝。 說實在，本篇範例不建議使用，編譯sass並沒有這麼困難，但會讓大家了解ruby是怎樣的東西，這安裝流程是怎麼樣的，這有助於更了解sass，後面會介紹其他編譯sass的方式。 Ruby & Sass安裝流程 本篇以windows為例 安裝Rubyinstaller 使用 Command Prompt with Ruby (Ruby的命令提示字元…硬要翻) 安裝sass、系統更新、安裝compass 使用 步驟1.安裝Rubyinstaller 首先連結到官網安裝Rubyinstaller(http://rubyinstaller.org/downloads/)，應該不會有人卡在這邊...，如果卡在這邊，建議先去找個網路遊戲下載安裝試試看。 步驟2.使用 Command Prompt with Ruby 在這個階段，只要找到你的Command Prompt with Ruby，並且打開就可以了。 步驟3.安裝sass 果你成功打開這個像DOS的東西，那應該就成功三分之一了，接下來就依序輸入指令碼，依序系統更新、安裝sass、安裝compass。 請依序輸入以下指令碼。 gem update –system gem install sass gem install compass 步驟4.使用sass 這個步驟的重點就是...怎麼使用dos指令，首先，就直接在桌面建立一個資料夾開始吧! (1)在桌面開了一個資料夾叫做SCSS，路徑是C:\\Users\\使用者ID\\Desktop\\scss (使用者ID) 裡面包含了兩個資料夾1.css 2.scss (2)接下來就是進入到你所建立的資料夾 輸入cd\\ (移動到根目錄) 輸入cd C:\\Users\\使用者ID\\Desktop\\scss (3)在你的C:\\Users\\使用者ID\\Desktop\\scss\\scss資料夾中，創一個test.scss的檔，並在檔案裡面輸入CSS，也可參考官網http://sass-lang.com/來做測試。 (4)回到你的Command Prompt with Ruby，輸入sass –watch scss:css，他將會把scss資料夾內的檔案編譯成CSS，並存在CSS這個資料夾。 sass –watch scss:css (5)神奇的事情發生了，SCSS被編譯成CSS檔，而且在你每次的SCSS存檔，都會被編譯。 完成! 只要Command Prompt with Ruby，沒有被中止，他就會持續監控你的SCSS檔，所以每次存檔都會被編譯。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"ruby","slug":"ruby","permalink":"https://wcc723.github.io/tags/ruby/"}]},{"title":"Sass 開始前的問與答","slug":"why-sass","date":"2013-08-30T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/08/31/why-sass/","link":"","permalink":"https://wcc723.github.io/sass/2013/08/31/why-sass/","excerpt":"sass官方網站 : http://sass-lang.com/ 如何開始使用sass呢? 在開始前，還是先認識一下這是怎樣的東西。","text":"sass官方網站 : http://sass-lang.com/ 如何開始使用sass呢? 在開始前，還是先認識一下這是怎樣的東西。 他是不是像Dreaweaver的軟體，安裝完後就可以用了? 很可惜不是，Sass是一種基於Ruby編寫的CSS擴充語言，所以要使用就要先有Ruby環境。 Sass，為何又有人說scss? 兩者都屬於sass，而差在附檔名以及編寫方式的不同。 .sass 是屬於舊式的sass語法，明顯的特徵是利用縮排取代大括號。 .scss 是較新的語法，為了讓新一代的設計師可以承受較少的痛學習sass，所以在結構上相當類似CSS。 (本站是用sass，只因為覺得大括號要找頭尾很麻煩。) Less 又是什麼? 他也是類似sass的CSS擴充語言，不同的是sass是在Ruby環境下，而less是Javascript library。 這邊有一個比較網站，可以自行參考看看。 Ruby環境，安裝是不是很麻煩? 對於沒有安裝類似環境的人來說，真的有夠麻煩...，但是很多時候痛一次就過了，當然也有花點小錢解決事情的方法~。 花點小錢的解決方法!? Fire.app Fire.app就...讚。 prepros prepros是免費的，但是在多次使用後發現有些bug，以及他的livereload只針對他所編譯的檔案才有效，所以現在比較沒有使用了。 sass 可以運用在現在的專案嗎? scss 是不錯的選擇，只要環境準備好，將CSS檔名修改成.scss 就可以開始了，而且從現有的專案開始慢慢學習，也不會有太大的挫折感。 Compass又是什麼? 自己去看上一集! 如果看完以上文章，還不是很了解的話，在接下來的文章會教大家如何使用，從實際範例中慢慢的認識sass。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass 基礎教學-為何要學Sass","slug":"why-sass","date":"2013-08-29T16:00:00.000Z","updated":"2017-06-21T12:11:01.000Z","comments":true,"path":"sass/2013/08/30/why-sass/","link":"","permalink":"https://wcc723.github.io/sass/2013/08/30/why-sass/","excerpt":"Sass官網 看不到簡報請點此連結http://www.slideshare.net/slideshow/embed_code/11639772 上面這個簡報介紹了的很清楚，在經過一段時間的使用，發現已經回不去了(相信用過的都有這種感覺!)。為何要用Sass ?這用說的都是說不清楚，看範例比較清楚~。","text":"Sass官網 看不到簡報請點此連結http://www.slideshare.net/slideshow/embed_code/11639772 上面這個簡報介紹了的很清楚，在經過一段時間的使用，發現已經回不去了(相信用過的都有這種感覺!)。為何要用Sass ?這用說的都是說不清楚，看範例比較清楚~。 Demo B 像是這前幾天做的效果，sass的code如下。 @mixin longShadow($lenght: 20,$rgb: #000) $all: () @for $i from 1 through $lenght $all: append($all, append(#{$i}px #{$i}px 0 ,rgba($rgb,0.9/$i + 0.05)),comma) text-shadow: $all 這是一個text-shadow的@mixin，換句話說是一個樣式模組，可以將它匯入至樣式表內，讓這一個text-shadow編譯成CSS。 text-shadow: 1px 1px 0 #b3b3b3, 2px 2px 0 rgba(179, 179, 179, 0.5), 3px 3px 0 rgba(179, 179, 179, 0.33333), 4px 4px 0 rgba(179, 179, 179, 0.25), 5px 5px 0 rgba(179, 179, 179, 0.2), 6px 6px 0 rgba(179, 179, 179, 0.16667), 7px 7px 0 rgba(179, 179, 179, 0.14286), 8px 8px 0 rgba(179, 179, 179, 0.125), 9px 9px 0 rgba(179, 179, 179, 0.11111), 10px 10px 0 rgba(179, 179, 179, 0.1), 11px 11px 0 rgba(179, 179, 179, 0.09091), 12px 12px 0 rgba(179, 179, 179, 0.08333), 13px 13px 0 rgba(179, 179, 179, 0.07692), 14px 14px 0 rgba(179, 179, 179, 0.07143), 15px 15px 0 rgba(179, 179, 179, 0.06667), 16px 16px 0 rgba(179, 179, 179, 0.0625), 17px 17px 0 rgba(179, 179, 179, 0.05882), 18px 18px 0 rgba(179, 179, 179, 0.05556), 19px 19px 0 rgba(179, 179, 179, 0.05263), 20px 20px 0 rgba(179, 179, 179, 0.05), 21px 21px 0 rgba(179, 179, 179, 0.04762), 22px 22px 0 rgba(179, 179, 179, 0.04545), 23px 23px 0 rgba(179, 179, 179, 0.04348), 24px 24px 0 rgba(179, 179, 179, 0.04167), 25px 25px 0 rgba(179, 179, 179, 0.04), 26px 26px 0 rgba(179, 179, 179, 0.03846), 27px 27px 0 rgba(179, 179, 179, 0.03704), 28px 28px 0 rgba(179, 179, 179, 0.03571), 29px 29px 0 rgba(179, 179, 179, 0.03448), 30px 30px 0 rgba(179, 179, 179, 0.03333), 31px 31px 0 rgba(179, 179, 179, 0.03226), 32px 32px 0 rgba(179, 179, 179, 0.03125), 33px 33px 0 rgba(179, 179, 179, 0.0303), 34px 34px 0 rgba(179, 179, 179, 0.02941), 35px 35px 0 rgba(179, 179, 179, 0.02857), 36px 36px 0 rgba(179, 179, 179, 0.02778), 37px 37px 0 rgba(179, 179, 179, 0.02703), 38px 38px 0 rgba(179, 179, 179, 0.02632), 39px 39px 0 rgba(179, 179, 179, 0.02564), 40px 40px 0 rgba(179, 179, 179, 0.025); 這個陰影在匯入後，可以轉成這麼長的CSS，而且透過變數的修改，可以另外再調整陰影長度及陰影顏色，如果這樣的陰影，如果客戶說太短，想要在加長50%，就可以感覺到CSS與SASS效率上的差異了。 Sass 與 Compass Compass 官方網站 Compass是基於sass的擴充函式庫，最常用到的就是CSS3 @mixin (又是@mixin!?)，還是用範例來解釋吧。 上面這段陰影的CSS code大家應該都很熟悉，目前的版本要這樣打... -webkit-box-shadow: 0 0 10px rgba(0, 0, 0, 0.6); -moz-box-shadow: 0 0 10px rgba(0, 0, 0, 0.6); box-shadow: 0 0 10px rgba(0, 0, 0, 0.6); 但是如果是sass with compass，就只要如下方式輸入... @include box-shadow(0 0 10px rgba(00,00,00,.6)) 只要匯入Css3 @mixin後，他就會幫你自動加入CSS個瀏覽器的hack，很棒吧~，在接下來的分享如何開始使用Sass與compass。","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Sass HSL function","slug":"sass-hsl-funtion","date":"2013-08-25T16:00:00.000Z","updated":"2019-12-23T02:20:34.993Z","comments":true,"path":"sass/2013/08/26/sass-hsl-funtion/","link":"","permalink":"https://wcc723.github.io/sass/2013/08/26/sass-hsl-funtion/","excerpt":"sass在顏色的處理有許多function可以用，如果多善用這些function可以讓網頁有更多的變化，並且提高網頁的一致性。","text":"sass在顏色的處理有許多function可以用，如果多善用這些function可以讓網頁有更多的變化，並且提高網頁的一致性。 HSL Functions HSL function 是我使用頻率較高的function，而HLS就是色彩學中的色相、明度、彩度，如果不清楚可以看一下Adobe所提供的色相環，自己親自玩看看就會比較了解了。 一開始我們先定義一個有點橘，但不會太橘的顏色(這樣等等demo會比較明顯)。 #F09671 12$color: #F09671//然後我們要給他一個變數，就叫做&lt;code&gt;$color&lt;/code&gt; Darken & Lighten 明亮度 先來點簡單的，調整明亮度Darken & Lighten。 1234lighten($color, $amount)//Makes a color lighter.darken($color, $amount)//Makes a color darker. darken($color,15%) = #e35318$color = #F09671lighten($color,15%) = #fadacd Saturate & Desaturate 飽和度 1234saturate($color, $amount)//Makes a color more saturated.desaturate($color, $amount)//Makes a color less saturated. saturate($color,15%) = #fc9165$color = #F09671desaturate($color,15%) = #e49b7d Hue 其實就是取得顏色在色相環的位置，所以這個demo是錯誤地~。 12hue($color)//Gets the hue component of a color. $color = #F09671hue($color) = 17.48031deg Adjust-hue 調整色相環位置。 12adjust-hue($color, $degrees)//Changes the hue of a color. $color = #F09671hue($color) = #f0b671 lightness 喔喔~又是一個錯誤的demo，這是取得顏色的目前明度值。 12lightness($color)//Gets the lightness component of a color. $color = #F09671lightness($color)= 69.21569% 我們可以看到剛剛的lighten + 15%，他的明度值確實也提高了15%。 $color = #F09671lighten($color,15%)= 84.21569% Grayscale 將顏色調整為灰階，調整為灰階明度是不會改變的。 grayscale($color) //Converts a color to grayscale. $color = #F09671grayscale($color)= #b1b1b1 lightness(grayscale($color)) = 69.21569% Complement 互補色 12complement($color)//Returns the complement of a color. $color = #F09671complement($color)= #71cbf0 Invert 這我有點不清楚怎麼解釋，就看一下他在色相環的 結果 ```sass Invert($color) //Returns the inverse of a color. ```sass $color = #F09671complement($color)= #0f698e","categories":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/categories/sass/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"CSS transition 各種速率","slug":"css-transtion-speed","date":"2013-08-23T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/08/24/css-transtion-speed/","link":"","permalink":"https://wcc723.github.io/css/2013/08/24/css-transtion-speed/","excerpt":"今天要介紹的是CSS transition中的timing-function，transition語法在CSS3動態中是相當容易被使用，如果再改變他的timing-function，可以獲得更豐富的效果。","text":"今天要介紹的是CSS transition中的timing-function，transition語法在CSS3動態中是相當容易被使用，如果再改變他的timing-function，可以獲得更豐富的效果。 參考 : http://www.w3schools.com/cssref/css3_pr_transition-timing-function.asp http://devdocs.io/css/transition-timing-function Demo中的共通sass div width: 50px height: 50px background: red +transition-property(margin-left) +transition-duration(5s) .demo:hover > div margin-left: calc(100% - 50px) DEMO開始 各種transition-timing-function的效果(安安，你們會卡嗎?我好卡)，主要有以下幾種屬性。 +transition-timing-function(ease) //緩慢的開始，中間變快，又變慢慢結束。相當於cubic-bezier(0.25,0.1,0.25,1)。 +transition-timing-function(ease-in) //ease-in：緩慢的開始。相當於cubic-bezier(0.42,0,1,1)。 +transition-timing-function(ease-out) //ease-out：緩慢的結束。相當於cubic-bezier(0,0,0.58,1)。 +transition-timing-function(ease-in-out) //ease-in-out：緩慢的開始和結束。相當於cubic-bezier(0.42,0,0.58,1)。 +transition-timing-function(linear) linear：表示從開始到結束的速度一致。相當於cubic-bezier(0,0,1,1)。 +transition-timing-function(cubic-bezier(0.1, 0.7, 1.0, 0.1)) cubic-bezier(n,n,n,n)：自由定義cubic-bezier函數，每個值為0到1之間的數字。 cubic-bezier +transition-timing-function(step-start) +transition-timing-function(step-end) //這兩個....是來鬧得? +transition-timing-function(steps(4, end)) //分為4個階段 Togather! ease ease-in ease-out ease-in-out linear cubic-bezier step-start step-end steps(4, end)","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"Web Font的基本設定","slug":"web-font","date":"2013-08-22T16:00:00.000Z","updated":"2017-06-21T12:10:27.000Z","comments":true,"path":"css/2013/08/23/web-font/","link":"","permalink":"https://wcc723.github.io/css/2013/08/23/web-font/","excerpt":"Web Font的基本用法不會很難，如果是要用本機的方式，首先就是要先找個資料夾放字型檔，接下來參考@font-face的作法即可。","text":"Web Font的基本用法不會很難，如果是要用本機的方式，首先就是要先找個資料夾放字型檔，接下來參考@font-face的作法即可。 @font-face 參考 : http://devdocs.io/css/@font-face http://compass-style.org/reference/compass/css3/font_face/ CSS3的設定 @font-face { [font-family: &lt;family-name&gt;;]? [src: [ &lt;uri&gt; [format(&lt;string&gt;#)]? | &lt;font-face-name&gt; ]#;]? [unicode-range: &lt;urange&gt;#;]? [font-variant: &lt;font-variant&gt;;]? [font-feature-settings: normal|&lt;feature-tag-value&gt;#;]? [font-stretch: &lt;font-stretch&gt;;]? [font-weight: &lt;weight&gt;]; [font-style: &lt;style&gt;]; } sass 的設定 +font-face($name, $font-files, $eot, $weight, $style) //font-face(自訂義名稱，檔案路徑，IE專用!?，文字粗，樣式(might be also italic)) This is Kavoon-Regular. 20130823 google Web fonts Google 有提供線上的版本，按照他們的方式操作並不會很難，只要先搜尋到想要的字體就可以開始了~ 參考 : http://www.google.com/fonts/ CSS版 //插入 link &lt;link href='http://fonts.googleapis.com/css?family=The+Girl+Next+Door' rel='stylesheet' type='text/css'&gt; //或是import @import url(&quot;http://fonts.googleapis.com/css?family=The+Girl+Next+Door&quot;) //本地CSS設定 font-family: 'The Girl Next Door', cursive; This is The Girl Next Door. javascript版 google會提供，只要插入在網頁裡即可，font-family也是依提供的設定即可。 This is Frijole. 現實的來了 捉雞 Feature Firefox (Gecko) Chrome Internet Explorer Opera Safari Basic support 3.5 (1.9.1) 4.0 4.0 10.0 3.1 WOFF 3.5 (1.9.1) 6.0 9.0 11.10 5.1 SVG Font Not&nbsp;supported Unimplemented (see bug&nbsp;119490) yes Not&nbsp;supported yes yes unicode-range yes&nbsp;(bug&nbsp;443976) yes 9.0 (Yes) (Yes) 手機 Feature Android Firefox Mobile (Gecko) IE Mobile Opera Mini Opera Mobile Safari Mobile Basic support (Yes) 1.0 (1.9.1) ? Not&nbsp;supported 10.0 (Yes) WOFF Not&nbsp;supported 5.0 (5.0) ? Not&nbsp;supported 11.0 Not&nbsp;supported SVG fonts Not&nbsp;supported Not&nbsp;supported Unimplemented (see bug&nbsp;119490) ? Not&nbsp;supported 10.0 (Yes) unicode-range &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; (Yes)","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]},{"title":"html meta基本語法","slug":"html-meta","date":"2013-08-21T16:00:00.000Z","updated":"2016-10-11T09:48:48.000Z","comments":true,"path":"html/2013/08/22/html-meta/","link":"","permalink":"https://wcc723.github.io/html/2013/08/22/html-meta/","excerpt":"傳說中meta只要能夠使用的好，可以帶來許多意想不到的效果，甚至是連用了都不知道有什麼功能...。 參考文章：http://www.cnblogs.com/sniper007/p/3258389.html 延伸閱讀：http://code.lancepollard.com/complete-list-of-html-meta-tags/","text":"傳說中meta只要能夠使用的好，可以帶來許多意想不到的效果，甚至是連用了都不知道有什麼功能...。 參考文章：http://www.cnblogs.com/sniper007/p/3258389.html 延伸閱讀：http://code.lancepollard.com/complete-list-of-html-meta-tags/ meta的組成 相傳meat的是分別由http-equiv和name而組成，以下就依據該網頁介紹各種用法。 1.name屬性 &lt;meta name=&quot;參數&quot; content=&quot;具體的參數值&quot;&gt; 功能是描述網頁，對應的屬性為content，主要的屬性有以下參數。 a.Keywords(關鍵字) 描述網頁的關鍵字 &lt;meta name=&quot;keywords&quot; content=&quot;a day a share&quot;&gt; b.​​description(網站內容描述) 描述網站的內容 &lt;meta name=&quot;description&quot; content=&quot;利用純靜態網頁，來分享Web技術，並透過每日的分享，來逐步提升自己的能力。&quot;&gt; c.robots(機器人嚮導) 用來告訴機器人那些頁面需要索引，而那些不需要。 &lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; //參數有all,none,index,noindex,follow,nofollow d.author(作者) 怎麼看都知道是作者。 &lt;meta name=&quot;author&quot; content=&quot;Casper&quot;&gt; 2.http-equiv屬性 name主要作為描述，http-equiv則會與瀏覽器產生作用。 a.Expires(期限) 設定網頁的到期時間，只要過期，就必須重新傳輸。 &lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri, 12 Jan 2001 18:18:18 GMT&quot;&gt; ​​b.Pragma(cache模式) 禁止使用cache。 &lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; c.Refresh(刷新) 重新整理，並導向目標頁面。 &lt;meta http-equiv=&quot;Refresh&quot; content=&quot;2；URL=http://ashareaday.wcc.tw&quot;&gt; //2秒後重新導向... d.Set-Cookie(cookie設定) 如果網頁過期，cookie將被刪除。 &lt;meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx; expires=Friday, 12-Jan-2001 18:18:18 GMT; path=/&quot;&gt; e.content-Type(顯示字編碼的設定) 就...設定編碼 &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; f.Window-target(顯示窗口的設定) 強制頁面在當前窗口以獨立頁面顯示。(這段不是很了解，似乎是不能被當成iframe?) &lt;meta http-equiv=&quot;Window-target&quot; content=&quot;_top&quot;&gt; 在html5之後meta屬性越來越多樣，還有許多目前沒提到，之後會依序補充。","categories":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"}]},{"title":"image 與 SVG","slug":"jpg-and-svg","date":"2013-08-20T16:00:00.000Z","updated":"2016-10-11T09:48:48.000Z","comments":true,"path":"html/2013/08/21/jpg-and-svg/","link":"","permalink":"https://wcc723.github.io/html/2013/08/21/jpg-and-svg/","excerpt":"image與SVG的運用","text":"image與SVG的運用 來源 : http://lynn.ru/examples/svg/en.html image image和img是非常相似的，大部分瀏覽器都可以用image取代img replace 以上的原始碼 &lt;svg&gt; &lt;image xlink:href=&quot;images/20130821.svg&quot; src=&quot;images/20130821.png&quot; width=&quot;75&quot; height=&quot;75&quot;/&gt; &lt;/svg&gt; 如果在支持SVG的瀏覽器會看到這樣 &lt;image xlink:href=&quot;images/20130821.svg&quot; width=&quot;75&quot; height=&quot;75&quot;/&gt; 如果是不支持SVG的瀏覽器會顯示如下 &lt;image src=&quot;images/20130821.png&quot; width=&quot;75&quot; height=&quot;75&quot;/&gt; 對於有些很簡單的圖像，她可能不需要獨立的SVG檔案，可以寫成這樣。 &lt;svg height=&quot;16&quot; width=&quot;16&quot;&gt; &lt;path d=&quot;M5 1v14l9-7&quot;&gt; //SVG code &lt;image src=&quot;next.png&quot;&gt; //替代PNG &lt;/svg&gt; 如果用img會得到以下結果... 好像不可以啊?","categories":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/categories/html/"}],"tags":[{"name":"html","slug":"html","permalink":"https://wcc723.github.io/tags/html/"},{"name":"svg","slug":"svg","permalink":"https://wcc723.github.io/tags/svg/"}]},{"title":"CSS3 文字陰影範例","slug":"text-shadow-demo","date":"2013-08-19T16:00:00.000Z","updated":"2017-06-21T12:10:28.000Z","comments":true,"path":"css/2013/08/20/text-shadow-demo/","link":"","permalink":"https://wcc723.github.io/css/2013/08/20/text-shadow-demo/","excerpt":"本篇會介紹許多CSS3文字陰影範例，而text-shadow在瀏覽器的支援度還算高，有興趣的朋友都可以試試。 來源參考：http://www.w3cplus.com/blog/52.html","text":"本篇會介紹許多CSS3文字陰影範例，而text-shadow在瀏覽器的支援度還算高，有興趣的朋友都可以試試。 來源參考：http://www.w3cplus.com/blog/52.html 最普通的版本 text-shadow: 1px 1px 5px black //text: x-offect y-offect Blur Color NORMAL Text-shadow 很常用的版本 陰刻與陽刻 text-shadow: 1px 1px 0 black text-shadow: -1px -1px 0 black Text-shadow Text-shadow 光輝的效果 利用模糊的半徑做出類似光輝的效果。 text-shadow: 0 0 20px orange GLOW AND EXTRA GLOW EFFECT 利用不同的模糊建立多層次的光輝，這個效果我還挺喜歡的，畢竟設計就是矯情~。 text-shadow: 0 0 5px white,0 0 10px white,0 0 15px white,0 0 40px #ff00de,0 0 70px #ff00de NEON EFFECT Photoshop 浮雕效果 利用上面所說的陰刻、陽刻的混和體。 text-shadow: -1px -1px 0 white, 1px 1px 0 #333,1px 1px 0 #444 PHOTOSHOP EMBOSS EFFECT 模糊文字效果 將原本的文字透明後，再將陰影模糊化做出模糊文字的效果。 color: transparent text-shadow: 0 0 5px red BLUR TEXT EFFECT 外框文字 如果有這種需求...，加減用也是不錯的 text-shadow: 1px 1px 0 red, -1px -1px 0 red STROKE TEXT 3D文字效果 利用一層一層堆疊的方式做出血尿般的3D效果。 text-shadow: 1px 1px rgba(220,220,220,.8),2px 2px rgba(220,220,220,.8),3px 3px rgba(220,220,220,.8),4px 4px rgba(220,220,220,.8),5px 5px rgba(220,220,220,.8) 3D TEXT EFFECT 反過來疊就會變這樣... 3D TEXT EFFECT 復古文字效果 這效果我也很喜歡，是利用兩個陰影堆疊出來的，可惜的是第一個陰影必須與背景相同顏色。 VINTAGE RETRO EFFECT 立體影像效果 將原本的文字及陰影都用rgba的方式製作半透明，相信有心的話，可以做出3D眼鏡都可以看的版本。 ANAGLYPHIC TEXT EFFECT","categories":[{"name":"css","slug":"css","permalink":"https://wcc723.github.io/categories/css/"}],"tags":[{"name":"sass","slug":"sass","permalink":"https://wcc723.github.io/tags/sass/"},{"name":"css","slug":"css","permalink":"https://wcc723.github.io/tags/css/"}]}]}