<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[JS 物件名詞解釋及常見觀念問題]]></title>
      <url>https://wcc723.github.io/development/2020/09/21/js-object/</url>
      <content type="html"><![CDATA[<p>接下來來到 JavaScript 另一個坑「物件」。</p>
<h2 id="物件的定義方法差在哪？"><a href="#物件的定義方法差在哪？" class="headerlink" title="物件的定義方法差在哪？"></a>物件的定義方法差在哪？</h2><p>JavaScript 定義物件的方式主要有兩種形式：</p>
<ul>
<li><code>var a = &#123;&#125;</code>：<code>&#123;&#125;</code> 稱為物件實字，是相對簡短且易讀的建立方式。</li>
<li><code>var b = new Object();</code>：使用 <code>Object</code> 建構函式產生物件。</li>
</ul>
<p>這兩種建立方式就結果而言並無差別，但普遍來說會更推薦使用「<strong>物件實字</strong>」，主要原因如下：</p>
<ol>
<li>相對於建構式來說更為簡短</li>
<li>物件實字易讀性佳</li>
<li>效能優於建構函式，可參考相關 <a href="https://stackoverflow.com/questions/7375120/why-is-arr-faster-than-arr-new-array">討論 1</a>、<a href="https://stackoverflow.com/questions/4597926/what-is-the-difference-between-new-object-and-object-literal-notation">討論 2</a></li>
<li>避免無關緊要的錯誤（下方補充）</li>
</ol>
<p>在實戰上，也不太會使用 <code>new Object()</code> 來建立一個物件，這個方法則只會在學習原型、建構式時才會用到，如果還未接觸到此部分的開發者，可先把它放在一旁。而這兩種建立方式各有些微的事項需要注意。</p>
<h4 id="物件實字"><a href="#物件實字" class="headerlink" title="物件實字"></a>物件實字</h4><p>物件實字的定義方式不太會出錯，只不過物件實字與陳述式中的 <code>&#123;&#125;</code> 的符號是相同的，所以在撰寫時需要注意所使用的是 陳述式 或 建構函式。</p>
<p>以下為 “物件實字”，可視為一個物件、表達式的結果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以下為 “區塊語法”，可視為一個陳述式（實戰中較少單獨使用，但可配合 <code>let</code>、<code>const</code> 限制作用域），結構上與物件相當類似，請避免搞混。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>延伸問題思考：區塊語法是否可以作為表達式運用？</p>
</blockquote>
<h4 id="物件建構式"><a href="#物件建構式" class="headerlink" title="物件建構式"></a>物件建構式</h4><p><code>new Object</code> 預期會回傳一個新的物件，但如果傳入的結構並非為物件，依然可以正確運行，僅不過回傳的結果可能會不如預期，如以下範例會回傳一個「物件型別」的數字 1。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num); <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(num + <span class="number">1</span>);    <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(num == <span class="number">1</span>);   <span class="comment">// true </span></span><br><span class="line"><span class="built_in">console</span>.log(num === <span class="number">1</span>);  <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<h2 id="物件內的屬性、方法"><a href="#物件內的屬性、方法" class="headerlink" title="物件內的屬性、方法"></a>物件內的屬性、方法</h2><p>物件的名稱定義可以看到許多不同的說法，在此透過 MDN 及原文來加以介紹，物件建立後會使用一個 <code>&#123;&#125;</code> 包覆著屬性（<code>property</code>），每一個屬性包含著「名稱」（name）及「值」（value）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  name: value</span><br><span class="line">  <span class="comment">// 名稱：值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一個屬性可以賦予純值、物件、陣列等等，依據開發的需求我們也同樣會賦予函式，而這類型的屬性則會稱為「方法」（methods）</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,      <span class="comment">// 屬性</span></span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函式則稱為方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="物件取值方法"><a href="#物件取值方法" class="headerlink" title="物件取值方法"></a>物件取值方法</h2><p>物件取值方式常見為<strong>點記號</strong>（Dot notation），這是精簡、好閱讀的取值方式，也算是最常運用的取值方法。以上述的程式碼來說，當取得 <code>name</code> 值時的點記號可以寫為：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person.name);</span><br></pre></td></tr></table></figure>
<p>另一種方式是常被新手忽略的「括弧記法」（Bracket notation），寫法結構類似於一個陣列的取值方式，寫法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;name&#x27;</span>]);  <span class="comment">// 取值</span></span><br><span class="line">person[<span class="string">&#x27;run&#x27;</span>]();              <span class="comment">// 呼叫函式</span></span><br></pre></td></tr></table></figure>
<p>相對於點記號來說，<code>[]</code> 看似結構複雜難以閱讀，但它也能突破許多取值上的限制，以下皆為點記號無法運行的方式，如：</p>
<ol>
<li>特殊字元的賦值、取值</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">person[<span class="number">1</span>] = <span class="string">&#x27;數字 1&#x27;</span>;</span><br><span class="line">person[<span class="string">&#x27;my-name&#x27;</span>] = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person[<span class="string">&#x27;my-name&#x27;</span>]);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用變數進行操作</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person[num]);</span><br></pre></td></tr></table></figure>
<p>當可以使用變數存取物件值時，如欲屬性名稱不確定時，可以搭配 <code>Object.keys</code> 列出所有的屬性名稱，並且依序取出所有的物件值，方法如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span>,      <span class="comment">// 屬性</span></span><br><span class="line">  run: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 函式則稱為方法</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;跑&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(person); <span class="comment">// keys 為 [&#x27;name&#x27;, &#x27;run&#x27;]</span></span><br><span class="line">keys.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(person[name]);</span><br><span class="line">   <span class="comment">// 分別結果為 &#x27;小明&#x27; 及 &#x27;run&#x27; 的方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="何時使用物件、何時使用陣列"><a href="#何時使用物件、何時使用陣列" class="headerlink" title="何時使用物件、何時使用陣列"></a>何時使用物件、何時使用陣列</h2><p>物件與陣列同時都可以包含許多資訊，因此會難以分辨在定義時該使用陣列或是物件，以簡單的定義來說：</p>
<ul>
<li>物件可用來定義單一複雜的資訊</li>
<li>陣列可用來定義重複的多數結構</li>
</ul>
<p>以汽車的資訊來說，一台車可能同時具有許多複雜的資訊，如品牌、色彩、價格、馬力、性能…，這些資訊並不重複且僅賦予在同一台車內，概念如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = &#123;</span><br><span class="line">  brand: <span class="string">&#x27;BMW&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  price: <span class="number">1630000</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2FF4AE2B99-D87A-4807-A128-C33AAFD5F8DC.png?alt=media&amp;token=3d36baaa-b54c-462e-a8ae-ac1709f17c7c" alt="單一品項，裡面需要不同的屬性進行描述就可使用物件"></p>
<p>當定義了一台汽車以後，也可以使用同樣的概念定義更多的汽車，汽車成為複數時，則會是多台重複結構的汽車，這時就可以改用陣列來儲存這些資訊：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cars = [&#123;</span><br><span class="line">  brand: <span class="string">&#x27;BMW&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">  price: <span class="number">2630000</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  brand: <span class="string">&#x27;Ferrari&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;red&#x27;</span>,</span><br><span class="line">  price: <span class="number">16300000</span></span><br><span class="line">&#125;,&#123;</span><br><span class="line">  brand: <span class="string">&#x27;Toyota&#x27;</span>,</span><br><span class="line">  color: <span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">  price: <span class="number">6300000</span></span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F2243DF17-C5F0-4550-8BDF-E5952CA3771C.png?alt=media&amp;token=c6a49180-e72e-46d1-94c4-4aef56955a85" alt="多個品項，但品項內的結構大多是重複即可使用陣列"></p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JS 加不加分號差在哪？]]></title>
      <url>https://wcc723.github.io/development/2020/09/20/js-semi/</url>
      <content type="html"><![CDATA[<p>這個議題許多論壇、文件都有討論，在 ESlint 的規範中也可從加不加分號區分為兩大派系，至於加不加分號關鍵點則需要了解分號對於 JavaScript 的影響，開始之前可以先看看以下題目。</p>
<p>下方程式碼的運行預期為：</p>
<ol>
<li>宣告 <code>a</code> 的值為 1</li>
<li>執行立即函式</li>
<li>於 console 中呈現 2</li>
</ol>
<p>請問這段程式碼運行是否正確？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure></p>
<p>.<br>.<br>.<br>.<br>如果你嘗試運行這段程式碼，則會出現此錯誤：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught TypeError: 1 is not a function</span><br></pre></td></tr></table></figure></p>
<p>什麼？ <code>1 is not a function</code> ？我們沒有打算運行數字 1，為何要說數字 1 不是函式，這種錯誤很難查找到原因，常常會在錯誤的行數上打轉。這個錯誤主要原因是上述程式碼運行時被視為同一行，概念如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">/* */</span> &#125;)()</span><br></pre></td></tr></table></figure>
<p>因此立即函式的 <code>()</code> 附加在 1 上，這是一個呼叫函式的語法，所以會造成 <code>1 is not a function</code> 的錯誤，如果要避免此錯誤就需要使用分號將其隔開：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> <span class="comment">// 用分號隔開就對了</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="ASI-自動加入分號"><a href="#ASI-自動加入分號" class="headerlink" title="ASI 自動加入分號"></a>ASI 自動加入分號</h2><p>ASI 是 「Automatic Semicolon Insertion」的縮寫，部分的斷行程式碼運行時會<strong>自動插入分號</strong>，這個機制可以部分程式碼如果沒有加入分號也能正確運行，如以下範例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span></span><br><span class="line">++b</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, b)</span><br></pre></td></tr></table></figure>
<p>此範例中，由於 <code>++</code> 是屬於一元表達式，它在僅能在表達式的左方<strong>或</strong>右方置入運算元，如果沒有 ASI 的機制程式碼會轉為「<code>var b = 1 ++ b</code>」 的錯誤結構。不過好在有 ASI，實際運行時他會被加入分號如下，也就不會出現如上的錯誤。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">++b;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, b); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="return-與分號的關係"><a href="#return-與分號的關係" class="headerlink" title="return 與分號的關係"></a>return 與分號的關係</h3><p>再來看一個有感的片段，以下程式碼中在 return 的後方空一行後再回傳值，請問運行結果是什麼呢？</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> </span><br><span class="line">  <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>這段程式碼因為 ASI 的修正，return 後方會被加上一個分號，也因為如此 return 與預期回傳的值被分了開來，所以 return 的內容為空值，最終函式也僅能接收到 <code>undefined</code> 的結果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">  <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(fn()); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h2 id="所以，分號到底要怎麼處理呢？"><a href="#所以，分號到底要怎麼處理呢？" class="headerlink" title="所以，分號到底要怎麼處理呢？"></a>所以，分號到底要怎麼處理呢？</h2><p>ASI 是出自於善意，用來修正沒有加入分號的片段程式碼，但偏偏有些地方沒有發揮其用途（如本篇一開始所介紹到的立即函式），導致程式碼出現了錯誤；甚至有些程式碼不會出錯，但會讓你的程式碼運行結果不如預期。</p>
<p>要解決 ASI 的問題，解決方式如下：</p>
<ul>
<li>無論如何都加入分號，自行決定程式碼的分段</li>
<li>謹記「不會」自動加入分號的規則，當不會自動插入分號時則手動加入</li>
</ul>
<h3 id="不會自動加入分號的規則"><a href="#不會自動加入分號的規則" class="headerlink" title="不會自動加入分號的規則"></a><strong>不會</strong>自動加入分號的規則</h3><p>以下整理各種「不會」自動加入分號的規則：</p>
<ol>
<li>新的一行是 <code>(</code>、<code>[</code>、<code>/</code> 開始，這類型通常會直接出現「Uncaught TypeError」導致程式碼無法運行（其後方的程式碼也會無法運作）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1</span><br><span class="line">var b &#x3D; a</span><br><span class="line">(a + b).toString()</span><br><span class="line"></span><br><span class="line">var a &#x3D; 1</span><br><span class="line">[1,2,3].forEach(bar)</span><br><span class="line"> </span><br><span class="line">(function() &#123; &#125;)()</span><br><span class="line">(function() &#123; &#125;)()</span><br><span class="line"> </span><br><span class="line">var a &#x3D; 1</span><br><span class="line">var b &#x3D; a</span><br><span class="line">&#x2F;test&#x2F;.test(b)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>新的一行以 <code>+</code>、<code>-</code>、<code>*</code>、<code>%</code> 作開始，這類型大多會影響運算結果，建議合併為一行撰寫（<code>+</code> 與 <code>++</code> 結果是不同的）。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2</span><br><span class="line">var b &#x3D; a</span><br><span class="line">+a</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>新的一行以 <code>,</code>、<code>.</code> 作開始，這類型在實戰中很常會運用，主要是避免程式碼過長所加入的分段，並不會影響運行，多加善用可使程式碼更易於閱讀。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 2</span><br><span class="line">var b &#x3D; a</span><br><span class="line">  .toString()</span><br><span class="line">console.log(typeof b)</span><br><span class="line"> </span><br><span class="line">var a &#x3D; 1</span><br><span class="line">,b &#x3D; 2 &#x2F;&#x2F; b 一樣會 var 被宣告</span><br></pre></td></tr></table></figure>
<p>因此，遇到以上的標點符號前方加入分號也是解決辦法</p>
<p>如果需要加入分號的狀況，除了在語句的末端加入分號外，也可將分號改在「不會自動加入分號」的最前方，如 <code>()</code> 本身不會自動加入分號，當有此需求時可以將 <code>;</code> 加入至前方（<a href="https://standardjs.com/rules-zhtw.html#%E5%88%86%E8%99%9F">ESLint Standard JS</a> 規範就選擇此方法避免錯誤）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 執行錯誤</span><br><span class="line">(function() &#123; &#125;)()</span><br><span class="line">(function() &#123; &#125;)()</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 正確</span><br><span class="line">;(function() &#123; &#125;)()</span><br><span class="line">;(function() &#123; &#125;)()</span><br></pre></td></tr></table></figure></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>不加入分號可以讓程式碼看起來更乾淨、精簡（對於習慣加入分號的開發者不這麼認為就是了），且在大部分正確的分段下並不會出現錯誤，僅有少部分的語句會出現執行上的錯誤（很少，大多都可避免），因此許多開發者也會選擇不加入分號，而我過去也是屬於這類型規範的愛好者。</p>
<p>不過在教學上，我會更傾向選擇嚴格的規範提供範例給學員，所以近幾年開發都轉為選用加入分號的規則。至於選擇何種，只要清楚運行上的限制，只要團隊允許都是好的方法。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[開發總是沒問題，上線老是各種錯]]></title>
      <url>https://wcc723.github.io/development/2020/09/19/js-expression-3/</url>
      <content type="html"><![CDATA[<p>不果是新手或老手都可能遇過這樣的狀況，程式碼在測試時運作上看起來都很正常，雖然有一些些地方還不是很熟悉，不過<strong>打從心裡</strong>認定它是正確的，但麻煩卻上線後才發現出錯，仔細檢查也看不出任何問題，殊不知是表達式的觀念錯誤。</p>
<p>程式碼的問題千萬種，本篇就持續在「表達式的觀念」挑出常見的問題，看看是否大家有遇到類似的狀況勒。</p>
<h2 id="連續賦值這麼屌，為何文件都說這不好"><a href="#連續賦值這麼屌，為何文件都說這不好" class="headerlink" title="連續賦值這麼屌，為何文件都說這不好"></a>連續賦值這麼屌，為何文件都說這不好</h2><p>連續賦值（chain variable assignments）的結構如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>以上這段程式碼中最常見的問題為，<code>a</code> 的值是來自於？</p>
<ol>
<li>1 先賦予至 b，b 再將值賦予至 <code>a</code></li>
<li>1 同時賦予至 <code>a</code> 與 <code>b</code> （賦予兩次）<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>以上兩者皆錯， 正確來說 1 的值來自於 <code>b = 1</code> 的回傳值，這時候你一定會想這什麼鬼，什麼叫做 <code>b = 1</code> 的回傳值，請再次回想表達式的特點「會回傳一個值」，<code>=</code> 屬於運算子的其中一種，它除了會賦予值以外也會同時回傳一個值。</li>
</ol>
<p>透過幾段程式碼來驗證這個觀念：</p>
<h4 id="1-先賦予至-b，b-再將值賦予至-a"><a href="#1-先賦予至-b，b-再將值賦予至-a" class="headerlink" title="1 先賦予至 b，b 再將值賦予至 a"></a>1 先賦予至 b，b 再將值賦予至 <code>a</code></h4><p>這個邏輯的概念 b 會先取得 1 的值，並且 <strong>b 的值會轉為 1 再傳給 a</strong>，以下的範例程式碼用另一個邏輯呈現如下：</p>
<ul>
<li><strong>使 b 的值無法被賦予為 1</strong></li>
<li>a 與 b 的值最終不相同</li>
</ul>
<p>範例中會使用到 <code>defineProperty</code> 的方法，並且調整 <code>writable</code> 的屬性讓值無法寫入，透過此方法 <code>b</code> 的值會被固定為 <code>2</code> 無法再被寫入。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">window</span>, <span class="string">&#x27;b&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="number">2</span>,</span><br><span class="line">  writable: <span class="literal">false</span></span><br><span class="line">&#125;);</span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, b); <span class="comment">// b 永遠為 2，無法再次被賦予值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>, a); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;b&#x27;</span>, b); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(a === b); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>程式碼執行結果如下：</p>
<ul>
<li><code>b</code> 值始終為 2</li>
<li><code>a</code> 值被賦予為 1</li>
<li><code>a</code> 與 <code>b</code> 不相等</li>
</ul>
<p>所以結論，<code>a</code> 的值並不是來自於 <code>b</code>。</p>
<h4 id="1-同時會賦予兩次"><a href="#1-同時會賦予兩次" class="headerlink" title="1 同時會賦予兩次"></a>1 同時會賦予兩次</h4><p>這個邏輯中 1 會將值賦予給 <code>a</code> 與 <code>b</code>，這個概念為<strong>數字 1 會被取值兩次</strong>，因此我們透過一個方法來記錄最右側的值被取得的次數。</p>
<p>在此我們會使用到 <code>get</code> 的方法來進行紀錄，當變數每次被取值時，會記錄次數乙次。</p>
<p>範例程式碼 1：驗證當每次被取值時 <code>num</code> 數值會增加 1，範例中被取值了兩次，因此結果為 2。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objWithGetter = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">variable</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = <span class="built_in">this</span>.num + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;variable&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = objWithGetter.variable;</span><br><span class="line"><span class="keyword">var</span> b = objWithGetter.variable;</span><br><span class="line"><span class="built_in">console</span>.log(objWithGetter.num); <span class="comment">// 當變數被取得時， num 的值會增加 1，在此被取得兩次，所以結果為 2</span></span><br></pre></td></tr></table></figure></p>
<p>範例程式碼 2：當連續賦值的時候，最終的結果也僅會有一次。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objWithGetter = &#123;</span><br><span class="line">  num: <span class="number">0</span>,</span><br><span class="line">  <span class="keyword">get</span> <span class="title">variable</span>() &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = <span class="built_in">this</span>.num + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;variable&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = b = objWithGetter.variable;</span><br><span class="line"><span class="built_in">console</span>.log(objWithGetter.num); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F56E3F327-6DA0-49F6-8512-E0628F38B039.png?alt=media&amp;token=9b7e2cf8-eb14-46df-9861-634c65cb63f9" alt="實際連續賦值的運作"></p>
<p>因此，在連續賦值的概念下中，兩個變數會被視為完全獨立的存在，在一些特殊情況時可能會有出乎意料的情況，就以 ESLint 的說明來說，最常見的即為在函式中使用連續賦值，導致<strong>其中轉為全域變數</strong>影響其它程式碼的運作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = b = <span class="number">1</span>;</span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// b 沒有被宣告，屬於全域屬性</span></span><br><span class="line"><span class="comment">// console.log(a); // 立即函式內的區域變數</span></span><br></pre></td></tr></table></figure>
<p>ESLint 文件：<a href="https://eslint.org/docs/rules/no-multi-assign">https://eslint.org/docs/rules/no-multi-assign</a></p>
<blockquote>
<p>Chaining the assignment of variables can <strong>lead to unexpected results</strong> and be difficult to read.<br>連續賦值可能導致不可預期的結果，以及難以被閱讀</p>
</blockquote>
<p>Airbnb ESLint 文件：<a href="https://github.com/airbnb/javascript#variables--no-chain-assignment">https://github.com/airbnb/javascript#variables--no-chain-assignment</a></p>
<blockquote>
<p>Why? Chaining variable assignments <strong>creates implicit global variables</strong>.<br>為何不使用連續賦值？這會產生全域變數</p>
</blockquote>
<h2 id="不管輸入什麼，判斷式的結果總為-true"><a href="#不管輸入什麼，判斷式的結果總為-true" class="headerlink" title="不管輸入什麼，判斷式的結果總為 true"></a>不管輸入什麼，判斷式的結果總為 true</h2><p>請檢視以下程式碼，請問其中的 <code>console.log</code> 是否會執行呢？<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (a = <span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;請問此段是否會執行&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>.<br>.<br>.<br>.<br>.<br>.<br>.<br>答案：這段程式碼 “會” 執行。</p>
<p>這段程式碼是新手常見的錯誤，就是將 <code>if</code> 中的判斷式寫成了 <code>=</code> 賦值，再來回顧一下 if 判斷式的結構。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition)</span><br><span class="line">   statement1</span><br><span class="line">[<span class="keyword">else</span></span><br><span class="line">   statement2]</span><br></pre></td></tr></table></figure>
<p>其中的 <code>condition</code> 可以使用任何的表達式進行替代，而 <code>=</code> 不僅是 JS 中用來賦予值的語法，同時也是屬於運算子的其中一種，所以在此它<strong>不僅會賦予值，同時還會回傳一個結果</strong>，以此段程式碼來說，就發生了以下狀況：</p>
<ul>
<li><code>a</code> 的值與原始不同，在此被賦予成 <code>false</code></li>
<li><code>=</code> 表達式會賦予值，同時會回傳一個值，在此總是會回傳 <code>true</code>（無論是否有成功賦予）</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F58B7B572-86B2-490D-BABC-186145A9B5A8.png?alt=media&amp;token=fe793296-afcc-4b4d-9455-74fcf5213ea7" alt="判斷結果為表達式的回傳"></p>
<p>所以當下次的判斷式不如預期，除了檢查來源值以外，也要同時檢查其中的判斷式（表達式）結構是否符合預期喔。</p>
<h2 id="1-還是-1-，兩個到底有什麼差"><a href="#1-還是-1-，兩個到底有什麼差" class="headerlink" title="++1 還是 1++，兩個到底有什麼差"></a>++1 還是 1++，兩個到底有什麼差</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(++num);</span><br><span class="line"><span class="built_in">console</span>.log(num++);</span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>
<p>請檢視以上程式碼，請問過程中的 num 的值分別為？</p>
<ul>
<li>1, 2, 3</li>
<li>2, 2, 3</li>
<li>2, 2, 2<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br>.<br><code>++</code> 是屬於一元運算子，所以前後只需要一個運算元即可運行，兩者的結果都會使變數值增加，但其中的過程卻大不同。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">運算元 運算子 num++</span><br><span class="line">運算子 運算元 ++1</span><br></pre></td></tr></table></figure>
<h4 id="觀念"><a href="#觀念" class="headerlink" title="觀念"></a>觀念</h4><p>變數也是屬於表達式，因此會<strong>先回傳變數值</strong>後再進行運算。所以過程會先回傳原始值，最終再將 <code>num</code> 值增加 1。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">num++</span><br></pre></td></tr></table></figure></p>
<p>運算子屬於表達式，因此 <code>++1</code> 會直接進行運算後回傳，因此會直接得到 2 的結果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">++num</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">所以執行上還是回到了表達式的概念，如果熟悉回傳的時機點將會更容易看出以下題目的結果，請問 a 值為？</span><br><span class="line"></span><br><span class="line">- 1</span><br><span class="line">- 2</span><br><span class="line">&#96;&#96;&#96;js</span><br><span class="line">var b &#x3D; 1;</span><br><span class="line">var a &#x3D; b++;</span><br><span class="line">console.log(a);</span><br></pre></td></tr></table></figure></p>
<p>回到初始的題目我們可以給予以下結論：</p>
<ul>
<li>無論是哪一種結果是不變的</li>
<li>但過程會有很大的差異，如果過程中需要賦予值到其它變數，則會影響其它變數所接收的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(++num); <span class="comment">// 回傳先 ++ 後的結果</span></span><br><span class="line"><span class="built_in">console</span>.log(num++); <span class="comment">// 先回傳 num，再進行 ++</span></span><br><span class="line"><span class="built_in">console</span>.log(num);</span><br></pre></td></tr></table></figure>
<h2 id="結論"><a href="#結論" class="headerlink" title="結論"></a>結論</h2><p>JS 的知識分為應用及基礎兩大區塊，好的應用知識能夠增加開發效率，基礎知識則是能夠增加除錯的能量，兩者在實戰中缺一不可。再快的速度遇到錯誤無法排除，也是會耗去大量時間找問題；只有基礎知識缺乏應用技巧，技能也淪為紙上功夫。最好還是相輔相成，以對等的知識量進行成長，能夠獲得最有效的開發能力。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 利用表達式優化你的程式碼]]></title>
      <url>https://wcc723.github.io/development/2020/09/18/js-expression-2/</url>
      <content type="html"><![CDATA[<p>上一節介紹了表達式的基本概念「回傳結果」，那麼接下來你一定會想了解有哪些地方可以用到表達式，本篇就列出 JS 語法與常見框架的表達式運用，熟悉以後將會大幅增加 JS 語法的變化性。</p>
<h2 id="運算子"><a href="#運算子" class="headerlink" title="運算子"></a>運算子</h2><p>運算子依據運算元數量，可分為一元、二元甚至是三元運算子，而運算元本身也是屬於表達式，以我們常見的 <code>===</code> 來說就屬於二元運算子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">運算元1 運算子 運算元2</span><br></pre></td></tr></table></figure>
<p>此範例中的前後 <code>1</code> 皆是運算元，運算元本身也是屬於表達式，並且此運算子最終會回傳一個 <code>true</code> 的結果，請記住這個概念，我們延伸介紹幾個不同的運算子運用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="邏輯運算子-、-amp-amp"><a href="#邏輯運算子-、-amp-amp" class="headerlink" title="邏輯運算子 ||、&amp;&amp;"></a>邏輯運算子 <code>||</code>、<code>&amp;&amp;</code></h3><p>邏輯運算子包含 <code>&amp;&amp;</code>、<code>||</code>、<code>!</code>，在語法的概念上稱為 and、or、not，常見情境是用來作為判斷語句使用（condition），不過在文件中的描述卻不僅於此，以 <code>&amp;&amp;</code> 來說，文件上的敘述為：</p>
<blockquote>
<p><strong>假如 運算式1 可以被轉換成 false的話，回傳 運算式1；否則，回傳 運算式2</strong>。 因此，&amp;&amp;只有在 兩個運算元都是True 時才會回傳 True，否則回傳 false。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expr1 &amp;&amp; expr2</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_14_%E4%B8%8A%E5%8D%8810_51.png?alt=media&amp;token=32908e54-5b97-44aa-960a-4830246af1e4" alt=""></p>
<p>常見的情況下，我們預期兩者都為 “真” 時，取得 “true” 的結果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>); <span class="comment">// 只要其一為假值，就會回傳假值</span></span><br></pre></td></tr></table></figure>
<p>不過運算元也是表達式，因此我們可以替換成任何表達式也可運行，以此範例來說我們取得的值並非為 <code>true</code>，而是後者 <code>&#39;杰倫&#39;</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;小明&#x27;</span> &amp;&amp; <span class="string">&#x27;杰倫&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<h4 id="然後勒？哪邊可以用到這個概念"><a href="#然後勒？哪邊可以用到這個概念" class="headerlink" title="然後勒？哪邊可以用到這個概念"></a>然後勒？哪邊可以用到這個概念</h4><p>與 <code>&amp;&amp;</code> 相對應的是 <code>||</code>，在文件上的說明為：</p>
<blockquote>
<p><strong>假如 運算式1 可以被轉換成 true 的話，回傳 運算式1； 否則，回傳 運算式2</strong>。 因此，||在 兩個運算元有任一個是True 時就會回傳 True，否則回傳 false。</p>
</blockquote>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_14_%E4%B8%8A%E5%8D%8810_59.png?alt=media&amp;token=fb6a35b7-defd-4249-930c-4898e659a895" alt=""></p>
<p>假定情境，我跟老媽去餐廳用餐，我和老媽都搶著付錢，但其中一人其實沒有錢，在此就可使用 <code>||</code> 來判斷有錢者的值為何。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myPay = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> momPay = <span class="number">1000</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myPay || momPay); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure></p>
<p>實戰中更常見 “傳入值不確定是否為真值” ，有可能為 <code>undefined</code>、<code>null</code>、<code>0</code>…，不過在執行上為了避免出錯，我們強制需付予一個值時，可使用以下方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> unconfirmed = <span class="literal">undefined</span>; <span class="comment">// 變數 a 無法確認來源值</span></span><br><span class="line"><span class="keyword">var</span> defaultValue = unconfirmed || <span class="number">1000</span>;</span><br><span class="line"><span class="comment">// 來源值為假值則賦予 1000，如果是真值則套用來源值</span></span><br><span class="line"><span class="built_in">console</span>.log(defaultValue); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure>
<h2 id="三元運算子-條件運算子"><a href="#三元運算子-條件運算子" class="headerlink" title="三元運算子 / 條件運算子"></a>三元運算子 / 條件運算子</h2><p>三元運算子的介紹：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Conditional_Operator">https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/Conditional_Operator</a></p>
<p>「三元運算子 / 條件運算子」是唯一用到三個運算元的運算子，它的結構如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition ? exprIfTrue : exprIfFalse</span><br></pre></td></tr></table></figure></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_14_%E4%B8%8A%E5%8D%8811_10.png?alt=media&amp;token=1d42fac0-8b82-4b83-94a8-a88b32cd344c" alt=""></p>
<p>範例如下，當年齡大於 18 則會取得 ‘成年’ 的結果，如果否定則回傳 ‘未成年’。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myAge = <span class="number">22</span>;</span><br><span class="line"><span class="built_in">console</span>.log(myAge &gt;= <span class="number">18</span> ? <span class="string">&#x27;成年&#x27;</span> : <span class="string">&#x27;未成年&#x27;</span>);</span><br></pre></td></tr></table></figure></p>
<p>而運算元本身就是屬於表達式，我們可以在這判斷式、前後運算元替換任何的表達式來運行它，也因為如此三元運算子還經常作為 <code>if () &#123; ... &#125;</code> 的縮寫。</p>
<p><code>if () &#123; ... &#125;</code> 是很易讀的判斷式，但如果僅做簡單判斷時，則會顯得過於攏長。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 宣告函式1, 2</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;函式1&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;函式2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> variable = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 當變數為真值時，執行 fn1，如果為假值則執行 fn2</span></span><br><span class="line"><span class="keyword">if</span> (variable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn1()); <span class="comment">// 不執行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(fn2()); <span class="comment">// &#x27;函式2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果改為三元運算子則可改寫成如下，當變數為真時執行並回傳 <code>fn1()</code>，如果為假時執行並回傳 <code>fn2()</code> ：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(variable ? fn1() : fn2());</span><br></pre></td></tr></table></figure></p>
<p>透過此方式可以將多行的 <code>if () &#123; ... &#125;</code> 判斷式縮減成一行，除了行數減少外，還可以同時回傳值（運算子最終也會回傳值），因此許多進階的開發者都會使用三元運算子取代單純的 <code>if () &#123; ... &#125;</code> 判斷式。</p>
<h2 id="框架運用"><a href="#框架運用" class="headerlink" title="框架運用"></a>框架運用</h2><p>目前的主流框架都是屬於畫面與 JS 邏輯分離（關注點分離），而在邏輯資料傳回畫面時的片段程式碼，大多都可利用表達式的方式撰寫，以 Vue 來說就明確說明可多利用表達式的特性，<a href="https://vuejs.org/v2/guide/syntax.html#Using-JavaScript-Expressions">參考文件</a>。</p>
<p>可利用的表達式範例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; number + 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; ok ? &#x27;YES&#x27; : &#x27;NO&#x27; &#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123; message.split(&#x27;&#x27;).reverse().join(&#x27;&#x27;) &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;&#x27;list-&#x27; + id&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>但如果使用的是陳述式則會無情地對你噴出錯誤：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is a statement, not an expression: --&gt;</span></span><br><span class="line">&#123;&#123; var a = 1 &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- flow control won&#x27;t work either, use ternary expressions --&gt;</span></span><br><span class="line">&#123;&#123; if (ok) &#123; return message &#125; &#125;&#125;</span><br></pre></td></tr></table></figure></p>
<p>可開啟以下連結，並使用 Chrome Console 除錯：<a href="https://codepen.io/Wcc723/pen/RwarveQ">https://codepen.io/Wcc723/pen/RwarveQ</a></p>
<p>程式碼如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; num === 1&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  &#123;&#123; num === 1 ? &#x27;數字 1&#x27;: &#x27;不是數字 1&#x27;&#125;&#125; <span class="tag">&lt;<span class="name">br</span>&gt;</span> </span><br><span class="line">            </span><br><span class="line">  <span class="comment">&lt;!-- `=` 也屬於運算子，這樣寫也是通的 --&gt;</span></span><br><span class="line">  &#123;&#123; num2 = 1 &#125;&#125;          </span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 但下面這行是陳述式，所以會噴錯 --&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &#123;&#123; var num2 = 1 &#125;&#125; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>本篇介紹表達式的常用情境，以及程式碼可以怎麼拆以及如何運用，下一篇則會繼續介紹表達式中常會引發的額外錯誤。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 表達式觀念及運用 - JS Expression]]></title>
      <url>https://wcc723.github.io/development/2020/09/17/js-expression/</url>
      <content type="html"><![CDATA[<p>JavaScript 分為兩大的語句類型，就像是我們日常語言中的動詞、名詞、連接詞等概念，但在 JS 中僅分為兩大類型，分別為「陳述式」及「表達式」，其中表達式更為重要，如果能夠熟練表達式更能解決許多開發上的問題，也更能活用各種語法。</p>
<blockquote>
<p>JavaScript 中的表達式原文為 「Expression」，翻譯上常見的有表達式、表示式、運算式等等。</p>
</blockquote>
<h2 id="表達式與陳述式的差異"><a href="#表達式與陳述式的差異" class="headerlink" title="表達式與陳述式的差異"></a>表達式與陳述式的差異</h2><p>表達式及陳述式在各文件上都有概略提到，但通常不會讓人覺得是重要的篇章，所以快速略過。不過在 JavaScript 的運用中，如果熟練「表達式」的觀念，將能增加許多運用的技巧且能避免許多不必要的錯誤。</p>
<ul>
<li>陳述式：會執行一些程式碼，可能是幾個單詞或是一個片段（但不會是單一個字母），但最大的特徵是<strong>不會回傳結果</strong>。</li>
<li>表達式：最大的特徵在於<strong>會回傳結果</strong>。</li>
</ul>
<h3 id="陳述式-Statement"><a href="#陳述式-Statement" class="headerlink" title="陳述式 Statement"></a>陳述式 Statement</h3><p>陳述式有幾大分類，如：</p>
<ul>
<li>宣告（var、function）</li>
<li>流程控制（block、if…else）</li>
<li>迴圈（for、for…in）</li>
<li>其它（import, export）</li>
</ul>
<p>完整分類可參考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements">MDN</a></p>
<p>陳述式可能是幾個單詞或是一個片段（但不會是單一個字母），其中也會混合到表達式的詞彙，所以當我們撰寫一段程式碼如下即可稱為陳述式（注意：是 <code>var a</code> ，而不是 <code>var</code> 也不是 <code>a</code>），用此語法即可宣告一個變數。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br></pre></td></tr></table></figure>
<p>相同的道理，如果我們僅有使用 <code>&#123;&#125;</code> 這個意思是「物件」，這不會是一個陳述式，必須在其中加入一些片段程式碼才會是陳述式，結構如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>陳述式先了解至此即可，我們先來看表達式。</p>
<h3 id="表達式-Expression"><a href="#表達式-Expression" class="headerlink" title="表達式 Expression"></a>表達式 Expression</h3><p>表達式的特點就是會回傳一個結果，所以任何可<strong>回傳結果</strong>都可稱為表達式（這句話看起來就是一段廢話，但實際運作時卻常常讓人有錯誤的判斷）。常見如下：</p>
<ul>
<li>純值</li>
<li>變數</li>
<li>運算子</li>
<li>執行函式</li>
<li>正規表達式</li>
<li>函式表達式</li>
<li>…</li>
</ul>
<p>表達式的重點在於「回傳結果」，因此是否能夠<strong>回傳結果</strong>就能判斷該語句或詞是否為表達式，我們用數字 1 來解釋什麼是回傳結果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure>
<p>直接打開你的 Chrome 的開發者工具，將上面的數字 1 貼到開發者工具內後按下 Enter，你會看到兩個數字 1 分別如下顯示：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_13_%E4%B8%8A%E5%8D%8811_19.png?alt=media&amp;token=5719c68e-6b42-4521-95d1-4daeb7687958" alt=""></p>
<p>因此在這之中數字 <code>1</code> 就是表達式（是的，單一個純值就是表達式），接下來加入一些運算子增加這段程式的複雜度，使用兩個數字 1 來進行比對。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>接下來會得到 <code>true</code> 的結果，所以 <code>1 === 1</code> 是屬於表達式。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_13_%E4%B8%8A%E5%8D%8811_22.png?alt=media&amp;token=b5bd0ec0-44a8-44ce-abed-2e198a290dc6" alt=""></p>
<p>相同的概念，如果定義了一個函式並運行它，那麼運行所回傳的結果也會稱為表達式。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函式陳述式宣告一個函式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呼叫函式</span></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_13_%E4%B8%8A%E5%8D%8811_29.png?alt=media&amp;token=09aedf99-68ee-4bed-a100-6e6e4f373c1d" alt=""></p>
<h3 id="容易搞混的地方"><a href="#容易搞混的地方" class="headerlink" title="容易搞混的地方"></a>容易搞混的地方</h3><p>“式” 這個字在中文通常表示為一段文字，所以我們常會誤解表達式、陳述式代表的是一個完整片段；而實際運作上陳述式大多是一個片段或詞彙沒錯，但表達式可以獨立出現，也可與陳述式混合使用。</p>
<p>以下片段程式碼整體來說是屬於陳述式（運作上不會回傳結果），但其中會夾雜許多表達式的語句。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (a) &#123;</span><br><span class="line">  fn(); <span class="comment">// 函式呼叫後會回傳結果，因此也屬於表達式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>圖解案例：<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_13_%E4%B8%8A%E5%8D%8811_34.png?alt=media&amp;token=5991b388-86cf-4eff-966d-f5db6940a474" alt=""></p>
<p>當然，還有多個表達式混合的概念，如運算子本身就是由多個表達式組成，常見的「二元運算子」，就是由一個<strong>運算子</strong>加上前後的<strong>運算元</strong>所組成，而運算元也是屬於表達式的一種。關於運算子<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators">可參考</a>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">運算元1 運算子 運算元2</span><br></pre></td></tr></table></figure>
<p>範例如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_8_13_%E4%B8%8A%E5%8D%8811_41.png?alt=media&amp;token=31b4c2c4-6297-4156-867d-dc99889c62ee" alt=""></p>
<p>所以在此範例中，也可以將<strong>運算元</strong>替換成 “呼叫函式” 或 “任何的表達式”。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line">fn() === fn();</span><br></pre></td></tr></table></figure></p>
<h2 id="哪邊可以看到表達式"><a href="#哪邊可以看到表達式" class="headerlink" title="哪邊可以看到表達式"></a>哪邊可以看到表達式</h2><p>相對於死板板的陳述式來說，表達式相當靈活且無所不在，當我們在查找文件中都可看到相對應的蹤影，在此先記得 “expression” 這個單字。</p>
<p>記得：你可以將文件中的 expression 語句替換成任何喜歡的表達式來執行，但絕不能替換成陳述式（statement）。</p>
<h4 id="案例：if-陳述式"><a href="#案例：if-陳述式" class="headerlink" title="案例：if 陳述式"></a>案例：if 陳述式</h4><p>文件：<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else</a></p>
<p>文件中說明 if 陳述式中的結構如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (condition)</span><br><span class="line">   statement1</span><br><span class="line">[else</span><br><span class="line">   statement2]</span><br></pre></td></tr></table></figure></p>
<p>其中包含了 condition(條件式) 及 statement(陳述式) 這兩個語句，再往下可以看到針對這兩個語句的說明。</p>
<blockquote>
<p>condition: An <strong>expression</strong> that is considered to be either truthy or falsy.<br>判斷式：一個<strong>表達式</strong>，它的值會被判定為真值或假值。</p>
</blockquote>
<p>因此 if 後方的條件式可以使用任何的表達式進行替代，因此可以如下的方式替換（替換成呼叫函式、各種運算子都是沒有問題的）。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span> + <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;1 + 1 為真值&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要把握此原則就可以進行任何的替換，但絕對不能替換成陳述式，陳述式則會出現語法上的錯誤。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">var</span> a = <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2FD95BCC87-4451-46DB-B935-19E907924BA4.png?alt=media&amp;token=e448f56d-adbb-4234-9913-e7d223eb8c5e" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>表達式在 JavaScript 是看似簡單的觀念，但了解以後可以更靈活運用許多語法，除此之外有許多的設計模式及觀念，也都是必須靈活運用表達式才可達成。</p>
<p>本篇附上幾個題目，大家可試著猜看看該片段程式碼屬於 “陳述式” 或 “表達式” 喔</p>
<p>題目 1：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object;</span><br></pre></td></tr></table></figure></p>
<p>題目 2：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Object</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript 開發中常見錯誤解決辦法]]></title>
      <url>https://wcc723.github.io/development/2020/09/16/chrome-js-alert/</url>
      <content type="html"><![CDATA[<p>身為一個開發者，當然都會了解經驗越多，除錯上會更為容易，這種事情你我都清楚。但對於一個新手來就是缺少錯誤上的經驗，所以當遇到紅字時會不知如何著手。</p>
<p>這一系列的文章是專門給剛入門新手的前端開發者觀看的，盡可能用白話的方式，並且提供簡單的範例程式碼以供驗證。</p>
<h2 id="Chrome-開發者工具的常見錯誤排解"><a href="#Chrome-開發者工具的常見錯誤排解" class="headerlink" title="Chrome 開發者工具的常見錯誤排解"></a>Chrome 開發者工具的常見錯誤排解</h2><p>Chrome 開發者工具的 Console 相當好用，最常使用的不外乎是透過<code>console.log</code> 呈現出變數或運算的結果，如果符合預期則皆大歡喜。</p>
<p>但最討厭的則是出現紅色文字，看似<strong>帶有威脅的語氣說「你出錯了！」</strong>，對於新手來說不僅是一種挫折，紅字上的錯誤也不知如何著手排除的情況下，也只能反覆地檢視自己原始碼，看看是不是有奇怪的地方，但就算停在了錯誤地方也往往不知是什麼意思，也會因此花上許多時間在除錯上。</p>
<p>本篇就來介紹 Chrome 開發者工具的常見錯誤回饋及排除技巧，讓你下次不再需要為了滿滿的紅字感到挫折，更能從中學習如何快速搜尋錯誤程式碼。</p>
<blockquote>
<p>注意：JavaScript 是屬於同步的程式語言，如果出現錯誤就會造成下方的程式碼導致無法運行，當<strong>紅字沒有解決，都可能造成接下來的程式碼運行錯誤或是無法繼續運行</strong>。</p>
</blockquote>
<h2 id="錯誤類型：SyntaxError"><a href="#錯誤類型：SyntaxError" class="headerlink" title="錯誤類型：SyntaxError"></a>錯誤類型：SyntaxError</h2><p><code>SyntaxError</code> 這類型錯誤通常是<strong>語法結構</strong>錯誤，遇到這類型錯誤建議透過 “文字編輯器”除錯，以 VSCode 來說會直接跳出這類型的錯誤提示。</p>
<p>如下圖，VSCode 以紅字提示 family 物件有錯誤，當出現錯誤時會建議不要只檢查當行，錯誤可能會存在於前後文之中（有可能跨多行的錯誤），此範例中仔細檢查可以發現 ‘小明’ 後方缺少了一個逗點。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2FC710C627-CEF7-4DDC-84FE-EA9125EC9A9F.png?alt=media&amp;token=d3066ce1-5977-4ae1-b0b0-eebf18989805" alt=""></p>
<blockquote>
<p>除錯重點：使用主流的文字編輯器，如 “VSCode” 進行除錯</p>
</blockquote>
<h3 id="Uncaught-SyntaxError-Unexpected-identifier"><a href="#Uncaught-SyntaxError-Unexpected-identifier" class="headerlink" title="Uncaught SyntaxError: Unexpected identifier"></a>Uncaught SyntaxError: Unexpected identifier</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">  family: &#123;</span><br><span class="line">    name: <span class="string">&#x27;小明家&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_34.png?alt=media&amp;token=a0ed1451-80c8-47d8-befe-dedc6a594636" alt="Uncaught SyntaxError: Unexpected identifier"></p>
<p>語法解析錯誤，因為在物件結構中缺少一個逗點，除了透過 VSCode 查看外，也可以直接透過 Chrome Console 連結至 Source 頁面查看錯誤行數，並請檢查此行的前後文是否有語法結構上的錯誤。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F912950B6-4757-4F09-BDD8-21E9DDBD3D6E.png?alt=media&amp;token=7ab22f94-fd04-4589-b42c-0fb17d922a4b" alt="點擊連結就可到該錯誤位置"></p>
<h3 id="Uncaught-SyntaxError-Unexpected-end-of-input"><a href="#Uncaught-SyntaxError-Unexpected-end-of-input" class="headerlink" title="Uncaught SyntaxError: Unexpected end of input"></a>Uncaught SyntaxError: Unexpected end of input</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(fn);</span><br></pre></td></tr></table></figure>
<p>語法解析錯誤：未預期的結束，此範例中缺少結尾的 <code>&#125;</code>，會建議在撰寫程式碼時盡可能維持正確的縮排，將程式排整齊後比較容易正確找到錯誤。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_36.png?alt=media&amp;token=9a690dbd-af76-4dd8-b5e3-277b40111727" alt="Uncaught SyntaxError: Unexpected identifier"></p>
<h3 id="Uncaught-SyntaxError-Unexpected-token-‘-’"><a href="#Uncaught-SyntaxError-Unexpected-token-‘-’" class="headerlink" title="Uncaught SyntaxError: Unexpected token ‘}’"></a>Uncaught SyntaxError: Unexpected token ‘}’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (name)</span><br><span class="line">  console.log(&#39;立即函式&#39;)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_38.png?alt=media&amp;token=1a4a6b05-fcae-4e40-897a-59dd55cf9ae2" alt="Uncaught SyntaxError: Unexpected token &#39;}&#39;"></p>
<p>語法解析錯誤：未預期的符號 <code>&#125;</code>，程式碼多了 <code>&#125;</code> 結尾符號導致環境運行錯誤，此錯誤排除與上述相同，盡可能將程式碼排整齊且維持首尾符號的一致。</p>
<p>除此之外再推薦一個 VSCode 工具，為你的首尾標籤加上對應的色彩：<a href="https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer">https://marketplace.visualstudio.com/items?itemName=CoenraadS.bracket-pair-colorizer</a></p>
<p>範例：程式碼中的 <code>&#123;&#125;</code> 都會以一對的色彩呈現。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F4EDE3D9B-8111-4BB2-9794-63A72D6352B1.png?alt=media&amp;token=b7af7db6-5bf6-4d18-b90a-bb266db94d48" alt=""></p>
<h3 id="Uncaught-SyntaxError-Identifier-‘a’-has-already-been-declared"><a href="#Uncaught-SyntaxError-Identifier-‘a’-has-already-been-declared" class="headerlink" title="Uncaught SyntaxError: Identifier ‘a’ has already been declared"></a>Uncaught SyntaxError: Identifier ‘a’ has already been declared</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="keyword">let</span> a;</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_39.png?alt=media&amp;token=a53cf16e-a7b9-4a18-bd64-15dd09b6e73f" alt="Uncaught SyntaxError: Identifier &#39;a&#39; has already been declared"></p>
<p>語法解析錯誤：識別符號（在此指的是變數）已經被宣告，請避免重複宣告同一個變數，ES6 中都禁止 let、const 重複宣告，直接排除即可。</p>
<h2 id="錯誤類型：ReferenceError"><a href="#錯誤類型：ReferenceError" class="headerlink" title="錯誤類型：ReferenceError"></a>錯誤類型：ReferenceError</h2><p><code>ReferenceError</code> 此類型錯誤通常是指「參考」找不到，當出現這類型錯誤時文字編輯器 “不一定” 出現錯誤（有裝 Linter 才會提示），所以時常會在執行階段才會看到這類型錯誤。</p>
<blockquote>
<p>除錯重點：</p>
<ul>
<li>透過 Chrome 的提示修正</li>
<li>在 JavaScript 撰寫環境中<a href="https://wcc723.github.io/javascript/2018/01/01/javascript-eslint/">安裝 ESLint</a></li>
</ul>
</blockquote>
<h3 id="ReferenceError-a-is-not-defined"><a href="#ReferenceError-a-is-not-defined" class="headerlink" title="ReferenceError: a is not defined"></a>ReferenceError: a is not defined</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_40.png?alt=media&amp;token=9ca239f8-7700-438b-9697-87fbd26fbbf1" alt="ReferenceError: a is not defined"></p>
<p>語法參考錯誤：由於 a 變數未定義，所以在取用該變數時會出現未定義的提示，只要預先定義此變數即可。</p>
<p>不過還有另一種很常見的情況，當引用外部套件時出現「套件名稱 + <code>is not defined</code>」，這類型情況通常是外部資源沒有正確載入，請確保該資源有加入到此網站中。</p>
<p>以下範例來說，就是屬於 jQuery 沒有正確導入。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uncaught ReferenceError: $ is not defined</span><br></pre></td></tr></table></figure></p>
<h2 id="錯誤類型：TypeError"><a href="#錯誤類型：TypeError" class="headerlink" title="錯誤類型：TypeError"></a>錯誤類型：TypeError</h2><p><code>TypeError</code> 則是型別上的錯誤，文字編輯器一樣不會預先提示有錯，必須在執行環境時才會看到，這類型的錯誤通常是以下幾種：</p>
<ul>
<li>在 undefined、null 嘗試取得其屬性（ex: undefined 中取得屬性值）</li>
<li>嘗試呼叫非函式變數或表達式（ex: <code>&#39;text&#39;()</code>）</li>
</ul>
<blockquote>
<p>除錯重點：在取得變數前方確認該變數當前的資料型別及結構</p>
</blockquote>
<h3 id="Uncaught-TypeError-Cannot-read-property-‘a’-of-undefined"><a href="#Uncaught-TypeError-Cannot-read-property-‘a’-of-undefined" class="headerlink" title="Uncaught TypeError: Cannot read property ‘a’ of undefined"></a>Uncaught TypeError: Cannot read property ‘a’ of undefined</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="built_in">console</span>.log(a.a);</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_42.png?alt=media&amp;token=e4b19f41-82b5-4840-bdd1-040f357feb5c" alt="Uncaught TypeError: Cannot read property &#39;a&#39; of undefined"></p>
<p>說明：該變數的值下無法找到特定的屬性，undefined、null 的值內無法在查找到其它的屬性，如果無法確認該變數是否為 <code>undefined</code>，可改寫其程式碼如下： </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a.a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Uncaught-TypeError-console-log-…-is-not-a-function"><a href="#Uncaught-TypeError-console-log-…-is-not-a-function" class="headerlink" title="Uncaught TypeError: console.log(…) is not a function"></a>Uncaught TypeError: console.log(…) is not a function</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;立即函式&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_43.png?alt=media&amp;token=86695046-7354-4c6c-bc54-d86397573b91" alt="Uncaught TypeError: console.log(...) is not a function"></p>
<p>說明：這段程式碼中看起來會是立即函式的錯誤，但卻出現了 <code>console.log(...) is not a function</code>。此錯誤主要是因為缺少了分號，因此將兩段程式碼合併為一行執行，運行的結果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;a&#39;)(function() &#123; ... &#125;)()</span><br></pre></td></tr></table></figure>
<p>當遇到此類型錯誤只要在兩者之間補上分號即可正常運作。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;立即函式&#x27;</span>)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>
<h2 id="錯誤類型-RangeError"><a href="#錯誤類型-RangeError" class="headerlink" title="錯誤類型 RangeError"></a>錯誤類型 RangeError</h2><p>這是建立了超過長度的陣列或過度的執行函式（產生過多執行堆疊）所造成的錯誤，這類型則需要重新檢視程式碼的邏輯，是否會造成過度的硬體資源消耗（記憶體或運算資源）。</p>
<blockquote>
<p>除錯重點：需重新檢視邏輯，如果必要可先刪除部分程式碼，先找出錯誤的片段後再進行除錯。</p>
</blockquote>
<h3 id="Uncaught-RangeError-Maximum-call-stack-size-exceeded"><a href="#Uncaught-RangeError-Maximum-call-stack-size-exceeded" class="headerlink" title="Uncaught RangeError: Maximum call stack size exceeded"></a>Uncaught RangeError: Maximum call stack size exceeded</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  a();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_9_16_%E4%B8%8A%E5%8D%8810_46.png?alt=media&amp;token=e5ea5575-bbf9-40ba-85af-3edf6eb933e2" alt=""></p>
<p>說明：函式呼叫時會產生一個執行堆疊，如果堆疊的過程中超過最大數量則會產生錯誤（函式內呼叫自己）。</p>
<p>此類錯誤也很常見，但卻不容易找到為何出錯，主要原因是執行堆疊超過環境的限制（運用框架中也很常見），如果遇到此錯誤建議改寫目前呼叫函式的方式。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>當 Chrome Console 出現錯誤時請維持正確的心態，新手常常會看到錯誤而緊張不知所措（畢竟從小紅被用紅字提醒就會感到緊張，深怕這個錯誤自己無法解決而影響到其他人）。</p>
<p>錯誤在撰寫程式碼中常見的過程，資深開發者與新手的差異是<strong>面對錯誤的經驗</strong>，同一個錯誤前幾次不清楚沒關係，都是經驗的累積，只要往後再次遇到相同的錯誤自然而然就能輕鬆面對。</p>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[完全解析 JavaScript import、export]]></title>
      <url>https://wcc723.github.io/development/2020/03/25/import-export/</url>
      <content type="html"><![CDATA[<p><code>import</code>、<code>export</code> 是 JavaScript 模組管理的方法，可以將每個檔案視為一個獨立的模組匯出，並在另一個檔案匯入使用。透過此方式每個檔案更能專注在特定的功能上，且能避免單一檔案過度龐大。</p>
<h3 id="相容性"><a href="#相容性" class="headerlink" title="相容性"></a>相容性</h3><p>介紹此方法前，還是要了解一下相容性，目前來說許多主流瀏覽器都是可以運行的，但是寫法需要稍做調整，而 Node.js 則是要到 13.2 才可直接運行模組化。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F5B469D68-AD4B-49D2-866B-C1E911087024.png?alt=media&amp;token=1d606513-ef7a-4cc3-b4b2-9da142f9027b" alt=""></p>
<h3 id="瀏覽器中運行"><a href="#瀏覽器中運行" class="headerlink" title="瀏覽器中運行"></a>瀏覽器中運行</h3><p>如果要在瀏覽器運行模組化，可以在 <code>&lt;script&gt;</code> 標籤加上 <code>type=&quot;module&quot;</code>，接下來無論是使用行內或是外部的 JS 都能運用模組功能。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>當然，這樣的模組功能並非所有瀏覽器都能夠運行，如果要同時兼顧新舊瀏覽器，可以改用以下做法：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 支援 module 語法的新瀏覽器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;module.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 不支援 module 語法此段會被新型瀏覽器忽略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;IENotGood.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Export-匯出"><a href="#Export-匯出" class="headerlink" title="Export 匯出"></a>Export 匯出</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2Fimg-export.png?alt=media&amp;token=4bd42d22-43d4-44aa-8801-a4149853a495" alt=""></p>
<p><code>export</code> 可以將函式、物件甚至是純值匯出，大部分運用上都是匯出物件（函式）為主，畢竟純值作為模組意義並不大。</p>
<p>export 又可區分為兩種，這兩種的匯出手法略有不同，也會影響到 import 的運用，所以在運用前請先明確區分這兩種的差異（非常重要）：</p>
<ul>
<li>named export（具名匯出）：可匯獨立的物件、變數、函式等等，<strong>匯出前必須給予特定名稱</strong>，而匯入時也必須使用相同的名稱。另外，一個檔案中可以有<strong>多個</strong> <code>named export</code>。</li>
<li>default export（預設匯出）：一個檔案僅能有<strong>唯一</strong>的 <code>default export</code>，而此類型不需要給予名稱。</li>
</ul>
<p>除此之外，兩者也可共存於同一個檔案內，只不過 <code>default export</code> 僅能有一個。</p>
<h4 id="default-export（預設匯出）"><a href="#default-export（預設匯出）" class="headerlink" title="default export（預設匯出）"></a>default export（預設匯出）</h4><p><code>default export</code> 匯出時不需要預先賦予名稱，可以在 <code>import</code> 時另外賦予，但要特別注意 <code>export default</code> 每個檔案僅能有一個。</p>
<p>直接匯出純值或表達式結果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p>
<p>預先定義一個變數並匯出，這種方式結果與上述的純值一樣。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a;</span><br></pre></td></tr></table></figure></p>
<p>export default 匯出物件是最常見的使用方式，此方法通常也會搭配物件的縮寫形式（Object shorthand）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123; obj, obj2 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>上段介紹的具名匯出所匯出的函式必須使用<strong>函數陳述式</strong>，而 <code>export default</code> 則可以直接使用匿名函式的形式匯出，就不需要預先定義。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匯出匿名函式</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匯出 class</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  callName() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="named-export（具名匯出）"><a href="#named-export（具名匯出）" class="headerlink" title="named export（具名匯出）"></a>named export（具名匯出）</h4><p><code>named export</code> 是將物件、函式等等預先賦予在特定的名稱上才能匯出，並且在 <code>import</code> 時也必須使用<strong>相同的名稱</strong>才能取到相同的變數或物件。</p>
<p>方法 1：具名匯出是需要將變數、物件預先宣告後再進行匯出，因此可以在 <code>export</code> 後緊接 <code>let</code>、<code>const</code> 宣告後再進行匯出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// let, const 純值</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>方法 2（使用率高）：使用函式陳述式匯出，這種方式與上述概念是相近的，一樣是先宣告再匯出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具名方法</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方法 3（使用率高）：使用物件縮寫的形式（Object shorthand）匯出物件，算是較為普遍運用的方式，可預先定義好所有的物件、方法後，在文件的結尾統一匯出。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> obj3 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj3&#x27;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; b, obj2, obj3 &#125;;</span><br></pre></td></tr></table></figure></p>
<p>小技巧：再匯出前可另外使用 <code>as</code> 修改名稱。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj2 = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj2&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> &#123; obj2 <span class="keyword">as</span> objNewName &#125;;</span><br></pre></td></tr></table></figure></p>
<h4 id="並存"><a href="#並存" class="headerlink" title="並存"></a>並存</h4><p>具名、預設匯出兩種方法可以並存在同一個檔案內，預設匯出僅能有一個。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Import-匯入"><a href="#Import-匯入" class="headerlink" title="Import 匯入"></a>Import 匯入</h2><p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2Fimg-import.png?alt=media&amp;token=19b37a20-45d3-4100-8b17-a9b8cd219b8d" alt=""></p>
<p>匯入的方式會與因為匯出方法不同而改變，因此必須清楚外部資源的匯出方式，如果是第三方資源則可以透過文件了解該如何匯入。</p>
<h4 id="匯入-default-export-並賦予名稱"><a href="#匯入-default-export-並賦予名稱" class="headerlink" title="匯入 default export 並賦予名稱"></a>匯入 default export 並賦予名稱</h4><p>預設匯出每個檔案僅會有一個，並且不會給予名稱，這種匯入方式會將預設匯出的模組引入，並且重新賦予一個變數名稱。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import file</span></span><br><span class="line"><span class="keyword">import</span> fn <span class="keyword">from</span> <span class="string">&#x27;./defaultModule.js&#x27;</span>;</span><br><span class="line">fn(); <span class="comment">// 直接執行函式</span></span><br></pre></td></tr></table></figure></p>
<h4 id="匯入-named-export"><a href="#匯入-named-export" class="headerlink" title="匯入 named export"></a>匯入 named export</h4><p>具名的匯出方式，則需要使用<strong>解構的語法</strong>將特定的模組取出（命名需與匯出的名稱一致），並且只有被匯入的原始碼片段才能夠被執行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>&#125;; <span class="comment">// 此段如果沒有被匯入，則無法運作</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import file</span></span><br><span class="line"><span class="keyword">import</span> &#123; fn &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure></p>
<p>也可以透過解構同時匯入多個物件、變數、函式等等。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import file</span></span><br><span class="line"><span class="keyword">import</span> &#123; fn, obj &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(obj)</span><br></pre></td></tr></table></figure></p>
<h4 id="重新命名"><a href="#重新命名" class="headerlink" title="重新命名"></a>重新命名</h4><p>具名匯出的物件、變數本身就帶有固定的名稱，如果要避免與當前的作用域產生衝突，則可以使用 <code>as</code>(alias) 來重新命名匯入的名稱。</p>
<p>可以在解構時針對單一的物件、變數重新賦予名稱：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import file</span></span><br><span class="line"><span class="keyword">import</span> &#123; fn <span class="keyword">as</span> newFn &#125; <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line">newFn();</span><br></pre></td></tr></table></figure></p>
<p>具名匯入亦可使用 <code>*</code> 來全部匯入，這時候就必須搭配 <code>as</code> 指向一個新的物件變數，此物件的屬性則會帶上所匯入的內容。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import file 全部匯入並賦予至一個物件上</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&#x27;./module.js&#x27;</span>;</span><br><span class="line">name.fn();</span><br><span class="line"><span class="built_in">console</span>.log(name.obj);</span><br></pre></td></tr></table></figure></p>
<h4 id="同時匯入預設、具名"><a href="#同時匯入預設、具名" class="headerlink" title="同時匯入預設、具名"></a>同時匯入預設、具名</h4><p>匯出時可同時存在兩種形式，因此匯入時也同樣支援。以下片段來說，在匯入時前者是帶入 <code>default export</code>，逗點後方則是帶入 <code>named export</code>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> defaultExport, * <span class="keyword">as</span> name <span class="keyword">from</span> <span class="string">&quot;module-name&quot;</span>;</span><br></pre></td></tr></table></figure></p>
<p>以下程式碼分別執行了：</p>
<ol>
<li>匯入 <code>default export</code> 並賦予 <code>fn</code> 的名稱</li>
<li>匯入全部的 <code>named export</code>，並給賦予至 <code>named</code> 的物件上<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export file</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span> &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;這是一段函式&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// import file</span></span><br><span class="line"><span class="keyword">import</span> fn, * <span class="keyword">as</span> named <span class="keyword">from</span> <span class="string">&#x27;./defaultModule.js&#x27;</span>;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(named.obj);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h4 id="匯入-Side-Effect-模組"><a href="#匯入-Side-Effect-模組" class="headerlink" title="匯入 Side Effect 模組"></a>匯入 Side Effect 模組</h4><p>有些模組並沒有實作 <code>export</code>，例如可直接執行的函式檔案，載入後會直接執行，不需要例外的呼叫即可作為  <strong>Side Effect 模組</strong>。</p>
<p>常見案例如早期版本的框架，直接將方法綁定於 window，因此不需要另外呼叫即可運作，如：<code>jQuery</code>、<code>angularJs</code> 就屬於此類型。</p>
<p>範例如下：模組檔案不需要進行匯出，直接 <code>import</code> 後就能運行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module file</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;IIFE&#x27;</span>);</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// import file</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./fn.js&#x27;</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="要用-default-或-named"><a href="#要用-default-或-named" class="headerlink" title="要用 default 或 named"></a>要用 <code>default</code> 或 <code>named</code></h2><p><code>default</code> 是非常易於使用的，針對只有單一元件、模組的檔案匯出上相對直覺很多，我自己開發上也多是利用 <code>default export</code>。</p>
<p>但在針對此議題來說，也有查閱過部分的文件，許多都是提到 export default 有管理上的問題，如：</p>
<ul>
<li>具名匯入時，命名須完全一致才可匯入，增加開發的嚴謹性</li>
<li>預設匯入時，無法確認該模組內是否有特定變數</li>
</ul>
<p>因此在開發大型專案、開源套件、眾多模組時，大多都會推薦使用 <code>named export</code> 的形式，不過這並非強制性的要求，大家也可以是自己開發上的需求做選擇。</p>
<p>相關文件：</p>
<ul>
<li><a href="https://jkchao.github.io/typescript-book-chinese/tips/avoidExportDefault.html#commonjs-%E4%BA%92%E7%94%A8">深入理解 TypeScript - export default 被认为是有害的</a></li>
<li><a href="https://humanwhocodes.com/blog/2019/01/stop-using-default-exports-javascript-module/">Why I’ve stopped exporting defaults from my JavaScript modules</a><ul>
<li><a href="https://juejin.im/post/5c4acd646fb9a049b5072f0e"> (译) 为什么我不再使用 export default 来导出模块</a></li>
</ul>
</li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
            <tag> modules </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[開公司的流程及雷點分享]]></title>
      <url>https://wcc723.github.io/business/2020/03/18/how-to-register-a-company/</url>
      <content type="html"><![CDATA[<p>這次跟大家分享開公司上的一些心得，由於網路上可以找到許多開公司的流程，本篇會著重在心得的分享，當然我也並非專業的會計、法務，正確的流程建議可以詢問合作的會計。</p>
<h2 id="會計"><a href="#會計" class="headerlink" title="會計"></a>會計</h2><p>開公司如果要省時間，找一個好會計是必要的，因為開公司在學校並非必修課程，大部分人都不會有開公司的經驗，雖然說是「開公司」但林林總總的項目非常多，除了公司設立外還有包含發票、營業稅、勞健保這些項目都是需要獨立申請，如果沒有一個人引導將會花去許多時間在搜尋。</p>
<p>還記得一開始的時候，以為公司申請好就會有發票、勞健保這些項目，申請後才知道這些是一一獨立的，如果沒有會計師協助處理，那麼就是負責人要了解這些項目，甚至需要親自排隊申請或者打電話到各個窗口詢問事宜。不熟的情況下整個流程耗去一個月是有可能的，從決定開公司那時候開始，經費就不斷的在燃燒，會<strong>建議申請的過程交給專業的人，負責人應該是將時間花費真正有價值的事情上</strong>！</p>
<p>交給專業的處理，也要了解一下大致上要花多少錢，基本上費用分為兩個部分，可以參考 <a href="https://simpany.co/price">Simpany</a>：</p>
<ul>
<li><strong>一次性費用</strong>：通常是在申請時才產生，如設立公司來說約需要一萬多元就屬於此類型。另外現在公司股東持有股份也需要公開申報，這也會產生一次性費用（會計師也會提供後續的年度維護，所以也有年度維護費用）。</li>
<li><strong>每月記帳費用</strong>：記帳包含從進項、銷項的費用計算，並且會製作 401 表作為稅務申報使用，如果公司進銷項複雜需要花上許多時間，也是建議給予專業的會計師處理，每月收費約 2000 元（依據地區、營業額會略有不同），每年計費則是以 14 個月做計算（年度營所稅的費用）。</li>
</ul>
<p>自己申報營業稅的感覺：<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F1584499881271.png?alt=media&amp;token=b8ac29a5-0b55-4dfb-a7ce-6b987bd4ad24" alt=""></p>
<p>另外每間會計事務所的「嚴謹」程度不同，有些事務所給他們發票後就會處理到好，不會詢問發票內的細項；有些則會一一比對帳務，確認發票是符合公司需求的。而越嚴謹的事務所，公司也需要更加配合，對於想要發展成中、大型企業的公司是比較好的（營業額 3,000 萬以上則會使用查帳，嚴格程度也會不統，有些事務所在營業額不高時就會做到接近查帳的條件）。</p>
<h2 id="公司、行號？"><a href="#公司、行號？" class="headerlink" title="公司、行號？"></a>公司、行號？</h2><p>在開立公司時，也需要決定是要使用公司或行號（公司又區分為有限公司及股份有限公司，在此就不多做說明），公司或行號通常會使用營業額來做區分，<strong>月營業額 20 萬以下可設立免用統一發票的行號</strong>，如果預期會超過此數目並且有開立發票的需求，則會直接建議開立有限公司，政府對於公司也會提供補助及更多法律上的保障（像是我們進駐在數創就必須是使用公司）。</p>
<h2 id="需要準備什麼？"><a href="#需要準備什麼？" class="headerlink" title="需要準備什麼？"></a>需要準備什麼？</h2><p>了解會計師重要性以後，我們就來開始準備開立公司吧，就算有請會計師，許多項目還是需要自行處理，以下列出可以事先準備的項目吧</p>
<h4 id="公司名稱預查"><a href="#公司名稱預查" class="headerlink" title="公司名稱預查"></a>公司名稱預查</h4><p>開立公司前先想好一個名字是必要的，可以透過經濟部的<a href="https://serv.gcis.nat.gov.tw/pub/cmpy/nameSearchListAction.do">預查輔助查詢</a>看看想要的名字是否可以使用，避免自己一廂情願用特定的名稱，屆時卻發現該名稱已經被佔用了。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F1584500109240.png?alt=media&amp;token=aa3709c1-57e2-4eb8-84a3-a151989b6359" alt=""></p>
<p>以下幾點經驗跟大家分享：</p>
<ul>
<li><code>XXXX資訊科技有限公司</code>、<code>XXXX科技有限公司</code>、<code>XXXX有限公司</code>：這些都屬於不同的名稱，可以自行排列組合。</li>
<li>名稱也要刻在印章上，請謹慎選擇</li>
<li>名字太長以後要寫很久（我就取太長了）</li>
<li>主要名稱目前還是以中文為主，據說近幾年要調整成可接受英文申請，但沒有持續關注此議題。</li>
</ul>
<h4 id="大小章"><a href="#大小章" class="headerlink" title="大小章"></a>大小章</h4><p>印章又稱為大小章，大章也就是公司章，小章則是負責人印章，雖然小章代表負責人，但基本上會與個人私章做區分，部會將公司的小章與個人私章混合使用，畢竟大小章在一起時就可<strong>代表公司執行許多業務</strong>，如銀行帳戶申請、匯款、公司合約或是政府單位各項業務都是使用大小章，必要時會將大小章交付給特定人士使用，所以會建議小章與私章是分開的。</p>
<p>印章會分為兩個階段使用，一則是在公司設立前會先帶有「籌備處」字樣的大章，在公司設立前會使用籌備處的印章申請各項業務，如開立銀行帳戶（有些銀行已經可接受不使用 “籌備處” 的印章，相對可省去一些麻煩）；另一則是公司成立後的正式大章，會建議在申請公司的過程中花些費用刻好，以便公司成立後可立即使用。</p>
<h4 id="資本額、銀行帳戶"><a href="#資本額、銀行帳戶" class="headerlink" title="資本額、銀行帳戶"></a>資本額、銀行帳戶</h4><p>成立公司時必須投入資本額作為股份，此資本額是作為公司營運使用，並且會作為盈餘分配的依據，原本公司設立有最低資本額的限制（股份有限公司為 50 萬元，有限公司為 25 萬元），後來也移除此項規定，所以只要會計師核准，資本額基本上可以無視。</p>
<p>接下來就是將你跟夥伴（股東）的資金準備好，然後到銀行開立帳戶（籌備戶），開立帳戶會產生一組臨時的帳戶名稱及號碼，名稱也就會帶上 “籌備戶” 的字樣，而現在有些銀行會在申請完後直接將 “籌備戶” 移除，並且使用同一組帳戶號碼。</p>
<p>申請完籌備戶以後，就可以在<strong>指定的時間內各自匯入談好的比例資金</strong>（太早匯也不行喔），交由會計師、政府查核後即可準備設立。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F1584682342688.png?alt=media&amp;token=f8e98ba5-836c-4d66-99a1-58c866dbc580" alt=""></p>
<h4 id="準備設立"><a href="#準備設立" class="headerlink" title="準備設立"></a>準備設立</h4><p>準備就緒以後，會計師會提供許多文件以供簽署，如公司章程、設立登記表、房屋所有權（或者願意租你開公司的證明文件）等各項表單，申請的過程中也可以選擇將大小章直接交由會計師（選擇信任的會計師，可以省去不少麻煩），加速整個設立的流程。</p>
<p>設立完成後就會收到政府的來函，包含設立許可、營業登記等等文件，尤其營業登記是政府許可的證明，申請網路線路、政府補助、正式銀行帳戶都是會使用到的，雖然它只是張 A4 紙，但請確保它有被妥善收藏。</p>
<h2 id="其它事項"><a href="#其它事項" class="headerlink" title="其它事項"></a>其它事項</h2><p>公司如果申請完了，就可以開始營業了嗎？</p>
<p>不行，畢竟要請員工就需要協助加保勞健保，有銷售就必須開立發票，這些項目還是需要在設立公司時一口氣完成。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F1584501325002.png?alt=media&amp;token=127c886e-4eb2-4393-b4f9-1bd340a210b3" alt=""></p>
<h4 id="工商憑證"><a href="#工商憑證" class="headerlink" title="工商憑證"></a>工商憑證</h4><p>現在政府許多業務都慢慢的電子化，工商憑證就如同個人使用自然人憑證，只不過它所代表的是公司行號。</p>
<p>申請完的政府業務如勞健保、電子發票，都會要求使用工商憑證登入（除非你喜歡臨櫃申請這些業務）。登入後可將業務指派給特定的職員或負責人，往後改為使用個人的自然人憑證或健保卡登入執行該業務（所以自然人憑證太破爛的也可以順便換新）。</p>
<h4 id="每月的痛-勞健保"><a href="#每月的痛-勞健保" class="headerlink" title="每月的痛 - 勞健保"></a>每月的痛 - 勞健保</h4><p>對於許多新創公司來說，每個月的噩夢除了薪資以外，另一個就是勞健保了（有部分負責人會認為勞健保比薪資可怕，費用約是總薪資的 20%），隨著勞工權益上升，公司所負擔的勞健保費用也越來越高，現在的勞健保也是屬於<a href="https://news.ltn.com.tw/news/focus/paper/1090424">逐年調漲</a>，在成立公司時不可忽視這個成本。</p>
<p>關於許多勞健保的細節可以獨立一篇做介紹，這邊僅說明前期可能會遇到事項：</p>
<h5 id="申請、投保："><a href="#申請、投保：" class="headerlink" title="申請、投保："></a>申請、投保：</h5><p>勞健保是屬於勞保、健保的簡稱，所以實際上投保時兩者是分離的，好在申請、投保這兩個步驟可以合併處理，因此一開始可以先帶著大小章以及營業登記到「勞保局」一起申請，第一次申請時也可順便投保，申請完一段時間即會收到勞保單位、健保單位設立的許可文件。</p>
<p>單位設立以後，就可透過工商憑證登入<a href="https://edesk.bli.gov.tw/aa/">勞保局的系統</a>進行投保及各項查詢，雖然勞健保是分離的，但勞保局系統可 “同時加保勞<strong>健</strong>保”，算是流程中的小確幸…。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F0373E941-54B9-4752-A0D8-C74E9EA91E8D.png?alt=media&amp;token=786f6b3e-3106-4d42-a1d1-00b73e8e24e2" alt=""></p>
<h5 id="勞保、勞退："><a href="#勞保、勞退：" class="headerlink" title="勞保、勞退："></a>勞保、勞退：</h5><p>勞保基本上就是依據員工的薪資做投保，投保級距可參考：<a href="https://twworkforce.com/2019/11/17/3in1/">https://twworkforce.com/2019/11/17/3in1/</a></p>
<p>關於負責人在勞保上，有以下一些事項需要注意：</p>
<ul>
<li>負責人預設是沒有勞退的</li>
<li>負責人的勞健保級距不可低於 45,800 元，亦不可低於全員工的最高薪資<ul>
<li>如果員工薪資為 50,000，負責人也不可低於此數字</li>
<li>新設立公司前半年可直接套用全員工最高薪資（如果最高薪為 36,000，前半年可先用此數字申請）</li>
</ul>
</li>
<li>負責人一定要保勞保，但可以不要領薪水 :D</li>
</ul>
<p>除此之外，每月的帳單上不會有每個員工的勞保明細，需要至<strong>勞保局的網站</strong>查詢。</p>
<h5 id="健保："><a href="#健保：" class="headerlink" title="健保："></a>健保：</h5><p>原則上，健保與勞保是一體的，所以在申請勞保時也會同時納入健保，在投保前也可先詢問員工是否要加保眷屬，加保原則是以一等親為主，二等親有其它條件（兄弟姊妹屬二等親）。</p>
<p>另外，在很少部分情況下，可以選擇不需要加保健保</p>
<blockquote>
<p>勞工從事短期性工作未滿三個月，或是一週工時少於 12 小時，勞工是可以要雇主不幫他投保的，並繼續依原投保狀況投保(Ex:寄託在直系親屬的公司裡)，但也特別要注意，基本上成年以後的人都要獨立加保不能依附在父母親名下，除非子女為學生才可以。所以有工作、又成年，你就不能拒絕雇主幫你投保健保哦。</p>
</blockquote>
<p>簡單來說：</p>
<ul>
<li>短期、工時少</li>
<li>學生</li>
<li>員工同意</li>
</ul>
<p>參考：<a href="https://www.1111.com.tw/dayoff/discussTopic.asp?cat=vacationQuestion&amp;id=222376">https://www.1111.com.tw/dayoff/discussTopic.asp?cat=vacationQuestion&amp;id=222376</a></p>
<p>除此之外，每月的帳單上不會有每個員工的健保明細，需要至<strong>健保局的網站</strong>查詢（這個系統真心覺得難用，各項登入說明的詞彙很容易誤解）。</p>
<h4 id="發票"><a href="#發票" class="headerlink" title="發票"></a>發票</h4><p>發票分為手寫發票與電子發票，顧名思義手寫發票就是用手寫的，電子發票可以用電腦輸入並以電子的方式傳送，以下列出其中的共通點及注意事項：</p>
<p>發票共通概念：</p>
<ul>
<li>都是以「本」為單位，一本為 50 張發票（也就是 50 個連續發票字軌）</li>
<li>無論電子發票、手寫發票都需要上傳或繳回已使用發票及作廢發票</li>
<li>開立發票有固定 5 % 的營業稅</li>
</ul>
<h4 id="手寫發票："><a href="#手寫發票：" class="headerlink" title="手寫發票："></a>手寫發票：</h4><p>優點只有一個：申請過程簡便，除此之外都是一堆雷<br>缺點：</p>
<ul>
<li>每張之間都要隔複寫紙，隔錯就報廢好幾張</li>
<li>不能寫錯字，一寫錯就作廢（我通常三張錯兩張，好一點三張錯一張）</li>
<li>耗費許多時間在手寫上</li>
<li>稅額要自己算（有現成工具，但還是要自己輸入數值才會有結果）</li>
<li>寫完還要寄給用戶</li>
</ul>
<p>先前手開發票一次要花上半小時到一小時的時間（包含寄送），真的不想再面對那樣的流程。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F1584503398209.png?alt=media&amp;token=c1ee51ef-50dc-4982-b9d7-28796d3caf55" alt=""></p>
<h4 id="電子發票："><a href="#電子發票：" class="headerlink" title="電子發票："></a>電子發票：</h4><p>電子發票申請上相當麻煩，而且每間國稅局回覆都略有不同，除了國稅局這關以外，還會建議在串接第三方的發票服務，並透過 API 的形式串接發票，可以節省非常多的時間在開發票上。</p>
<p>電子發票具有以下特點：</p>
<ul>
<li>開立後不需要提供紙本發票（用戶可要求索取，但大部分不會有這些需求）</li>
<li>有效減少錯誤，不用擔心寫錯字浪費紙張</li>
<li>廠商收到電子發票，可直接用印表機列印後報帳（不需要主動寄送，節省雙方成本）</li>
<li>B2C 發票中獎需另外主動聯絡用戶</li>
<li>可以串接 API，並且自動化發送發票明細</li>
</ul>
<p>申請完電子發票後，就可以在<strong>政府的平台</strong>上使用基本的電子發票功能，包含：</p>
<ul>
<li>索取電子發票（以本為單位下載）</li>
<li>開立單張電子發票（如同手開）</li>
<li>上傳空白電子發票字軌（沒上傳國稅局會打電話過來唸）</li>
</ul>
<p>不過同時也建議串接<strong>第三方的發票系統</strong>，雖然需要額外的費用，但可以節省非常多的時間成本，費用上每張約 1 ~ 1.5 元，量越大價格越低，第三方電子發票平台具有以下特點：</p>
<ul>
<li>提供 API 自動化開立發票</li>
<li>發票管理系統，便於開立、作廢、折讓等各種功能</li>
<li>自動計算稅額</li>
<li>提供每月申報的銷項列表（節省會計時間）</li>
<li>自動化上傳空白發票字軌</li>
<li>可開立預約發票（預先預約，等時間到才開立）</li>
<li>中獎查詢</li>
</ul>
<p>光自動化開立發票我就買單了，剩餘功能也是有效節省許多時間，也可以跟經常寫錯的人工發票說掰掰，真的沒有理由不使用（也可以自行串接國稅局的 Turnkey，但不建議）。</p>
<h2 id="開完公司了"><a href="#開完公司了" class="headerlink" title="開完公司了"></a>開完公司了</h2><p>本篇是在開完公司後將近兩年後的時間寫的，其中也包含這段時間的一些經驗分享，希望對於想創業的夥伴有些幫助。</p>
<p>看完這篇以後，如果你也成功了設立公司，先恭喜你踏出了第一步，接下來還有更多的挑戰等你來面對 :D</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F1584502786005.png?alt=media&amp;token=ee47d74d-37c0-4c16-8f2f-bd4b7f55f3e5" alt=""></p>
]]></content>
      
        <categories>
            
            <category> business </category>
            
        </categories>
        
        
        <tags>
            
            <tag> business </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Flex 空間計算規則]]></title>
      <url>https://wcc723.github.io/css/2020/03/08/flex-size/</url>
      <content type="html"><![CDATA[<p>此篇是延續先前的 Flex 的文章（<a href="/css/2017/07/21/css-flex/">圖解：CSS Flex 屬性一點也不難</a>），本篇則是著重在 flex 中的 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code> 這三個屬性，如果對於 Flex 基礎尚不熟悉的可先閱讀前一篇文章。</p>
<p>首先，回顧下先前的三個屬性介紹：</p>
<p>flex 是縮寫，裡面依序包含三個屬性 <code>flex-grow</code>、<code>flex-shrink</code> 和 <code>flex-basis</code>。</p>
<ul>
<li>flex-grow: 元件的伸展性，是一個數值，當空間分配還有剩餘時的當前元件的伸展性，預設值為 <code>0</code>，如果設置為 0 則不會縮放。</li>
<li>flex-shrink: 元件的收縮性: 元件的伸展性，是一個數值，當空間分配還不足時的當前元件的收縮性，預設值為 <code>0</code>，如果設置為 0 則不會縮放。</li>
<li>flex-basis: 元件的基準值，可使用不同的單位值。</li>
</ul>
<p>在以上的 <code>flex-grow</code>、<code>flex-shrink</code> 中，這兩個數性可以填入任意整數，關鍵也在於這個任意整數的計算方式如何，本篇將用圖文方式介紹其中運算的規則。</p>
<h2 id="grow-shrink-的計算概念"><a href="#grow-shrink-的計算概念" class="headerlink" title="grow, shrink 的計算概念"></a>grow, shrink 的計算概念</h2><p>這兩者所填入的皆是整數，運作的概念上非常接近，都是 <strong>按比例分配剩餘空間</strong>，只是兩者是在相反的情境下運作，我們先來介紹比較常使用到的 <code>flex-grow</code>，接下來再用相同的概念來理解 <code>shrink</code>。</p>
<h3 id="Grow-伸展值，分配剩餘的空間"><a href="#Grow-伸展值，分配剩餘的空間" class="headerlink" title="Grow 伸展值，分配剩餘的空間"></a>Grow 伸展值，分配剩餘的空間</h3><p>我們先建立一個簡單的基礎，在一個外部容器上加上 <code>display: flex;</code>，內部則補上 <code>flex: 1;</code> 預期會得到如下的結果：三個等比切分的內元素（三個寬度各佔 33%）。</p>
<p>下方的介面中，可以自行開啟 HTML, CSS 來檢視、調整原始碼，如果看到的結果不符合預期可以點選右下角的 <code>rerun</code>。</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="jOPGBPq" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 1">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/jOPGBPq">
  Flex 寬度計算規則 - 1</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>接下來，為了讓接下來的實驗更好驗證，對於這些元素再補上一些設定：</p>
<ol>
<li>外層容器設定為 600px</li>
<li>內容最左邊的元素設定 200px 寬度（flex-basis 強制設定）</li>
<li>右方兩個藍色元素設定 flex-grow: 1</li>
</ol>
<p>到這個階段會看到以下的結果，三個方框的寬度依然是一致的（都是 200px）。</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="mdJBWJg" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 2">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/mdJBWJg">
  Flex 寬度計算規則 - 2</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>接下來，將最右方的元素 flex-grow 改為 2，則可以看到以下的結果。</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="GRJMrbe" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/GRJMrbe">
  Flex 寬度計算規則 - 3</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>由於 Flex 是按比例分配剩餘空間，因此在前面的範例中，兩者 flex-grow 都是 1 的情況下，會呈現 1:1 的結果，這次改為 1:2 那麼寬度的計算上也會改為 1:2，重點如下：</p>
<ul>
<li>分配空間是依據比例（flex-grow 的總和值再重新分配）</li>
<li>是分配 <strong>剩餘的空間</strong>，已經佔用的空間不會重新分配</li>
</ul>
<p>因此，以上方的範例來說：</p>
<ol>
<li>總寬度為 600px，最左方的元素佔用 200px 寬度，因此剩餘 400px</li>
<li>flex-grow 分別為 2、1，因此總和為 3</li>
<li>比例分配上為 400px / 3 = 133.33333px</li>
<li>左方寬度為 133 * 1，右方元素為 133 * 2 = 266</li>
</ol>
<p>圖文說明：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2Fflex-1.jpg?alt=media&amp;token=945065be-e215-44c9-a5f6-82030c32399a" alt="依據可分配剩餘空間，依據比例劃分"></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2Fflex-2.jpg?alt=media&amp;token=c0211b2d-453f-47d3-bbb6-1513f59169a5" alt="重新分配大小"></p>
<p>接下來，請使用你的開發者工具檢視上方的結果（左方約為 134px，右方為 266px）。</p>
<h3 id="注意，可分配的空間"><a href="#注意，可分配的空間" class="headerlink" title="注意，可分配的空間"></a>注意，可分配的空間</h3><p>flex 的可分配空間會隨著條件不同而改變，以下範例來說，中間的元素補上了 100px，我們會發現他的寬度計算會與上一個的範例有所不同。</p>
<ul>
<li>中間的元素與右邊元素尺寸大小不相上下</li>
</ul>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="css,result" data-user="Wcc723" data-slug-hash="poJdOrb" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 8">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/poJdOrb">
  Flex 寬度計算規則 - 8</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>此段的計算邏輯：</p>
<ol>
<li>計算出可分配的空間：總寬(600px) - 左方元素(200px) - 中間元素的固定寬(100px) = 300px</li>
<li>計算比例：300px / 3(<code>flex-grow</code> 總值) = 100px</li>
<li>重新分配：<ul>
<li>右方元素(grow: 2) 100px * 2 = 200px</li>
<li>中間元素(basis: 100px; grow: 1) 100px + 100px * 1 = 200px</li>
</ul>
</li>
</ol>
<p>接下來，透過開發者工具會得到 <em>接近</em> 上述的結果。</p>
<blockquote>
<p>問題：為什麼是接近上述的結果，而不是完全符合呢？</p>
</blockquote>
<p>因為 flex 計算上是 <strong>分配剩餘的空間</strong>，空間上被佔用的因素非常多，如上述的 flex-basis 就是會屬於佔用空間的一種，除此之外包含元素內部的 文字、邊線、任何內容都會影響到佔用空間，因此也會影響到剩餘的空間分配。</p>
<h2 id="Shrink-收縮值，分配多餘的空間"><a href="#Shrink-收縮值，分配多餘的空間" class="headerlink" title="Shrink 收縮值，分配多餘的空間"></a>Shrink 收縮值，分配多餘的空間</h2><p><code>flex-shrink</code> 與 <code>flex-grow</code> 運作上則是相反，<code>shrink</code> 是將超出的部分重新分配，確保元素不會被裁切（如果足夠被分配完）。</p>
<p>以下範例透過三個 <code>flex-basis: 250px</code> 來超出範圍，並且統一設定 <code>flex-shrink</code> 與 <code>flex-grow</code> 皆為 0（禁止伸展、收縮），可以得到以下的結果：內元素超出了外容器。</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="WNvXjaz" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 4">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/WNvXjaz">
  Flex 寬度計算規則 - 4</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>接下來，將右邊兩個元素 <code>flex-shrink</code> 設為 <code>1</code>，會看到兩個元素多餘的內容收縮到外容器內部並維持相同的寬度，最左方的元素則維持原本的寬度不變。</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="WNvXjYz" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 5">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/WNvXjYz">
  Flex 寬度計算規則 - 5</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>接下來，一樣進行 2:1 的 shrink 設置實驗，左方為 <code>flex-shrink: 1</code>，右方為 <code>flex-shrink: 1</code>，接下來你可能會猜想兩者的尺寸應為 <code>2: 1</code> 吧！</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="LYVOyXV" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 6">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/LYVOyXV">
  Flex 寬度計算規則 - 6</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>實際結果：當然不是～</p>
<p>上面有提到 <code>shrink</code> 是分配多餘的空間，因此不是全部的空間上都重新分配，所以運作的結果如下：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2Fflex-3.jpg?alt=media&amp;token=a691be48-f1fd-4650-804b-3691f76b8081" alt="先計算超出範圍的空間及比例"></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2Fflex-4.jpg?alt=media&amp;token=3422ac1d-6c5c-42e8-ad10-31ac034a1dc2" alt="依據比例重新扣除"></p>
<p>接下來，重新使用你的開發者工具，檢視上方的結果吧（會得到中間元素寬度 200px，右方元素寬度 150px）。</p>
<h2 id="遵循軸線"><a href="#遵循軸線" class="headerlink" title="遵循軸線"></a>遵循軸線</h2><p>Flex 撇除了原本的寬度、高度的空間定義，改用三個屬性（basis、grow、shrink）來定義一個容器的尺寸，不僅是為了提高容器的空間彈性，除此之外計算出來的空間尺寸還能依據 Flex 的軸線重新計算，大大增加了空間的彈性。</p>
<p>以下範例來說，將 Flex 主軸線切換為 <code>flex-direction: column;</code>，內層元素依然可依據垂直的方式重新分配空間大小，且計算邏輯一致。</p>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="Wcc723" data-slug-hash="LYVOyqp" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Flex 寬度計算規則 - 3 - cloumn">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/LYVOyqp">
  Flex 寬度計算規則 - 3 - cloumn</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>如果透過文字還是不容易理解，可以看我過去線上教學的<a href="https://www.youtube.com/watch?v=0QjOO-M2gs8">影片 - Flex 寬度計算方法</a>，或是<a href="https://www.youtube.com/watch?v=lmBM7_OTDBQ">Flex 完整教學</a></p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[爬蟲、E2E 測試兩相宜的好工具 - Puppeteer]]></title>
      <url>https://wcc723.github.io/development/2020/03/01/puppeteer/</url>
      <content type="html"><![CDATA[<p>Puppeteer 是 Node.js 的函式庫，它提供各種 API 來控制 Chrome 或 Chromium 瀏覽器，而此瀏覽器也是目前主流的瀏覽器，用來做為測試、爬蟲都相當合適，並且所提供的 API 語法淺顯易懂，只要具有 jQuery 的使用經驗就可以很快速地上手。</p>
<h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>官方提供兩個版本，一個包含 Chromium，另一個則無，如果有安裝 Chrome 的情況下可以不需要另外下載 Chromium，直接運行本機的應用程式即可（選擇輕量 headless 模式運行一樣很快）。</p>
<p>所以可以採用以下語法加入設定後跳過下載（或者也可以直接使用 puppeteer-core）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set puppeteer_skip_chromium_download true</span><br></pre></td></tr></table></figure></p>
<p>下載 Puppepeer<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i puppeteer </span><br></pre></td></tr></table></figure></p>
<p>接下來可以新增一個檔案 <code>test.js</code>，使用官方提供的範例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch();</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage();</span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://example.com&#x27;</span>);</span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123; <span class="attr">path</span>: <span class="string">&#x27;example.png&#x27;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>執行 <code>node test.js</code> 則會出現錯誤，主要原因是沒有下載 Chromium，這部分可以手動設置自己的 Chrome 使用。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2FD4B77A61-3F06-4F76-8B5E-2D91D9BFE0D9.png?alt=media&amp;token=225e5015-189e-4933-bbf3-1960d22196b2" alt=""></p>
<p>接下來將上述原始碼中的 <code>browser</code> 變數改為如下即可運行，<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    executablePath:</span><br><span class="line">      <span class="string">&#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;</span>,</span><br><span class="line">    headless: <span class="literal">false</span></span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><br>Windows 路徑可參考：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;C:\\Program Files (x86)\\Google\\Chrome\\Application\\chrome.exe&#39;</span><br></pre></td></tr></table></figure></p>
<p>重新執行一次上述的原始碼，則可以發現快速打開了 Chrome 後就關閉了瀏覽器，打開你的專案資料夾可以發現多了一張圖片，在這個過程中 Chrome 已經依據腳本完成了流程，因此來看一下剛剛發生了什麼事：</p>
<ol>
<li>打開瀏覽器</li>
<li>開啟新的分頁</li>
<li>進入特定的網址</li>
<li>截圖，並把圖片存到特定的路徑</li>
</ol>
<p>在這個流程下大致就能體會到 Puppeteer 是怎樣的工具，它可以模擬用戶的行為對瀏覽器操作，因此只要熟悉的它的語法做到爬蟲、測試都不會有太大的問題。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-core&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用自訂的 Chrome</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    executablePath:</span><br><span class="line">      <span class="string">&#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;</span>,</span><br><span class="line">    headless: <span class="literal">false</span> <span class="comment">// 無外殼的 Chrome，有更佳的效能</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage(); <span class="comment">// 開啟新分頁</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://example.com&#x27;</span>); <span class="comment">// 進入指定頁面</span></span><br><span class="line">  <span class="keyword">await</span> page.screenshot(&#123; <span class="attr">path</span>: <span class="string">&#x27;example.png&#x27;</span> &#125;); <span class="comment">// 截圖，並且存在...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> browser.close(); <span class="comment">// 關閉瀏覽器</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F5E922289-CABB-4762-87E7-FC088B2C80E3.png?alt=media&amp;token=0e75f79e-b0ad-44e0-a591-b2bb527f09c7" alt="資料夾內可以看到執行截圖的畫面"></p>
<h2 id="基礎方法說明"><a href="#基礎方法說明" class="headerlink" title="基礎方法說明"></a>基礎方法說明</h2><p>中文文件：<a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/">https://zhaoqize.github.io/puppeteer-api-zh_CN/#/</a></p>
<p>Puppeteer 大部分的行為都是非同步的（都是 Promise 的方法），因為無法確認網頁點擊後多久後開啟，也無法確認輸入文字需要多長的時間，而 Promise 搭配 async、await 就能將程式碼轉成類似於同步的語言。</p>
<p>所以使用 Puppeteer 時會看到很多 <code>await ...</code>，目的是要確保原始碼可以依序執行，因此以下介紹的方式也都建議都加上 await。</p>
<h3 id="常見方法"><a href="#常見方法" class="headerlink" title="常見方法"></a>常見方法</h3><p>可以先思考下載網頁中通常會進行哪些行為，不外乎就是：</p>
<ul>
<li>點擊連結</li>
<li>填寫表單</li>
<li>進入特定頁面，確保資訊有出現</li>
</ul>
<p>這些方法在文件中都是在文件中的 <code>page</code> 找到（所有的頁面行為基本上都在這），以下列出常見的方法給大家參考：</p>
<ul>
<li><code>page.goto(url[, options])</code>：直接進入特定的連結頁面</li>
<li><code>page.$(selector)</code>：選取特定元素，等同於 document.querySelector</li>
<li><code>page.$$(selector)</code>：前者的複數型，等同於 document.querySelectorAll</li>
<li><code>page.$eval(selector, pageFunction[, ...args])</code>：對於選取的元素進行特定行為，如取出元素的 HTML 屬性值。</li>
<li><code>page.$$eval(selector, pageFunction[, ...args])</code>：前者的複數型</li>
<li><code>page.click(selector[, options])</code>：點擊特定的元素</li>
<li><code>page.type(selector, text[, options])</code>：在特定的元素上輸入文字內容，通常是 input 上輸入</li>
<li><code>page.select(selector, ...values)</code>：在 select 元素上選取特定的值</li>
<li><code>page.waitForSelector(selector[, options])</code>：等待頁面上的特定元素出現，在非同步的過程中很實用。</li>
</ul>
<p>方法中可以看到 selector 不斷的出現，selector 即是畫面上的元素選取方式，因為它可以模擬用戶的行為，所以 selector 的選取技巧在此工具中是非常重要的。</p>
<h3 id="Selector-技巧"><a href="#Selector-技巧" class="headerlink" title="Selector 技巧"></a>Selector 技巧</h3><p>選取器是遵循 <code>document.querySelector</code> 的規則，基本上就是與撰寫 CSS 時的方式一致（所以才會提到熟悉 jQuery 會非常有幫助），在選擇元素的過程中，最準確的是 id（一個網頁原則上只有一個 id），所以直接的方式就是使用 id 選擇該元素。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">page.click(<span class="string">&#x27;#button&#x27;</span>); <span class="comment">// 點擊網頁中 id 為 button 的元素</span></span><br></pre></td></tr></table></figure>
<p>但許多時候網頁元素是沒有 id 的，那麼就可以搭配 Chrome 的開發者工具直接抓出特定元素選取器。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_2_27_%E4%B8%8A%E5%8D%8811_11.png?alt=media&amp;token=d56adac1-47a2-45e4-85c6-4dac5bab5965" alt=""></p>
<p>如上圖，在特定的元素上按下右鍵 &gt; Copy &gt; Copy selector，接下來就可以取得絕對的元素路徑（頁面必須維持在固定的狀態）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#tsf &gt; div:nth-child(2) &gt; div.A8SBwf &gt; div.RNNXgb &gt; div &gt; div.a4bIc &gt; input</span><br></pre></td></tr></table></figure></p>
<p>另外一種方式，如果確定元素具有特定的 HTML 屬性時，也可以使用以下的方式選取，這種寫法是使用 CSS 的屬性選取器。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">await</span> page.$(<span class="string">&#x27;input[title=&quot;Google 搜尋&quot;]&#x27;</span>)); <span class="comment">// 可以選到標籤屬性為 title=&quot;Google 搜尋&quot; 的項目</span></span><br></pre></td></tr></table></figure></p>
<h2 id="流程實戰"><a href="#流程實戰" class="headerlink" title="流程實戰"></a>流程實戰</h2><p>最後，透過 Google 搜尋特定的文字，並且進入特定頁面的方式，規劃一個簡單的流程，來測試是否可以正確運行，流程如下：</p>
<ol>
<li>開啟 Google 頁面</li>
<li>搜尋 <code>flex</code> 文字並送出</li>
<li>轉址進入搜尋結果頁面</li>
<li>點選具有 <code>https://wcc723.github.io</code> 的頁面</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> puppeteer = <span class="built_in">require</span>(<span class="string">&#x27;puppeteer-core&#x27;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 使用自訂的 Chrome</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> puppeteer.launch(&#123;</span><br><span class="line">    executablePath:</span><br><span class="line">      <span class="string">&#x27;/Applications/Google Chrome.app/Contents/MacOS/Google Chrome&#x27;</span>,</span><br><span class="line">    headless: <span class="literal">false</span> <span class="comment">// 無外殼的 Chrome，有更佳的效能</span></span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.newPage(); <span class="comment">// 開啟新分頁</span></span><br><span class="line">  <span class="keyword">await</span> page.waitFor(<span class="number">10000</span>); <span class="comment">// 等待十秒鐘（給我開錄影工具用的）</span></span><br><span class="line">  <span class="keyword">await</span> page.goto(<span class="string">&#x27;https://www.google.com.tw&#x27;</span>); <span class="comment">// 進入指定頁面</span></span><br><span class="line">  <span class="keyword">await</span> page.type(<span class="string">&#x27;input[title=&quot;Google 搜尋&quot;]&#x27;</span>, <span class="string">&#x27;flex&#x27;</span>); <span class="comment">// Google 搜尋特定項目</span></span><br><span class="line">  <span class="keyword">await</span> (<span class="keyword">await</span> page.$(<span class="string">&#x27;input[title=&quot;Google 搜尋&quot;]&#x27;</span>)).press(<span class="string">&#x27;Enter&#x27;</span>); <span class="comment">// 特定元素上按下 Enter</span></span><br><span class="line">  <span class="keyword">await</span> page.waitFor(<span class="number">1000</span>); <span class="comment">// 等待一秒</span></span><br><span class="line">  <span class="keyword">await</span> page.waitForSelector(<span class="string">&#x27;#gsr&#x27;</span>); <span class="comment">// 確定網頁的元素出現</span></span><br><span class="line">  <span class="keyword">await</span> page.click( <span class="comment">// 點擊網址中包含以下的連結...</span></span><br><span class="line">    <span class="string">&#x27;a[href*=&quot;https://wcc723.github.io&quot;]&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 接下來也可插入 await browser.close(); 關閉瀏覽器</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>在上述的範例中 <code>href*=&quot;https://wcc723.github.io&quot;]</code> 是選取網址中<strong>包含</strong> <code>https://wcc723.github.io</code> 的連結，</p>

<video width="320" height="240" controls autoplay>
  <source src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202003%2FMar-01-2020%2013-26-52.mp4?alt=media&token=d586a299-a888-4084-932b-cfbf569bfb5a" type="video/mp4">
Your browser does not support the video tag.
</video>

<blockquote>
<p>運行中的畫面</p>
</blockquote>
<p>參考資料：</p>
<ul>
<li>Google 提供的範例：<a href="https://developers.google.com/web/tools/puppeteer/examples">https://developers.google.com/web/tools/puppeteer/examples</a></li>
<li>中文文件：<a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/">https://zhaoqize.github.io/puppeteer-api-zh_CN/#/</a></li>
<li>Chrome 與 Chromium 差異：<a href="https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/">https://www.howtogeek.com/202825/what%E2%80%99s-the-difference-between-chromium-and-chrome/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test </tag>
            
            <tag> puppeteer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS Border 運用技巧（手繪框線、三角形、空間運用）]]></title>
      <url>https://wcc723.github.io/css/2020/02/21/css-border/</url>
      <content type="html"><![CDATA[<p>CSS Border 大部份來說是用在裝飾上，卡片的邊線、hover 的視覺效果、物件之間的間隔等等，這些視覺效果除了 Border 以外亦有其它方式可以達到；雖然如此，Border 的使用率還是比較高，因為相對來說更為簡單方便，不過也別這樣小看它，透過一些小技巧時，Border 還有很多靈活運用的方式。</p>
<h2 id="基本觀念介紹"><a href="#基本觀念介紹" class="headerlink" title="基本觀念介紹"></a>基本觀念介紹</h2><p>先了解 Border 基本的觀念，有助於接下來的靈活運用。</p>
<h4 id="Border-具有空間"><a href="#Border-具有空間" class="headerlink" title="Border 具有空間"></a>Border 具有空間</h4><p>這是很多新手常遇到的問題，border 本身是具有空間的，因此元素如果增加了 border 以後會導致整體元素空間增大。因此元素如果要維持原有的尺寸，則必須將 border 所增加的空間給扣除。</p>
<p>以下範例來說，左方的方框增加了額外 border 時，就導致元素尺寸大於右方的方框。</p>

<div class="demo d-flex">
  <div class="border-2 box bg-gray"></div>
  <div class="box bg-gray"></div>
</div>
<style>
.d-flex {
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
}
.box {
  height: 80px;
  width: 80px;
  margin: 3px;
  display: flex;
  justify-content: center;
  align-items: center;
}
.bg-gray {
  background-color: #ccc;
}
.border-2 {
  border: 2px solid #00cc99;
}
</style>

<h4 id="Border-可以搭配圓角"><a href="#Border-可以搭配圓角" class="headerlink" title="Border 可以搭配圓角"></a>Border 可以搭配圓角</h4><p>CSS 中的圓角 <code>border-radius</code> 是一個偉大的發明，他並不會使元素的邊緣被裁切，而是能夠產生滑順的圓角。除此之外，雖然名稱為 <strong>border</strong>-radius 但運用上並不只限於 border，在大部分的元素上都可以運用 border-radius，而 border-radius 運用上具有以下的技巧：</p>
<ul>
<li>不需要所有角都使用等距空間，每個角可自訂獨立的數值（左二範例）</li>
<li>當圓角數值超過元素空間時，將會以 <strong>較短的邊線距離產生正圓角</strong>，這樣的特性下可以在元素的邊緣套用正圓形（左三範例）</li>
<li>當圓角數值採用百分比且超過 50% 時，將會以 <strong>邊線距離的一半產生圓角</strong>，此特性在非正方形的情況下可能會變成橢圓形。</li>
</ul>
<p>大多數情況來說，我都會將圓角數值設為極大值，來產生更好看圓邊，避免會出現橢圓形的狀況。</p>

<div class="demo d-flex">
  <div class="border-4 box bg-gray radius"></div>
  <div class="border-4 box bg-gray radius-6-12-24-48"></div>
  <div class="border-4 box bg-gray radius-circle" style="width: 120px"></div>
  <div class="border-4 box bg-gray radius-oval" style="width: 120px"></div>
</div>
<style>
.radius {
  border-radius: 24px
}
.radius-6-12-24-48 {
  border-radius: 6px 12px 24px 48px;
}
.radius-circle {
  border-radius: 200px;
}
.radius-oval {
  border-radius: 50%;
}
</style>

<h4 id="不同的樣式"><a href="#不同的樣式" class="headerlink" title="不同的樣式"></a>不同的樣式</h4><p>大部分來說 border 運用都是以 <code>solid</code> 為大宗，其次為 <code>dashed</code> 及 <code>dotted</code>，以下列出所有的 border 樣式，除此之外 border 的樣式還可以混合使用喔。</p>

<div class="demo d-flex">
  <div class="border-4 border-dotted box bg-gray">dotted</div>
  <div class="border-4 border-dashed box bg-gray">dashed</div>
  <div class="border-4 border-solid box bg-gray">solid</div>
  <div class="border-4 border-double box bg-gray">double</div>
  <div class="border-4 border-groove box bg-gray">groove</div>
  <div class="border-4 border-ridge box bg-gray">ridge</div>
  <div class="border-4 border-inset box bg-gray">inset</div>
  <div class="border-4 border-outset box bg-gray">outset</div>
  <div class="border-4 border-mix box bg-gray">混合</div>
</div>
<style>
.border-4 {
  border: 4px solid #00cc99;
}
.border-dotted {border-style: dotted;}
.border-dashed {border-style: dashed;}
.border-solid {border-style: solid;}
.border-double {border-style: double;}
.border-groove {border-style: groove;}
.border-ridge {border-style: ridge;}
.border-inset {border-style: inset;}
.border-outset {border-style: outset;}
.border-mix {border-style: dotted dashed solid double;}
</style>

<hr>
<h2 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h2><h3 id="空間運用"><a href="#空間運用" class="headerlink" title="空間運用"></a>空間運用</h3><p>Border 很常運用在選單的 hover 或 active 的視覺效果，但如果沒有注意到就可能因為 border 的空間讓選單產生位移，如以下範例來說，滑鼠移入選單時就會造成選單位移。</p>
<p>關鍵程式碼：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.demo-item</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid <span class="number">#00cc99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div class="demo d-flex">
  <div class="demo-navbar d-flex">
    <a href="#" class="demo-item">選單 1</a>
    <a href="#" class="demo-item">選單 2</a>
  </div>
</div>
<style>
.demo-navbar {
  background-color: #fff;
  box-shadow: 0 3px 3px rgba(0, 0, 0, .16);
  padding: 0 30px;
  justify-content: center;
}
a.demo-item {
  display: block;
  padding: 10px 15px;
}
a.demo-item:hover {
  border-bottom: 3px solid #00cc99;
  text-decoration: none;
}
</style>

<p>會造成這樣的原因在於「Border 本身是具有空間的」，因此直接在 hover 上新增 border 時就會發生此問題，其中一種解決方法則是預先加入 “透明的 border 空間”，在 hover 或其它的行為時再來切換 border 的色彩。</p>
<p>關鍵程式碼：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo-navbar</span> &#123;</span><br><span class="line">  <span class="comment">/* 將部分的空間先扣除 */</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">27px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.demo-navbar</span> <span class="selector-class">.demo-item</span> &#123;</span><br><span class="line">  <span class="comment">/* 加入下方透明的 Border */</span></span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">3px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div class="demo d-flex">
  <div class="demo-navbar demo-navbar-update d-flex">
    <a href="#" class="demo-item">選單 1</a>
    <a href="#" class="demo-item">選單 2</a>
  </div>
</div>
<style>
.demo-navbar-update {
  padding: 0 27px;
}
.demo-navbar-update .demo-item {
  border-bottom: 3px solid transparent;
}
</style>

<p>由於 Border 本身是佔有空間的，所以也可以使用其它不含空間的視覺效果來達到此效果，以下範例則是使用 <code>box-shadow</code> 做到類似的效果。</p>
<p>關鍵程式碼：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.demo-item</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> -<span class="number">3px</span> <span class="number">#00cc99</span> inset; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div class="demo d-flex">
  <div class="demo-navbar demo-navbar-update2 d-flex">
    <a href="#" class="demo-item">選單 1</a>
    <a href="#" class="demo-item">選單 2</a>
  </div>
</div>
<style>
.demo-navbar-update2 a.demo-item:hover {
  border-bottom: 0;
  box-shadow: 0 -3px #00cc99 inset; 
}
</style>

<h3 id="三角形"><a href="#三角形" class="headerlink" title="三角形"></a>三角形</h3><p>接續一開始所提到 border 本身是佔有空間的，當有兩個邊線的 border 重疊的部分就會產生 “實體的交疊”，這個實體的交疊就會產生三角形的視覺效果。</p>
<p>下方的範例來說，上者是下邊、右邊的 border 產生，下者則是四邊的 border 產生。</p>

<div class="demo">
  <div class="left-border"></div>
  <div class="arrow"></div>
</div>
<style>
.left-border {
  width: 0;
  height: 0;
  margin: 0 auto;
  border-right: orange 20px solid;
  border-bottom: blue 20px solid;
}
.arrow {
  width: 0;
  height: 0;
  margin: 0 auto;
  border-top: red 20px solid;
  border-right: orange 20px solid;
  border-bottom: blue 20px solid;
  border-left: green 20px solid;
}
</style>

<p>當四邊均為 border 時，就能產生四個三角形，當如果僅需要一個方向的三角時，就可以使用到前一個段落所提到的技巧 “透明 border”。</p>
<p>關鍵程式碼：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.message-box</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="comment">/* 四邊透明的 border */</span></span><br><span class="line">  <span class="attribute">border</span>: transparent <span class="number">10px</span> solid;</span><br><span class="line">  <span class="comment">/* 將其中一補上色彩 */</span></span><br><span class="line">  <span class="attribute">border-top-color</span>: <span class="number">#00cc99</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>透過此方法就能做到類似訊息框的視覺效果。</p>

<div class="demo d-flex">
  <div class="message-box">歐拉歐拉歐拉歐拉歐拉！</div>
</div>
<style>
.message-box {
  background: #00cc99;
  color: white;
  padding: 10px;
  border-radius: 5px;
  position: relative;
}
.message-box:after {
  content: "";
  width: 0;
  height: 0;
  position: absolute;
  left: 10px;
  bottom: -20px;
  border: transparent 10px solid;
  border-top-color: #00cc99;
}
</style>

<h3 id="多層次"><a href="#多層次" class="headerlink" title="多層次"></a>多層次</h3><p>除了 Border 以外，有很多方法可以做到類似的視覺效果，而其中一個很常利用的就是 <code>box-shadow</code>，與 border 最大不同之處就是 <code>box-shadow</code> 不佔有任何空間。兩者在此也可以作為好朋友產生多層次的邊框效果。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.border-multi</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">  <span class="attribute">box-shadow</span>: </span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> orange, </span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">10px</span> yellow,</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">15px</span> green,</span><br><span class="line">    <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">20px</span> blue;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">25px</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="demo d-flex">
  <div class="border-multi box bg-gray"></div>
</div>
<style>
.border-multi {
  border: 5px solid red;
  box-shadow: 
    0 0 0 5px orange, 
    0 0 0 10px yellow,
    0 0 0 15px green,
    0 0 0 20px blue;
  margin: 25px  
}
</style>

<h3 id="手繪邊框"><a href="#手繪邊框" class="headerlink" title="手繪邊框"></a>手繪邊框</h3><p>最後，展示比較特別的視覺風格 “手繪邊框”，前幾個範例都是圍繞在 border-radius 上，這個也不例外，最重要的關鍵點在於 border-radius 可以在同一個角設定兩個以上的參數。</p>
<p>如以兩個範例</p>
<ul>
<li>範例一：設定左上的圓角，前者的數值是左上圓角<strong>靠上方</strong>邊線的圓半徑，後者的數值則是左上圓角<strong>靠左方</strong>邊線的圓半徑，原始碼 如下：</li>
<li>範例二：縮寫方法，可以一次設定四個圓角不同的形式。</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 範例一 */</span></span><br><span class="line"><span class="selector-class">.border-top-left-radius</span> &#123;</span><br><span class="line">  <span class="attribute">border-top-left-radius</span>: <span class="number">10px</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 範例二 */</span></span><br><span class="line"><span class="selector-class">.border-2-size</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">15px</span> / <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="demo d-flex">
  <div class="border-4 box bg-gray border-top-left-radius"></div>
  <div class="border-4 box bg-gray border-2-size"></div>
</div>
<style>
.border-top-left-radius {
  border-top-left-radius: 10px 100px;
}
.border-2-size {
  border-radius: 15px / 100px;
}
</style>

<p>最後也補充此風格的技巧說明：</p>
<ul>
<li>border-width：可設定不同的粗細變化，做出手繪過程中的不同粗細變化</li>
<li>transform：手繪過程中通常不會過於水平或垂直，所以外層都可以補上 transform 製作出傾斜的效果<ul>
<li>內層也同樣需要補上 transform 將文字內容給予補正</li>
</ul>
</li>
<li>border-style：也可試著加入不同樣式的邊線，做出不同的手繪視覺效果</li>
</ul>
<p>關鍵程式碼：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.ink-box</span> &#123;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">2px</span> <span class="number">3px</span> <span class="number">2px</span> <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">90%</span> <span class="number">6%</span> <span class="number">93%</span> <span class="number">5%</span> / <span class="number">5%</span> <span class="number">94%</span> <span class="number">7%</span> <span class="number">95%</span>;</span><br><span class="line">  <span class="comment">/* 做出傾斜的視覺感 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">2deg</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.ink-box-double</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: dashed black <span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box-inner</span> &#123;</span><br><span class="line">  <span class="comment">/* 將傾斜的部分修正 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate</span>(-<span class="number">2deg</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

<div class="demo d-flex">
  <div class="ink-box">
    <div class="box-inner">Handwriting style</div>
  </div>
  <div class="ink-box ink-box-double">
    <div class="box-inner">Handwriting style</div>
  </div>
</div>
<style>
@import url('https://fonts.googleapis.com/css?family=Caveat&display=swap');
.ink-box {
  width: 150px;
  height: 150px;
  background:#fff;
  border: solid black 1px;
  display: flex;
  justify-content: center;
  align-items: center;
  /* 紙風格 */
  border-width: 2px 3px 2px 5px;
  border-radius: 90% 6% 93% 5% / 5% 94% 7% 95%;
  font-family: 'Caveat';
  transform: rotate(2deg);
}
.ink-box-double {
  border: dashed black 2px;
}
.box-inner {
  transform: rotate(-2deg);
}
</style>

<p>參考文件：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius">https://developer.mozilla.org/zh-CN/docs/Web/CSS/border-radius</a></li>
<li><a href="https://code.tutsplus.com/tutorials/css-refreshers-borders--net-24655">https://code.tutsplus.com/tutorials/css-refreshers-borders--net-24655</a></li>
<li><a href="https://freefrontend.com/css-border-examples/">https://freefrontend.com/css-border-examples/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> border </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript Promise 全介紹]]></title>
      <url>https://wcc723.github.io/development/2020/02/16/all-new-promise/</url>
      <content type="html"><![CDATA[<p>最近直播介紹如何串接開源資料，也剛好許多朋友詢問到 Ajax、Promise 相關的問題，因此重新撰寫一篇文來介紹 Promise，這篇文章也與過去形勢不太一樣，試著先將常見的問題放在前頭，接下來才開始介紹 Promise。</p>
<p>另外本文的內容較多，Promise 想看簡易版可參考：<a href="/javascript/2017/12/29/javascript-proimse/">/javascript/2017/12/29/javascript-proimse/</a>。</p>

<iframe width="100%" height="315" src="https://www.youtube.com/embed/7CXnNMVMXeo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>

<blockquote>
<p>使用 Vuejs 結合 Open Street Map 製作口罩地圖</p>
</blockquote>
<h2 id="關於-Promise-常見問題"><a href="#關於-Promise-常見問題" class="headerlink" title="關於 Promise 常見問題"></a>關於 Promise 常見問題</h2><p>Q: Promise 跟 Ajax 有什麼關係？</p>
<p>關於 Ajax 可以先參考這份：<a href="https://zh.wikipedia.org/wiki/AJAX">https://zh.wikipedia.org/wiki/AJAX</a></p>
<p>以目前來說，Ajax 可以向伺服器傳送及取得資料，並且不需要重新整理瀏覽器畫面，這樣可以大幅提升使用者體驗並且減少伺服器負擔（僅處理資料，畫面由前端處理）。</p>
<p>Ajax 是屬於一個透過 JavaScript 技術名稱，用於取得遠端資料；而 Promise 則是一個語法，專門用來處理非同步行為，並不是專門用來處理 Ajax 使用，所以兩者是不同的。</p>
<p>Q: Promise 與 Async、Await 有什麼關係？</p>
<p>Promise 是用來優化非同步的語法，而 Async、Await 可以<strong>基於 Promise</strong> 讓非同步的語法的結構類似於 “同步語言”，更易讀且好管理。</p>
<p>Async、Await 參考：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function">https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function</a></p>
<p>Q: 請問 Promise 很常用到嗎？是否一定要學呢？</p>
<p>使用頻率高，必學。</p>
<h2 id="非同步的問題"><a href="#非同步的問題" class="headerlink" title="非同步的問題"></a>非同步的問題</h2><p>Promise 本身是用來改善 JavaScript 非同步的語法結構。</p>
<p>在過去的文章中有提到，JavaScript 是屬於同步的程式語言，因此<a href="https://wcc723.github.io/javascript/2017/12/07/javascript-event-queue/">一次僅能做一件事情</a>，但遇到非同步的事件時，就會將非同步的事件移動到程式碼的最後方，等到所有的原始碼運行完以後才會執行非同步的事件。</p>
<p>以下列的程式碼來說，在 console 中依序的會出現的順序為：</p>
<ol>
<li><code>開始</code></li>
<li><code>程式碼結束</code></li>
<li><code>非同步事件</code> &lt;- 最後執行</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;開始&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;非同步事件&#x27;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;程式碼結束&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>雖然在上段的原始碼中，setTimeout 所定義的時間為 0，但因為是屬於非同步事件，因此還是會在其他原始碼運行完以後才執行。</p>
<p>在 Ajax 的行為中也是一樣，當需要<strong>確保擷取到遠端資料才繼續往下執行時</strong>，如果程式碼是依序撰寫的方式，就會無法正確呈現資料，以下範例我們使用 Promise base 的 Ajax 函式庫 axios 進行一下錯誤的示範：</p>
<p>與上述的概念是相同的，Ajax 本身也是屬於非同步的行為。在一開始先定義了一個 data 物件，中間段落使用 axios 嘗試取得遠端資料，後面的緊接的 <code>console.log(data);</code> 呈現的依然是一開始定義的物件，並不會是 Ajax 取得的資料。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> data = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;開始&#x27;</span>);</span><br><span class="line"></span><br><span class="line">axios.get(<span class="string">&#x27;https://randomuser.me/api/&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  data = response;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br></pre></td></tr></table></figure>
<p>在上述的範例中，data 正確的賦值位置在以下片段，如果預期在取得資料後進行其它的行為，了解整個 Promise 的運作將非常的重要。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  data = response;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Promise-的結構及狀態"><a href="#Promise-的結構及狀態" class="headerlink" title="Promise 的結構及狀態"></a>Promise 的結構及狀態</h2><h3 id="結構"><a href="#結構" class="headerlink" title="結構"></a>結構</h3><p>Promise 本身是一個建構<strong>函式</strong>，函式也是屬於物件的一種，因此可以附加其它屬性方法在上，透過 console 的結果可以看到 Promise 可以直接使用 all、race、resolve、reject 的方法，寫法如下（後面再介紹運用方式）：</p>
<ul>
<li>Promise.all</li>
<li>Promise.race</li>
<li>Promise.resolve</li>
<li>Promise.reject</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F8EDE3272-824E-4C1B-AE12-0B4913740853.png?alt=media&amp;token=3bff6e31-60b0-4683-a4d9-b09d4d1a00b0" alt="Promise 建構函式展開後的結構"></p>
<p>Promise 建構函式 <strong>new 出的物件</strong>，則可以使用其中的原型方法（在 <code>prototype</code> 內），其中就包含 <code>then</code>、<code>catch</code>、<code>finally</code>，這些方法則必須在新產生的物件下才能呼叫。</p>
<p>透過 <code>new Promise()</code> 的方式建立 <code>p</code> 物件，此時 p 就能使用 Promise 的原型方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line"></span><br><span class="line">p.then();    <span class="comment">// Promise 回傳正確</span></span><br><span class="line">p.catch();   <span class="comment">// Promise 回傳失敗</span></span><br><span class="line">p.finally(); <span class="comment">// 非同步執行完畢（無論是否正確完成）</span></span><br></pre></td></tr></table></figure></p>
<p>除此之外，Promise 建構函式建立同時，必須傳入一個函式作為參數（executor function），此函式的參數包含 resolve, reject，這兩個方法分別代表成功與失敗的回傳結果，特別注意這兩個僅能回傳其中之一，回傳後表示此 Promise 事件結束。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; </span><br><span class="line">    resolve(); <span class="comment">// 正確完成的回傳方法</span></span><br><span class="line">    reject();  <span class="comment">// 失敗的回傳方法</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><code>resolve</code> 及 <code>reject</code> 的名稱可以自定義，但在開發上大多數開發者習慣維持此名稱。</p>
<h3 id="狀態"><a href="#狀態" class="headerlink" title="狀態"></a>狀態</h3><p>Promise 的關鍵在處理非同步的事件，而非同步的過程中也包含著不同的進度狀態，在 Promise 的執行過程中，可以看到以下狀態。</p>
<ul>
<li>pending：事件已經運行中，尚未取得結果</li>
<li>resolved：事件已經執行完畢且成功操作，回傳 <code>resolve</code> 的結果（該承諾已經被實現 fulfilled）</li>
<li>rejected：事件已經執行完畢但操作失敗，回傳 <code>rejected</code> 的結果</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2Fimg-promise-pending.png?alt=media&amp;token=f5a5607b-4436-44e6-ab1f-0d8dd4bf59b3" alt=""></p>
<blockquote>
<p>進入 fulfilled 或 rejected 就算完成後不會再改變，Promise 中會使用 resolve 或 reject 回傳結果，並在調用時使用 then 或 catch 取得值。</p>
</blockquote>
<p>如果要判斷 Promise 是否完成，可依據 Promise 事件中的 <code>resolve</code> 及 <code>reject</code> 是否有被調用，以下範例來說在沒有調用兩個方法時，Promise 的結果則會停留在 pending。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(promise());</span><br></pre></td></tr></table></figure></p>
<p>在 Promise 的執行函式中，可以看到以下兩個屬性：</p>
<ul>
<li><em>[[PromiseStatus]]</em>: <code>&quot;pending&quot;</code> -&gt; 表示目前的進度狀態</li>
</ul>
<ul>
<li><em>[[PromiseValue]]</em>: <code>undefined</code>  -&gt; 表示 <code>resolve</code> 或 <code>reject</code> 回傳的值</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2FA14E1FA8-23ED-4317-B421-F0555976FE69.png?alt=media&amp;token=a5199945-3cc6-4f06-8050-218ab1eeee91" alt=""></p>
<p>以下範例來說，執行完函式直接 <code>reject(&#39;失敗&#39;)</code>，最終也能取得 rejected 的狀態及值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;reject(<span class="string">&#x27;失敗&#x27;</span>);&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.dir(promise());</span><br></pre></td></tr></table></figure></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2FFC09AAC0-B91B-41FA-862C-0966731A2B18.png?alt=media&amp;token=552d26ae-9e63-4d1b-8d07-4e9c3a05e53a" alt=""></p>
<h2 id="建立自己的-Promise"><a href="#建立自己的-Promise" class="headerlink" title="建立自己的 Promise"></a>建立自己的 Promise</h2><p>如果要熟悉 Promise，最好的方式莫過於自己撰寫一次 Promise。</p>
<p>Promise 預設會帶入 resolve, reject 的參數（可自訂名稱，但大家習慣 resolve 及 reject），resolve 代表成功；reject 代表失敗，而兩者必定只能回傳其中之一，且必定只能回傳一次。</p>
<p>函式陳述式建立以後，直接透過 <code>return new Promise</code> 回傳並建立一個 Promise 物件，並且在內部加入一個執行函式且帶上 <code>resolve, reject</code> 的參數，到這個階段就是常見的 Promise 結構，接下來在依據執行的結果來透過 <code>resolve, reject</code> 回傳值即可（以下範例會隨機調用 resovle 及 reject）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 隨機取得 0 or 1</span></span><br><span class="line">    <span class="keyword">const</span> num = <span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 則執行 resolve，否則執行 reject</span></span><br><span class="line">    <span class="keyword">if</span> (num) &#123; </span><br><span class="line">      resolve(<span class="string">&#x27;成功&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    reject(<span class="string">&#x27;失敗&#x27;</span>)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在呼叫前 Promise 前回顧一下 Promise 會有三個狀態：</p>
<ul>
<li>Pending -&gt; 尚未得到結果</li>
<li>Resolved：事件已經執行完畢且成功操作，回傳 <code>resolve</code> 的結果</li>
<li>Rejected：事件已經執行完畢但操作失敗，回傳 <code>rejected</code> 的結果</li>
</ul>
<p>上列的三種狀態每次執行必定會經過 Pending，接下來進入 Fulfilled 或 Rejected 的其中之一，並且可以使用 <code>then()</code> 及 <code>catch()</code> 取得成功或失敗的結果。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2Fimg-promise-resovle_reject.png?alt=media&amp;token=88067e09-92d4-4c67-9455-d13e4c5f22cc" alt=""></p>
<p>在 <code>.then(onFulfilled, onRejected)</code>中可帶入兩個回呼函式，兩者分別又可以帶入各自的參數：</p>
<ul>
<li><code>onFulfilled</code>：執行成功的函式，所帶入參數表示 Promise 函式中 <code>resolve</code> 所帶入的值。</li>
<li><code>onRejected</code>：執行失敗的函式，帶入參數表示 Promise 函式中 <code>reject</code> 所帶入的值。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise.then(onFulfilled, onRejected);</span></span><br><span class="line"><span class="comment">// 前者為 resolve callback，後者則為 reject</span></span><br><span class="line">promise()</span><br><span class="line">  .then(<span class="function">(<span class="params">success</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(success);</span><br><span class="line">  &#125;, <span class="function">(<span class="params">fail</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fail);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>在大部分情況下，開發者習慣僅使用 <code>.then()</code> 來取得成功的結果，失敗的部分交由 <code>catch(onRejected)</code> 來處理，這兩種寫法差異很小。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// promise.then(onFulfilled);</span></span><br><span class="line"><span class="comment">// promise.catch(onRejected)</span></span><br><span class="line">promise()</span><br><span class="line">  .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(success);</span><br><span class="line">  &#125;)</span><br><span class="line">    <span class="comment">// 失敗的行為一律交給了 catch</span></span><br><span class="line">  .catch(<span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fail);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<h3 id="鏈接"><a href="#鏈接" class="headerlink" title="鏈接"></a>鏈接</h3><p>為了確保非同步完成後才執行另一個方法，過去都只能不斷的透過 callback 的方式來確保下一個方法正確執行，網路上如果搜尋 callback hell 也可以看到相關的文章及程式碼波動拳的圖片。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2FE555E697-1EA5-460A-86BF-C640B2E568CF.png?alt=media&amp;token=06affb69-e3bb-4733-b783-537779c0a741" alt=""></p>
<p>Promise 另一個特點在於 <code>then</code>、<code>catch</code> 都可以使用鏈接的方式不斷的進行下一個任務，在此範例中我們修改 Promise 的結果，改成傳入 <code>0</code> 則會調用 <code>reject</code>，其它數值則會調用 <code>resolve</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    num ? resolve(<span class="string">`<span class="subst">$&#123;num&#125;</span>, 成功`</span>) : reject(<span class="string">&#x27;失敗&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>接下來，當我們要進行確保 Promise 任務結束後在進行下一個任務時，就可以使用 <code>return</code> 的方式進入下一個 then，此 return 也有以下特點：</p>
<ul>
<li>方法不限於 promise 函式，任何表達式（expression）都可進行回傳</li>
<li>如果是 promise 函式，則會繼續遵循 then 及 catch 的運作</li>
<li>如果不是  promise 函式，在下一個 then 則可以取得結果<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">promise(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(success);</span><br><span class="line">    <span class="keyword">return</span> promise(<span class="number">2</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(success);</span><br><span class="line">    <span class="keyword">return</span> promise(<span class="number">0</span>); <span class="comment">// 這個階段會進入 catch</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;   <span class="comment">// 由於上一個階段結果是 reject，所以此段不執行</span></span><br><span class="line">    <span class="built_in">console</span>.log(success);</span><br><span class="line">    <span class="keyword">return</span> promise(<span class="number">3</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">fail</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(fail);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Then-VS-Catch-的失敗回呼差異"><a href="#Then-VS-Catch-的失敗回呼差異" class="headerlink" title="Then VS Catch 的失敗回呼差異"></a>Then VS Catch 的失敗回呼差異</h3><p><code>then</code>、<code>catch</code> 都可以透過進行鏈接，上述也有提到 <code>then</code> 同時也能接收失敗的結果，在此用圖示表示兩者在執行上不同的結果。</p>
<p>不使用 <code>then</code> 接收失敗：無論在哪一個階段遇到 reject 時，接下來會直接跳到 <code>catch</code>，在其後的 <code>then</code> 都不會執行。另外提一下：<code>catch</code> 依然可以使用 <code>return</code> 繼續串接（實戰中很少這樣寫）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F3484D2DC-3CF9-4292-B019-C7D76C448F13.png?alt=media&amp;token=3e68ed68-cbc0-4be2-88ca-c24d31c5e07e" alt=""></p>
<p>使用 <code>then</code> 接收失敗：<code>then</code> 中的兩個函式必定執行其中一個（onFulfilled, onRejected），可以用此方式確保所有的鏈接都能夠被執行。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2FE4D3FA80-B070-4B23-9E3C-A58CE60C3C8C.png?alt=media&amp;token=ba0ccc0b-13ba-4425-a878-eeaeddc30ed9" alt=""></p>
<h3 id="Finally-完成"><a href="#Finally-完成" class="headerlink" title="Finally 完成"></a>Finally 完成</h3><p>最後方可以使用 finally 來確認工作結束，<code>finally</code> 不帶有任何參數。這個方法適合用來作為 Ajax 已經讀取完成，透過 <code>finally</code> 來關閉讀取的效果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">promise(<span class="number">1</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">success</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(success);</span><br><span class="line">  &#125;).finally(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;done&#x27;</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="使用-Promise-改寫-XMLHttpRequest"><a href="#使用-Promise-改寫-XMLHttpRequest" class="headerlink" title="使用 Promise 改寫 XMLHttpRequest"></a>使用 Promise 改寫 XMLHttpRequest</h2><p>Promise 很大一部份是用來處理 Ajax 行為，此段透過改寫的形式了解使用 Promise 及傳統的寫法有哪些差異。</p>
<p>傳統上，需透過 <code>XMLHttpRequest</code> 建構式來產生可進行遠端請求的物件，並且依序定義方法(<code>GET</code>)及狀態(<code>onload</code>)並送出請求(<code>send</code>)，取得結果後的其它行為則需要撰寫在 <code>onload</code> 內，程式碼結構如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> url = <span class="string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定義 Http request</span></span><br><span class="line"><span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定義方法</span></span><br><span class="line">req.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 當請求完成，則進行函式的結果</span></span><br><span class="line">req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (req.status == <span class="number">200</span>) &#123;</span><br><span class="line">    <span class="comment">// 成功直接列出結果</span></span><br><span class="line">    <span class="built_in">console</span>.log(req.response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 失敗的部分</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 送出請求</span></span><br><span class="line">req.send();</span><br></pre></td></tr></table></figure></p>
<p>接下來將以上的行為封裝至 <code>get</code> 函式內，此函式包含 Promise 及上述的 <code>XMLHttpRequest</code> 行為，運用時只要直接使用 <code>get(url)...</code>，接下來的運用方式則是符合 Promise 的結構，重複運用的情況下程式碼可以大幅提高易讀性。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 定義 Http request</span></span><br><span class="line">    <span class="keyword">var</span> req = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    req.open(<span class="string">&#x27;GET&#x27;</span>, url);</span><br><span class="line">    req.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (req.status == <span class="number">200</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 resolve 回傳成功的結果，也可以在此直接轉換成 JSON 格式</span></span><br><span class="line">        resolve(<span class="built_in">JSON</span>.parse(req.response));</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 reject 自訂失敗的結果</span></span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(req))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    req.send();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 往後的 HTTP 直接就能透過 get 函式取得</span></span><br><span class="line">get(<span class="string">&#x27;https://jsonplaceholder.typicode.com/todos/1&#x27;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;)</span><br><span class="line">  .catch(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(res)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<h2 id="Promise-方法"><a href="#Promise-方法" class="headerlink" title="Promise 方法"></a>Promise 方法</h2><p>最後，介紹 Promise 中其它的方法，就 Promise 的物件下，展開後可以看到以下方法：</p>
<ul>
<li>Promise API<ul>
<li>all -&gt; 多個 Promise 行為同時執行，全部完成後統一回傳。</li>
<li>race -&gt; 多個 Promise 同時執行，但僅回傳第一個完成的。</li>
<li>Promise.reject, Promise.resolve -&gt; 定義 Fulfilled 或 Rejected 的 Promise 物件。</li>
</ul>
</li>
</ul>
<p>此段用下方定義的 promise 函式做說明，可以傳入兩個參數：</p>
<ul>
<li>num: 此 Promise 執行成功與否</li>
<li>time: 此 Promise 所執行的時間長度<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">promise</span>(<span class="params">num, time = <span class="number">500</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      num ? resolve(<span class="string">`<span class="subst">$&#123;num&#125;</span>, 成功`</span>) : reject(<span class="string">&#x27;失敗&#x27;</span>);</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><p>透過陣列的形式傳入多個 promise 函式，在全部執行完成後回傳<strong>陣列結果</strong>，陣列的結果順序與一開始傳入的一致。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([promise(<span class="number">1</span>), promise(<span class="number">2</span>), promise(<span class="number">3</span>, <span class="number">3000</span>)])</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>
<p>這個方法很適合用在多支 API 要一起執行，並確保全部完成後才進行其他工作時。</p>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h3><p>透過陣列的形式傳入多個 promise 函式，在全部執行完成後回傳<strong>單一結果</strong>，結果為第一個運行完成的，以下範例來說就會回傳 <code>promise(1)</code> 的結果。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race([promise(<span class="number">1</span>), promise(<span class="number">2</span>), promise(<span class="number">3</span>, <span class="number">3000</span>)]).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>這個方法可以用在站點不穩定，同時發送多支同行為 API 確保可行性使用，但實作中使用率並不高。</p>
<h3 id="Promise-reject-Promise-resolve"><a href="#Promise-reject-Promise-resolve" class="headerlink" title="Promise.reject, Promise.resolve"></a>Promise.reject, Promise.resolve</h3><p>這兩個方法是直接定義 Promise 物件已經完成的狀態（resolve, reject），與 new Promise 一樣會產生一個新的 Promise 物件，但其結果是已經確定的，以下提供範例說明：</p>
<p>使用 <code>Promise.resolve</code> 產生一個新的 Promise 物件，此物件可以使用 then 取得 resolve 的結果。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2FF06BCD1A-091F-401C-98F5-EAA6AD629530.png?alt=media&amp;token=284edbcc-4466-42bc-960d-ffd91c73bee0" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">Promise</span>.resolve(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line">result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;resolved&#x27;</span>, res); <span class="comment">// 成功部分可以正確接收結果</span></span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;rejected&#x27;</span>, res); <span class="comment">// 失敗部分不會取得結果</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>改為 <code>Promise.reject</code> 產生 Promise 物件，此物件必定呈現 rejected 的結果。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="built_in">Promise</span>.reject(<span class="string">&#x27;result&#x27;</span>);</span><br><span class="line">result.then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res); <span class="comment">// 只有此段會出現結果</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// rejected result</span></span><br></pre></td></tr></table></figure></p>
<p>注意：<code>Promise.reject</code>、<code>Promise.resolve</code> 是直接定義結果，無論傳入的是否為 Promise 物件。</p>
<p>參考文章：</p>
<ul>
<li>Google 開發者文件：<a href="https://developers.google.com/web/fundamentals/primers/promises">https://developers.google.com/web/fundamentals/primers/promises</a></li>
<li>MDN Promise：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise">https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
            <tag> js </tag>
            
            <tag> promise </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[單元測試 - 非同步及 Ajax]]></title>
      <url>https://wcc723.github.io/development/2020/02/09/jest-async/</url>
      <content type="html"><![CDATA[<p>本篇延續上一篇：<a href="/development/2020/02/02/jest-intro/">十分鐘上手前端單元測試 - 使用 Jest</a></p>
<p>JavaScript 是屬於同步，單執行緒的程式語言，因此當有非同步的事件時就會被往放到事件佇列，直到所有程式碼運行過後才會執行事件佇列內的程式，如果不熟悉這段觀念就會使程式的運行不符合預期，相關概念可以看此文章<a href="https://wcc723.github.io/javascript/2017/12/07/javascript-event-queue/">一次只能做一件事情的 JavaScript</a>。</p>
<p>另外，現在的非同步大多都使用 Promise 來撰寫，包含 ES6 的 Fetch 及許多遠端請求的套件亦是使用 Promise 作為基礎。因此在撰寫 Jest 撰寫非同步測試時也會使用到相關的概念，至於 Promise 可參考 <a href="https://wcc723.github.io/javascript/2017/12/29/javascript-proimse/">使用 Promise 處理非同步</a></p>
<h2 id="範例函式"><a href="#範例函式" class="headerlink" title="範例函式"></a>範例函式</h2><p>這次的測試目標是使用 Ajax Get 取得遠端資料，並且確保遠端的資料是符合預期的。<a href="https://jsonplaceholder.typicode.com/">JSONPlaceholder</a> 此服務可以供前端模擬 Ajax 行為，包含 GET、POST、PUT、DELETE 都可以練習，同時也可以使用 id 的方式取得固定的資料內容。</p>
<p>使用的遠端資料 API 路徑（最後一個數字則是 id，可確保取得固定資料）：<br><a href="https://jsonplaceholder.typicode.com/todos/1">https://jsonplaceholder.typicode.com/todos/1</a></p>
<p>該路徑取得的格式及值如下，本次將會驗證 <code>title</code> 的值是否為 “delectus aut autem”：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  userId: 1,</span><br><span class="line">  id: 1,</span><br><span class="line">  title: &quot;delectus aut autem&quot;,</span><br><span class="line">  completed: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>除此之外，我們還會使用 axios 此套件來取得遠端資料，這是一個基於 Promise 開發的 HTTP 請求工具，可運用於瀏覽器或 Node.js 上（<a href="https://github.com/axios/axios">axios</a>），使用以下指令安裝 axios：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure></p>
<p>接下來在範例專案引入 axios，並且取得遠端資料。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> axios = <span class="built_in">require</span>(<span class="string">&#x27;axios&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fns = &#123;</span><br><span class="line">  fetchData: <span class="function">(<span class="params">num = <span class="number">1</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> axios</span><br><span class="line">      .get(<span class="string">`https://jsonplaceholder.typicode.com/todos/<span class="subst">$&#123;num&#125;</span>`</span>)</span><br><span class="line">      .then(<span class="function"><span class="params">res</span> =&gt;</span> res.data)</span><br><span class="line">      .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="string">&#x27;error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果透過 <code>console.log()</code> 檢視此段函式，可以發現他所回傳的是 Promise 函式，並非遠端的值。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(fns.fetchData())</span><br></pre></td></tr></table></figure></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F11509BFB-F255-4C09-8A79-F12EDB14D609.png?alt=media&amp;token=0c0b0157-1e19-4e20-b5ff-ab25a86309e7" alt=""></p>
<p>如果要正確取得遠端值，則必需使用 <code>then</code> 這個方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fn.fetchData(<span class="number">1</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="錯誤範例"><a href="#錯誤範例" class="headerlink" title="錯誤範例"></a>錯誤範例</h2><p>JavaScript 特性是同步的，它會依序執行所有的程式碼，但遇到「非同步的事件」則會將事件移動到事件佇列內最後執行。因此，測試的預期結果如果是直接放到非同步的後方，則會無法正確取得資料。</p>
<p>以下範例來說：</p>
<ol>
<li><code>fn.fetchData(1)</code> 是屬於非同步事件，因此<strong>會最後才執行</strong>。</li>
<li>因為 fn.fetchData(1)  是最後執行，所以 <code>expect(data.title)</code> 中的 data 是一開始定義的 <code>&#123;&#125;</code></li>
<li>所以結果必定為 <code>failed</code>（<code>fn.fetchData(1)</code> 不可能先執行完）。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;should 返回值必定為 &quot;delectus aut autem&quot;（沒有正確套用 Promise）&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 非同步必定需要加上 return，才能正確驗證結果</span></span><br><span class="line">  <span class="keyword">let</span> data = &#123;&#125;;</span><br><span class="line">  </span><br><span class="line">  fn.fetchData(<span class="number">1</span>).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    data = res;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// expect 無法正確取得值</span></span><br><span class="line">  expect(data.title).toEqual(<span class="string">&#x27;delectus aut autem&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="非同步"><a href="#非同步" class="headerlink" title="非同步"></a>非同步</h2><p>Promise 是常見的非同步的方法，基於 Promise 上還可以使用 Async、Await，這兩種寫法在 Node.js 中都可以運行，因此也都可以導入 Jest 中撰寫。</p>
<h3 id="使用-Promise"><a href="#使用-Promise" class="headerlink" title="使用 Promise"></a>使用 Promise</h3><p>由於上述提到 <code>fn.fetchData</code> 會直接回傳 Promise 函式，Promise 執行完後回傳的值則必須使用 then 來取出，測試的期望及匹配也就必須寫在 then 之內，確保 Promise 已經執行完成。</p>
<p>所以只要將先前範例中的 <code>expect()</code> 移動到 <code>then</code> 內部基本上就能運作。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非同步：Promise 寫法</span></span><br><span class="line">test(<span class="string">&#x27;should 返回值必定為 &quot;delectus aut autem&quot;&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 斷言，確保非同步有正確取得資料</span></span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 當有使用 assertions 則必需加上 return，才能正確驗證結果</span></span><br><span class="line">  <span class="comment">// The assertion for a promise must be returned.</span></span><br><span class="line">  <span class="keyword">return</span> fn.fetchData(<span class="number">1</span>).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    expect(data.title).toEqual(<span class="string">&#x27;delectus aut autem&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="斷言"><a href="#斷言" class="headerlink" title="斷言"></a>斷言</h3><p>在前面的範例中，如果移除 <code>expect.assertions</code> 還是可以正確運作，而 <code>assertions</code> 的目的是確保有完整取得 Promise 資料，可以將程式碼改為如下將得到不同結果：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 此段範例中，Promise 直接進入 Catch 則會通過驗證</span></span><br><span class="line"><span class="comment">// 因為 catch 回傳的 &#x27;error&#x27; 與期望值一致</span></span><br><span class="line">test(<span class="string">&#x27;assertions 驗證&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fn.fetchData(<span class="number">1</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> expect(e).toMatch(<span class="string">&#x27;error&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>如果要確保程式碼正確取得 Promise Resolve 的結果，就可以使用 <code>expect.assertions(num)</code>（num 表示斷言的數量）。</p>
<p>當補上 <code>expect.assertions(1)</code> 就必須使用 resolve 的結果才能通過驗證，<code>expect.assertions</code> 在 async 的寫法上也會更顯得重要。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;assertions 驗證&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> fn.fetchData(<span class="number">1</span>).catch(<span class="function"><span class="params">e</span> =&gt;</span> expect(e).toMatch(<span class="string">&#x27;error&#x27;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用-ES6-Async-Await"><a href="#使用-ES6-Async-Await" class="headerlink" title="使用 ES6 Async, Await"></a>使用 ES6 Async, Await</h3><p>JavaScript 特性是同步的，它會依序執行所有的程式碼。但在 ES6 中，只要將函式轉為 Async 函式，就可以使用 <code>await</code> 來接受 Promise 回傳的結果，相對於 Promise 來說，await 不需要另外使用 then 或函式的巢狀結構，並且會<strong>依序執行</strong> Promise 的事件，也因為這個特性使非同步原始碼不需要寫得很 “巢”。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;should 回傳值必定為 &quot;delectus aut autem&quot;（async）&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// async 函式下，await 會確保取得遠端資料後才繼續往下運行</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fn.fetchData(<span class="number">1</span>);</span><br><span class="line">  expect(data.title).toEqual(<span class="string">&#x27;delectus aut autem&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="驗證特定屬性是否存在"><a href="#驗證特定屬性是否存在" class="headerlink" title="驗證特定屬性是否存在"></a>驗證特定屬性是否存在</h3><p>除此之外，遠端資料相對於本地端是更不可預期的，因為蝴蝶效應的關係，後端改了程式碼可能沒有知會前端，導致前端程式碼發生不可預期的錯誤（但開發者可能找不到原因），測試中也可以導入特定欄位是否存在的驗證。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;驗證非同步 特定屬性是否已被定義&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  expect.assertions(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fn.fetchData(<span class="number">1</span>);</span><br><span class="line">  expect(data.title1).toBeDefined();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>參考資料：<br>參考：</p>
<ul>
<li>官方文件：<a href="https://jestjs.io/en/">https://jestjs.io/en/</a></li>
<li>影片：<a href="https://www.youtube.com/watch?v=7r4xVDI2vho">https://www.youtube.com/watch?v=7r4xVDI2vho</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test </tag>
            
            <tag> jest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十分鐘上手前端單元測試 - 使用 Jest]]></title>
      <url>https://wcc723.github.io/development/2020/02/02/jest-intro/</url>
      <content type="html"><![CDATA[<p>隨著應用程式越來越大，人工流程的測試也會耗去許多的時間，許多功能再開發後都必須重新進行點擊特定目標、撰寫複雜表單、送出來檢驗功能的正確性，當功能越來越複雜時，人工測試所花的時間也會越來越常，因此改用測試工具相對會節省去許多時間。尤其到了上線時才發現錯誤，那時候心中真的會吶喊 No、No、No～。</p>
<p>前端的測試常見的有兩大類別：</p>
<ol>
<li>Unit Test：中文稱為單元測試，是以一個行為進行測試，可驗證運行是否符合結果。</li>
<li>E2E Test：直接模擬使用者在瀏覽器上的行為做測試</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_2_2_%E4%B8%8A%E5%8D%889_40.png?alt=media&amp;token=251f2e66-b504-4c1e-904f-d07c0f33ce23" alt="Unit 是小單位的測試，而 E2E 則是完整的應用測試"></p>
<blockquote>
<p>圖片來源：<a href="https://vuejsdevelopers.com/2019/04/01/vue-testing-unit-vs-e2e/">Unit vs E2E Testing for Vue.js</a></p>
</blockquote>
<p>因此 Unit Test 相對來說測試成本降低非常多，在任何時間點都可以優先導入測試（甚至在開發前 - TDD），雖然測試聽起來要另外撰寫程式碼做驗證，但撰寫並不一定會花上許多時間（思考驗證邏輯反而會花上許多），但好的測試可以帶來許多的優點：</p>
<ul>
<li>避免修改程式碼後的錯誤：修改程式的過程中可能會發生蝴蝶效應，A 處修改的原始碼卻使看似毫無關聯的 B 處錯誤。</li>
<li>不需要每次修改都重新人工測試</li>
</ul>
<p>除此之外，身為一個工程師看不慣前輩（或是過去的自己）的 Code 是很正常的，但重構同時也會帶來風險，如何確保新舊程式碼之間的結果一致是相對困難的過程。</p>
<h2 id="Jest"><a href="#Jest" class="headerlink" title="Jest"></a>Jest</h2><p>本篇會以 Jest 作為起手式介紹，後續也會另外介紹一篇 E2E 的測試框架。Jest 在 React 界有許多開發者推薦使用，Vue 的 Cli 中也是可做為預設的單元測試選項。</p>
<p>單元測試的基本觀念是對 <code>function</code> 進行測試，但許多同學可能聽到 “測試” 就會覺得些許的麻煩。接下來我們透過一個小故事來介紹單元測試中的各種行為。</p>
<blockquote>
<p>小明是一間麥當當分店的店長，接下來要為新進的員工進行評鑑，因此他模擬了顧客行為要在麥當當買大麥克套餐 127 元，並且使用百元鈔票付款，因此他會拿出 200 元現金，預期讓點餐員找回正確的零錢。</p>
</blockquote>
<p>因此，這段對應到單元測試會有以下流程：</p>
<ol>
<li>測試的目標為何？ -&gt; 會使用一段文字描述做什麼、期望的結果為何<ul>
<li>小明決定拿出 200 元，心裡想著「拿 200 元買套餐，預期會找 73 元」</li>
</ul>
</li>
<li>導入要測試的函式 -&gt; 實際運行的過程<ul>
<li>點餐員收走了 200 元減去大麥克套餐的 127 元，得到了 73 元找給了小明</li>
</ul>
</li>
<li>測試的期望是什麼？ -&gt; 驗證的期望值，可以用各種方式比對結果<ul>
<li>小明收了錢後，算了算確實是 73 元沒有錯</li>
</ul>
</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2Fimg-jest%20img-01.png?alt=media&amp;token=6f5fe263-ca87-4b7f-8129-354f898a9d8d" alt=""></p>
<p>在這個過程中就有可能發生：</p>
<ul>
<li>點餐員不夠專業，找錢的過程出錯</li>
<li>小明的預期是錯誤的，可能小明在一開始就沒規劃好，也沒算準導致錯誤</li>
</ul>
<p>無論如何，接下來我們將透過實際的程式碼來介紹上述的過程。</p>
<h3 id="驗證點餐員的行為是否符合預期"><a href="#驗證點餐員的行為是否符合預期" class="headerlink" title="驗證點餐員的行為是否符合預期"></a>驗證點餐員的行為是否符合預期</h3><p>接下來，我們會新增兩個檔案，一個是點餐員的行為，另一個是測試整個過程的腳本。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|- employee.js          點餐員的行為</span><br><span class="line">|- employee.test.js     點餐員的測試腳本</span><br></pre></td></tr></table></figure></p>
<p>點餐員目前只有一個行為就是找零錢，他會接收兩個數值（顧客的現鈔、餐點的價格），並且回傳一個結果（找的零錢）。注意：<strong>這個檔案必需 export 才能被測試檔案接收並測試</strong>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> employee = &#123;</span><br><span class="line">  makeChange: <span class="function"><span class="keyword">function</span>(<span class="params">bill, price</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bill - price;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = employee;</span><br></pre></td></tr></table></figure></p>
<p>命名一個中間補上 <code>.test.</code> 的檔名作為測試檔（這是測試預設的檔名），接下來在此補上要測試的內容。測試的過程中會明確的標上「測試的目標描述<code>test(...)</code>」，並且定義「測試的結果是否符合預期<code>expect()...</code>」<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> employee = <span class="built_in">require</span>(<span class="string">&#x27;./employee&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 明確描述測試的目標：&#x27;拿 200 元買套餐，預期會找 73 元&#x27;</span></span><br><span class="line">test(<span class="string">&#x27;拿 200 元買套餐，預期會找 73 元&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> bill = <span class="number">200</span>;  <span class="comment">// 小明手中的鈔票</span></span><br><span class="line">  <span class="keyword">const</span> price = <span class="number">127</span>; <span class="comment">// 餐點的價格</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 期望找錢的結果是符合預期的</span></span><br><span class="line">  expect(employee.makeChange(bill, price)).toBe(<span class="number">73</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>準備安裝環境及測試結果</strong>，在上述過程中已經將原始碼及測試的過程都準備好，接下來只要小步驟就能將測試環境導入：</p>
<ol>
<li>輸入 <code>npm install jest --save-dev</code> 安裝 Jest</li>
<li>打開 <code>package.json</code> 內將 script 內新增方法並加入 <code>jest</code>。</li>
</ol>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;jest&quot;</span>: <span class="string">&quot;^24.9.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;jest&quot;</span> <span class="comment">// 運行 test 的方法時，會使用 jest 作為套件開始運行</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>輸入 <code>npm run test</code> 查看結果</li>
</ol>
<p>如果過程沒有錯誤，你應該可以在終端機下看到以下結果，我們定義了一個目標「拿 200 元買套餐，預期會找 73 元」，這個測試結果是沒有問題的。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F2E447489-6AE1-4689-A4D9-F8DC81289B50.png?alt=media&amp;token=dba98c41-cd79-4324-b76c-0483fc4db5c3" alt=""></p>
<p>到此，已經掌握到基礎的測試過程，提出一個目標並且使期望值通過（心中是否會聽到 Yes、Yes、Yes 的聲音呢？）。</p>
<p><img src="https://i.ytimg.com/vi/ixoK4PV7x0A/maxresdefault.jpg" alt=""></p>
<p>監控測試：也可以將 <code>scripts</code> 中的方法改為如下，就可以不需要每次都重新輸入 <code>npm run test</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;jest&quot;</span>: <span class="string">&quot;^24.9.0&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;testwatch&quot;</span>: <span class="string">&quot;jest --watchAll&quot;</span></span><br><span class="line"> <span class="comment">// 使用 npm run testwatch 時會持續用監控的形式，而不是只有單一次報告</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>藉此，相信你對於測試有基本的概念，在進入下一個階段前可以先回顧一下三個階段：</p>
<ol>
<li>測試的目標為何？ -&gt; <code>test(&#39;...&#39;, ()=&gt;&#123;&#125;)</code></li>
<li>導入要測試的函式 -&gt; <code>employee.makeChange()</code></li>
<li>測試的期望是什麼？  -&gt; <code>expect(...).toBe(...);</code></li>
</ol>
<h4 id="專案結構調整"><a href="#專案結構調整" class="headerlink" title="專案結構調整"></a>專案結構調整</h4><p>透過範例了解以後，我們稍微調整一下專案結構，便於後續的介紹：</p>
<p>資料夾目錄與上述接近，將 <code>employee</code> 改為 <code>fn</code>，用來定義多個函式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">|- fn.js          原始的測試檔案</span><br><span class="line">|- fn.test.js     測試的腳本</span><br></pre></td></tr></table></figure></p>
<p>JS 檔案中，透過物件定義多個行為。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fns = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fns;  <span class="comment">// 將函式給予匯出</span></span><br></pre></td></tr></table></figure></p>
<p><code>fn.test.js</code> 這個測試檔案將匯入上述的函式檔案，並且開始進行測試：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fn  = <span class="built_in">require</span>(<span class="string">&#x27;./fn&#x27;</span>);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;...&#x27;</span>, <span class="function">()=&gt;</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>準備好以後，我們來繼續往下介紹吧！</p>
<h2 id="搭配-VSCode-環境"><a href="#搭配-VSCode-環境" class="headerlink" title="搭配 VSCode 環境"></a>搭配 VSCode 環境</h2><p>除了使用終端機外，Jest 與 VSCode 也能有很好的整合，不需要每次運行都輸入 <code>npm run test</code>，搭配套件使用即可在每次存檔後看到測試的結果。</p>
<p>套件連結：<a href="https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest">https://marketplace.visualstudio.com/items?itemName=Orta.vscode-jest</a></p>
<p>接下來新增一個 <code>jest.config.js</code>，此測試檔案預設僅需要匯出一個空的即可運作（全部使用官方預設即可），參考如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">|- fn.js          原始的測試檔案</span><br><span class="line">|- fn.test.js     測試的腳本</span><br><span class="line">|- jest.config.js 新增的 Jest 設定檔案</span><br></pre></td></tr></table></figure>
<p>在測試的文檔右方即可看到測試成功的 v，如果是失敗狀態則會出現紅色的 x。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F2CB85F9B-3BA8-48CE-B4BD-8CF8A32C9C1B.png?alt=media&amp;token=03914775-ba75-47b9-919c-2445c94a32cc" alt=""></p>
<p>錯誤的狀態如下，會出現 x ，並且在 expect 行列上出現紅色下底線，游標在上時會提供預期值及實際接收值。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2FF35348BD-B7EC-4441-BCB1-DD8A3E8A07ED.png?alt=media&amp;token=609c5d0c-984b-4a8f-a3a7-8a332fcb51f6" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F1048885A-1DDF-4B73-B3C2-39C4ECE34B36.png?alt=media&amp;token=6bc20e4e-0333-458b-85de-1ffbefd2b3da" alt=""></p>
<h3 id="VSCode-片段提示"><a href="#VSCode-片段提示" class="headerlink" title="VSCode 片段提示"></a>VSCode 片段提示</h3><p>每次都要重新輸入 <code>test(&#39;....&#39;, ()=&gt; &#123;&#125;)</code> 或各種驗證覺得麻煩嗎？Jest 的各種語法都很好理解，但反覆輸入真的會花上許多時間，因此可以透過 Snippets 來增快寫測試的速度。</p>
<p><a href="https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets">https://marketplace.visualstudio.com/items?itemName=andys8.jest-snippets</a></p>
<p>使用方式，輸入比對方法中的首字及其後的大寫字母（建議直接從 Jest 官方文件去做聯想，可以學得更快），參考如下：</p>
<ul>
<li><code>tb</code> -&gt; <code>expect().toBe();</code></li>
<li><code>tblt</code> -&gt; <code>expect().toBeLessThan();</code></li>
<li><code>tblte</code> -&gt; <code>expect().toBeLessThanOrEqual();</code></li>
</ul>
<p>基本的起手式，也可以輸入 <code>test</code> + <code>tab</code> 即可出現以下片段：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;should &#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在測試的檔案下，輸入特定字母也會提示具有哪些片段可用。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F99D96F65-1C61-469E-87C2-150D2F64D4D5.png?alt=media&amp;token=1e907cfd-7ce4-461f-ac65-0f71b3bfe079" alt=""></p>
<h2 id="常見的條件驗證方式-matchers"><a href="#常見的條件驗證方式-matchers" class="headerlink" title="常見的條件驗證方式 - matchers"></a>常見的條件驗證方式 - matchers</h2><p>編寫測試時需要讓值符合期望，Jest 中的 expect 後方可以使用 <code>matchers</code>（匹配器）作為條件驗證，如先前的範例 <code>expect(...).toBe(...);</code> 中的 <code>toBe</code> 就屬於 <code>matchers</code>，作為各種不同條件的驗證使用。</p>
<p>如果是熟悉 JavaScript 的開發者，可以直接看 Jest <a href="https://jestjs.io/docs/en/22.x/expect">官方文件</a> expect 的部分，所有的 <code>matchers</code> 皆陳列於此，本段落會列出實際開發中常見的 <code>matchers</code>，有了基礎概念後，對於官方所提供的文件也能更快上手。</p>
<p>在 <code>fn.js</code> 中先定義多個方法，這些方法會回傳數值、<code>null</code>、<code>undefined</code> 等各種純值，另外還會回傳<strong>物件</strong>（物件的驗證概念會與純值不同）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始碼</span></span><br><span class="line"><span class="keyword">const</span> fns = &#123;</span><br><span class="line">  add: <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2,</span><br><span class="line">  isNull: <span class="function">() =&gt;</span> <span class="literal">null</span>,</span><br><span class="line">  isUndefined: <span class="function">() =&gt;</span> <span class="literal">undefined</span>,</span><br><span class="line">  <span class="built_in">isNaN</span>: <span class="function">() =&gt;</span> <span class="literal">NaN</span>,</span><br><span class="line">  checkValue: <span class="function">(<span class="params">val</span>) =&gt;</span> val,</span><br><span class="line">  createUser: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在純值的驗證上相對單純，除了 <code>toBe</code> 外，有各種直白的 <code>matchers</code> 可供利用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toBe：使值完全符合，判斷是使用 Object.is</span></span><br><span class="line"><span class="comment">// 概念接近於 `===`</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 相加是否正確&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.add(<span class="number">5</span>, <span class="number">5</span>)).toBe(<span class="number">10</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// toBeNull：測試回傳值是否為 null</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 Null&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.isNull()).toBeNull();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// toBeUndefined：測試回傳值是否為 undefined</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 Undefined&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.isUndefined()).toBeUndefined();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在 JavaScript 中，如果使用 <code>NaN === NaN</code> 則會回傳 False，官方另有提供 <code>toBeNaN</code> 作為驗證，但其實使用 <code>toBe(NaN)</code>也能通過，主要原因 toBe 是使用 <code>Object.is</code> 的方法，相關討論可參考 <a href="https://github.com/facebook/jest/issues/4907">NaN check</a>：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// toBeNaN：測試回傳值是否為 NaN</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 是否為 NaN&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.isNaN()).toBeNaN();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>真值、假值（<code>truthy</code>、<code>falsy</code>）是判斷式中的判斷依據，並不一定完全是布林值的 <code>true</code> or <code>false</code>，所以在此就不適合使用 <code>toBe</code>，可以使用 <code>toBeFalsy</code>、<code>toBeTruthy</code> 進行驗證。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是判斷真值與</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 是否為假值&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.checkValue(<span class="number">0</span>)).toBeFalsy();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 是否為真值&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.checkValue(<span class="number">1</span>)).toBeTruthy();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h3 id="物件比對"><a href="#物件比對" class="headerlink" title="物件比對"></a>物件比對</h3><p>JavaScript 的特性之一，<strong>物件是傳參考而不是傳值</strong>（關鍵字可查詢：Javascript call by sharing）。</p>
<p>以下列範例來說，雖然物件內的值是相同的，但因為物件是傳參考的特性，所以最終所回傳的結果還是 <code>false</code>。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(user === &#123;<span class="attr">name</span>: <span class="string">&#x27;小明&#x27;</span>&#125;); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>在 Jest 也是相同的概念，如果直接使用 <code>toBe</code> 來比對物件，就算其內部的屬性值是相同的，一樣會得到 <code>failed</code> 的結果。</p>
<p>範例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 原始碼</span></span><br><span class="line"><span class="keyword">const</span> fns = &#123;</span><br><span class="line">  createUser: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test (failed)</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 小明&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.createUser()).toBe(&#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>因此在做物件比對時，必須使用另一個方法 <code>toEqual</code> 才能比對兩個物件內的值是否相同。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test (passed)</span></span><br><span class="line">test(<span class="string">&#x27;測試 fn 是否為 小明&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(fn.createUser()).toEqual(&#123;</span><br><span class="line">    name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="toBe-及-toEqual-的差異"><a href="#toBe-及-toEqual-的差異" class="headerlink" title="toBe 及 toEqual 的差異"></a>toBe 及 toEqual 的差異</h4><p><code>toBe</code> 及 <code>toEqual</code> 語意上都是很接近的，許多情況下兩者混用也會出現相同的結果，但在運作上會有所不同，以下分別列出兩者特點及差異：</p>
<ul>
<li><code>toBe</code> 是使用 <code>Object.is</code> 作為判斷，並非使用 <code>===</code>，所以在部分情況下會與 ECMAScript 有所不同。</li>
<li><code>toEqual</code> 是屬於深度比對（<em>deep equality</em>），一一使用 <code>Object.is</code> 比對物件或陣列內的純值；也由於是深度比對，就如同在物件內將值一一取出重新比對，效能上會較差一些。</li>
</ul>
<p>參考：</p>
<ul>
<li><a href="https://jestjs.io/docs/en/expect#toequalvalue">https://jestjs.io/docs/en/expect#toequalvalue</a></li>
<li><a href="https://jestjs.io/docs/en/expect#tobevalue">https://jestjs.io/docs/en/expect#tobevalue</a></li>
<li>Jasmin（此段說明接近 Jest）：<a href="https://stackoverflow.com/questions/22413009/jasmine-javascript-testing-tobe-vs-toequal">https://stackoverflow.com/questions/22413009/jasmine-javascript-testing-tobe-vs-toequal</a></li>
</ul>
<h3 id="數值比對"><a href="#數值比對" class="headerlink" title="數值比對"></a>數值比對</h3><p>數值比對中也有提供「大於、小於、大於等於、小於等於」等方法，以下直接提供範例做參考：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test</span></span><br><span class="line">test(<span class="string">&#x27;測試數值 是否小於 2000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num1 = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">const</span> num2 = <span class="number">900</span>;</span><br><span class="line">  expect(num1 + num2).toBeLessThan(<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;測試數值 是否小於 2000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num1 = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">const</span> num2 = <span class="number">1000</span>;</span><br><span class="line">  expect(num1 + num2).toBeLessThan(<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;測試數值 是否小於或等於 2000&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> num1 = <span class="number">1000</span>;</span><br><span class="line">  <span class="keyword">const</span> num2 = <span class="number">1000</span>;</span><br><span class="line">  expect(num1 + num2).toBeLessThanOrEqual(<span class="number">2000</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="字串符合"><a href="#字串符合" class="headerlink" title="字串符合"></a>字串符合</h3><p>字串除了 toBe 以外，還可以使用 <code>toMatch</code> 搭配正規表達式進行驗證，以下提供 mail 的驗證供參考：  </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;測試 email 格式是否正確&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(<span class="string">&#x27;gres@gmail.com&#x27;</span>).toMatch(</span><br><span class="line">    /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0<span class="number">-9</span>]+((\.|-)[A-Za-z0<span class="number">-9</span>]+)*\.[A-Za-z]+$/</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">test(<span class="string">&#x27;測試 email 格式是否正確 2&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  expect(<span class="string">&#x27;gres@gmail&#x27;</span>).toMatch(</span><br><span class="line">    /^\w+((-\w+)|(\.\w+))*\@[A-Za-z0<span class="number">-9</span>]+((\.|-)[A-Za-z0<span class="number">-9</span>]+)*\.[A-Za-z]+$/</span><br><span class="line">  );</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="陣列是否包含特定值"><a href="#陣列是否包含特定值" class="headerlink" title="陣列是否包含特定值"></a>陣列是否包含特定值</h3><p>陣列比對上與物件相同，都是使用 <code>toEqual()</code>，另外可以使用 <code>toContain</code> 檢視陣列中是否有包含特定值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test(<span class="string">&#x27;陣列是否包含 Casper&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> newArray = [<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;Someone&#x27;</span>, <span class="string">&#x27;Casper&#x27;</span>];</span><br><span class="line">  expect(newArray).toContain(<span class="string">&#x27;Casper&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h2><p><code>describe</code> 的用途是提供一個群組的描述，以一開始的範例來說，我們可能會驗證點餐員以下行為是正確的：</p>
<ul>
<li>點餐內容與顧客需求相符</li>
<li>結帳金額正確</li>
<li>找零的金額正確</li>
</ul>
<p>那麼 describe 就可以將這些測試定義成一個群組：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">describe(<span class="string">&#x27;僱員的行為測試&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  test(<span class="string">&#x27;點餐內容與顧客需求相符&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  test(<span class="string">&#x27;結帳金額正確&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">  test(<span class="string">&#x27;找零的金額正確&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在使用 <code>npm run test</code> 則可以接受到群組的測試結果。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202002%2F31C2FE55-F215-4D4A-AC34-0286D9AE90EE.png?alt=media&amp;token=b8ed15bc-b6f9-4300-8956-ff979ca74a79" alt=""></p>
<p><code>describe</code> 的群組定義也同樣可以使用巢狀，詳細可見官方網站：<br><a href="https://jestjs.io/docs/en/api#describename-fn">https://jestjs.io/docs/en/api#describename-fn</a></p>
<h2 id="預告"><a href="#預告" class="headerlink" title="預告"></a>預告</h2><p>單元測試難的也並非是語法，更重要的是如何驗證函式的行為與產品邏輯一致。本篇簡單入門了 Jest 的運作方式，接下來還會繼續介紹非同步的測試及框架的實戰測試方法。</p>
<p>參考：</p>
<ul>
<li>官方文件：<a href="https://jestjs.io/en/">https://jestjs.io/en/</a></li>
<li>單元測試和整合測試的涵蓋範圍：<a href="https://ithelp.ithome.com.tw/m/articles/10229734">https://ithelp.ithome.com.tw/m/articles/10229734</a></li>
<li>影片：<a href="https://www.youtube.com/watch?v=7r4xVDI2vho">https://www.youtube.com/watch?v=7r4xVDI2vho</a></li>
<li>神 Q 超人簡報：<a href="https://hackmd.io/@ei_7gAIeSEq2x9U-cH1WoQ/r1FoTHClL">https://hackmd.io/@ei_7gAIeSEq2x9U-cH1WoQ/r1FoTHClL</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> test </tag>
            
            <tag> jest </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[前端開發者，圖片常犯的五個粗心錯誤]]></title>
      <url>https://wcc723.github.io/development/2020/01/04/image-common-mistakes/</url>
      <content type="html"><![CDATA[<p>前端開發者是透過程式碼將資訊呈現成畫面，因此畫面的好壞也多少影響品質，在觀看許多履歷或作業的過程中，會發現許多相似的錯誤，而這些錯誤都是有跡可循，並且可以避免的；本篇先以常見的圖片問題與大家分享，看是否你也犯了這些錯誤呢？</p>
<h2 id="一、圖片變形"><a href="#一、圖片變形" class="headerlink" title="一、圖片變形"></a>一、圖片變形</h2><p>新手錯誤率：⭐⭐⭐⭐<br>令人感受的粗心度：👎👎👎👎</p>
<p>圖片變形是最明顯的錯誤，大部分的使用者都能看到這樣的問題，而這些問題會讓人感受到開發者的不細心。</p>
<p>要避免圖片變形，關鍵在於「避免在 <strong>比例可能會調整</strong> 的空間使用 <code>img</code> 標籤」</p>
<p>以下圖為例：該圖的原始檔案長寬為 <code>1350px * 901px</code> 就比例來說是張橫式的圖片，如果在網頁上的空間提供非此比例則會造成變形。</p>
<p><img src="https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=800&amp;q=80" alt="範例圖片：長寬為 1350px * 901px"></p>
<p>以下圖來說，左方是屬於正確呈現的圖片，維持原本的橫向矩形，如果改為右圖接近方形的情況就會產生變形。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202001%2F862EFA76-A178-41B6-8188-BE7CD02DF361.png?alt=media&amp;token=a0706597-3f39-485f-b7ab-e81c9690c9aa" alt=""></p>
<p>有些時候，比例變化沒有那麼大的情況下，開發者可能會誤以為圖片沒有變形，但在用戶看來並非如此，現在人普遍美感大幅提升的情況下，越來越多人可以輕易看出這樣的問題。</p>
<p>避免方法：</p>
<ol>
<li>僅限制寬 <em>或</em> 高，另一邊使其自由伸展</li>
<li>如果寬高比例是無法控制的，可以使用背景圖作替代</li>
</ol>
<p>錯誤範例及解決辦法：</p>

<p class="codepen" data-height="300" data-theme-id="default" data-default-tab="html,result" data-user="Wcc723" data-slug-hash="zYxPmXR" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="圖片變形範例">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/zYxPmXR">
  圖片變形範例</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>範例連結：<a href="https://codepen.io/Wcc723/pen/zYxPmXR">https://codepen.io/Wcc723/pen/zYxPmXR</a></p>
<h2 id="二、圖片尺寸過大"><a href="#二、圖片尺寸過大" class="headerlink" title="二、圖片尺寸過大"></a>二、圖片尺寸過大</h2><p>新手錯誤率：⭐⭐⭐⭐⭐<br>令人感受的粗心度：👎👎</p>
<p>雖然越高的解析度會有更好的畫質呈現，但受限於裝置能夠呈現的極限及人眼的辨識度下，過於提高的解析度並不會有更高的畫質，反而會造成 1. 圖片下載速度過慢、2. 瀏覽器渲染速度變慢導致網頁操作不順暢。雖然現在的裝置普遍效能很高，但超過 2000px ~ 3000px 的圖片還是會影響顯示效能。</p>
<p>這個錯誤算是最常見，但卻不一定會被發現的錯誤，因為圖片顯示上是沒有問題的（只是可能慢一些），大多情況則是會透過開發者工具檢查此問題。以下圖來說就載入該空間所需十倍尺寸大的圖片</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F202001%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2020_1_4_%E4%B8%8B%E5%8D%882_36.png?alt=media&amp;token=7177b375-5d19-48b4-9856-3da331159295" alt=""></p>

<p class="codepen" data-height="265" data-theme-id="default" data-default-tab="html,result" data-user="Wcc723" data-slug-hash="NWPwOQr" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="圖片檔案過大">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/NWPwOQr">
  圖片檔案過大</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

<p>範例連結：<a href="https://codepen.io/Wcc723/pen/NWPwOQr">https://codepen.io/Wcc723/pen/NWPwOQr</a></p>
<p>避免辦法：</p>
<ol>
<li>簡單解決辦法，釐清你的圖片的用途：<ol>
<li>主要圖片、小圖：<strong>圖片的寬高尺寸盡量不超過顯示區域的兩倍</strong>（ex: 寬度 300px 的顯示區域則圖片寬度不超過 600px 為主），現在許多裝置都有 Retina 顯示器，此情況下 2 倍解析度已有不錯的品質。</li>
<li>背景圖：因為背景圖並非主要用來傳達資訊的內容，因此使用 1:1 的顯示尺寸即可。</li>
</ol>
</li>
<li>使用 srcset 設置響應式圖像： 透過 <code>srcset</code> 可以在同一個 img 標籤載入不同尺寸的圖片，參考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/img#attr-srcset">文件</a></li>
</ol>
<p>範例程式碼：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">class</span>=<span class="string">&quot;img-fluid&quot;</span> <span class="attr">srcset</span>=<span class="string">&quot;https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=300&amp;q=80 800w, https://images.unsplash.com/photo-1556656793-08538906a9f8?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=1200&amp;q=80 1200w&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>請另開分頁，並調整視窗尺寸後並重新整理畫面（可以取得不同尺寸的圖片）：<a href="https://codepen.io/Wcc723/full/oNgoQXm">https://codepen.io/Wcc723/full/oNgoQXm</a></p>
<h2 id="三、SVG-內混用了點陣圖、未外框的文字"><a href="#三、SVG-內混用了點陣圖、未外框的文字" class="headerlink" title="三、SVG 內混用了點陣圖、未外框的文字"></a>三、SVG 內混用了點陣圖、未外框的文字</h2><p>新手錯誤率：⭐⭐<br>令人感受的粗心度：👎👎</p>
<p>SVG 是屬於向量圖，而一般的 <code>jpg</code>, <code>png</code> 是屬於點陣圖，向量圖來說最大的特性在於<strong>沒有解析度的限制</strong>，並且是屬於數學座標，且檔案大多小於點陣圖，並且有極佳的顯示品質。因此再大的區塊，也都僅需要載入很小檔案的 svg 就有很棒的呈現。</p>
<p>SVG 是屬於 XML 格式的標記語言，原始碼的內容都是在標記所有節點的座標位置，因此在原始碼會看到元素標籤、座標位置的相關資訊，輸出的檔案結構如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;svg-outline&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">fill-rule</span>=<span class="string">&quot;evenodd&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">path</span> <span class="attr">d</span>=<span class="string">&quot;M49.564,64.336 C45.878,64.336 41.926,62.968 39,60.27 L42.838,55.596 C44.852,57.306 47.474,58.484 49.716,58.484 C52.224,58.484 53.402,57.534 53.402,56.014 C53.402,54.38 51.844,53.848 49.412,52.822 L45.802,51.302 C42.838,50.124 40.064,47.654 40.064,43.55 C40.064,38.8 44.32,35 50.324,35 C53.592,35 57.05,36.254 59.52,38.724 L56.138,42.98 C54.276,41.574 52.528,40.814 50.324,40.814 C48.234,40.814 46.942,41.65 46.942,43.17 C46.942,44.728 48.728,45.336 51.236,46.324 L54.77,47.73 C58.266,49.136 60.356,51.492 60.356,55.482 C60.356,60.194 56.404,64.336 49.564,64.336 Z&quot;</span> <span class="attr">id</span>=<span class="string">&quot;S&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#000000&quot;</span> <span class="attr">fill-rule</span>=<span class="string">&quot;nonzero&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">path</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>SVG 圖片範例</p>

<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <g id="svg-outline" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
      <path d="M49.564,64.336 C45.878,64.336 41.926,62.968 39,60.27 L42.838,55.596 C44.852,57.306 47.474,58.484 49.716,58.484 C52.224,58.484 53.402,57.534 53.402,56.014 C53.402,54.38 51.844,53.848 49.412,52.822 L45.802,51.302 C42.838,50.124 40.064,47.654 40.064,43.55 C40.064,38.8 44.32,35 50.324,35 C53.592,35 57.05,36.254 59.52,38.724 L56.138,42.98 C54.276,41.574 52.528,40.814 50.324,40.814 C48.234,40.814 46.942,41.65 46.942,43.17 C46.942,44.728 48.728,45.336 51.236,46.324 L54.77,47.73 C58.266,49.136 60.356,51.492 60.356,55.482 C60.356,60.194 56.404,64.336 49.564,64.336 Z" id="S" fill="#000000" fill-rule="nonzero"></path>
  </g>
</svg>

<p>當 SVG 內容插入點陣圖片後，圖片就不是只存在著座標位置，還會將點陣圖片以 base64 的格式插入。記得，這個圖片會造成許多額外的檔案大小，並且無法如同 SVG 一樣自由縮放，如同喪失使用 SVG 的用意。</p>
<p>通常會出現這樣的錯誤是在設計稿插入了點陣圖，並誤將此圖片輸出出來，開發者如果沒有檢查通常不會主動發現這樣的錯誤。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;svg-bmp&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">fill-rule</span>=<span class="string">&quot;evenodd&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">id</span>=<span class="string">&quot;Bitmap&quot;</span> <span class="attr">x</span>=<span class="string">&quot;39&quot;</span> <span class="attr">y</span>=<span class="string">&quot;35&quot;</span> <span class="attr">width</span>=<span class="string">&quot;22&quot;</span> <span class="attr">height</span>=<span class="string">&quot;30&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAeCAYAAAAo5+5WAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAFqADAAQAAAABAAAAHgAAAAAsUXibAAACGklEQVRIDaWVzUtWQRSHX0sjXfiBCJGErowgqFaJK10kbkUoaKFILmon2V/Qulq0yFoErowWhatEDcGFbcOVIm0EP7ACsbJU+np+rw7OnTtz517eA887M2d+58x978ycW1UKWxNTt6AHrkEL1MFn2IQP8A4W4BCipuBH8AP+5WAdzT04A0G7yMwq5EnoapaJU3zK2vBodTegyHiX+E4381yFSfUAK1BvJ+6NJP3L/Bbo734JaL/hvwQJm2AU+sva9Y6EulRqZzwGG6A4LdwPKVvCE0rcmlKfOM7S1Ql6eOJK9rYZ+hL/xt+YlOYbnTqWaTd9dhrnE6j2TebxvUHke2Lj09kehto8yWzNTQYmSVa7g+4pXLaDY/1FBFlJ3TnViiGoiSW+gkDv2k0QG38i5jZUQdCuMqOLEEvmm39FXOYm69y+BB01X4Is3xQxUVOleg55y6dZ0HsDfas14ByFvOVUt7iQaXP6YAHM04Xa5kKZLfEd+n8yFrhuacvdNn4T9dQVWOP39ENPPGBqhfR6lzPwEbogZvsZgq9mTgtMg/0EbxmnPjPHATdoDxy9idUr0he9bKqpZsJt15h7DY/hBcSu/jyasg3y6yarZNx9lPbollWSyI59ZpKadoTOT7BFRfuTxOvDkLJ2POOg3S6SVBXxLkTtPIoHMAu/wLfIIX7V4/vgPfeZNZQgfYUvwDnQNf0OOqOqwXsQtP8amWC6AXj6RwAAAABJRU5ErkJggg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">image</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>SVG 圖片範例，此範例文字在高解析的裝置下會變得模糊。</p>

<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <g id="svg-bmp" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
      <image id="Bitmap" x="39" y="35" width="22" height="30" xlink:href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABYAAAAeCAYAAAAo5+5WAAAAAXNSR0IArs4c6QAAAERlWElmTU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAA6ABAAMAAAABAAEAAKACAAQAAAABAAAAFqADAAQAAAABAAAAHgAAAAAsUXibAAACGklEQVRIDaWVzUtWQRSHX0sjXfiBCJGErowgqFaJK10kbkUoaKFILmon2V/Qulq0yFoErowWhatEDcGFbcOVIm0EP7ACsbJU+np+rw7OnTtz517eA887M2d+58x978ycW1UKWxNTt6AHrkEL1MFn2IQP8A4W4BCipuBH8AP+5WAdzT04A0G7yMwq5EnoapaJU3zK2vBodTegyHiX+E4381yFSfUAK1BvJ+6NJP3L/Bbo734JaL/hvwQJm2AU+sva9Y6EulRqZzwGG6A4LdwPKVvCE0rcmlKfOM7S1Ql6eOJK9rYZ+hL/xt+YlOYbnTqWaTd9dhrnE6j2TebxvUHke2Lj09kehto8yWzNTQYmSVa7g+4pXLaDY/1FBFlJ3TnViiGoiSW+gkDv2k0QG38i5jZUQdCuMqOLEEvmm39FXOYm69y+BB01X4Is3xQxUVOleg55y6dZ0HsDfas14ByFvOVUt7iQaXP6YAHM04Xa5kKZLfEd+n8yFrhuacvdNn4T9dQVWOP39ENPPGBqhfR6lzPwEbogZvsZgq9mTgtMg/0EbxmnPjPHATdoDxy9idUr0he9bKqpZsJt15h7DY/hBcSu/jyasg3y6yarZNx9lPbollWSyI59ZpKadoTOT7BFRfuTxOvDkLJ2POOg3S6SVBXxLkTtPIoHMAu/wLfIIX7V4/vgPfeZNZQgfYUvwDnQNf0OOqOqwXsQtP8amWC6AXj6RwAAAABJRU5ErkJggg=="></image>
  </g>
</svg>

<p>在 SVG 加入文字內容時，需要確保文字輸出是有被轉外框，如果沒有轉外框程式碼會看似如下簡短，但如果用戶沒有此字體，該文字就無法如預期顯示。</p>
<p>此錯誤是屬於<strong>設計稿中的文字沒有轉外框</strong>，因此開發者很難以發現。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">width</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100px&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 100 100&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;svg-font&quot;</span> <span class="attr">stroke</span>=<span class="string">&quot;none&quot;</span> <span class="attr">stroke-width</span>=<span class="string">&quot;1&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;none&quot;</span> <span class="attr">fill-rule</span>=<span class="string">&quot;evenodd&quot;</span> <span class="attr">font-family</span>=<span class="string">&quot;NotoSansCJKtc-Black, Noto Sans CJK TC&quot;</span> <span class="attr">font-size</span>=<span class="string">&quot;38&quot;</span> <span class="attr">font-weight</span>=<span class="string">&quot;700&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">text</span> <span class="attr">id</span>=<span class="string">&quot;S&quot;</span> <span class="attr">fill</span>=<span class="string">&quot;#000000&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tspan</span> <span class="attr">x</span>=<span class="string">&quot;38.359&quot;</span> <span class="attr">y</span>=<span class="string">&quot;66&quot;</span>&gt;</span>S<span class="tag">&lt;/<span class="name">tspan</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>SVG 圖片範例，此範例的文字可以圈選，且與上方的字體不一定相同（視系統內是否有該字體）。</p>

<svg width="100px" height="100px" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <g id="svg-font" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" font-family="NotoSansCJKtc-Black, Noto Sans CJK TC" font-size="38" font-weight="700">
        <text id="S" fill="#000000">
            <tspan x="38.359" y="66">S</tspan>
        </text>
    </g>
</svg>

<p>SVG 的錯誤與設計師有很大的關係，因此前端開發者在使用 SVG 稿件時也有義務一同檢視該檔案是否正確。而設計師也需要對此更加注意，避免輸出錯誤的圖檔給予開發者使用。</p>
<p>相較於其它錯誤來說，此錯誤與設計師的稿件輸出有很大關係。因此，如果你是 UI 設計師，此類型錯誤會令人感受到不專業。</p>
<h2 id="四、背景圖裁切掉主體"><a href="#四、背景圖裁切掉主體" class="headerlink" title="四、背景圖裁切掉主體"></a>四、背景圖裁切掉主體</h2><p>新手錯誤率：⭐⭐⭐<br>令人感受的粗心度：👎</p>
<p>現在開發都會考量 RWD 的顯示，RWD 中的圖片大多會改變寬高或轉為背景圖來處理，而背景圖並非都適合運用在 RWD 中，因為在縮放的過程中會有不同比例的裁切，這些裁切如果是在主體上，對於網頁品質會有很大的扣分。</p>
<p>在以下的範例中有一個長形的沙發，也由於沙發長度過長，因此在行動版中左右方會有裁切。</p>

<p class="codepen" data-height="400" data-theme-id="default" data-default-tab="css,result" data-user="Wcc723" data-slug-hash="mdyqzgZ" style="height: 265px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="圖片裁切掉主體">
  <span>See the Pen <a href="https://codepen.io/Wcc723/pen/mdyqzgZ">
  圖片裁切掉主體</a> by Wcc723 (<a href="https://codepen.io/Wcc723">@Wcc723</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

<p>因此在選擇圖片時，可以先思考行動版、桌面版所呈現的<strong>比例</strong>，兩者比例中的重疊空間稱為「重疊安全區域」，如果主體可以完整置入此區域內就可以避免被裁切。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%20%EF%BC%91%EF%BC%90.png?alt=media&amp;token=7480df17-3e1b-4c71-8e66-f139525102cc" alt="通常來說，方形且在中央區域的主體比較穩定"></p>
<p>完整的介紹文章：<a href="/design/2018/11/01/responsive-images/">網頁設計 - 響應式圖片選用技巧</a></p>
<h2 id="五、圖片連結錯誤"><a href="#五、圖片連結錯誤" class="headerlink" title="五、圖片連結錯誤"></a>五、圖片連結錯誤</h2><p>新手錯誤率：⭐⭐<br>令人感受的粗心度：👎👎👎👎👎</p>

<img src="/xxx/xx" alt="這張圖片無法顯示">

<p>如果圖片是屬於裝飾類型，並且由開發者所置入，就必須要多加注意。開發者也通常會反覆檢視自己輸出的頁面是很正常的，因此這類型錯誤通常不會是在開發階段時遺漏，很多是在轉換環境時沒有完整檢查出錯。大多原因在於相對路徑與絕對路徑的掌握度不足。</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> html </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS 技巧：精簡語法操作暗色主題 - CSS Dark Mode]]></title>
      <url>https://wcc723.github.io/css/2019/12/22/css-dark-mode/</url>
      <content type="html"><![CDATA[<p>Mac 暗色主題推出後，就讓黑色控非常喜愛，而且這樣的暗色佈景使用起來更不傷眼。以我來說是比較喜歡在亮色的佈景下工作的，但暗主題的對於長期需要在電腦面前工作來說，真的相對輕鬆很多。雖然如此，也並非所有的介面都是有提供暗主題，以網頁來說就需要開發者另外定義暗主題才會進行切換（不使用任何瀏覽器插件的情況下）。</p>
<p>好在，暗色主題的語法相當容易，以下介紹如何作切換，並且會提供一個小技巧，只要透過短短的幾行就能操控整個網站所有元件的主題色彩。</p>
<h2 id="支援度"><a href="#支援度" class="headerlink" title="支援度"></a>支援度</h2><p>先附上大家所在意的支援度，但其實暗色主題本身就是由 Apple 先提出的，所以 Mac OS、iOS 的支援度會比較高，其它的瀏覽器也正在持續跟進中。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201912%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_12_22_%E4%B8%8A%E5%8D%8811_50.png?alt=media&amp;token=3090bbfe-cf0d-4a7a-8b97-23243cdd106a" alt=""></p>
<h2 id="語法"><a href="#語法" class="headerlink" title="語法"></a>語法</h2><p>MDN 上的介紹：<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme">https://developer.mozilla.org/en-US/docs/Web/CSS/@media/prefers-color-scheme</a></p>
<p>暗色主題的 CSS 是透過 @media 取得裝置的主題模式，就如同取得裝置的形式一樣（尺寸、橫向或垂直、是否為螢幕等等…），相信對於撰寫過響應式的開發者都不陌生。</p>
<p>語法上使用 prefers-color-scheme 來監測是亮色或暗色的主題，相對應的值也就是 <code>dark</code> or <code>light</code>。<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> $&#123;<span class="selector-tag">dark</span> <span class="selector-tag">or</span> <span class="selector-tag">light</span>&#125;) &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>實際演示範例範例：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.mode</span> &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">background-color</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.text-mode</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">  content: &quot;light&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="css"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.mode</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background-color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#eee</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.text-mode</span><span class="selector-pseudo">:after</span> &#123;</span></span><br><span class="line">    content: &quot;dark&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo mode&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>本區塊會隨著暗色與亮色主題切換<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>您目前的是 <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;text-mode&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">span</span>&gt;</span> 主題<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>請透過切換你的暗色、亮色主題來改變下方的範例（暗色主題為深色背景，亮色則反之）。</p>

<style>
.mode {
  background-color: #eee;
  color: #333;
}
.text-mode:after {
  content: "light";
}

@media (prefers-color-scheme: dark) {
  .mode {
    background-color: #333;
    color: #eee;
  }
  .text-mode:after {
    content: "dark";
  }
}
</style>
<div class="demo mode">
  <p>本區塊會隨著暗色與亮色主題切換</p>
  <p>您目前的是 <span class="text-mode"></span> 主題</p>
</div>

<h2 id="使用變數快速切換網頁的主題色"><a href="#使用變數快速切換網頁的主題色" class="headerlink" title="使用變數快速切換網頁的主題色"></a>使用變數快速切換網頁的主題色</h2><p>暗色系與亮色中的色彩並不是黑白兩色互相切換，以 Material Design 來說，如果亮色的主色色彩為 <code>#6222ee</code>，在暗色系並不會使用相同色，而是會改變為 <code>#bb85fc</code> 藉此來增加辨識度，而整個網頁中所需要套用色彩的區塊非常多，從按鈕到元件都會不斷地引用，如果透過一個個的 @media 設定將會增加開發及管理的困難度。</p>
<p><img src="https://storage.googleapis.com/spec-host/mio-staging%2Fmio-design%2F1576174064000%2Fassets%2F11xwGmImm24QEBIRv6a0NzhW-wTc9rFh6%2Fdarktheme-darktheme-usage-availability-toggle.png" alt=""></p>
<blockquote>
<p>Material Design 中的暗色、亮色切換範例，兩者的主色（紫色）在不同的主題下色彩也會改變。</p>
</blockquote>
<p>因此，在開發時可以將暗色、亮色的佈景主題色彩以 CSS 變數的方式作定義，避免直接將色彩寫入 CSS 元素上，接下來在 @media 中僅需要改變 CSS 的變數就能夠完整切換所有元件的主題色彩。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="attribute">--theme-primary</span>: <span class="number">#6222ee</span>;</span><br><span class="line">  <span class="attribute">--theme-background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.card</span> &#123;</span><br><span class="line">  <span class="comment">/* ... */</span></span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--theme-background);</span><br><span class="line">  <span class="attribute">color</span>: <span class="built_in">var</span>(--theme-primary);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> (<span class="attribute">prefers-color-scheme:</span> dark) &#123;</span><br><span class="line">  <span class="selector-class">.card</span> &#123;</span><br><span class="line">    <span class="attribute">--theme-primary</span>: <span class="number">#bb85fc</span>;</span><br><span class="line">    <span class="attribute">--theme-background</span>: <span class="number">#111</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<style>
.card {
  --theme-primary: #6222ee;
  --theme-background: #eee;
}

.card {
  margin: 0 auto;
  padding: 15px;
  text-align: center;
  max-width: 320px;
  border-radius: 3px;
  border: 1px solid #777;
  background-color: var(--theme-background);
  color: var(--theme-primary);
}

@media (prefers-color-scheme: dark) {
  .card {
    --theme-primary: #bb85fc;
    --theme-background: #111;
  }
}
</style>
<div class="demo mode">
  <div class="card">
    <p>本卡片會隨著暗色與亮色主題切換</p>
  </div>
</div>

<p>本文中還有利用到 CSS Variables，有興趣可參閱本篇文「<a href="https://w3c.hexschool.com/blog/21985acb">原生 CSS 變數運用技巧（CSS Variables）</a>」。</p>
<h4 id="設計規範"><a href="#設計規範" class="headerlink" title="設計規範"></a>設計規範</h4><p>目前在 Apple 及 Material Design 中也都有針對亮色、暗色的佈景主題提供規範，在完整投入之前，也不妨先參考看看。</p>
<p>Material Design</p>
<ul>
<li>Material Design：<a href="https://design.google/library/material-design-dark-theme/">https://design.google/library/material-design-dark-theme/</a></li>
</ul>
<p>Apple</p>
<ul>
<li>Mac：<a href="https://developer.apple.com/design/human-interface-guidelines/macos/visual-design/dark-mode/">https://developer.apple.com/design/human-interface-guidelines/macos/visual-design/dark-mode/</a></li>
<li>iOS：<a href="https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/">https://developer.apple.com/design/human-interface-guidelines/ios/visual-design/dark-mode/</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
            <tag> develop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一分鐘切換成中文版 VSCode（完整圖文版）]]></title>
      <url>https://wcc723.github.io/development/2019/12/01/vscode-chinese/</url>
      <content type="html"><![CDATA[<p>雖然開發者都具有一定的英文閱讀能力，但如果在不熟悉的情況下，就比較難以快速上手一個新工具。如果要快速掌握一個完整的工具或技術，最好的方式還是先切換成熟悉的語言。</p>
<p>而 VSCode 雖然預設並無法直接切換語系，但官方有提供各國的語言套件，讓開發者可以自行選用。</p>
<h2 id="切換成中文版"><a href="#切換成中文版" class="headerlink" title="切換成中文版"></a>切換成中文版</h2><p>如果你對於 VSCode 有興趣，別因為 VSCode 預設開啟是英文版就急著關閉，預設雖然是使用英文版，也找不到語系切換的地方，但其實官方有提供中文版的套件安裝（為了讓 VSCode 輕量化，語系需要另外安裝）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201912%2FEE9646DE-DC18-433C-833F-F4AEADDE4239.png?alt=media&amp;token=e97eb33d-5681-4ec7-80d7-092818f614c9" alt=""></p>
<p>畫面的左方功能列表中，可以找到 Extensions，點選後輸入 “Chinese” 即可搜尋到中文的相關語系，選擇中文（繁體）後頁面的右方即會出現相關介紹，此時按下 “Install” 就會安裝中文語系套件。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201912%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_11_24_%E4%B8%8A%E5%8D%8810_40.png?alt=media&amp;token=8dd5eb78-208d-4b2b-ba7c-f1ca8040d4f1" alt=""></p>
<p>安裝後系統會自動跳出是否切換成該語系，按下 Yes 後就會套用成中文版囉～</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201912%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_11_24_%E4%B8%8A%E5%8D%8810_42.png?alt=media&amp;token=b4200258-bccb-4005-8e99-c70022aef868" alt=""></p>
<p>不過人生中最怕的就是那個 “But”，如果沒有自動跳出右下方的提示該如何切換呢？另外 VSCode 如果更新時，可能也會再次切換為英文版，這時候就需要手動切換語系。</p>
<p>手動切換流程也並不複雜，可使用以下三個步驟手動切換</p>
<ol>
<li>按下 <code>ctrl + shift + P</code>（Mac 版請按下 <code>cmd + shift + P</code>）</li>
<li>輸入 <code>display language</code> 就會跳出 “Configure Display Language”</li>
<li>選擇安裝的語系 “zh-tw” 即可安裝</li>
</ol>
<p>以下附上影片供參考</p>
<video width="1920" height="1080" class="img-fluid" controls><source src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201912%2Fvscode%20%E4%B8%AD%E6%96%87%E5%8C%96.mp4?alt=media&token=f6634ca2-33ac-46bc-9f83-50bedad602ae" type="video/mp4"></video>

]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> develop </tag>
            
            <tag> vscode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[十分鐘快速掌握 Markdown]]></title>
      <url>https://wcc723.github.io/development/2019/11/23/ten-mins-learn-markdown/</url>
      <content type="html"><![CDATA[<p>Markdown 是目前非常普遍用來撰寫文檔的語言，一開始的目標就是使用「易讀易寫的純文字格式編寫文件」，此初衷讓使用者可以專注在文字的本身，而不需要透過其它工具來切換格式。以 Word 撰寫文檔來說，就必須透過上方的工具列來切換<strong>標題、列表、粗體、斜體</strong>等等；而 Markdown 並沒有這樣的工具列，完全都是<strong>使用標示符號來完成這些需求</strong>。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2F9393649C-A1ED-49BF-81F5-49EFD30924C3.png?alt=media&amp;token=addd2eb8-077a-4a66-a644-b79b7a19b19a" alt=""></p>
<h2 id="常見應用"><a href="#常見應用" class="headerlink" title="常見應用"></a>常見應用</h2><p>大部分情況下 Markdown 是用來撰寫程式語言相關的文檔，因為純文字的特性與程式碼一致，且可搭配標示符號來改變呈現格式，像是在 Github 的文件中使用 <code>readme.md</code> 的 Markdown 格式，則會預設作為該儲存庫的介紹。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_11_14_%E4%B8%8B%E5%8D%887_31.png?alt=media&amp;token=ffa2704b-b955-49d4-9ed4-69801ec96253" alt=""></p>
<p>除了軟體開發以外，目前也越來越多的服務加入了 Markdown 的編寫支援，與文字傳達有關聯性的都慢慢加入其中的語法，像是筆記工具、文字通訊、部落格等等都有這類影子，如 <a href="https://bear.app/">Bear note</a> 就是完全使用 Markdown 的筆記工具、Slack 則是支援部分的文字訊息、Hexo 則是透過 Markdown 撰寫的部落格工具；除此之外，現在 Facebook 發文也可以使用此格式來撰寫文章（目前是限定社團才能使用）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2FCC12304F-C0D9-4A0F-8DA5-CE1A9846DE5F.png?alt=media&amp;token=6b3146db-b215-44e2-a885-a5181929ce2b" alt=""></p>
<p>現在台灣主流的通訊工具 LINE，也可以透過部分的 Markdown 語法來傳遞程式碼或是調整文字格式（電腦版限定）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_11_23_%E4%B8%8A%E5%8D%8811_13.png?alt=media&amp;token=a3c94694-151e-4fad-8845-4f626a5b78c9" alt=""></p>
<h2 id="學習-Markdown"><a href="#學習-Markdown" class="headerlink" title="學習 Markdown"></a>學習 Markdown</h2><p>基本概念：Markdown 可以輸出成 HTML 的格式，所以各種標示也會對應 HTML 的標籤，就顯示的結構上可區分為兩大類：區塊、行內。</p>
<ul>
<li>區塊：此類別會讓內容獨立形成一個區塊，區塊內的 <strong>全部文字都是套用同樣的格式</strong>，標題、引用、清單都是屬於此類型，而區塊可以疊加使用，如引用內可以包含標題。</li>
<li>行內：套用此類別的內容可插入於區塊內，如：強調文字、斜體字、文字連結等等，要特別注意插入圖片也是屬於此類別（與 HTML 特性相符合）。</li>
</ul>
<p>以 Word 的概念來介紹，<strong>區塊元素表示文字整段都是同樣的風格、層級（洋紅色標示），而行內元素則是在區塊的文字上做修飾（綠色標示）</strong>。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_11_19_%E4%B8%8B%E5%8D%8811_13.png?alt=media&amp;token=893c6e7a-010b-452e-913f-5418e91179e8" alt=""></p>
<p>除了以上兩點以外，每個 Markdown 環境所能接受的語法都略有不同，像是部分工具、環境雖然接受使用 Markdown 撰寫，但標題上只接受三個以下的層級（正確為六個層級），所以實際上還是需以運行的環境為主，而本篇介紹的則是介紹通用的使用方式。</p>
<h3 id="區塊元素"><a href="#區塊元素" class="headerlink" title="區塊元素"></a>區塊元素</h3><p>此類別會讓內容獨立形成一個區塊，區塊內的 <strong>全部文字都是套用同樣的格式</strong>，標題、引用、清單都是屬於此類型，而區塊可以疊加使用，如引用內可以包含標題。</p>
<h4 id="標題"><a href="#標題" class="headerlink" title="標題"></a>標題</h4><p>總共分為六個層級，依據 HTML 的結構會轉為 <code>&lt;h1&gt; ~ &lt;h6&gt;</code>，形式上是在文字前方補上不同數量的 <code>#</code>，<code>#</code> 數量越少層級越高，反之則是越低，以下方結構來說 <code># 標題 1</code> 是層級最高，且視覺上最大的標題。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 標題 1</span></span><br><span class="line"><span class="section">## 標題 2</span></span><br><span class="line">...</span><br><span class="line"><span class="section">###### 標題 6</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>呈現結果（以下為 Bear note 的範例）</p>
</blockquote>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2F2E67180F-CD56-4FB0-9C7F-5DEC0F3C261E.png?alt=media&amp;token=24c18b5a-ac14-4c41-9da1-bbbb86483014" alt=""></p>
<hr>
<h4 id="文字段落"><a href="#文字段落" class="headerlink" title="文字段落"></a>文字段落</h4><p>當沒有加上任何標示符號時，該區塊的文字就是<strong>文字段落區塊</strong>，而段落與段落之間會保留一行空白空間，在接下一段的內容。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 這是標題</span></span><br><span class="line">這是一段文字段落</span><br><span class="line"></span><br><span class="line">這是第二行的文字段落，還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：標題、內文</p>
</blockquote>

<div class="demo">
  <h2 ><a href="#這是標題" class="headerlink" title="這是標題"></a>這是標題</h2>
  <p>這是一段文字段落</p>
  <p>這是第二行的文字段落，還是要勉強自己，笑起來處子般通紅；看人突然好想你，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。</p>
</div>

<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>引用的寫法與樣式都類似於 Email 中的回文原文，只要在文章前面補上 <code>&gt;</code> 的符號即可。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 這裡是一段引用文字</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：引用文字</p>
</blockquote>

<div class="demo">
<blockquote>
<p>這裡是一段引用文字</p>
</blockquote>
</div>

<p>部分文件提到：引用文字不僅可以單獨使用，也可以混用其他的區塊元素，或者透過多個 <code>&gt;</code> 來調整層級。但要特別注意，並非所有的 Markdown 環境都支援多個層級的寫法，許多環境僅能單獨使用 <code>&gt;</code>，</p>
<h4 id="清單"><a href="#清單" class="headerlink" title="清單"></a>清單</h4><p>清單分為一般列表及包含數字符號的列表，兩種都包含多個層級，只要加上一個縮排或兩個空格就可以新增一個層級。</p>
<p>一般列表的使用彈性較高，<code>-</code>、<code>+</code>、<code>*</code> 等符號後方加上一個空白後都可以轉為列表，要表示下一個層級可多一個縮排或是兩個空白即可。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> 這是清單</span><br><span class="line"><span class="bullet">+</span> 這也是清單</span><br><span class="line"><span class="bullet">*</span> 這同樣是清單</span><br><span class="line"><span class="bullet">    -</span> 清單子項目</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：一般列表</p>
</blockquote>

<div class="demo">
<ul>
<li>這是清單</li>
<li>這也是清單</li>
<li>這同樣是清單<ul>
<li>清單子項目</li>
</ul>
</li>
</ul>
</div>

<p>包含數字符號的列表則是使用 數字 + <code>.</code>作為開頭，列表中的第一個數字是數字列表的起始序號，而後方的數字不需要按照順序，如：<code>1. 2. 2.</code> 結果依然會是 <code>1. 2. 3.</code>；另外縮排的規則與一般列表相同。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 數字型清單</span><br><span class="line"><span class="bullet">2.</span> 第二個數字清單</span><br><span class="line"><span class="bullet">2.</span> 數字清單不需要連續數字</span><br><span class="line"><span class="bullet">    3.</span> 數字清單子項目</span><br></pre></td></tr></table></figure>
<p>後方的數字不需要按照順序。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">2.</span> 數字清單從 2 開始</span><br><span class="line"><span class="bullet">3.</span> 第 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：數字列表（數字 3 開始）</p>
</blockquote>

<div class="demo">
<ol start="3">
<li>數字型清單</li>
<li>第二個數字清單</li>
<li>數字清單不需要連續數字<ol start="1">
<li>數字清單子項目</li>
</ol>
</li>
</ol>
</div>

<p>如果段落文字需要以數字 + <code>.</code> 作為開頭，可以改為 數字 + 反斜線 + .，範例如下。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2019\. 避免 <span class="code">`數字.`</span> 轉為數字型清單的方法</span><br></pre></td></tr></table></figure>
<h4 id="區塊程式碼"><a href="#區塊程式碼" class="headerlink" title="區塊程式碼"></a>區塊程式碼</h4><p>作為許多開發者撰寫文本的工具，插入程式碼片段也是合情合理的。Markdown 中會使用三個連續的反引號（<strong>`</strong>）開頭及結尾做為區塊的程式碼，並且可以在首行的位置補上該段程式碼的語言類別，藉此輸出具有 Highlight 的程式碼。</p>
<p>三個連續的反引號（<strong>`</strong>）用在開頭結尾，即可作為區塊程式碼。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201911%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_11_23_%E4%B8%8A%E5%8D%8810_34.png?alt=media&amp;token=41f54821-b727-48e7-9885-cd5dd689f851" alt=""></p>
<p>首行補上特定程式碼語言名稱，該段可使用特定語言的 Highlight （依據輸出的環境而定），以下圖為例則是使用 <code>js</code> 或 <code>javascript</code>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;這執行第&#x27;</span> + i + <span class="string">&#x27;次&#x27;</span>);</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>當輸出為 html 時，該段落並不會被瀏覽器作為標籤渲染，而是呈現可被使用者閱讀的程式碼。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>這是一段 HTML 結構<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="分隔線"><a href="#分隔線" class="headerlink" title="分隔線"></a>分隔線</h4><p>分隔線，可以使用三個連續符號表示（<code>-</code>、<code>*</code>，部分環境亦可使用 <code>_</code>）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">***</span><br><span class="line">___</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：分隔線</p>
</blockquote>

<div class="demo">
  <hr>
</div>

<h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><p>雖然 Markdown 有提供表格的符號，但實際運用上並不是很方便，如果環境許可我大多會直接使用 HTML 的表格標籤替代 Markdown 的表格。Markdown 的表個就像是使用符號 “畫” 一個表格，實際撰寫時對其很麻煩。</p>
<p>下圖為表格的範例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">| thead 1 | thrad 2 | thread 3 |</span><br><span class="line">|---------|---------|----------|</span><br><span class="line">| td      | td      | td       |</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：表格</p>
</blockquote>

<div class="demo">
  <table>
  <thead>
  <tr>
  <th>thead 1</th>
  <th>thrad 2</th>
  <th>thread 3</th>
  </tr>
  </thead>
  <tbody>
  <tr>
  <td>td</td>
  <td>td</td>
  <td>td</td>
  </tr>
  </tbody>
  </table>
</div>

<h3 id="行內元素"><a href="#行內元素" class="headerlink" title="行內元素"></a>行內元素</h3><p>套用此類別的內容可插入於區塊內，如：強調文字、斜體字、文字連結等等，要特別注意插入圖片也是屬於此類別（與 HTML 特性相符合）。</p>
<h4 id="斜體"><a href="#斜體" class="headerlink" title="斜體"></a>斜體</h4><p>斜體字與強調文字使用上是很接近的，可以使用 <code>*</code> 或 <code>_</code> 符號套用在文字的前後方，即可將文字改為斜體字；而將 <code>*</code> 或 <code>_</code> 使用連續兩個加在文字的前後方則會是強調文字。</p>
<p>以下為斜體文字的範例，另外在 <code>*</code> 或 <code>_</code> 的前後補上空白會維持原本的符號，就不會套用斜體效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">還是要*勉強自己*，笑起來處子般通紅；看人_突然好想你_，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。* 普通文字 *。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：斜體</p>
</blockquote>

<div class="demo">
  <p>還是要<em>勉強自己</em>，笑起來處子般通紅；看人<em>突然好想你</em>，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。<em> 普通文字 </em>。</p>
</div>

<h4 id="強調"><a href="#強調" class="headerlink" title="強調"></a>強調</h4><p>以下為強調文字的範例，使用兩個 <code>*</code> 或 <code>_</code>套用在文字的前後方 。<code>**</code> 或 <code>__</code> 的前後補上空白會維持原本的符號，一樣不會套用強調效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">還是要**勉強自己**，笑起來處子般通紅；看人__突然好想你__，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。** 普通文字 **。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：強調</p>
</blockquote>

<div class="demo">
  <p>還是要<strong>勉強自己</strong>，笑起來處子般通紅；看人<strong>突然好想你</strong>，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣。<strong> 普通文字 </strong>。</p>
</div>

<h4 id="行內程式碼"><a href="#行內程式碼" class="headerlink" title="行內程式碼"></a>行內程式碼</h4><p>與區塊程式碼一樣使用反引號，在此改為單一個反引號加在文字的前後方即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">還是要勉強自己，笑起來處子般通紅；看人 &#96;&lt;strong&gt;&#96; 突然好想你 &#96;&lt;&#x2F;strong&gt;&#96;，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣 &#96;var a &#x3D; 0&#96;。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：行內程式碼</p>
</blockquote>

<div class="demo">
  <p>還是要勉強自己，笑起來處子般通紅；看人 <code>&lt;strong&gt;</code> 突然好想你 <code>&lt;/strong&gt;</code>，顯露所有鋒芒堅持方向，顯露所有鋒芒堅持方向，在我活的地方為什麼你，我嘆了嘆氣 <code>var a = 0</code>。</p>
</div>

<h4 id="連結"><a href="#連結" class="headerlink" title="連結"></a>連結</h4><p>連結的結構略有不同，會分為前後兩個片段符號：</p>
<ul>
<li>前者為 <code>[ ]</code>：中括號內需要補上連結的<strong>顯示文字</strong>。</li>
<li>後者為 <code>( )</code>：小括號內補上的是連結路徑。 </li>
</ul>
<blockquote>
<p>以下為連結範例：<a href="https://www.google.com.tw/">Google</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[Google](https:&#x2F;&#x2F;www.google.com.tw&#x2F;)</span><br></pre></td></tr></table></figure>
<h4 id="圖片"><a href="#圖片" class="headerlink" title="圖片"></a>圖片</h4><p>圖片要特別注意是屬於行內元素，因此圖片也可以放在文字段落之中（與 HTML 中的 img 標籤邏輯一致），不過大多情況下會將圖片作為獨立區塊使用。</p>
<p>圖片也與連結結構接近，只不過前方多了 <code>!</code>。</p>
<ul>
<li><code>![ ]</code>：與連結結構接近，但前方緊貼著 <code>!</code> 符號。中括號的內容也並非必填，其文字內容通常作為 hover 後的提示文字或作為 SEO 增強使用。</li>
<li><code>( )</code>：圖片連結位置。</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">unsplash 圖片</span>](<span class="link">https://images.unsplash.com/photo-1573900941478-7cc800f708f3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2100&amp;q=80</span>)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>實際運作範例：圖片</p>
</blockquote>

<div class="demo">
  <img src="https://images.unsplash.com/photo-1573900941478-7cc800f708f3?ixlib=rb-1.2.1&amp;ixid=eyJhcHBfaWQiOjEyMDd9&amp;auto=format&amp;fit=crop&amp;w=2100&amp;q=80" alt="unsplash 圖片">
</div>

<p>參考文章：</p>
<ul>
<li><a href="https://markdown.tw/">https://markdown.tw</a> </li>
</ul>
]]></content>
      
        <categories>
            
            <category> development </category>
            
        </categories>
        
        
        <tags>
            
            <tag> markdown </tag>
            
            <tag> develop </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：獲利優先，將你的資金塊狀化]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/27/block-your-money/</url>
      <content type="html"><![CDATA[<p>獲利優先的概念是來自於這本書：<a href="https://www.books.com.tw/products/0010794087">https://www.books.com.tw/products/0010794087</a></p>
<p>此書是在介紹公司的資金管理方式，大多數新創公司管理人，容易在資金上升後喪失對金錢的敏感度，導致支出費用過高，收入不敷支出使用而使公司倒閉，這個狀況不僅會出現在公司上，家庭中大數目的資金運用時都很容易忽略掉細節。</p>
<p>這會導致：</p>
<ul>
<li>跳巢加薪才 3000 ，下個月就多花 6000</li>
<li>高金額的費用沒有注意細向花費</li>
<li>月底還以為剩錢，結果在領薪水前透支了</li>
<li>預支未來的資金做運用 （提早透支，真正拿到資金時卻又不夠，只好再次預支</li>
<li>第一次投資就失敗（投入數字過高，導致恐懼心理容易認賠出場</li>
</ul>
<h2 id="資金塊狀化"><a href="#資金塊狀化" class="headerlink" title="資金塊狀化"></a>資金塊狀化</h2><p>為了維持對於金錢的敏感度，書中提供了「資金塊狀化」的概念，簡單來說 10,000 數目看似很大，但如果拆成 2,000 來看就簡單很多，如果把每個花費都用 2,000 做拆分在花費上就容易更警慎，用一個小故事來介紹這個概念。</p>
<p>| 小朋友們參加幼稚園的活動，活動中有一塊大蛋糕，兩三個小朋友就想直接用湯匙挖來吃，想說一起吃一個大蛋糕是可以吃完的，但小朋友們其實沒有辦法掌握自己的食量，加上這麼大的蛋糕容易產生誤判。因此老師看到急忙阻止，因為很清楚這幾個小朋友是吃不完的，接下來老師將大蛋糕一一的切小，每個小朋友都分發到了切片小蛋糕，就能大概感受到這是平常爸爸媽媽切好給他的份量。</p>
<p>不知道大家是否有相同經驗，訂購一大份蛋糕、烤雞、合菜都曾經錯估合適的用餐人數，不是過多就是過少，但一一分盤以後，用餐人數的掌握度就會提高。</p>
<p>金錢的掌握也是同樣的概念，從學生時代的消費都是 50 ~ 100 做計算，長時間下來對於百元上下的費用掌握度提高，出可支配費用上升，但對於上千、上萬的金額敏感度卻沒有因此而提升，沒有足夠經驗的情況，就常常會錯估花費的金額。我們對於小數目的費用已經有數年的經驗，累積下來也有上千、上萬次，但在萬元以上的運用卻僅有數十次到數百次，所以經常容易錯估費用導致額外的花費</p>
<h2 id="用盤子分裝你的存款"><a href="#用盤子分裝你的存款" class="headerlink" title="用盤子分裝你的存款"></a>用盤子分裝你的存款</h2><p>先前的章節介紹到花費基本上可以分為 固定、生活、變動三大類，收入的分配也可以做這種方式<br>有些銀行提供子帳戶的服務，就可將預先將錢分配到不同的帳戶上。經過每月的紀錄，也可抓出這幾個類別在通常需要花費多少；也就像是將食物分盤的概念一樣，集中、大量的食物、金錢我們難以去估算份量。</p>
<p>透過拆分的方式將需要花費的預先保留，以供當月使用，最後再將一部份百分比的費用預先留存<br>（如：每個月另外留下 20% 收入），以薪資五萬為例，結構如下：</p>
<ul>
<li>固定花費 35%：17,500</li>
<li>生活費 10%：10,000</li>
<li>變動花費 10%：10,000</li>
<li>保留存款 45%：22,500</li>
</ul>
<p>每個人的收入、支出大不相同，可依據自己的帳務統計來規劃合適的盤子，使用這種方式更能控制即將花費的項目，也能藉此慢慢的增加存款以供未來投資使用。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：有土斯有財？還是緊握著負債]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/26/buy-a-house/</url>
      <content type="html"><![CDATA[<p>傳統觀念中有土斯有財，不斷的鼓勵大家去擁有自己的土地、住宅，出社會後也會有許多長輩洗腦「該擁有屬於自己的房子」。但在臺北這樣高房價的地區，許多人買了第一間房後就長期背著負債，「窮爸爸、富爸爸」一書中提到「自用住宅即是負債」，雖然房子也是資產的一種，但資產是可以脫手轉為現金的，第一間房是否可以轉為現金呢？還是在房貸的壓力下產生難以轉移的問題。</p>
<p>開始工作幾年以後，到許多同輩開始擁有屬於自己房子，有些人有部分長輩資助，也有些人靠自己買了千萬豪宅，但要特別注意自己是否能夠負擔，如果你和我一樣是沒有長輩資助，全額靠自己的可聽聽以下建議。</p>
<h2 id="買房的負債，以不影響生活為前提"><a href="#買房的負債，以不影響生活為前提" class="headerlink" title="買房的負債，以不影響生活為前提"></a>買房的負債，以不影響生活為前提</h2><p>當然，每個人都會老，老人不太可能在以租屋為前提尋找住所，以目前的社會環境來說會避免租用房子給年長者，為避免額外的延伸問題，大多還是租給年輕學生、小家庭為主，所以長期下來還是需要規劃屬於自己的自住宅。而購買房子時都會有一筆不小貸款，對於貸款有以下的建議：</p>
<h3 id="確保手中現金至少可維持一年的還款費用"><a href="#確保手中現金至少可維持一年的還款費用" class="headerlink" title="確保手中現金至少可維持一年的還款費用"></a>確保手中現金至少可維持一年的還款費用</h3><p>意外總是來的像龍捲風，如被資遣、家中事故、個人因傷無法工作等等…，這都會造成短期的資金不足，許多文章建議每月還款金額低於家庭收入 35%，我自己則是建議更低於此值 (看地區而定)。別忘了，自住宅就是負債，負債當無法轉正（無法脫手）就永遠是負債，</p>
<p>所以除了每月還款外，自己依然要有留存一定的錢財作為<strong>風險控制</strong>及<strong>投資使用</strong>，這是意外發生時無法還款，以及讓自己資產有辦法成長，並在未來能夠將當前房屋脫手使用。</p>
<h3 id="每月還款避免超過租金行情"><a href="#每月還款避免超過租金行情" class="headerlink" title="每月還款避免超過租金行情"></a>每月還款避免超過租金行情</h3><p>租不如買，前提要是買比租還划算，以天龍國內湖的公寓輕鬆突破 1500 萬來說，每月還款約落在 42,000，但平均租金則是 30k+，目前來說台北的房價成長趨緩，如果以往後想要脫手 (或租人)  都會具有風險。</p>
<h3 id="每月還款不影響生活水平"><a href="#每月還款不影響生活水平" class="headerlink" title="每月還款不影響生活水平"></a>每月還款不影響生活水平</h3><p>上一篇有介紹分裝你的費用，頭期款 + 每月還款 將是一筆不小的數目，如果因此壓縮生活品質，會讓人的情緒進入負面的循環，無法出國玩、無法買自己想要的東西、買任何東西都要斤斤計較，加上時程長達二三十年(大概就是自己人生長度了!?)，相信大家不想過著長期被房貸綁架的日子。</p>
<h2 id="也想想你住的是哪一區"><a href="#也想想你住的是哪一區" class="headerlink" title="也想想你住的是哪一區"></a>也想想你住的是哪一區</h2><p>上面的項目列出後，是不是發現似乎沒房好買了呢？</p>
<p>想要買房不是看房價，而是看自己的還款能力，天龍國自然具有高競爭力、高房價；許多買房者最終被房貸壓垮，就是選擇高房價的地區且錯估自己的還款能力，但並非全台灣都是天龍價，如果你的薪資只有雞蛋等級，就別試著去接巨石等級的房價，買房是長期的規劃，全台灣那麼大，雞蛋等級的薪資也會有適合的巢可以放置。</p>
<h2 id="買房的最終目的是賣出"><a href="#買房的最終目的是賣出" class="headerlink" title="買房的最終目的是賣出"></a>買房的最終目的是賣出</h2><p>如果要避免房子就是負債，那就需要確保手中的房子是可以脫手的，傳統觀念買房都是為了自住，出售則是次要目標；但如果將者兩者對調思維結果將會大不同，如果是為了售出優先自住為次要需求時：</p>
<ol>
<li>地點優先而不是屋齡</li>
<li>具有成長性的區域，不會挑選毫無成長力的區域</li>
<li>會逐一挑選有價值的物件，而不會急於一時</li>
</ol>
<p>當觀念改變後，選擇也會大不同。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：超簡易記帳 - 輕鬆規劃你的理財目標]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/25/how-to-accounting/</url>
      <content type="html"><![CDATA[<p>前一篇介紹到退休所需要的資金是兩千萬，雖然這是大部分 “投資廣告” 所提出的金額，但這個金額確切是如何計算出來的呢？這個金額與每個人的花費習慣有很大的關係，兩千萬則是大部分人計算出來的結果，大家也可以用以下方法試著估算一下自己的每月花費，再用每月花費來估算 “年花費”。</p>
<p>目前大部分人類都可以活到 9x 歲來說，從 60 歲退休到 9x 約有 30 年時間，年花費 * 30 就是退休所需的基本金額。</p>
<h2 id="經常錯估的金額"><a href="#經常錯估的金額" class="headerlink" title="經常錯估的金額"></a>經常錯估的金額</h2><p>沒有記帳習慣的人來說，“年花費” 是很容易低估的，因為我們總是會忘記把錢花去哪邊，翻開銀行的交易紀錄，看著上個月或上上個月，總有許多想不起來的大筆支出。因此，記帳將會是預估年花費一個很重要的方法。年花費大多來說也會逐年提高，隨著家庭人員增加、年紀的增長，透過記帳更能了解消費習慣的改變。</p>
<h2 id="簡單的記帳方法"><a href="#簡單的記帳方法" class="headerlink" title="簡單的記帳方法"></a>簡單的記帳方法</h2><p>雖然現在有許多記帳軟體，可以記錄到細微的花費，如早餐、交通、點心等等。但記帳最重要的是區分 “固定花費” 及 “變動花費”，每日的餐點、下午茶、點心，甚至是搭車繞了遠路不需要記得那麼細，這麼細微的紀錄會額外花費許多精力，只要錯過幾次就容易導致放棄。</p>
<p>在此與大家介紹一下我的記帳模式，每月可只記錄兩次（次數越少，越不會因為一次的遺漏導致放棄），紀錄上也僅要針對主要費用做紀錄即可，不需要過度細節。</p>
<h3 id="固定花費"><a href="#固定花費" class="headerlink" title="固定花費"></a>固定花費</h3><p>我們每月都有必備需要支出的項目：</p>
<ul>
<li>水電、房租、房貸、瓦斯費、電話費</li>
<li>保險費</li>
<li>孝親費</li>
<li>及其它每月落差不大的支出費用</li>
</ul>
<p>這些費用每月都需要且數目變動不大，可預先列出固定欄位來記錄這些品項。</p>
<h3 id="生活費"><a href="#生活費" class="headerlink" title="生活費"></a>生活費</h3><p>生活費包含：吃、喝、交通等大部分用小額現金的費用。雖然每天飲食不同、交通方式略有改變，但其實每月的生活費其實差異不大，與其一一的紀錄這些花費品項，不如使用一個固定小錢包來支付這些費用，因此每次提款進入小錢包時，就可以了解生活費的使用狀況，記帳時僅需紀錄提款的時間點、額度就可算出生活費的概略值。<br>(每月幾百元以下的誤差可忽略)</p>
<h3 id="變動花費"><a href="#變動花費" class="headerlink" title="變動花費"></a>變動花費</h3><p>生在江湖，推坑、聚餐、出國玩樂在所難免，因此包含：</p>
<ul>
<li>卡費（依據品項分類）</li>
<li>聚餐費用</li>
<li>玩樂費用</li>
<li>奢侈品</li>
<li>意外費用</li>
<li>服務訂閱費用（雲服務、iCloud、Adobe 服務…，可以使用年計算）</li>
<li>非固定的大金額支出</li>
</ul>
<p>預先訂一個額度（如 2000 元），如果不是每月都需要支付的，只要超過就屬於變動花費，因此<strong>實際上需要另外紀錄</strong>的也是此項目。記帳時，翻開你的信用卡消費記錄或是另外透過工具紀錄這些消費，就可以知道實際的高額消費情況。</p>
<p>下圖是幾年前我實際紀錄的表格，可以算出每月最終的餘額，非固定支出部分也都有註解說明品項，每月紀錄兩次即可。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_9_25_%E4%B8%8B%E5%8D%883_46.png?alt=media&amp;token=61394029-6b9e-45df-8b60-a889f8bc19e6" alt=""></h2><p>有了以上帳目之後，你可以了解到：</p>
<ul>
<li>多少錢是你的最低需求（固定花費 + 生活費）</li>
<li>哪些費用是可以節省的（變動花費的特定項目檢視）</li>
<li>一年多少錢，你可以過的還不錯 (固定花費 + 生活費 + 變動花費)</li>
</ul>
<p>一年兩千萬的退休金<br>也就是大多數人的 <strong>固定花費 + 生活費 + 變動花費</strong> 總和（約每年 60 萬），乘上 30 年的結果，平均則會落在 1800 ~ 2000 萬之間。</p>
<p>透過記帳，可以真正認識自己的消費習慣，能夠了解每年可動用的金額是多少，預先規劃出幾年的投資計劃，並且預先推算退休所需的費用，藉此設計出屬於個人的投資方式。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：iPhone 11 Pro Max 心得文]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/24/iphone-11/</url>
      <content type="html"><![CDATA[<p>參加個人挑戰的好處，就是可以隨意的歪樓！？</p>
<p>最近入手了三眼神童 iPhone 11 Pro Max，在這支手機上是好幾個月前就已經打算入手，與這台本身的特性沒有什麼關係，會購買主要原因是一般的 LCD 手機螢幕只要看 5 分鐘就會開始頭暈，也因為如此，一天觀看手機的時間平均是不超過 30 分鐘的（不清楚原因，目前僅了解對於要專注細微的發光體會感到不適）；看過 OLED 後發現可以減輕看螢幕的不適，加上家中老母希望可以換一台手機，所以就適順勢換一台手機了。</p>
<p>我：「要 Android 的還是要我用過的 iPhone？」</p>
<p>老母：「iPhone」</p>
<p>我：「iPhone 二手的，確定？」</p>
<p>老母：「我要 iPhone」</p>
<p>所以就只好順勢換一台手機，把舊的 iPhone 給老母。另外 OLED 也並非蘋果專利，看到 Pixel 系列也是有些興趣，但不得不說蘋果近幾年除了 iPhone 以外，更重視整個生態系，例如：</p>
<ul>
<li>蘋果系統下的 iCloud 對於相關產品的支援度很高，加上老婆手機儲存空間不足時，可以直接升級成家庭版的 iCloud，費用不高也方便。</li>
<li>各裝置的整合性，如 iPhone 所接到的電話可以使用 Mac 接聽，Mac 複製的連結可以直接貼到 iPhone 上（直接開啟也沒有問題）。</li>
<li>與其它的裝置便利性，AirDrop 可以直接丟檔案可其它人，AirPlay 可以不接線直接投影畫面等等。</li>
</ul>
<p>而這些功能就會讓習慣 iPhone 的人在轉移上有所顧慮，綜合以上所述，反正我就是買了一台 iPhone。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2FIMG_4072.png?alt=media&amp;token=9110f2bc-a765-4454-b185-b6fd1a13463e" alt=""></p>
<p>我選擇的是金色的 iPhone，雖然這次主打的是新色彩夜幕綠，但我對於深色並沒有特別的愛好，所以還是從亮色系做選擇（金或銀），當然兩者都不錯，後來選擇略有些變化的金色。</p>
<h2 id="11-Pro-Max-的優缺點"><a href="#11-Pro-Max-的優缺點" class="headerlink" title="11 Pro Max 的優缺點"></a>11 Pro Max 的優缺點</h2><p>這次的 iPhone 主打特色就是三眼神童，具有超級強的相機，在官網的介紹中可以發現三眼相機介紹佔了將近 2/3 的篇幅，這幾天並沒有拍相當多的照片，但還是可以略感受到它與前幾代的差異，如：</p>
<ul>
<li>色彩更討喜：這點我認為是最大的改動，雖然 iPhone 一直給人稱讚的是接近原色的表現，但原色不一定是討喜的色彩，這方面在韓國、中國的手機可以感到很大的優勢，而這次的 iPhone 依然與原色接近，但同時更能呈現豐富的變化色彩在其中，讓畫面更為討喜。</li>
<li>暗處表現更好：AI 的運算已經讓暗處不受相機感光的限制，而三眼童子結合 AI 自然能有更優的表現。</li>
<li>長距離拍攝依然清晰：多一個長鏡頭當然會更好</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2FIMG_0020.png?alt=media&amp;token=75a407f7-a1a3-4755-b92c-c89245e2346f" alt=""></p>
<p>拿到手機後帶著女兒去草衙道，但是她幾乎從頭哭到尾，只有在晚上的時候才能好好的拍一張照片，雖然畫面上所提供的是室外照片，但不得不說這次在室內的日光燈下也有很好的調整，讓膚色不會像過往一樣偏綠，看起來會更討喜。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2FIMG_0021.png?alt=media&amp;token=9ee843e9-2834-4f5b-9abe-642a4eeb5545" alt=""></p>
<p>這次的相機加入了長時間曝光，這對於習慣使用單眼的拍照者來說多了更多成像手法，雖然如此，對於手抖者來說，透過 AI 的輔助夜景也依然清晰。</p>
<p>除了相機以外，再說說從 iPhone 8 替換成 11 Pro 的一些感想：</p>
<p>優點：</p>
<ul>
<li>OLED 螢幕：這是換這台手機的主因，搭配深色主題讓畫面呈現對我沒那麼刺眼，使用來說可以比以往有更長一點的時間（恩，就長一點，大概兩倍吧，所以適十分鐘）；不過官方說的螢幕可以呈現更亮這對我來說就沒什麼興趣了 ～＿～。</li>
<li>深色主題：結合上述優勢，自然能讓眼睛能夠更為舒適，且現在許多 APP 也開始加入深色模式，使用上也比較不會疲勞（OLED 在黑色部分是不發光的）。</li>
<li>刷臉：真的挺方便的，臨時 LINE 的訊息喵一眼就能看到。</li>
<li>三眼神童：很厲害，但沒仔細用的拍照功能，有機會會希望多些嘗試，讓我回到文青的年代（有那個年代過嗎）。</li>
<li>還沒看過的 Apple TV+</li>
</ul>
<p>這台也並非沒有缺點，其中 3D Touch 的移除是最難過也是最不爽的，在先前的版本 3D Touch 很適合用來看 LINE 的訊息，而且不會變成已讀的狀態，這就很適合用來看老婆傳來的訊息（x）；現在改了一個爛名字，找個爛藉口來取代本來的優點，更不爽的是 Macbook 的 Touchbar 更沒有用，卻不找個機會將它給移除。</p>
<p>現在只希望 LINE 能夠透過長點擊來開啟訊息，讓訊息不會變成已讀 :(。</p>
<p>另外也由於 Home 鍵的移除，許多操作就與原本略有不同，像是 Apple Pay 的啟用改為右側按鈕點擊兩下，這也讓付款的時候一時不知道怎麼使用，還好店員遇過類似問題立馬解決我的困惑。</p>
<p>目前入手還沒有幾天，加上使用時間並不長，有機會希望可以補上更多的介紹。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：從哪邊學習投資？]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/23/where-to-learn/</url>
      <content type="html"><![CDATA[<p>在開始學習投資以前，我心裡是牴觸的，主要原因是不了解，認為這是高度風險的財富管理方式。身邊也有許多人對於投資不熟也會有這樣的疑惑：</p>
<ul>
<li>聽說買股票的人都賠錢誒 &gt; 如果都賠錢怎麼會那麼多人投入</li>
<li>是不是要很多錢才能開始學投資啊 &gt; 是投資才有錢，不是有錢才投資</li>
<li>那是內線的人玩的，我們這種局外人玩不起 &gt; 真正好的股票不是少數人決定的</li>
</ul>
<p>這些疑惑其實是來自於自身恐懼心理造成的，各種優點將會被忽略不見，而將細微的點不斷放大。</p>
<p>正確的投資來說，只要掌握少量的幾檔好投資標的，不斷的長期持有就可以致富，以 <a href="https://goodinfo.tw/StockInfo/StockDetail.asp?STOCK_ID=2330">GoodInfo</a> 這個網站來說可以填入股票名稱，下方就會列出這張股票 每月、每季、半年、年、三年、十年的成長紀錄，在此可以試著輸入認識的股票名稱，就可以看到這些股票的成長狀態，以近年來大家都認識的台積電來說，三年的成長幅度也有 47% (2019/9/9 的資料)，意指投入 100 萬，三年後如果賣出至少有 147 萬，<strong>另外還有每年的股利可領取</strong>。</p>
<p>上面僅是列出公開的數據，更重要的是如何選擇一個投資標的，無論選擇的是海內外股票、債券、基金等等，在沒有任何經驗之前，都需要一名導師來帶領我們進入這個領域，選擇導師的重點：</p>
<ul>
<li>產生連結</li>
</ul>
<p>選擇導師時，盡可能選擇能與其產生連結的導師，無論是家人、朋友、同事，因為投資過程中是非常漫長的，許多問題都是在操作的過程中才會出現，在遇到問題時能夠詢問「導師」會增加你持有的信心，避免在正確的機會下做出錯誤的操作。</p>
<ul>
<li>信任</li>
</ul>
<p>信任再投資中是非常重要的，為何選擇一檔股票都是可以用「信任」這個詞來說明，在與任何導師進行學習時，會有產生不斷的溝通對答，如果你無法信任這名導師的教導，就別繼續與這名導師學習，因為不信任也會使操作投資時的信心動搖，無法具有長期持有的信心，容易在投資目標短期下跌時就出手導致賠錢。</p>
<ul>
<li>獲利經驗</li>
</ul>
<p>上方我提出了持有台積電三年可成長 47%，這句話具有很大的錯誤，真正的投資獲利來自於兩個步驟，一是從購買到賣出中間的價差；二則是持有時間的利息。因此，除了股利以外，如果沒有賣出就無法賺到那個 47%，而且大多數人看到股票成長時都會繼續持有，下跌時賣出，許多老鳥也會說到：股票中最困難的判斷是「何時賣出」。所以找的導師不僅要教如何買，更要教你怎麼賣！</p>
<p>哪邊可以找到投資的導師呢？每個人的背景不同，適合的方式也不同：</p>
<h3 id="工作場所"><a href="#工作場所" class="headerlink" title="工作場所"></a>工作場所</h3><p>這是我主要學習投資的地方，也很幸運讓我有機會糾正錯誤的財務觀念，當學到一定程度以後，也從中了解到什麼是財富自由，且財富自由並沒有那麼困難。</p>
<p>並非所有的工作環境都會有擅長投資的同事，依據產業的不同，每個工作者所具有的次要幾能也會不同，有些擅長交際、有些則擅長交易。因此要尋找擅長投資的同事，可以從百大企業、金融體系、具規模的傳產、公教體系這些尋找，因為這些員工普遍來說收入穩定 (不太會換工作) 且具有一定資金 (有一定年資)，所以比較會投資股票。</p>
<h3 id="專門的講師"><a href="#專門的講師" class="headerlink" title="專門的講師"></a>專門的講師</h3><p>去除上面兩種，如果還是無緣接觸，則可以試著去尋找專門的講師，專門的講師具有一定經驗，且會為了課程專門設計教材，在學習上自然會更有成效。但要特別注意，講師相對來說難以產生連結，除了學習外一定要從過程中與人再次產生連結 (講師或其他學員)，這樣在實際操作的過程中才能解除疑惑，更能降低投資失敗的機率 (投資只要降低失敗就能穩定成長)。</p>
<h3 id="家庭"><a href="#家庭" class="headerlink" title="家庭"></a>家庭</h3><p>如果家族中有人擅長投資，尤其是自己的父母，從他們開始學習最好，因為他們是最能夠直接產生連結與信任的導師。大部分的家庭都是不斷地述說金錢的可惡，但卻沒有教導正確的理財觀念，導致窮不只窮一代，還窮了好幾代，這不僅是物質上的窮，更是心態上的貧窮(因為恐懼而不學習)。</p>
<p>這也是出社會以後的體悟，因此也很欣賞將理財經驗傳授給自己子女的家長，而不是避而不談相關的財務概念。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：充滿未來希望的成長公式]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/22/hope/</url>
      <content type="html"><![CDATA[<p>當初花了大量的時間不斷充實自己能力，目的就是可以能拿到更好的收入，雖然薪資也如預期的不斷成長，但是心中還是有一個結沒有解開，以台灣來說，每個人退休所需要的資金約是兩千萬，在薪資成長的幅度下，就算不吃不喝達到目標還是非常的困難。</p>
<p>主計處所提供的網站來說，研究所畢業生年收入在 100 萬也算是接近中位數，而 100 萬實際要存下來的錢並不多，以一般大部分人的年支出約落在六十萬的情況下，實際能存下的約四十萬，以不買房地產的情況下至少要存 50 年，更別說要買房或者薪資未達中位數的。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_9_22_%E4%B8%8B%E5%8D%884_37.png?alt=media&amp;token=3ae0eea2-93ef-4f15-8eaa-6a703e12bdad" alt=""></p>
<p><a href="https://earnings.dgbas.gov.tw/experience_sub_01.aspx">https://earnings.dgbas.gov.tw/experience_sub_01.aspx</a></p>
<p>而這個問題，在我進入鴻海後有很大的轉變，還記得有一天主管問我，認為要工作到幾歲時退休呢？</p>
<p>我很天真的回覆：「應該是需要工作到老吧」</p>
<p>他很認真的回覆：「為了錢工作一輩子這個思維是不對的」</p>
<p>也就持續跟我說明理財的重要性，還記得剛開始的前幾年我無法接受他這個思想，認為「不工作就有錢」是有錢人才有可能達到的，而在這個大企業下，可以認識許多對於財務管理有一定掌握的人。因此那幾年，除了眼界有很大的不同外，對於理財的觀念也有很大的增長，也對於這些觀念慢慢有所改觀，也在此學到不同的理財觀念，並整合成屬於自己的投資模式。</p>
<h2 id="透過理財觀念，大幅降低難度"><a href="#透過理財觀念，大幅降低難度" class="headerlink" title="透過理財觀念，大幅降低難度"></a>透過理財觀念，大幅降低難度</h2><p>以下說明很容易理解的概念，假設我們每年能夠存下的款項是 30 萬，如果持續 20 年不中斷則可以存到 600 萬；但如果透過股票或各種形式的投資 (每年 7% 的成長率)，一樣每年投入 30 萬約 14 年就可以達到 600 萬（到此投入才 420 萬），而 20 年後則有機會可以達到 1200 萬（投入 600 萬），這樣的數值是單純存款的兩倍（注意，這是極度理想化的數值，實際上還是依據每個人的投資選擇而定）。</p>
<p>公式參考：<a href="https://docs.google.com/spreadsheets/d/1YosXnSu3nguHuQEpJ9xpdVbD3V1x1pPKFSH37eeSjzM/edit#gid=1444089297">https://docs.google.com/spreadsheets/d/1YosXnSu3nguHuQEpJ9xpdVbD3V1x1pPKFSH37eeSjzM/edit#gid=1444089297</a></p>
<p>除此之外，如果是每年 7% 的成長率，每七年則會翻倍一次。</p>
<p>意指，上述的資金在 20 年後沒有再持續投入，則會在第 27 年到達 2400 萬（成本依然是 600 萬）。沒有學會投資理財的觀念，很難想像如何存到退休所需要的資金，而且沒有正確的理財觀念，縱使獲得了 2000 萬也很難妥善管理。</p>
<p>而是否是在真的有足夠收入時才思考投資呢？絕對不是，金錢投資是要在平時就要慢慢培養觀念，資金的成長不是立即性的（有，也通常輪不到大部分人），透過平時的累積觀念，才能在機會來臨時正確出手。但大多人會忽略這段期間的理財觀念培養，當有足夠資金時，想嘗試投資時又無法掌握大數字的精準度，也就因此會常聽到新手投入股市失敗，卻又不敢再次投入的故事。</p>
<p><a href="https://github.com/xiaolai/regular-investing-in-box">https://github.com/xiaolai/regular-investing-in-box</a></p>
<blockquote>
<p>李孝來：投资，是我能找到的唯一一个普通人可以跨越阶层的通路</p>
</blockquote>
<p>跨越階層的方式非常多，創業、中樂頭、理財投資等等方法非常多。撇除中樂透的低機率以外，創業也是一種方式，但創業的成功率極低，<a href="https://www.businesstoday.com.tw/article/category/80407/post/201807060013/%E5%9C%A8%E5%8F%B0%E7%81%A3%EF%BC%8C%E5%85%AC%E5%8F%B8%E6%88%90%E7%AB%8B%E4%B8%80%E5%B9%B4%E5%80%92%E9%96%89%E7%8E%87%E7%AB%9F%E8%83%BD%E9%AB%98%E9%81%9490%EF%BC%85%EF%BC%9F">根據經濟部中小企業處統計，公司成立一年內倒閉的機率高達 90%</a>，相對來說投資理財是成功率更高的，但並非每個人都有機會可以接觸到合適的理財導師。因此，不斷的學習成長是非常重要的，在增加物質上資產的同時，也增加思維上的資產，讓自己更能接觸到符合自己的理財導師。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：樂觀、悲觀 - 財務的思維改變]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/21/poverty/</url>
      <content type="html"><![CDATA[<p>出社會以前，因為對於市場的不理解，所以有許多「天真」的用詞，也因為這個天真過去還認為自己挺樂觀的，曾經認為窮人與富人差異沒有那麼大，許多故事都告訴我們窮人也能翻身。</p>
<p>但出了社會才瞭解故事只是故事，那並非容易的事情。</p>
<p>小故事：</p>
<blockquote>
<p>舉個例子，一個不靠家中努力向上的青年，每天早出晚歸，年收入約落在 120 萬的情況下，除了生活費、卡費、孝親費等每年亦能存下 60 萬（實際上收入越高，支出也會越高），後來看收入不錯就買了台北市一間公寓價值 1500 萬，（貸款 1200 萬情況下，每月約四萬的房貸，每年的支出增加 48 萬），接下來的每年的存款剩餘 12 萬。</p>
</blockquote>
<blockquote>
<p>而另一位家境小康的朋友雖然不算挺有錢，但家中資助一間台北市公寓，雖不算認真，但吃住都在家中費用省下許多，年收入 80 的情況下，因為沒有孝親費及房貸每年存款依然有 50 萬，加上家中從小就幫小孩存上基金、股票，每年還有十幾萬可領，另外還有持續增加的資產。這樣穩健的基礎下，再不背負房貸的情況下資產輕鬆超越「努力向上的青年」，加上家中持續灌輸基本的理財觀念，所以長期下來也是不愁吃穿。</p>
</blockquote>
<p>上述故事可以了解到家庭背景對於新鮮人的影響，更何況出了社會，就要認真面對 “收入” 這個問題，除了要能夠養活當前的自己外，也同時需要為了 “未來“ 以及 ”風險“ 做準備，一個人老年約需要的資金約是兩千萬，而風險更是不確定性，除了自身的風險外，更大一部份來自於長輩的風險（年紀大自然容易遇到不確定性的意外），這些風險可能會讓我們短時間內沒有收入，並且面臨許多親情與現時兩難的問題。</p>
<h3 id="從自以為的樂觀到悲觀"><a href="#從自以為的樂觀到悲觀" class="headerlink" title="從自以為的樂觀到悲觀"></a>從自以為的樂觀到悲觀</h3><p>問題不斷的湧出後，每天都在思考該怎麼面對這些困境，每當越思考就會越難過、越悲觀，這是一面難以跨越的牆，並非無法做到，只是一時找不到解法，卻不曉得這個問題讓曾經自以為樂觀的自己，慢慢的散佈出悲傷的情緒到周圍的人身上，直到有人對我說到：「我認為你挺悲觀的」，才真正地認清這樣的思維對自己的打擊有多大。</p>
<p>貧窮分為兩個層面，一個是物質上的貧窮，另一個則是思維上的貧窮，我們大多數被物質上的貧窮限制了思維的成長，所以有句話說「貧窮限制了你的想像」，負面、悲觀的思維也是如此。因此，要達到物質的富有，也需要先讓思維富有才行。</p>
<h3 id="重新振奮"><a href="#重新振奮" class="headerlink" title="重新振奮"></a>重新振奮</h3><p>思而不做是沒有任何幫助的，出社會的第二年以後我投入許多技職上的改變，目的是消除這些恐懼，另一方面則試著去面對這些問題。到了現在，透過學習讓有機會進入更好的環境，更高的薪水、更優秀的人才、更豐富的環境，也因此慢慢改變我原有的想法，更知道如何改善自己及未來的生活。</p>
<p>接下來幾篇會寫到關於財務觀念的改變，這些觀念讓我重新規劃我的人生，並深切地相信我的女兒可以過得比我更富有。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：改變思維的三個重要技能]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/20/three-skills/</url>
      <content type="html"><![CDATA[<p>當掌握第二個技能以後，視野自然也會更為開闊，出社會陸續掌握的技能不少，雖不一定到精通，但有些技能帶給我許多思維上的衝擊，讓我不得不思考過去的觀念是否需要調整，也慢慢地了解到為什麼能力越強的人會更為謙卑。</p>
<p>出社會後主要改變思維的三個技能為：</p>
<ol>
<li>程式</li>
<li>理財</li>
<li>行銷</li>
</ol>
<h2 id="程式語言"><a href="#程式語言" class="headerlink" title="程式語言"></a>程式語言</h2><p>雖然在學生時代就開始慢慢接觸程式語言，但真正認識則是出社會以後，程式語言真正教給我的並不是單純一個技能，它同時能夠影響工作效率及思考能力，並且因為這是趨勢，它同時會帶來更為主流的工作型態及思維。以下大致列出對於我的改變：</p>
<ul>
<li>掌握趨勢：軟體開發是趨勢，而我的切入點是前端開發，前端開發的崛起與目前的行動裝置有很大的關聯性，也因此更需要了解目前行動裝置的趨勢。~所以，買新手機絕對可以說是為了工作。~</li>
<li>高速學習的技能：現在的程式語言淘汰更快，尤其是前端，因此不斷學習是必備條件，也因此開發者的學習速度相對來說是更快的。</li>
<li>持續學習：同上，因為我們知道技術有可能被淘汰，所以自然養成持續學習的習慣，長期下來我們更能避免在社會上被淘汰。</li>
<li>自動流程：軟體開發者大多都很懶惰，步驟能越少越好，如果是同一件事情需要無腦的反覆執行時，開發者就會將它給自動化，藉此能夠釋放出更多的時間，做更有價值的事情。</li>
<li>工作模組化：開發中很重視相同的程式碼 “不要” 寫兩次，因此會習慣將類似的片段給模組化，這對於工作管理及效率有很大的幫助。</li>
<li>更能掌握價值的核心：作為開發者，工作很容易就進入核心（當沒有工程師時，也代表產品無法完成），很容易清楚自己的定位，也能夠從中獲得許多成就感（~不過也容易從中迷失~）。</li>
<li>邏輯能力：開發的過程中自然會不斷的訓練邏輯能力，這會讓理解事情的速度加快，並且與不同領域之間具有更有效率的溝通（無法溝通的人也就無需溝通）。</li>
<li>分享：能夠獨佔就代表自己優於其他人，這是許多傳統技能的邏輯，但在軟體開發上不一定是好事，許多企業也慢慢將專有技術開源化，因此「開源已是常態，分享更能造福更多人」（包括未來的自己）正是軟體開發的生態。</li>
<li>社群：由於新技術不斷出現，自學的速度有限，必須透過各種形式來加快「認識新技術」，而社群也因此孕育而生，率先掌握技能者可以從分享加強對新技能的概念，而後進者也能從中認識新的技能，開發者們也能透過社群增加彼此的連結，形成互助的環境。</li>
</ul>
<p>在這個社會上，更能看到許多具有軟體技能的成功者，無論是在原有或另一個領域都能有不錯的表現。</p>
<h2 id="理財"><a href="#理財" class="headerlink" title="理財"></a>理財</h2><p>對於財務方面長期沒有安全感，不僅是對於當下，更對未來感到無力，而在鴻海工作的那幾年與同事之間學習與討論許多相關的觀念，並且糾正長期對於理財的錯誤觀念，也讓我從對於財務沒有安全感並漸漸地對於此充滿希望。</p>
<p>本系列文章會有許多關於理財的主題介紹，讓大家慢慢地了解為何我會從缺乏安全感到對未來感到希望（絕對可以開場就讓大部分人感到絕望），相關內容會有大量的篇幅作介紹，在此就不多述。</p>
<h2 id="行銷"><a href="#行銷" class="headerlink" title="行銷"></a>行銷</h2><p>這段標題是 “行銷”，更精確地來說是 Growth Hacker。開發、設計的過程中都是用 “我” 的思維在執行，例如：</p>
<ul>
<li>我認為這個色彩比較好</li>
<li>我認為流程應該是這樣</li>
<li>我認為用戶喜歡這樣做</li>
<li>我認為 XX 廠商這麼做廣告效果不會好</li>
<li>我認為主管的意見不專業</li>
<li>我覺得老闆這麼做一定會虧錢</li>
<li>我覺得工程師沒有站在用戶端的思維</li>
<li>我覺得賈伯斯在世一定會這麼想</li>
<li>強者我朋友的意見是 …</li>
<li>…</li>
</ul>
<p>這樣的思維具有強烈的自我意識，這些意見容易造成與其他人的衝突，更重要的是 <strong>無法證明是否正確</strong>。以 UX 來說，我們都清楚站在用戶端思考是正確的，但如何真正的站在用戶端呢？難道是去詢問用戶？（透過直接詢問時，此流程已經有所預期性，參考性將大幅降低）</p>
<p>幾年前接觸到 Growth Hacker 時，慢慢地了解到大多數人所認為的與用戶具有非常大的差異，因為我們的生活環境不同，無法真正認識其他背景的人們，所以許多猜想都是無意義且錯誤的，更有效的方式是直接透過數據來分析用戶行為，透過學習這個技能也知道自己的思維不代表他人，也知曉應從另一個觀點觀察這個社會。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：放棄十年本科經歷，投入網頁開發領域]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/19/became-a-webdesigner/</url>
      <content type="html"><![CDATA[<p>當完兵投入社會的時候，家裡也剛好出了些事情，心中最大的希望就是找份工作。當時，Flash 因為 iPhone 的出現而沒落，所以當下選擇可以是回到設計的本業、網頁設計師或者是繼續找 Flash 工作試試看（沒落，但它還是存在的）。</p>
<p>而無論哪一種，其實我當下的選擇是 “看哪個薪水多，就選哪個！”；打開求職網站後「設計的工作基本上可以移除了」，普遍的薪資是低於網頁設計、Flash 的工作，所以就以網頁設計師、Flash 的選擇為主。</p>
<p>我投的履歷並不多，可是有投的履歷只要有回應，基本上都是錄取的，主要是在研究所的 Flash 作品非常搶眼，加上學歷及經歷（得獎）的優勢，面試上很容易就能打動人，其中一間主要製作 Flash 教學的公司也坦言：「如果到他們公司，很快就能升上主管」。但也是考慮長久的發展性，我又再次放棄修練許久的專長，投入另一個不熟悉的領域。</p>
<blockquote>
<p>除此之外，雖然我是台北人，但後來都在高雄工作，許多人會因此詢問為何在高雄工作？而不是在機會豐富的台北，相關的內容將會有獨立篇幅作介紹。</p>
</blockquote>
<h3 id="放棄原有技能，有時能獲得更多"><a href="#放棄原有技能，有時能獲得更多" class="headerlink" title="放棄原有技能，有時能獲得更多"></a>放棄原有技能，有時能獲得更多</h3><p>進入第一間公司是以接案為主，起初壓力挺大的，原因在於我是使用平面設計觀念在製作網頁設計，主管並不滿意我的設計作品，但由於主管並未具有設計背景，所以給予的建議也不一定能精準到重點：</p>
<ul>
<li>我覺得你的顏色這樣不行</li>
<li>你不能用平面設計的思維做網頁</li>
<li>你可以多參考前輩們的作品</li>
</ul>
<p>就這樣反反覆覆也花了不少時間摸索什麼是 “網頁設計”，幾周的時間下來也好不容易交出勉強被接受的作品，但也深知自己能力上的不足。</p>
<blockquote>
<p>後來自己當老闆，在給予新進的平面設計師員工建議時，也一直會想到這段過去，但也好在自己是設計底，給予的建議也能夠更精確</p>
</blockquote>
<p>接下來空閒的時間就不斷投入網頁設計的研究，會去不斷的翻找當時主流的開發模式，如：</p>
<ul>
<li>響應式網頁 → 行動版剛開始盛行，由於是屬於新技術，投入後就是跟著浪頭走，許多優勢很明顯。但也由於是新技術，所有的觀念都要自己想辦法摸索。</li>
<li>文字編輯器 → 當時公司是 Dreamweaver 為主，後來改用 Sublime Text 戒除所見即所得的開發模式（WYSIWYG）。</li>
<li>Sass → 一開始我還以為是一種軟體，可以直接外掛於 Dreamweaver 或其它文字編輯器下，研究後才知道需要 Ruby 環境。</li>
<li>CSS3 → 雖然當時 CSS3 並沒有被許多瀏覽器所支援，但提前掌握這些技術在往後可被支援時，可以優先並精準的使用在網頁上。</li>
</ul>
<h3 id="社群是什麼？"><a href="#社群是什麼？" class="headerlink" title="社群是什麼？"></a>社群是什麼？</h3><p>不斷的尋找新的技術、資源，自然也會搜尋到相關的資源，當時洧杰正好創立「高雄前端社群」，好奇心的驅使下也就去參加了，也由於「前端」這個技術正在發展中，也會思考如何強迫自己加快成長速度，當下決定站上講台與他人介紹來加速成長，因此與 洧杰 毛吹自薦介紹幾場不同的技術，這帶給我了：</p>
<ul>
<li>更快速的成長</li>
<li>除了學一次，還要懂的如何介紹</li>
<li>認識許多比我更厲害的人</li>
<li>知道自己還有哪些需要進步</li>
</ul>
<p>我也不是擅長在講台上分享的人，一開始很會很緊張面對數十人介紹一個主題，不過當時的想法是「提早犯錯總比未來犯錯成本更低」，透過幾次的介紹也會越來越熟悉該如何面對多人的舞台，其實也不會有人在意犯的哪幾個小錯誤，也因此認識許多前端的高手，讓自己接下來遇到問題也能有人可以討論。</p>
<h3 id="鐵人的開始"><a href="#鐵人的開始" class="headerlink" title="鐵人的開始"></a>鐵人的開始</h3><p>接下來，除了在台上介紹技術外，我更希望能有平時的學習計畫，如果希望一個持續性目標可以達成，就試著與周遭朋友或更多人說（立下 flag），因此我立下一個百日貼文的 flag，也順勢的被洧杰推坑參加了 IT 邦幫忙的鐵人賽，至今還是維持每年有 30 天的學習習慣…。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：初入程式語言，沒想到是 JavaScript 的親戚啊]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/18/start-to-learn-program/</url>
      <content type="html"><![CDATA[<p>由於家境的關係，對於金錢一直都沒有安全感，雖然視覺設計、繪畫等等是興趣，但很清楚趨勢不是如此，研究所期間可感受到：「平面設計是夕陽產業，網頁等多媒體會是趨勢」。許多面向都証明如此，如果對金錢沒有安全感，就勢必需要做一些改變。</p>
<p>當時，網路上很紅的技術是 Flash，臉書在台灣也才剛崛起，那時候大家最常玩的遊戲就是開心農場，開心農場就是 Flash 的遊戲之一。而 Flash 當時是搭配 ActionScript 3.0 （簡稱 AS），這也是基於 ECMAScript 規範開發的語言，因此與 JavaScript 本是同根生，當時我也不會任何的程式語言，只是想著：「我要是可以做出類似的遊戲，相信以後會有更好的收入」，運氣也是挺好的，在當時都不懂的情況下居然選到目前主流的 ECMAScript 的同規範語言。</p>
<p>接下來為了一股腦的投入學習 AS 之中，為了可以全心全意學習該語言，當時也跟指導教授請求說希望以此做遊戲（藝術學院說要寫程式做論文的概念），搭配著經過 “設計” 的圖像，硬是在最後一年的期間做出一款小遊戲。</p>
<p>遊戲畫面的一景，目前遊戲忘記丟在哪了（遮臉），要是當年就認識 Github 有多好。</p>
<p><a href="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_9_18_%E4%B8%8B%E5%8D%884_00.png?alt=media&amp;token=7df7e4ae-130d-4e05-86f4-042f84076f2a"></a></p>
<h3 id="學習的經驗分享"><a href="#學習的經驗分享" class="headerlink" title="學習的經驗分享"></a>學習的經驗分享</h3><p>在一開始也是抱著天真的想法：「什麼程式語言的，了不起一個多月我就能學會」，預估學習程式及撰寫的時間也沒有很長，但實際上我學到差點放棄想休學 :(，這段我們就放到後面再說。</p>
<p>以學生來說，最便宜的學習方式莫過於買書，那時買了數本 AS 的書籍，包含：</p>
<ul>
<li>基礎教學</li>
<li>字典類型的 AS 書籍</li>
<li>特效範例等等</li>
</ul>
<p>如果從零開始學來說，基礎教學是最有效果的，因為可以從中瞭解程式碼運作的概念，記得很清楚當時為了搞清楚什麼是 <code>var a = 1</code>; 這句話其實就花了不少時間，更別說後來還要練習寫陣列、函式等等（其實我到作品完成後，還是沒有搞懂什麼是陣列）。所以在初學的時候最重要的是從範例中獲得一些些成就，別急著了解整個來龍去脈的觀念，讓它動起來再來思考細節。</p>
<p>字典類型的書籍是次要的，因為當時的文字編輯器（也就是 Flash 本身）的提示並不完整，所以當有語法上的需求時都是直接從字典中查找。最少用到的書籍則是範例特效，這些酷炫的效果並不一定適合放在作品內。</p>
<h3 id="放棄的心態"><a href="#放棄的心態" class="headerlink" title="放棄的心態"></a>放棄的心態</h3><p>確實，我也是曾經想放棄這條路，學生時代缺錢加上獨立學習上的挫折感，在資源匱乏的情況下不知道可以從哪詢問，且日子一天一天過去，作品離完成還有很大一條路，也曾經跟家裡提到：「想要放棄研究所的學歷」。家裡的人後來也說給一些錢來讓我完成這個學業（後來我沒有拿），希望我可以再撐下去，也因為那多一點點的堅持，讓現在有機會可以投入前端開發這條路。</p>
<h3 id="影響"><a href="#影響" class="headerlink" title="影響"></a>影響</h3><p>後來出社會的時候，拖賈伯斯的福 Flash 瞬間沒落，學了許久的 AS 馬上就派不上用場（雖然拿著個作品去面試時，基本上是不會被打槍的）。不過一個沒落也意味著另一個崛起，此時前端開發是正流行起來的時間點（預先準備，機會才會有可能來臨），也正好 AS 與 JS 本是一家親，所以再轉學習時的成本是比較低的。</p>
<p>除此之外，雖然早期資源沒有現在那麼多，那麼也會相對越早投入的人，越容易取得領先優勢並搶得先機；而現在的資源豐富讓更多人可以快速掌握技術，讓這些技術也並非只有少數人所掌握，大家不斷的成長情況下，業界審視這些人才時的標準自然會提高。以 JS 來說，過去僅需要掌握 jQuery 就足夠了，但現在除了函式庫、框架需要有基本的了解外，對於 JS 核心運作也需要有一定的掌握度。因此無論過去與現在，其實學習都需要花上大量的時間與精力，只是前者著重於探索，後者更需要專精。</p>
<p>雖然我花了一年左右的時間從無到有學會了 AS，在還沒派上用場的時他就已經沒落，但可以證明的是「學習」本身就是讓自己更容易接近機會的方法，我們無法確認學習到的技術是一定可以當下派上用場，但學習是可以不斷累積，並且造成良性的結果。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：從設計轉開發者的思維改變]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/17/design-to-developer/</url>
      <content type="html"><![CDATA[<p>在學期間我的主力是「美術及平面設計」，從國中開始一直到研究所都是屬於相關領域，軟體開發是一個很大的轉變，這個轉變不僅影響我的生活更影響我的思維。也因為如此，我會向許多設計師推薦學習軟體開發，</p>
<h3 id="設計"><a href="#設計" class="headerlink" title="設計"></a>設計</h3><p>小時候很喜歡看動漫，也因此認為自己喜歡畫畫，家中也認為我應該對此是有興趣的（我也真切的這麼認為），後來從國中在美術才藝班（算補習班吧!?）&gt; 復興商工美工科 &gt; 台南大學美術系 &gt; 高雄師範大學 視覺設計研究所 都是屬於美術、設計相關體系。</p>
<p>而學習的過程中，才慢慢的發掘自己比較想要什麼，但這個路程也是非常漫長的。以復興後期來說，認為自己對於美術的喜愛度或許沒那麼高，更希望能夠做出具有「價值」的作品，所以在高三時就選擇「視覺傳達組」，希望自己的作品並非只有用在升學或是自己觀賞，而是真正的可以賺錢。當然，以高職那時候還是太嫩惹，但至少已經慢慢往「價值」這個目標邁進。</p>
<blockquote>
<p>當時那組不僅是全校分組第一，也是當時代表學校參與新一代設計展的組別，而新一代設計展是大學設計科系為主的展覽，高職當時僅有復興參加。</p>
</blockquote>
<p>升大學時，因為高職功課普遍都很爛，我還是其中更爛的那種，所以重考了一年多，拼了命考上了公立台南大學美術系。美術系前幾年還是乖乖地畫畫，只不過會接些案子以及參加競賽來當生活費，在大四的時候，半學期的獎金加上案子的費用約有 15 萬～ 18 萬(實際數值忘記了)，那時候也是可以完全靠自己的方式賺錢，而主力就是在高職打好的設計底。</p>
<blockquote>
<p>當時參加競賽都是有技巧的，用特定的風格就很容易得獎（水墨 + 向量風格，可參考北京奧運的設計），當時還有得過「高雄世運會 Logo 徵選」優選，也是用此方式得獎。</p>
</blockquote>
<p>大學時轉到了高雄師範大學，案源及獎金沒有像過去那麼的高，當時也會思考「我接下來真的是要當設計師嗎？」，也會因此不斷的搜尋關於設計師的工作想像。而我的專長是平面設計，當時會認為平面設計的限制很大，設計本質就是傳達，而平面的傳達是受到限制的（當然也有屬於它的優勢）；相對於平面設計來說，多媒體網頁的傳達力更強，因此就開始了 ECMAScript 的學習之旅!?（這段故事在後面會另外補完）。</p>
<p>另外，近幾年我也不斷審思設計的價值是什麼？</p>
<ul>
<li>來自於案主或老闆的費用？</li>
<li>比賽得獎的獎金？（我認為設計系學生真的是很好賺，又直接）</li>
<li>設計因為曝光而有價值？ （設計費其中一種計價模式是用印刷品數量計算）</li>
<li>還是設計可以為產品曝光加分？</li>
</ul>
<p>這個答案，一直到出社會後我才能慢慢體會，尤其是將許多技能整合後才能更清楚什麼是「設計的價值」。</p>
<h3 id="從設計轉工程師"><a href="#從設計轉工程師" class="headerlink" title="從設計轉工程師"></a>從設計轉工程師</h3><p>在學期間無論是高職、大學、研究所我們都是獨立學習，美術設計的體系下，每個人都是獨立的個體，很少有經驗分享或技術分享的思維，而為什麼會有這個現象我認為是：</p>
<ul>
<li>台灣設計領域的封閉：老師、業界、評審者都是固定的一群人，導致整個生態與思維是封閉的。</li>
<li>技術很固定：掌握工具後剩下的就是個人的美感培養，所以不太需要類似開發者的成長社群</li>
<li>每個人都是競爭的心態：案子、薪水要比別人多，就是要證明比別人強</li>
</ul>
<p>不久前遇到了一個文化工作人士，也指出了藝術領域一個很大的問題點：「藝術領域的人都是個人主義，不太會有分享及社群的概念。」在美術設計長期的訓練下，自然也會有很強烈的自我主義，所以接觸到軟體領域後會發現這個環境與過去有很大的不同，奉獻的能量更有助於自我發展（鐵人賽也是一個例子）。除此之外，軟體開發者在成長的過程中，也會不斷的創造出更多社群，如：前後端開發者社群、行銷社群、創業家社群，這些群體中都很容易找到開發者們。</p>
<p>長期下來思維也慢慢的從全部自己來（過去，我是盡可能不使用任何圖庫、圖示或第三方的資源），慢慢轉變為分享、共享、共有的思維模式，不僅更有效率也更能接近價值的核心。</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：你的願景是什麼？]]></title>
      <url>https://wcc723.github.io/ironman/2019/09/16/what-is-your-vision/</url>
      <content type="html"><![CDATA[<p>當兵的後期，有一位和我很好的義務役也即將退伍，他在退伍的時候發表感謝內容表示：「特別感謝我給他的希望的感覺」，平常的時候我常會找他閒聊，也許是談話的內容讓他更具有信心，也讓他想要去追求屬於自己的夢想（印象中是機場塔台相關的工作）。現在想起，也許是那時比較天真吧，認為什麼事情拼一下就有機會了。</p>
<h2 id="天真的夢想與真誠的願景"><a href="#天真的夢想與真誠的願景" class="headerlink" title="天真的夢想與真誠的願景"></a>天真的夢想與真誠的願景</h2><p>小時候各位應該都有自己的夢想，當超人、當總統、假面騎士、鋼彈駕駛員等等，但到了成年以後我們了解這些是有困難的（或者不可能!?），在這樣的情況下，是否還有夢想呢？還是夢想只存在天真的情況下才能擁有？</p>
<p>在「你怎麼看待時間，決定你成為哪種人」這本書提到(精簡版：<a href="https://www.youtube.com/watch?v=pI0O_Oepay4">https://www.youtube.com/watch?v=pI0O_Oepay4</a>)，目標是短期的，而願景是長期的，成功人士及企業都會擁有願景，並且以這個願景為使命來訂定目標，在訂定願景時和小時候的夢想來說都是接近遙不可及的目標(在怎麼說，小時候的我也是真誠地相信能夠成為假面騎士呢！)。</p>
<p>離開學校從軍中退伍，並進入社會職場的那幾年，過得並不是很如意，學貸、低薪、家庭不如意等種種的壓力不斷的接連而來，這些不愉快的情緒逐漸的影響生活，當時還真正能體會到無知就是一種幸福，承擔則是一種壓力，對於自己的過去具有許多不滿卻又無能為力。當然，這種情緒對於生活是會產生負面的影響，因此立下一個短期的願景「35 歲要過著讓人羨慕，而不是我忌妒人的生活」(說實話，當時看著許多富二代的生活真的很讓我忌妒)，而這個願景也深深的改變我接下來的生活。</p>
<p>今年過了 35 歲有了些許的成就，或許不一定讓所有人羨慕，但至少我不再忌妒他人的生活，並且很喜歡現在的自己(就以被討厭的「被討厭的勇氣」一書所提到，至少我已經達到滿意的階段，羨不羨慕我則是他人的課題)。這段時間也忙於小孩的出生、新課程的準備、公司的營運讓我沒有再去思考接下來的<strong>願景</strong>，這樣的日子過了一段時間，心靈上看似清閒卻又有些空虛，就好像是遊戲中拿到最想要的神裝，滿足的情緒下卻帶有一些空虛，主要原因是沒有訂定接下來的願景，讓自己似乎不斷的完成短期目標，卻不清楚自己該面向何處。而願景應該是難以達到的目標，而當初雖然我是設立難以達到的目標，但是具有一個時間點，所以時間後該願景也會結束。</p>
<h2 id="接下來"><a href="#接下來" class="headerlink" title="接下來"></a>接下來</h2><p>而在最近看到 洧杰 螢幕上的願景（他將願景直接秀在瀏覽器的新頁面上），第一個是「改善台灣的軟體就業環境」，第二則是「和太太長命百歲」。當下立刻思考到那我的呢？自從 35 歲的門檻度過之後，一時還想不到接下來的願景是什麼。</p>
<p>目前的工作是六角學院負責人，除了在公司內部打雜以外，更重要的是輔導學員們從零開始慢慢投入網頁開發的未來，剛開始的目標是教導學生掌握一個特定技能，隨著時間的累積越來越多的學員不僅掌握關鍵技能，還從這些技能轉職成功。從一開始大多成功投入的學員都是具有基本的背景，而許多非本科的學員對自己並沒有任何信心，但現在很多案例是從 0 開始學習並完成所有挑戰進入前端領域。</p>
<p><a href="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201909%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_9_16_%E4%B8%8B%E5%8D%882_40.png?alt=media&amp;token=6559aa74-9643-4b37-99f5-4b03ca8970f2"></a></p>
<p>讓許多人成功邁向自己的目標時，也發現自己並非僅是傳遞一項技能的講師，而是輔導他們<strong>邁向自己目標</strong>的導師。因此，現在想回到以前過去的思維，相信這個世界並沒有那麼困難，像讓同儕士兵退伍後去追求自己目標一樣，慢慢引導更多人迎向自己的目標。</p>
<p>接下來我也會有兩個願景，一個請讓我作為秘密為家人付出，另一個將會是希望「<strong>讓更多人充滿希望，並真誠地相信自己能夠達到目標</strong>」</p>
<ul>
<li>強化身心，破除無意義的恐懼</li>
<li>讓人了解如何安排挑戰計畫</li>
<li>協助最後的一哩路，讓他們找到對的人</li>
<li>身體力行，自己也要一同成長</li>
<li>真心期望大家都發大財</li>
</ul>
<p>而這一系列文章也將會分享我的成長經歷，以及許多成長過程中的思維改變，經歷過小公司、百大企業員工並成為老闆的各種體驗分享，從一個不可能更差的人生，到改變思維看到各種希望的過程!?</p>
]]></content>
      
        <categories>
            
            <category> ironman </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[自建 Name Server]]></title>
      <url>https://wcc723.github.io/dns/2019/04/25/custom_name_server/</url>
      <content type="html"><![CDATA[<p>本篇教學是延續「<a href="https://www.hexschool.com/2019/03/07/2019-03-07-interview/">大神來六角</a>」的 “網址管理與 DNS 託管全攻略”，目的是讓參與的學員更了解 DNS 在轉址的過程觀念。</p>
<p>對於 Name Serve 的概念可以參考 <a href="https://aws.amazon.com/tw/route53/what-is-dns/#DNS_%E5%A6%82%E4%BD%95%E5%B0%87%E6%B5%81%E9%87%8F%E8%B7%AF%E7%94%B1%E5%88%B0_Web_%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%EF%BC%9F">AWS 提供的架構圖</a>：</p>
<p><img src="https://d1.awsstatic.com/Route53/how-route-53-routes-traffic.8d313c7da075c3c7303aaef32e89b5d0b7885e7c.png" alt=""></p>
<p>擁有一個網域後，只要網域的供應商可以設定 NS Record，都可以用來自行建立 Name Server，並且可以自行代管該網域下的所有子網域。</p>
<blockquote>
<p>本篇中的環境在教學結束後被釋放，所以無法再次連接。</p>
</blockquote>
<p>參考文章：</p>
<ul>
<li><a href="http://linux.vbird.org/linux_server/0350dns.php#DNS_Zones">http://linux.vbird.org/linux_server/0350dns.php#DNS_Zones</a> </li>
<li><a href="https://eric0806.blogspot.com/2014/06/ubuntu-bind9-dns-server.html">https://eric0806.blogspot.com/2014/06/ubuntu-bind9-dns-server.html</a> </li>
</ul>
<h2 id="建立環境"><a href="#建立環境" class="headerlink" title="建立環境"></a>建立環境</h2><ul>
<li>購買一個網域，並且該網域可以自訂 NameServer 的<ul>
<li>本次服務購買 GoDaddy</li>
</ul>
</li>
<li>準備一台主機，本次使用 Digital Ocean 的 Ubuntu 16</li>
</ul>
<h2 id="上層-Name-Server-設定"><a href="#上層-Name-Server-設定" class="headerlink" title="上層 Name Server 設定"></a>上層 Name Server 設定</h2><p>首先，必須先將給予自訂的 Name Server 一個網址，如果僅有 IP 的情況下將無法自訂 Name Server，在此先給予我的主機 dns 這個名稱：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_4_21_%E4%B8%8B%E5%8D%882_59.png?alt=media&amp;token=39b0e838-7bf6-468f-85ef-4d5c0ae11543" alt=""></p>
<p>接下來將 customdns 這個名稱交給予 dns.casper.tw 這個 Name Server 代管，因此：</p>
<ul>
<li><code>dns.casper.tw</code> 這是 Name Server 主機</li>
<li><code>customdns.casper.tw</code> 這是 Name Server 主機所代管的網域，接下來可以自訂 <code>&#123;&#123; xxx &#125;&#125;.customdns.casper.tw</code> 的網址在這個網域下。</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F809515F0-8C63-4B53-A9BE-A688F68F0D19.png?alt=media&amp;token=91861918-2f76-4e8b-8a6f-a7923b0fb550" alt=""></p>
<h2 id="Name-Server-設定"><a href="#Name-Server-設定" class="headerlink" title="Name Server 設定"></a>Name Server 設定</h2><p>在此，會使用 <strong>Bind</strong> 這一個 Name Server 工具，本工具有許多觀念需要理解，會在接下來的流程中一一的說明：</p>
<p>安裝 Bind 工具：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install bind9 bind9-doc dnsutils</span><br></pre></td></tr></table></figure></p>
<p>安裝完成後進入 <code>/etc/bind</code> 的套件下，輸入 <code>ll</code> 可以看到以下的資料結構：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll</span></span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_4_16_%E4%B8%8B%E5%8D%8810_00.png?alt=media&amp;token=bb953ffd-a08f-4b0d-90eb-d88e289653f1" alt=""></p>
<p>主要調整檔案：</p>
<ul>
<li><code>named.conf.options</code>：主要的 DNS 工具的選項。</li>
<li><code>named.conf.local</code>：設定管理的 IP、正反解的對應檔案路徑、次要 Name Server 的設定等等。</li>
<li>自訂檔案：<ul>
<li><code>/zones/&#123;&#123;customdns.casper.tw&#125;&#125;.tw</code> 正解檔</li>
<li><code>/zones/&#123;&#123; xxxip.rev &#125;&#125;</code> 反解檔</li>
</ul>
</li>
<li>其它 <code>/etc/default/bind9</code>：修正 ipv4、ipv6 的問題</li>
</ul>
<p><code>Bind</code> 設定檔撰寫的過程中，會不斷的重啟、除錯，以下列出重要的語法：</p>
<ul>
<li><code>/etc/init.d/bind9 restart</code>：重啟。</li>
<li><code>/etc/init.d/bind9 status</code>：目前機器的狀態，必須要調整到沒有錯誤訊息為止。</li>
</ul>
<h3 id="設定-named-conf-options"><a href="#設定-named-conf-options" class="headerlink" title="設定 named.conf.options"></a>設定 named.conf.options</h3><p>透過編輯器設定 <code>named.conf.options</code>，這是 bind 工具的主要項目，按照預設也不會有太大關係，但本次是以 ipv4 為主，所以 v6 的功能可以先關閉，另外 Name Server 預設是 53 port，當上層網域指定過來後就會自動用 53 的接口，所以不要隨意調整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">acl intra &#123; xx.xx.xx.xx; &#125;;</span><br><span class="line">&#x2F;&#x2F; 自訂義變數 intra，可查詢的 DNS 主機，不設定也沒關係</span><br><span class="line">options &#123;</span><br><span class="line">        directory &quot;&#x2F;var&#x2F;cache&#x2F;bind&quot;;</span><br><span class="line">        dnssec-validation auto;</span><br><span class="line"></span><br><span class="line">        auth-nxdomain no;    # conform to RFC1035</span><br><span class="line">        listen-on port 53 &#123; any; &#125;;</span><br><span class="line">        allow-query &#123; any; &#125;;</span><br><span class="line">        allow-query-cache &#123; none; &#125;;</span><br><span class="line">        recursion no; </span><br><span class="line">        &#x2F;&#x2F; allow-recursion &#123; intra; &#125;;</span><br><span class="line">        also-notify &#123; &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="設定-named-conf-local"><a href="#設定-named-conf-local" class="headerlink" title="設定 named.conf.local"></a>設定 named.conf.local</h3><p>這是與配置檔案連接的檔案，算是主要的進入點，透過這個檔案與正解、反解配置檔案產生關聯。</p>
<p>另外 Name Server 可以設定超過一台主要的為 Master，其它次要的為 Slave，在這個範例中僅設定一個主要，實作中會建議另外設定 Slave，避免主要的機器無法連接導致所有網址失聯。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">acl allow-trans-ip &#123; <span class="number">138.68</span><span class="number">.229</span><span class="number">.69</span>; &#125;;</span><br><span class="line"><span class="comment">// 定義允許取得配置的 ip ，如果有多個 ip 可以使用分號隔開</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 正解的區域 ---</span></span><br><span class="line"><span class="comment">// 定義掌管的 Domain</span></span><br><span class="line">zone <span class="string">&quot;customdns.casper.tw&quot;</span> &#123;</span><br><span class="line">    type master; <span class="comment">// 定義 master 或 slave</span></span><br><span class="line">    file <span class="string">&quot;/etc/bind/zones/customdns.casper.tw.fwd&quot;</span>; <span class="comment">// 自訂義正解檔案的路徑，名稱可自訂</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 定義可以從主要機器取得配置的 ip，在此不設定也沒關係，但實作中建議加上</span></span><br><span class="line">    allow-transfer &#123;</span><br><span class="line">        allow-trans-ip; <span class="comment">// 上方定義的變數</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// --- 反解的區域 ---</span></span><br><span class="line">zone <span class="string">&quot;229.68.138.in-addr.arpa&quot;</span> &#123;</span><br><span class="line">    type master; <span class="comment">// 對應 master</span></span><br><span class="line">    file <span class="string">&quot;/etc/bind/zones/138.68.229.rev&quot;</span>; <span class="comment">// 反解配置檔案路徑</span></span><br><span class="line">    allow-transfer &#123; allow-trans-ip; &#125;; <span class="comment">// 同上</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 反解命名規則：</span></span><br><span class="line"><span class="comment">// ip 假設為 138.68.229.69</span></span><br><span class="line"><span class="comment">// 反解應設定為 229.68.138.in-addr.arpa</span></span><br></pre></td></tr></table></figure>
<h3 id="設定正反解配置檔案"><a href="#設定正反解配置檔案" class="headerlink" title="設定正反解配置檔案"></a>設定正反解配置檔案</h3><p>上方定義了 <code>named.conf.local</code>，其中又連向兩個配置檔案，分別為：</p>
<ul>
<li><code>/etc/bind/zones/customdns.casper.tw.fwd</code> 正解</li>
<li><code>/etc/bind/zones/138.68.229.rev</code> 反解</li>
</ul>
<p>而這兩個檔案名稱是可以自訂的，在此僅是依據所管理的網域及反解路徑命名，首先設定 <code>customdns.casper.tw.fwd</code> 正解檔案：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$TTL    120</span><br><span class="line">;</span><br><span class="line">@       IN      SOA     customdns.casper.tw. xxx.gmail.com. (</span><br><span class="line">                        2014062007;</span><br><span class="line">                        600;</span><br><span class="line">                        900;</span><br><span class="line">                        86400;</span><br><span class="line">                        120);</span><br><span class="line"></span><br><span class="line">;</span><br><span class="line">@       IN      NS      dns.casper.tw.;</span><br><span class="line"></span><br><span class="line">dns.casper.tw.       IN      A       165.22.129.123;</span><br><span class="line">www.customdns.casper.tw.     IN      A       138.68.229.69;</span><br></pre></td></tr></table></figure>
<p>分別說明以上檔案分別包含什麼內容：</p>
<ul>
<li>定義 TTL 變數，單位是 “秒”，時間越短用戶就需要更頻繁的詢問</li>
<li>定義 SOA，SOA 算是 Name Server 的申明檔案，其中也包含該伺服器的管理者聯絡方式：<ul>
<li><code>customdns.casper.tw.</code> Master DNS 伺服器主機名稱，後方的 <code>.</code> 是不能省略的</li>
<li><code>xxx.gmail.com.</code> 負責該網域的聯絡人，gmail 前方的 @ 被轉為 <code>.</code></li>
<li><code>2014062007</code> 序號 (Serial)，在此可以思考為版本號，slave 用此來判斷 master 是否有更新</li>
<li><code>600</code> slave 的更新頻率</li>
<li><code>900</code> 當 Slave 連線失敗重新嘗試時間 (Retry)</li>
<li><code>86400</code>失效時間 (Expire)，當 Slave 重新連線到達多少時間會停止嘗試，屆時需要管理員處理。</li>
<li><code>120</code> TTL 預設時間</li>
</ul>
</li>
<li>定義 Name Server<ul>
<li>NS：Name Server 縮寫</li>
<li><code>dns.casper.tw.</code> Name Server 位置</li>
</ul>
</li>
<li>定義 Record 參數<ul>
<li><code>www.customdns.casper.tw.</code> 自訂義網址</li>
<li><code>138.68.229.69</code> 對應 ip</li>
</ul>
</li>
</ul>
<blockquote>
<p>反解：一般網域查詢時是由右至左，如：.root &gt; .tw &gt; .casper &gt; .dns，而 ip 的運作是相反的，上述的 ip 中在運作時方向為 138 &gt; 68 &gt; 229 &gt; 69，用來從 ip 反向查詢到主機名稱。</p>
</blockquote>
<p>定義反解檔案 <code>138.68.229.rev</code>，反解檔案的 SOA 與正解檔一致，不同的是 Record 內容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$TTL    3600</span><br><span class="line">;</span><br><span class="line">@       IN      SOA     customdns.casper.tw. agito723.gmail.com. (</span><br><span class="line">                        2014062007;</span><br><span class="line">                        600;</span><br><span class="line">                        900;</span><br><span class="line">                        86400;</span><br><span class="line">                        120);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@       IN      NS      dns.casper.tw.</span><br><span class="line">;</span><br><span class="line">123.129.22.165.in-addr.arpa.     IN      PTR     dns.casper.tw. ;</span><br><span class="line">69       IN      PTR     www.customdns.casper.tw. ;</span><br></pre></td></tr></table></figure><br>反解檔案與正解檔案設定差異不大，規則上定義為 <code>PTR</code>(反解 Record)，並且在 ip 需要使用反解的規則撰寫。到這個步驟基本上就算完成了，接下來就是進入測試、重啟與除錯。</p>
<h2 id="重啟及除錯"><a href="#重啟及除錯" class="headerlink" title="重啟及除錯"></a>重啟及除錯</h2><p>接下來，輸入 <code>/etc/init.d/bind9 restart</code> 就可以重啟測試，重啟後建議再輸入 <code>/etc/init.d/bind9 status</code> 來除錯，以下列出常見的錯誤：</p>
<p>遇到的問題：</p>
<h4 id="network-unreachable-resolving"><a href="#network-unreachable-resolving" class="headerlink" title="network unreachable resolving"></a>network unreachable resolving</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">network unreachable resolving &#39;ns39.domaincontrol.com&#x2F;AAAA&#x2F;IN&#39;: 2001:503:d414::30#53</span><br></pre></td></tr></table></figure>
<p>解法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#編輯 &#x2F;etc&#x2F;default&#x2F;bind9</span><br><span class="line">gedit &#x2F;etc&#x2F;default&#x2F;bind9</span><br><span class="line"></span><br><span class="line"># 如下，加上 -4</span><br><span class="line"># startup options for the server</span><br><span class="line">OPTIONS&#x3D;&quot;-4 -u bind&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="bad-dotted-quad"><a href="#bad-dotted-quad" class="headerlink" title="bad dotted quad"></a>bad dotted quad</h4><p>設定檔中包含了不正常的空格，這些空格有可能在分號後方，可依據錯誤訊息尋找是否有多餘的空格。</p>
<p>正常的 status 運作應會出現以下訊息，並且沒有任何的紅色文字：<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F548C775E-8362-4F11-BECE-74F54490082F.png?alt=media&amp;token=e0862396-afaf-45d1-a9a1-51d4bbf9e021" alt=""></p>
<h2 id="Name-Server-開張"><a href="#Name-Server-開張" class="headerlink" title="Name Server 開張"></a>Name Server 開張</h2><p>如果沒有任何錯誤，正常來說就能直接連線至你的網址。接下來再透過 <code>dig +trace &#123; 網址 &#125;</code> 也能看到自建的 Name Server 相關訊息。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_4_21_%E4%B8%8B%E5%8D%884_05.png?alt=media&amp;token=c8447166-7010-463e-ba7d-bb02dc8e8118" alt=""></p>
]]></content>
      
        <categories>
            
            <category> dns </category>
            
        </categories>
        
        
        <tags>
            
            <tag> dns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[免費申請屬於自己的 SSL 憑證(手把手帶你加上 https 綠色鎖頭)]]></title>
      <url>https://wcc723.github.io/ssl/2019/04/24/free-ssl/</url>
      <content type="html"><![CDATA[<h2 id="SSL-For-Free"><a href="#SSL-For-Free" class="headerlink" title="SSL For Free"></a>SSL For Free</h2><p>為了讓更多網站可以加上綠鎖頭(https)，並且提高網路的安全性，此服務免費提供網站 SSL 憑證，同時憑證不僅是免費的，還是屬於萬用憑證（包含所有子網域），雖然每次的憑證效期僅有三個月，但可以不斷的續約，對於每年需花個幾千、幾萬才能購買一個萬用憑證來說，算是節省不少。本篇將會一步一步介紹如何申請到此憑證。</p>
<p>開發環境說明：</p>
<ul>
<li>主機 Digital Ocean：Ubuntu 16</li>
<li>後端語言：Node.js </li>
</ul>
<p>另外，憑證的金鑰綁定是由開發者來完成，但這個服務是直接在網站上完成，開發者僅需要直接下載做好的憑證即可。</p>
<h3 id="申請憑證"><a href="#申請憑證" class="headerlink" title="申請憑證"></a>申請憑證</h3><p>透過以下網站申請：<a href="https://www.sslforfree.com/">SSL For Free</a> ，直接輸入要申請的網域即可。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F4DB860CA-9F37-423E-B3BD-7FB05B3B04F4.png?alt=media&amp;token=cb06bce7-5568-46e1-9ace-3baf54c7263f" alt=""></p>
<p>申請後，他會要求認證網域是否由<strong>申請者</strong>管理，接下來會有以下的認證步驟(三選一)：</p>
<ol>
<li>透過 FTP 上傳驗證檔</li>
<li>手動上傳驗證，本教學會使用此流程，順便說明一些細項</li>
<li>DNS 驗證，這是最簡單的流程，直接在 DNS TXT Record 補上驗證訊息即可</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2FDB669936-3447-42EA-8992-838D273A7E8E.png?alt=media&amp;token=f5649ebc-9606-4d21-ad9a-572cf17feede" alt=""></p>
<h3 id="手動驗證流程"><a href="#手動驗證流程" class="headerlink" title="手動驗證流程"></a>手動驗證流程</h3><p>選擇手動驗證會出現以下流程說明，接下來在我們的 Ubuntu 伺服器端先安裝好 node.js 及 express 環境後繼續以下動作。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2FE397329A-D05D-4EC0-BECE-3BDAA4DCB818.png?alt=media&amp;token=48f342f1-2171-4b51-abdf-d437789c30c8" alt=""></p>
<ol>
<li>開啟 express 框架中的 <code>bin/www</code> 將 port 改為 80 port，並且將 DNS 指向此主機（需與 SSL 申請的網址同一個）。</li>
<li>下載該手動驗證的檔案。</li>
<li>在 <code>public</code> 資料夾下，建立該資料夾  <code>/.well-known/acme-challenge/</code> 並且把該檔案上傳上去(上傳方式可參考後方說明)</li>
<li>須確保網址上的這個檔案能夠被開啟 </li>
</ol>
<p>上傳驗證檔案的說明：<br>方法 1: 可以直接透過指令上傳驗證檔案，需要在本地端輸入以下指令，並且對應遠端的路徑。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">scp &#123;&#123;檔名&#125;&#125; root@&#123;&#123;主機&#125;&#125;:~&#123;&#123;資料夾路徑&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 範例：</span><br><span class="line">scp xxx root@12.3.45.678:~&#x2F;website</span><br></pre></td></tr></table></figure><br>方法 2: 直接手動新增 <code>vi &#123; 檔名 &#125;</code>，將下載檔案的內容貼入</p>
<h3 id="按下-Download-ssl"><a href="#按下-Download-ssl" class="headerlink" title="按下 Download ssl"></a>按下 Download ssl</h3><p>確保上述流程完成後，就可以按下 <code>Download SSL</code>，失敗也會提供訊息，<strong>但如果發生錯誤，請重新上述的步驟</strong>。</p>
<p>接下來會核發 90 天的憑證，並且已經生成了憑證、私鑰等檔案。接下來下載這些檔案，其中 <code>certificate.crt</code>、<code>private.key</code> 這兩隻需要上傳到 server 上。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F42D626D8-4A32-4289-B667-2DD477AE3B33.png?alt=media&amp;token=d0fb72fd-2453-4371-959b-2ec66629dd70" alt=""></p>
<h2 id="express-with-https"><a href="#express-with-https" class="headerlink" title="express with https"></a>express with https</h2><p>步驟 1: 上傳 <code>certificate.crt</code>、<code>private.key</code> 到伺服器上，直接放到專案中方便存取的路徑即可。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp certificate.crt root@0.0.0.0:~/&#123;&#123; 專案路徑 &#125;&#125;/ssl/</span><br><span class="line">scp private.key root@0.0.0.0:~/&#123;&#123; 專案路徑 &#125;&#125;/ssl/</span><br></pre></td></tr></table></figure></p>
<p>步驟 2: 透過 <code>npm install https --save</code> 安裝 <code>https</code> 套件<br>步驟 3: 打開 <code>bin/www</code>，並且將檔案修改成以下（後方有完整的程式碼）</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_4_17_%E4%B8%8B%E5%8D%884_25.png?alt=media&amp;token=5ac2f823-951e-4ee0-916c-0c457cb63dc1" alt=""></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">&#x27;../app&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> debug = <span class="built_in">require</span>(<span class="string">&#x27;debug&#x27;</span>)(<span class="string">&#x27;website:server&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Get port from environment and store in Express.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> privateKey  = fs.readFileSync(__dirname + <span class="string">&#x27;/../ssl/private.key&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> certificate = fs.readFileSync(__dirname + <span class="string">&#x27;/../ssl/certificate.crt&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> credentials = &#123; <span class="attr">key</span>: privateKey, <span class="attr">cert</span>: certificate &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> port = normalizePort(process.env.PORT || <span class="string">&#x27;443&#x27;</span>);</span><br><span class="line">app.set(<span class="string">&#x27;port&#x27;</span>, port);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Create HTTP server.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> server = https.createServer(credentials, app);</span><br></pre></td></tr></table></figure>
<p>完成後就可以直接連線至該網址，加上憑證後預設也會自動連線至 443 port，所以就可以直接使用當時的網址連線即可。</p>
<p>簽核的認證範例：<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201904%2F704EAA52-5D36-4E0C-9630-A992D5FD5347.png?alt=media&amp;token=70bd9b1c-f89c-425e-96d5-e854d5a7571e" alt=""></p>
]]></content>
      
        <categories>
            
            <category> ssl </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ssl </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript This 系列文：this 為什麼指向 window]]></title>
      <url>https://wcc723.github.io/javascript/2019/03/21/this-why-window/</url>
      <content type="html"><![CDATA[<p>本篇是接續先前的：<a href="/javascript/2017/12/12/javascript-this/">鐵人賽：JavaScript 的 this 到底是誰？</a>，會更深入的探討 JavaScript This 的運作及觀念，這一系列的文章順序上不會從基礎開始介紹，會建議先從先前文章開始閱讀。</p>
<h2 id="純粹的調用-Simple-call"><a href="#純粹的調用-Simple-call" class="headerlink" title="純粹的調用 (Simple call)"></a>純粹的調用 (Simple call)</h2><p>直接呼叫函式的情況下，this 會指向全域，在以下範例中可以取到 name 的值，但一般來說很不推薦這樣的寫法，後面會提到這樣的寫法是怎麼造成的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;;</span><br><span class="line">callSomeone(); <span class="comment">// 小明</span></span><br></pre></td></tr></table></figure></p>
<h3 id="IIFE、Callback、閉包也屬於此類別嗎？"><a href="#IIFE、Callback、閉包也屬於此類別嗎？" class="headerlink" title="IIFE、Callback、閉包也屬於此類別嗎？"></a>IIFE、Callback、閉包也屬於此類別嗎？</h3><p>上述的函式只有單一層級，為了加深大家的印象，我們透過各種改變 “函式” 作用域的方式看是否會改變 this 的結果。</p>
<h4 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h4><p>立即函式，這算是直接在函式內直接在呼叫另一個函式，而這個結果下一樣與純粹的呼叫結果相同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;;</span><br><span class="line">  callSomeone(); <span class="comment">// 小明</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>無論我們把函式宣告放在 IIFE 內與外結果都是一致的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  callSomeone(); <span class="comment">// 小明</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<h4 id="Closure"><a href="#Closure" class="headerlink" title="Closure"></a>Closure</h4><p>這樣結果依然相同，並不會因為獨立的作用域改變造成 this 的不同。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">easyCard</span>(<span class="params">base = <span class="number">100</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> money = base</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">update = <span class="number">10</span></span>) </span>&#123;</span><br><span class="line">    money = money + update</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, money)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> MingEasyCard = easyCard(<span class="number">100</span>)</span><br><span class="line">MingEasyCard()</span><br><span class="line"><span class="comment">// &#x27;小明&#x27; 110</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Callback-function"><a href="#Callback-function" class="headerlink" title="Callback function"></a>Callback function</h4><p>callback function 也是一樣的結果，透過以上這些範例了解到，並不會因為作用域的改變導致 This 的不同，更重要的還是在於<strong>函式是不是與物件有扯上關係</strong>，至此為止我們實驗了各種函式呼叫方式，都可以知道函式再直接呼叫的情況下，this 都是指向 window。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myEasyCard</span>(<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> money = <span class="number">100</span></span><br><span class="line">  <span class="keyword">return</span> callback(money); <span class="comment">// window</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myEasyCard(<span class="function"><span class="keyword">function</span> (<span class="params">money</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, money); <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>而 callback function 會提到另一個常見的案例，就是陣列相關的處理方式，參考 MDN 的<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#%E8%AA%9E%E6%B3%95">說明</a> forEach 的結構如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.forEach(<span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">currentValue[, index[, array]]</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//your iterator</span></span><br><span class="line">&#125;[, thisArg]);</span><br></pre></td></tr></table></figure>
<p>因此 forEach 中間的 callback 一樣是屬於直接呼叫，所以會 this 會指向 window 物件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, item)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="嚴謹模式"><a href="#嚴謹模式" class="headerlink" title="嚴謹模式"></a>嚴謹模式</h3><blockquote>
<p>觀念說明開始，為什麼 this 會指向 window 物件</p>
</blockquote>
<p>這個階段我們加上 <code>&#39;use strict&#39;</code> 則會進入嚴謹模式，接下來直接呼叫的內容都會變成 <code>undefined</code>的奇特景象，可以理解這是為了避免不必要的錯誤提示，在此也建議別透過一般函式呼叫的 this 取用 <code>window</code>。</p>
<p>直接套上嚴謹模式則會出現錯誤範例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;小明&#x27;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// 這裡改成了 this，因為沒辦法找到 name</span></span><br><span class="line">&#125;</span><br><span class="line">callSomeone(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>而 undefined 與 window 有什麼關係呢？我們可以先介紹另一個觀念 <code>call()</code>，<code>call</code> 是可將物件傳入並替代函式內的 this：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Ming = &#123;</span><br><span class="line">  name: <span class="string">&#x27;小明&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, num);</span><br><span class="line">&#125;</span><br><span class="line">callSomeone.call(Ming, <span class="number">2</span>); <span class="comment">// 小明, 2</span></span><br></pre></td></tr></table></figure>
<p>透過 <code>.call(Ming, 2)</code> 的方式，可將 Ming 傳入並取代 this，後面帶上一個參數 <code>2</code> 則是函式的參數。因此 <code>.call()</code> <strong>前者為套用 this 的物件，後者以後都是函式的參數</strong>。參考下圖：函式中的 <code>this</code> 為 call() 的第一個值，而函式參數為第二個(包含後續的值)。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2FD776D6BE-46F9-433F-9D85-96291FD12F8A.png?alt=media&amp;token=cfb5fc9c-dc8b-4fe5-bc28-5bd555042183" alt=""></p>
<p>接下來我們將 <code>Ming</code> 物件替換，直接定義一個 name 在全域之上，並且傳入 undefined 的值來替代 this，猜猜會發生什麼事!?<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域魔王&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, num);</span><br><span class="line">&#125;</span><br><span class="line">callSomeone.call(<span class="literal">undefined</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure><br>此時會發現運作上依然沒有問題，<strong>傳入 undefined 進入後 this 會直接指向全域</strong>。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2FCEBA40C7-690E-4422-B09E-3541AF207C63.png?alt=media&amp;token=aef490be-ecd9-4749-84f5-5bd4da8b2ce0" alt=""></p>
<p>這麼神奇的狀態也算是 JavaScript 的 Feature，發生的理由可以參考：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call#%E5%8F%83%E6%95%B8">MDN</a> 的說明。</p>
<blockquote>
<p>MDN：若這個函數是在非嚴苛模式( <a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Functions_and_function_scope/Strict_mode">non-strict mode</a> ),null、undefined將會被置換成全域變數。</p>
</blockquote>
<p>因此，上述程式碼在嚴謹模式下將無法正確運行，因為傳入 <code>undefined</code> 時將會正確以 <code>undefined</code> 作運行。同樣概念下，在一般全域環境套用 ‘use strict’ <code>this</code> 作為一般調用時，將會直接套用 undefined 而不會是 window。</p>
<p>而上述程式碼於嚴謹模式下，將會正確的傳入 undefined。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域魔王&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>, num);</span><br><span class="line">&#125;</span><br><span class="line">callSomeone.call(<span class="literal">undefined</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>接下來，可以將本文的上方的程式碼都加上 <code>&#39;use strict&#39;</code> 都會得到相同的結果，this 都會指向 undefined。</p>
<hr>
<h2 id="延伸閱讀：This-都是物件"><a href="#延伸閱讀：This-都是物件" class="headerlink" title="延伸閱讀：This 都是物件"></a>延伸閱讀：This 都是物件</h2><p>前一篇介紹到 「this 大部分取決於 <strong>它在哪個物件下被呼叫</strong>」，所以其中改變 this 的方法之一則是透過物件下呼叫函式：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> auntie = &#123;</span><br><span class="line">  name: <span class="string">&#x27;漂亮阿姨&#x27;</span>,</span><br><span class="line">  callName: callName  </span><br><span class="line">  <span class="comment">// 這裡的 function 指向全域的 callName function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auntie.callName() <span class="comment">// &#x27;漂亮阿姨&#x27;，呼叫是在物件下調用，那麼 this 則是該物件</span></span><br></pre></td></tr></table></figure>
<p>除此之外，還可以透過本文所介紹的 call 來改變 this 的值，先前範例都是傳入「物件」，此部分我們傳入數值來看看其型別：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">typeof</span>(<span class="built_in">this</span>), <span class="keyword">typeof</span>(num));</span><br><span class="line">&#125;</span><br><span class="line">callSomeone.call(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// object number</span></span><br></pre></td></tr></table></figure>
<p>此部分的 this 我們使用數字 1，函式參數使用數字 2，結果會發生 this 的型別變成了 <code>object</code>!?</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2FA398F871-CD13-48A1-9A9D-97B53B27196E.png?alt=media&amp;token=4336cc32-d8e5-4228-bee0-e0b500556e29" alt=""></p>
<p>重新透過 console 查看 this 會得到以下的結果，這是透過建構式產生的數值(<code>new Number(1)</code>)，透過 call 所傳入的純值會被使用 new 建構式的方式產生，所以型別依然維持是「物件」（可參考：<a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Function/call#%E5%8F%83%E6%95%B8">MDN</a>），因此 this 終究為物件形式。</p>
<blockquote>
<p>MDN：原生型態的值將會被封裝</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript This 系列文：this 與物件的關係]]></title>
      <url>https://wcc723.github.io/javascript/2019/03/18/JS-THIS/</url>
      <content type="html"><![CDATA[<p>本篇是接續先前的：<a href="/javascript/2017/12/12/javascript-this/">鐵人賽：JavaScript 的 this 到底是誰？</a>，會更深入的探討 JavaScript This 的運作及觀念，這一系列的文章順序上不會從基礎開始介紹，會建議先從先前文章開始閱讀。</p>
<h2 id="物件的方法調用-As-an-object-method"><a href="#物件的方法調用-As-an-object-method" class="headerlink" title="物件的方法調用 (As an object method)"></a>物件的方法調用 (As an object method)</h2><p>「物件的方法調用」是最常見改變 this 的方法，只要搞懂這一部份就能了解決大部分的 this 運作，大部分的文件介紹此部分說明為：在函式內的 <code>this</code> 值取決於該函式如何被呼叫。而如何被呼叫實在難以被定義，如：callback、閉包、函式內的函式等等其實都與 this 沒有關聯性。</p>
<p>提供另一個比較易懂的中文說明：this 大部分取決於 <strong>它在哪個物件下被呼叫</strong>，也就是本段落主要介紹的「物件的方法調用」這個觀念佔了 <strong>絕大部分</strong> 的 JavaScript 實作時的 this 運作（接下來幾篇會陸續介紹其它幾種），版頭圖則是說明這一類型的 This 運作模式，只要找到上層物件就搞定了整個觀念，下述文中產生了一個函式，透過兩個不同的方式取用則有不同的結果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;全域阿婆&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> auntie = &#123;</span><br><span class="line">  name: <span class="string">&#x27;漂亮阿姨&#x27;</span>,</span><br><span class="line">  callName: callName  </span><br><span class="line">  <span class="comment">// 這裡的 function 指向全域的 callName function</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callName()        <span class="comment">// &#x27;全域阿婆&#x27;</span></span><br><span class="line">auntie.callName() <span class="comment">// &#x27;漂亮阿姨&#x27;，呼叫是在物件下調用，那麼 this 則是該物件</span></span><br></pre></td></tr></table></figure>
<p>前者是稱為「純粹的呼叫」，此種情況相對單純下個段落會有完整介紹，而另一個物件呼叫 <code>auntie.callName()</code> 則會將 this 指向 “漂亮阿姨”，這個部分相信大家就能有基本的體會，物件下呼叫會影響 this 的指向。</p>
<p>概念如同下圖，在物件下的函式 this 為前者物件。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2F92E6BA08-EF5E-4287-98B4-E38ED2549D02.png?alt=media&amp;token=69407e80-c041-4861-8870-92db99a8d3a9" alt=""></p>
<p>而 this 這個詞就可以思考成 <strong>這一個「物件」</strong>，它會隨著在哪一個物件下被調用而影響結果，在此情境下如果有更深層的 this 依然是當下這一個物件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> auntie = &#123;</span><br><span class="line">  name: <span class="string">&#x27;漂亮阿姨&#x27;</span>,</span><br><span class="line">  callName: callName,</span><br><span class="line">  watch: &#123;</span><br><span class="line">    name: <span class="string">&#x27;Magic Watch&#x27;</span>,</span><br><span class="line">    callName: callName</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">auntie.callName() <span class="comment">// &#x27;漂亮阿姨&#x27;</span></span><br><span class="line">auntie.watch.callName() <span class="comment">// &#x27;Magic Watch&#x27;</span></span><br></pre></td></tr></table></figure>
<p>在這個概念下，每一層的函式的 this 都是上一層物件，很簡單吧，所以漂亮阿姨下的每一層物件函式 this，都是指向該上層物件。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2F2D6C6680-DD7F-4CAF-982D-18D80F1EEB6B.png?alt=media&amp;token=4598a924-8c2a-445d-bf23-93a767ae9703" alt=""></p>
<h3 id="Vue-js-下的概念"><a href="#Vue-js-下的概念" class="headerlink" title="Vue.js 下的概念"></a>Vue.js 下的概念</h3><p>使用 Vue.js 時運作的原理就與上述的接近，我們可以看到以下的程式碼運作時，物件第一層的內容均是指向 myCar 這一個物件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myCar = &#123;</span><br><span class="line">  name: <span class="string">&#x27;長大以後要當保時捷&#x27;</span>,</span><br><span class="line">  go: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.go()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">myCar.init()</span><br></pre></td></tr></table></figure>
<p>接下來看一下 Vue.js 的程式碼，你可能會思考這樣的結構比上述的多了一層，理論上 Vue 的 this 的運作會不太一樣才是。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    text: <span class="string">&#x27;這是一段話&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    go() &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.text) <span class="comment">// 這是一段話</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>不過當 Vue 實際運作時，元件內的物件、函式等等均會被向上拉，methods, computed 等等均不會存在，所以並非以原始碼<strong>而是以實際運行的狀態</strong>為主，如下圖，methods 內的 <code>go()</code> 及 data 內的 text 均在元件物件頂層。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2019_3_16_%E4%B8%8B%E5%8D%883_40.png?alt=media&amp;token=b0c65c3c-0750-4f44-b522-77a661a41c51" alt=""></p>
<p>接下來運行的概念如下，元件下的函式的 this 就會直接指向該元件，所以 <code>go()</code> 這個函式的 this 自然就能夠使用元件內的 text 資料囉。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201903%2F0DF4C4CC-0504-4870-B536-C93513478255.png?alt=media&amp;token=7b8adaf2-5ee3-43ea-8123-9747e2b801ec" alt=""></p>
<h3 id="延伸閱讀：陣列內插入函式"><a href="#延伸閱讀：陣列內插入函式" class="headerlink" title="延伸閱讀：陣列內插入函式"></a>延伸閱讀：陣列內插入函式</h3><p>在 JS 型別中，陣列也是屬於物件的一種，因此將函式插入陣列之中運行，this 的指向會如何呢？</p>
<p>一般來說不會有人這樣寫，但我們可以從中獲得相同的結果：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeone</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;this is&#x27;</span>, <span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> MingFamily = [<span class="string">&#x27;小明&#x27;</span>, <span class="string">&#x27;爸&#x27;</span>, <span class="string">&#x27;媽&#x27;</span>, callSomeone]</span><br><span class="line">MingFamily[<span class="number">3</span>]()</span><br></pre></td></tr></table></figure>
<p>同上所述，callSomeone 這一個函式的運作也是接在 MingFamily 陣列後方，所以 this 將會指向 MingFamily 這一個陣列喔！</p>
]]></content>
      
        <categories>
            
            <category> javascript </category>
            
        </categories>
        
        
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 設計的過去、現在、未來]]></title>
      <url>https://wcc723.github.io/design/2018/11/13/ironman-final/</url>
      <content type="html"><![CDATA[<p>「這張圖幫我美工一下」，讓工作中的設計師聽在耳裡非常的不爽，當下正想立即回嘴：「你才美工，你全家都美工！」才發現說話的是老闆。</p>
<p>過去，許多設計師非常討厭這句話，「美工」原意應該為「美術工藝」的縮寫，在此用法則改為「美術工人」、「美術工作」之意，身為具有創意思維的設計師怎能接受這樣的說法。當然，隨著環境的變遷，會這樣說的老闆、同事也就越來越少，與其它領域合作時應互相尊重。</p>
<h2 id="你是美工嗎？"><a href="#你是美工嗎？" class="headerlink" title="你是美工嗎？"></a>你是美工嗎？</h2><p>「工人」指從事某種職業的勞動者，多指工業生產領域，依靠出賣勞動獲取報酬的人，通常指「體力勞動者」，因為工作內容大多是重複的行為，所以大多數的人只要透過勞動就能勝任。</p>
<p>因此，設計師如果僅透過相同的行為從事設計，打開 Photoshop 用著相同技法、相同的習慣，將業務所需的圖文排列，沒有太大的變化及成長，其實也就與上述的「美工」無異，高度的可替代性，僅需要美術相關學院畢業都可以勝任。因此，設計師與工程師一樣是必須不斷的學習，擴增自己的視野，多了解不同領域之間的協作關係。</p>
<h2 id="未來發展"><a href="#未來發展" class="headerlink" title="未來發展"></a>未來發展</h2><p>1111 剛過，這個節慶來自於中國的光棍節，現在則是華人電商促銷折扣的日子，每一年的今天「天貓」電商業績都會不斷的創新高，只要一天時間就可以獲得將近一兆的營業額。</p>
<p>這麼大的活動自然需要有大量的廣告及圖片推動產品的銷售，上千億張的廣告圖片等待產出，必然需要大量的人力來處理。但在 2017 年開始，阿里開發了「<a href="https://buzzorange.com/techorange/2017/04/28/alibaba-ai/">魯班</a>」智能圖片產生器，收集資料庫內大量圖片素材中並分析其中的裝飾、配色、構圖，並搭配商品素材自動產生廣告圖，透過深度學習的變化下產生的圖片一般用戶是沒有辦法辨別是自動產出的，僅需要將廣告圖所需的圖片、文案加入，並搭配不同風格變化即可，在 2017 年有 1.7 億張廣告圖是由「魯班」產生。</p>
<h2 id="衝擊"><a href="#衝擊" class="headerlink" title="衝擊"></a>衝擊</h2><p>在先前的文章其實也有不斷提到「設計規範」，規範本身也是限制設計師行為的工具，為了確保設計結果的可行性，但這樣的過程中設計師也慢慢地轉換回使用相同技法、放置圖文的「工人」，從設計師轉換為「繪製流程圖」的員工（工作是將流程圖依據規範排列出來），那麼也意味著這個流程是否在不久後可能會被類似「魯班」的工具所取代呢？</p>
<p>當然，這個過程不可能太快，畢竟阿里巴巴的開發能夠帶來大量的利益，一般的中小企業不太可能導入人工智能的方式處理，一方面是成本太高，另一方面則是資料量不足。但可以知道的是未來會出現「通用類型」的商用圖文智能工具，專門來處理重複、簡單的行為。</p>
<p>那麼設計師該如何維持自身的價值呢？</p>
<h3 id="具備意涵的設計能力"><a href="#具備意涵的設計能力" class="headerlink" title="具備意涵的設計能力"></a>具備意涵的設計能力</h3><p>智能工具可以辨識畫面構圖、素材、色彩等等，但無法辨識圖片是否具有深層內涵，它可快速排列出具有美感、類似風格、多樣變化的圖片，但無法為任何一張圖賦予「意義」。所以設計師只有排的「美」是不足夠的，還必須思考怎樣讓圖片具有「意義」，讓圖片並非只有圖文的訊息傳遞，還需要帶有機械無法呈現的情感。</p>
<h3 id="訓練-AI-的能力"><a href="#訓練-AI-的能力" class="headerlink" title="訓練 AI 的能力"></a>訓練 AI 的能力</h3><p>由於 AI 是透過大量資料分析做深度學習，因此「資料來源」非常重要，設計師就必須帶領 AI 創新，瞭解如何訓練 AI 並優化其結果。也如同上面所提的文章一樣，設計師的工作將轉為「學習這套系統（魯班），學習如何訓練機器，同時在美學方面做把控」</p>
<h3 id="分析使用者體驗的能力"><a href="#分析使用者體驗的能力" class="headerlink" title="分析使用者體驗的能力"></a>分析使用者體驗的能力</h3><p>除此之外，設計師也能做橫向的發展，以視覺為基礎研究使用者的行為，藉此優化人或 AI 所沒有涉及的部分。AI 雖然有極高的效率，但畢竟是由現有的資源做分析，也就是當現有資料具有盲點時 AI 不一定能夠修正，此時必須回到人本身具有的彈性思維。</p>
<p>所以接下來大家更不需要擔心被稱為「美工」，因為這類型的工作將被 AI 所取代。反之，設計師應不斷的學習，避免自己只有在重複的行為上工作。</p>
<hr>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這是第五次參加鐵人賽了！先前的鐵人賽都是撰寫技術相關主題，本次是回到設計的內容，其實撰寫的過程中才發現久沒接觸確實生疏了許多，也包含不少設計觀念其實有些修正，必須重新翻閱文件才能了解 orz。</p>
<p>不管如何，這次也是順利完賽，在此也獻給許多想要進步的朋友們，只要挑戰完 30 天該技能就能突飛猛進，寫文章並非是要寫給他人，更重要的是挑戰自我。最後列出本次的所有連結：</p>
<p>網頁設計基本概念</p>
<ul>
<li><a href="https://wcc723.github.io/design/2018/10/15/frontend-design-holy-road/">前端「設計」聖光之路</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/16/dont-use-graphic-design-tool/">別使用平面繪圖軟體繪製 UI 設計</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/17/design-vs-developer/">設計師思維及工程師思維</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/18/grid-system/">網頁設計常用格線系統(上)</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/19/grid-system-2/">網頁設計常用格線系統(下)</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/20/design-guide/">文件、規範參考 - Material Design</a></li>
</ul>
<p>色彩運用</p>
<ul>
<li><a href="https://wcc723.github.io/design/2018/10/21/color/">網頁設計色彩配置概念</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/22/accessibility/">你的網頁文字是否足夠清楚呢？</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/23/link-color/">連結的配色</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/24/button-color/">按鈕的配色</a></li>
</ul>
<p>字體</p>
<ul>
<li><a href="https://wcc723.github.io/design/2018/10/25/fonts/">系統字體介紹</a></li>
<li><a href="網路字體運用">網路字體運用</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/27/fonts-family/">文字大小、行高與空間上的關係</a></li>
</ul>
<p>圖片</p>
<ul>
<li><a href="圖片格式的運用">圖片格式的運用</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/29/image-opti/">圖片壓縮方法</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/30/image-svg/">SVG 輸出注意事項</a></li>
<li><a href="https://wcc723.github.io/design/2018/10/31/icon-fonts/">Icon fonts 的常見資源</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/01/responsive-images/">響應式圖片選用技巧</a></li>
</ul>
<p>版面</p>
<ul>
<li><a href="https://wcc723.github.io/design/2018/11/02/weblayout/">版面視覺動線配置(1)</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/03/weblayout-2/">版面視覺動線配置(2)</a></li>
</ul>
<p>規範</p>
<ul>
<li><a href="https://wcc723.github.io/design/2018/11/04/styleguide-1/">網頁設計規範 - 參考來源</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/05/styleguide-2/">一致性的距離（計算方法、水平、垂直）</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/06/styleguide-3/">定義不斷出現的網頁元素</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/07/styleguide-4/">通用視覺效果</a></li>
</ul>
<p>其它</p>
<ul>
<li><a href="https://wcc723.github.io/design/2018/11/08/funnel/">實際透過工具測量用戶行為</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/09/communication-tools/">設計師與開發者的溝通工具</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/10/design-reference/">設計「參考」資源</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/11/design-material/">設計「素材」資源</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/12/design-to-developer/">平面設計師轉設計前端的經驗分享</a></li>
<li><a href="https://wcc723.github.io/design/2018/11/13/ironman-final/">設計的過去、現在、未來</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 平面設計師轉設計前端的經驗分享]]></title>
      <url>https://wcc723.github.io/design/2018/11/12/design-to-developer/</url>
      <content type="html"><![CDATA[<p>平面設計師轉設計前端的經驗分享<br>一開始的文章有提到，我原本也是從事設計，出社會以後開始轉往開發者。學習到目前也能開發到後端（還不會提到是全端工程師，畢竟術業有專攻），學開發觀念與過去學習設計有非常大的差異，也會不斷地反思過去設計思維的價值。</p>
<h2 id="為何要從設計轉前端？"><a href="#為何要從設計轉前端？" class="headerlink" title="為何要從設計轉前端？"></a>為何要從設計轉前端？</h2><p>原因很簡單，設計師的薪資普遍低於開發者。這也並非台灣特有現象，而是商業的上設計和開發本質就有很大的不同。設計主要的收入都是以專案為概念，雇主或業主提出一個設計案，設計師來完成它，這個過程中設計師是很難主導商業價值的（但並非沒有，產品設計師、漫畫家、插畫家也有很多成功的案例）；相對的，開發則不僅限於專案，開發者較能夠自行主導屬於自己的商業模式。</p>
<p>在學期間就已經開始轉往開發，雖然是 Flash 不過也對於程式碼有基礎的概念（雖然出社會後 Flash 就死掉了），過程中我所學習的是 ActionScript，這個語法是基於 ECMAScript 的標準開發的，因此與 JavaScript 接近許多，出社會後就持續往前端的路邁進。</p>
<h2 id="這之中學到了什麼？"><a href="#這之中學到了什麼？" class="headerlink" title="這之中學到了什麼？"></a>這之中學到了什麼？</h2><p>轉往開發者的路上也是跌跌撞撞的，運氣不錯的是那幾年「前端」一詞才剛出現，進步上比較能有成就感（薪資 :D），但相對來說資源就會缺少很多，許多技術在研討會聽過，但是周遭能夠找到可詢問的人幾乎沒有，只能自己上網埋頭研究。</p>
<p>這個過程中，剛好廖洧杰創立了「<a href="https://www.facebook.com/groups/358503154261390/">高雄前端社群</a>」，大家還不熟的情況下，也就硬著頭皮上台介紹了幾次，每次簡報都是先挖坑再跳入研究，反覆幾次以後大家就以為我會的不少，但其實也才剛學而已（遮臉）。因此，從中體驗到了挖坑、分享是加速學習的方式，如果要更快則是要增加頻率，後來自己挑戰了<a href="https://wcc723.github.io/page/27/">連續 100 篇發文</a>，當時 IThome 鐵人賽也剛好開始，在那之後就陸陸續續參加了好幾屆。</p>
<p>這種學習方式是「設計」領域學不到的，設計領域重視創意、概念、自我，而開發領域重視執行、學習、共享。</p>
<h2 id="學習上的建議"><a href="#學習上的建議" class="headerlink" title="學習上的建議"></a>學習上的建議</h2><p>由於體驗了兩個不同領域更能了解兩個領域間思維上的差異，同時能使用設計師語言與設計師聊天（你才美工、你全家都美工），也能使用資料邏輯和工程師打屁（幫我從第零個衣櫥裡拿衣服）。這段故事也分享給許多人知道，畢竟很多設計師因為現實的原因想轉行到 UI 或工程師，以下分享一些學習上的概念：</p>
<h3 id="分享，是最佳途徑"><a href="#分享，是最佳途徑" class="headerlink" title="分享，是最佳途徑"></a>分享，是最佳途徑</h3><p>工程師學習時，會建議不斷的分享過程，這會有助於獲得階段性成就，並且在為了分享的過程中，會將細節觀念看得更透徹並將其轉換成文字，所以自然能夠學得更有效果。</p>
<p>學習並掌握一個技巧需要花上不少時間，過程中的煎熬不一定每個人都能體驗其樂趣，但透過階段性學習的分享，會較容易從中獲得成就感。</p>
<p>另外提到，因為寫了不少文章，每日流量也在千人上下，就順手置入廣告於<a href="https://wcc723.github.io/">部落格</a>之中，開始做了廣告版面的一些實驗性功能…（地方開發者需要贊助 :D）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F4363C0DF-973C-42D8-BEB1-7C4B55EEBD04.png?alt=media&amp;token=4918cf6b-e526-4723-a95d-755907d7abd9" alt=""></p>
<h3 id="學習不是一時的"><a href="#學習不是一時的" class="headerlink" title="學習不是一時的"></a>學習不是一時的</h3><p>在轉行的過程中，總是會想選擇一個一勞永逸地工具或方向，比如說前端框架或語言只想挑一個學習，想使用同一個技術挑戰十幾年，但就目前開發領域的高速成長來說是不太可能的，許多技術出現兩三年則沒落。</p>
<p>可能會去想這樣不斷追新技術不就太累？其實不斷的學習過程中，就會不斷的累積基礎概念，接下來厚實的基礎概念就會有助於學習更新的技術，且不斷學習新技術也是開發者的優點及價值，讓開發者更容易適應新事物及學習新觀念。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>作為設計師轉行開發者，價值觀會有明顯的變化，許多是直接顛覆過去學習設計的思維及價值觀，過程中也會不斷審思過去價值觀是否正確，而這個過程給予想轉工程師的設計師自行從中學習體驗，也歡迎私下與我分享你的過程喔。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 設計「素材」資源]]></title>
      <url>https://wcc723.github.io/design/2018/11/11/design-material/</url>
      <content type="html"><![CDATA[<p>做設計總少不了一些圖庫當資源，圖庫資源在網路上非常多，無論免費、付費都可以找到不少，但是設計師在執行時，通常只會挑用一些偏好使用的站點來運用，以下介紹我在開發時比較常利用的素材網站。</p>
<p>素材也有區分類別，先前有介紹的網頁圖示、字體重複的部分就不再列出，本篇另外介紹點陣、向量、日文字體、短影片等幾個類別。</p>
<h2 id="點陣素材"><a href="#點陣素材" class="headerlink" title="點陣素材"></a>點陣素材</h2><p>一直以來我都是以向量為主做設計、開發，點陣素材如果需要自己來就需要透過攝影，但這個領域已很久沒有接觸，且好的照片並不是那麼容易可以拍出來。</p>
<p>近期最長參考的點陣素材是 Unsplash 這個服務，它所提供的攝影圖片品質 “極高”，且圖片皆是免費並可以做商業運用，在挑選圖片時總是會先逛逛這個站點。</p>
<ul>
<li><a href="https://unsplash.com/">https://unsplash.com/</a></li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F1DA9CB57-2BD9-43B8-9D2F-44DB58192AC7.png?alt=media&amp;token=d2bb4a4a-cf27-47aa-b630-0876c90f2fa3" alt=""></p>
<p>雖然 Unsplash 非常好，但同時也變成他的缺點，當需要找一系列的圖片時，就會較難找出相同風格、相同情境的，當一些特定系列圖片就會參考其它的素材網站。</p>
<ul>
<li><a href="https://stocksnap.io/">https://stocksnap.io/</a></li>
<li><a href="https://www.photock.jp/">https://www.photock.jp/</a></li>
</ul>
<p>以 Photock 來說，搜尋「桜」就會出現許多品質、風格相近的櫻花圖片，Unsplash 則會接近於藝術照。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FAC867803-CE5B-4AF8-9FBB-FF7CA49E05B6.png?alt=media&amp;token=ffdb672c-c3d8-4fe4-8c2b-a7a2e132d131" alt=""></p>
<h2 id="向量素材"><a href="#向量素材" class="headerlink" title="向量素材"></a>向量素材</h2><p>大部分向量素材都是需要收費的，而向量素材更重要的是需要一系列的風格，透過付費較能一次取得大量相同風格的授權圖。目前較常使用的是 Flaticon，主要是它另外有提供應用程式，可以直接搜尋圖片並將圖片拖拉至 Illustrator 或 Sketch 等繪圖軟體（剛剛看了一下只有支援 MacOS）。<br><a href="https://www.flaticon.com/">https://www.flaticon.com/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FCB8BF83B-70E7-4A31-9120-6F469CD28AD1.png?alt=media&amp;token=3746d8d6-95b2-43a1-a855-6f4fbac641b5" alt=""></p>
<p>如下圖，可以直接在應用程式內搜尋圖示並直接加入到繪圖軟體內，如果需要系列圖片，也可以在 Flaticon 網站上搜尋後加入收藏，應用程式也能直接取用。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FE02D7BCB-7980-490A-B3E2-C96F58F25B01.png?alt=media&amp;token=74c79b39-a8b0-404a-b9ff-02db8498bf13" alt=""></p>
<p>很多圖片是免費使用的，但是付費的通常都比較精細 :D。</p>
<h2 id="日文字體"><a href="#日文字體" class="headerlink" title="日文字體"></a>日文字體</h2><p>由於中文字的開發成本高，加上繁體字的用戶只有台灣及香港，所以大多中文字都是需要付費。而「日本漢字」是從繁體中文演化而來，如果需要一些特殊的字體不妨可以參考「日本漢字字體」。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F9807BCDE-44FA-45DC-883F-941FC5ADEF09.png?alt=media&amp;token=0c5d9ece-7262-4ade-806e-c05dc2854fe1" alt=""></p>
<ul>
<li><a href="https://www.freejapanesefont.com/">https://www.freejapanesefont.com/</a></li>
<li><a href="https://fontbear.net/">https://fontbear.net/</a></li>
</ul>
<p>優點是風格特殊，但由於不是純中文字體，所以經常會有缺字的問題，此時就只能換詞或是乖乖換回中文字體使用。</p>
<h2 id="影片素材"><a href="#影片素材" class="headerlink" title="影片素材"></a>影片素材</h2><p>網頁一進入後就展示「全螢幕影片」相對於「靜態圖片」是更吸引人的。但影片素材處理相對複雜，Coverr 就是專門提供免費全屏影片的服務，並且會附上全屏所需要的 CSS 及 JS（但 RWD 支援性還需要自行調整）。</p>
<ul>
<li><a href="https://www.coverr.co/">https://www.coverr.co/</a></li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F88E86C3B-61EF-41F5-8A9B-5698CBCEF10E.png?alt=media&amp;token=c830cb82-e872-4b5f-bb66-da93188fc5c1" alt=""></p>
<p>素材網站也會隨著不同工作、經歷不斷地調整選用，過去我還會使用經典「書法字體」，並將歷代書法家的字體轉為向量圖運用，不過現在這類型網站較無維護，加上日文字體相對方便許多，所以就沒有再使用了。</p>
<p>以前學習設計時還有剛出社會的幾年，其實不太喜歡用素材，主要原因如下：</p>
<ul>
<li>素材資源難以統一</li>
<li>素材資源不一定能夠搭配目前設計</li>
<li><strong>用了素材感覺自己的設計就不是自己的</strong></li>
</ul>
<p>前面幾個其實是次要原因（但目前還是有此狀況），過去接受美學訓練時，都不斷強調自我的重要性；而在慢慢轉變到工程師後，這樣的思維就不會那麼強烈，因為工程師是偏向共享，這樣的理由下慢慢說服我自己去運用素材，加上後來工作需要加速完成商業運作，與程式碼品質的衡量下就選擇直接使用現有素材。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 設計「參考」資源]]></title>
      <url>https://wcc723.github.io/design/2018/11/10/design-reference/</url>
      <content type="html"><![CDATA[<p>開始執行設計時，除了要明確了解目標外，另一重點則是需要大量的想法及設計參考，假設需要製作遊戲類型的網站，那麼就需要先了解該類型的風格、配色、變化性等等，缺少這些參考也會難以動手開工。本篇列出經常搜尋的網站，以及這些網站的特性和參考點。</p>
<h2 id="Behance"><a href="#Behance" class="headerlink" title="Behance"></a>Behance</h2><p><a href="https://www.behance.net/">https://www.behance.net/</a></p>
<p>Adobe 旗下的作品張貼網站，相當中規中矩的呈現各設計師作品，上方也可以透過搜尋的方式找尋特定類別。進入作品頁面後會以「專案」來呈現，呈現出作者、點閱人數、推薦人數、使用的工具等訊息。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F8DC67A1B-BC17-4215-83C4-73DB7D378938.png?alt=media&amp;token=18457b39-bc7c-4b81-b57e-9b2d05c65b06" alt=""></p>
<p>也可以進入特定設計師、團隊的頁面內，參考特定作者的作品。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F95C75924-A984-492E-A7EE-88FB65230FE5.png?alt=media&amp;token=3f2ce277-a5e2-41cb-8395-4b8476475d34" alt=""></p>
<h2 id="Dribbble"><a href="#Dribbble" class="headerlink" title="Dribbble"></a>Dribbble</h2><p>基本的功能上與 Behance 很接近，近期流行的圖、火紅的設計師、團隊等等過濾方式皆有，不過 Dribbble 我喜歡的點在於它可以使用 “色彩” 作為搜尋的方式。如下圖，每個作品他會抓取部分重要的色彩，如果想看該色彩的延伸作品，點擊後就會出現該色系相關作品。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F40D4EAAE-9108-47E1-9A46-6E9CDDD7D35A.png?alt=media&amp;token=cd159775-73d0-494d-b5fe-77f8464e69a0" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F4260B29B-D255-4B9E-ADBE-E93C3704469D.png?alt=media&amp;token=8763f398-1a93-4943-a8a6-345f3e797a84" alt=""></p>
<h2 id="Pinterest"><a href="#Pinterest" class="headerlink" title="Pinterest"></a>Pinterest</h2><p><a href="https://www.pinterest.com/">https://www.pinterest.com/</a><br>Pinterest 是 「pin」及 「Interest」兩個單字組成的，白話的意思是釘選有興趣的作品，因此該網站需要註冊登入才能使用，也是因為會主動推薦用戶可能感興趣的作品。</p>
<p>使用搜尋後，他會跳出更多的「詞彙」，試著找尋用戶有興趣的內容，當然接下來的搜尋、釘選都會有助於 Pinterest 提供正確的圖片。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F33D6C415-4B7F-45FD-999F-363A00615D95.png?alt=media&amp;token=b0bbd6bb-d5d0-4181-9aaf-b8d9f5ac97bb" alt=""></p>
<h2 id="Collect-UI"><a href="#Collect-UI" class="headerlink" title="Collect UI"></a>Collect UI</h2><p><a href="https://collectui.com/designs">https://collectui.com/designs</a><br>這是一個大雜燴收集的網站，圖片都是來自於 Dribbble 上被推薦的內容，在前期沒有特定想做的風格，會先來這個網站找尋想要的「靈感」，有些方向後再去其它網站逛逛。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F864EEC04-48FE-4FC2-B7C4-F12EC854FE12.png?alt=media&amp;token=83d42413-7d14-498f-ae53-018d22e92c04" alt=""></p>
<h2 id="品牌設計規範"><a href="#品牌設計規範" class="headerlink" title="品牌設計規範"></a>品牌設計規範</h2><p><a href="http://findguidelin.es/">http://findguidelin.es/</a><br>有些時候需要要找各大「經典」來參考時，像是 Airbnb、Facebook、Dropbox、Uber 等等，突然想參考時 Google 也不一定能搜尋到，這時候 FindGuildlin 就打開直接看吧～。 </p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F7648BD3E-F524-4332-94A4-E7D4CD41473F.png?alt=media&amp;token=44062265-828e-4c3d-8cbe-8791fe304478" alt=""></p>
<h2 id="實際網頁參考"><a href="#實際網頁參考" class="headerlink" title="實際網頁參考"></a>實際網頁參考</h2><p>最後，列出會特別收錄優良作品的網站，像是 Awwwards 及 CSSDA 就會收集國際上優秀的網頁設計作品，並頒發獎章給予該網站。</p>
<ul>
<li><a href="https://www.awwwards.com/">https://www.awwwards.com/</a></li>
<li><a href="https://www.cssdesignawards.com/">https://www.cssdesignawards.com/</a></li>
</ul>
<p>Onepage 則是收集單頁類型網站，其中包含許多視差滾動的技巧。</p>
<ul>
<li><a href="https://onepagelove.com/">https://onepagelove.com/</a></li>
</ul>
<p>Mediaqueri 目前較無更新，但再響應式網站剛流行時就很參考這個網站，技巧都很基礎，重點是放在 RWD 的排版上。</p>
<ul>
<li><a href="https://mediaqueri.es/">https://mediaqueri.es/</a></li>
</ul>
<p>本篇重點在尋找靈感，這些也是常用來搜尋靈感的網站，下一篇則會介紹搜尋「素材」的資源，歡迎大家隨意收錄。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 設計師與開發者的溝通工具]]></title>
      <url>https://wcc723.github.io/design/2018/11/09/communication-tools/</url>
      <content type="html"><![CDATA[<p>溝通非常重要，不好的溝通不只沒有效率，也會造成不同領域間的嫌隙。如同設計師跟業者索取素材資源時，業者提供的是低解析度的 word 檔案，也很難解釋什麼叫做更高解析度的圖片！設計師對上工程師也是相同道理，如果給予的是 .ai、.psd 檔案，工程師會難以從中獲得執行所需要的資訊（需要另外學習如何操作）。</p>
<p>本篇就提供一些好用的工具，讓工程師與開發者可以了解設計師的規範，並且可以即時回饋讓設計師便於修改。</p>
<h2 id="Markman"><a href="#Markman" class="headerlink" title="Markman"></a>Markman</h2><p><a href="http://www.getmarkman.com/">http://www.getmarkman.com/</a></p>
<p>Markman 是中國廠商開發的 UI 標示工具，可以用於「輸出後」的圖片，只要透過簡單的拖曳就能標記出色彩、距離、輔助說明等，操作上簡單易用。由於是運用在輸出後的圖檔，所以無論是哪一種繪圖軟體都可以搭配運用（另外支持 PSD）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fmarkman-length.gif?alt=media&amp;token=028344c5-ac61-4cda-a104-034011030cc6" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fmarkman-color.gif?alt=media&amp;token=45db7847-0679-4a73-b1af-f93c3ec0d4da" alt=""></p>
<h2 id="Sketch-Zeplin"><a href="#Sketch-Zeplin" class="headerlink" title="Sketch Zeplin"></a>Sketch Zeplin</h2><p><a href="https://zeplin.io/">https://zeplin.io/</a></p>
<p>Zeplin 最早是 Sketch 的擴充功能，目前還支援 Photoshop、Illustrator 等繪圖軟體，算是真正整合設計軟體、設計規範、工程師協作的工具，透過 Zeplin 設計師可以一鍵輸出所有的設計規範，且不需要另外標示尺寸、色彩等。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F0AE8CF4A-599B-40D2-93E3-A7F9B4A3A94A.png?alt=media&amp;token=9819d5f4-4e66-4e8b-88c1-aa473cf68b7c" alt=""></p>
<p>工程師可以透過該工具直接取得所需要的資訊，如尺寸、間距、色彩，這讓畫面不至於因為過多標示感到凌亂，也能得以呈現更多的資訊。不僅如此，開發者也可以依據所開發的平台（Web、iOS、Android）從中取得所需要的程式碼。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FF2802599-3411-41B7-856E-87AA30180A9F.png?alt=media&amp;token=302f8f5e-7a9d-47cc-8cc5-d9f39b3134ca" alt=""></p>
<p>Zeplin 官網有詳細介紹：<a href="https://zeplin.io/why-zeplin">https://zeplin.io/why-zeplin</a><br>過去寫過的相關文章：<a href="https://wcc723.github.io/tools/2015/04/09/zeplin-intro/">https://wcc723.github.io/tools/2015/04/09/zeplin-intro/</a></p>
<h2 id="Adobe-XD-Spec"><a href="#Adobe-XD-Spec" class="headerlink" title="Adobe XD Spec"></a>Adobe XD Spec</h2><p>範例設計稿：<a href="https://lihi.cc/LAfsC">https://lihi.cc/LAfsC</a><br>介紹說明：<a href="https://helpx.adobe.com/tw/xd/help/design-specs-for-developers.html">https://helpx.adobe.com/tw/xd/help/design-specs-for-developers.html</a></p>
<p>Sketch 並沒有屬於自己的規範工具（類似 Zeplin 那種），而 Adobe XD 則是有推出 Spec 工具，只要有付費 Adobe CC 都可以直接運用，目前雖然功能並非如 Zeplin 那樣的完整，但在 Web 開發上也是相當足夠使用。</p>
<p>基本的間距、尺寸、色彩資訊皆有呈現。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F05CF299A-DA45-4971-B645-0FB58BC11246.png?alt=media&amp;token=e9177d79-e457-43b3-8bf0-d0652fe486ca" alt=""></p>
<p>另外也有討論工具。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FDCCC0131-87FE-4D40-9921-86C5BD2B6D81.png?alt=media&amp;token=708dfd70-49c0-4fc7-b8ef-b4ebb69fa8f8" alt=""></p>
<h2 id="Slack"><a href="#Slack" class="headerlink" title="Slack"></a>Slack</h2><p>Slack: <a href="https://slack.com/">https://slack.com/</a><br>台灣聊天使用的是 LINE 工具，除了閒聊外還有完整的表情圖片可以運用，非常適合抒發情緒。但在開發上還是建議使用工作用的通訊工具，主要是對於開發有完整的支援性，另一方面也可暫時關閉閒聊用的通訊工具，確保工作上的專注力。</p>
<p>與一般通訊工具一樣，基本的留言、搜尋都沒有問題，除此之外也有重點字詞標示、子討論項目等功能，且可以與各大現有的服務做整合如：Github、Google Drive 等等，使資訊更新時 Slack 都能及時收到。</p>
<h4 id="整合-Adobe-Creative-Cloud"><a href="#整合-Adobe-Creative-Cloud" class="headerlink" title="整合 Adobe Creative Cloud"></a>整合 Adobe Creative Cloud</h4><p><a href="https://slack.com/apps/A7P35MCT0-adobe-creative-cloud">https://slack.com/apps/A7P35MCT0-adobe-creative-cloud</a></p>
<p>透過 Slack 不僅可以傳遞規範網址以及預覽，也可做到設計師更新規範時，Slack 會即時收到規範已更新的訊息。 </p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F0E53C9F4-9AE0-47B2-A943-0F0B5DFD9E12.png?alt=media&amp;token=21d04614-ae12-4030-929b-98c1633cdb31" alt=""></p>
<h2 id="Dropbox-Paper"><a href="#Dropbox-Paper" class="headerlink" title="Dropbox Paper"></a>Dropbox Paper</h2><p>為了不讓 Sketch 專美於前，Adobe XD 不僅有類似於 Sketch 的功能，且還與各大廠商合作（如前面所提到的 Slack 服務），Dorpbox Paper 則是整合文件與 Adobe XD Spec 的功能，使匯出的規範連結貼入 Dropbox Paper 時能夠直接預覽。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fxd-paper-demo_smaller.gif?alt=media&amp;token=3e2d067a-fd71-46c5-9c13-73ece8f5f004" alt=""></p>
<p>詳細說明：<a href="https://blogs.dropbox.com/dropbox/2018/10/adobe-xd-dropbox-paper-integration/">https://blogs.dropbox.com/dropbox/2018/10/adobe-xd-dropbox-paper-integration/</a></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>好的工具不僅可事半功倍，用在溝通上也可以增進感情，身為設計師不喜歡收到解析度不足的檔案，工程師也希望能夠收到標示明確的文件，本篇介紹的工具都不需要花費太多精力就可以使用（但可能需要花點＄），如果有更好用的工具也歡迎在下留言讓我知道。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 實際透過工具測量用戶行為]]></title>
      <url>https://wcc723.github.io/design/2018/11/08/funnel/</url>
      <content type="html"><![CDATA[<p>開發、設計時我們會盡可能站在用戶的導向做思考，當中也會腦補許多行為，如：</p>
<ul>
<li>字要小才會顯得精緻</li>
<li>輪播 Banner 很吸睛，最新消息放在上面大家都會看</li>
<li>說明要拆很多頁，用戶不喜歡同一頁滾太久</li>
</ul>
<p>相信以上範例在目前網頁已經少見很多，畢竟這些都是經過許多前人的研究調整而成。但身為設計師，多少都會想透過不同的視覺調整，嘗試是否能夠做出更好的使用者體驗，本篇就透過一些工具介紹，讓大家了解如何「觀察」使用者的體驗。</p>
<h2 id="用嘴巴問"><a href="#用嘴巴問" class="headerlink" title="用嘴巴問!?"></a>用嘴巴問!?</h2><p>一個畫面做出來，總是可以透過詢問同事、朋友的方式，了解該畫面是否好看、好用等等，但訪談本身也是極需專業及技巧，如果沒有許多事情準備很難有足夠效益，缺乏正確準備的詢問可能具有以下的問題：</p>
<h4 id="對設計師的情感了解"><a href="#對設計師的情感了解" class="headerlink" title="對設計師的情感了解"></a>對設計師的情感了解</h4><p>詢問大多會從週遭的人開始，周遭的人也對於設計師、開發者有基礎的認識，此時回答的內容就會受到情感的影響，比如說：友好的稱讚、習慣性的酸言酸語，而這些對於使用者體驗調查本身並沒有任何幫助。</p>
<h4 id="對於詢問內容已有基本的了解"><a href="#對於詢問內容已有基本的了解" class="headerlink" title="對於詢問內容已有基本的了解"></a>對於詢問內容已有基本的了解</h4><p>接下來，詢問的過程中總是會先介紹問答的目標，也就是目標對象是在「有心理準備的情況下」接受檢測，那麼大部分的行為將不具有參考性，因為真正的用戶並不會有「被觀察」的感受來使用網站。</p>
<h4 id="受眾、用戶可能並非真正網站使用者"><a href="#受眾、用戶可能並非真正網站使用者" class="headerlink" title="受眾、用戶可能並非真正網站使用者"></a>受眾、用戶可能並非真正網站使用者</h4><p>再者，詢問的對象大多是與自己生活相仿的對象，例如：都居在相同都市、年齡接近、生活習慣接近、價值觀差異小。不同背景、價值觀的人們在瀏覽網站時的目標也會不同。</p>
<p>如：嬰幼兒商品網站，那麼身為媽媽所觀察的點就不會是只有價錢，而是會仔細看產品本身是否能解決他的問題，相關評價是否優良等等，但如果是其它人可能會關注在價格、Banner 的媽媽很漂亮、嬰兒圖片可愛等等。</p>
<h2 id="使用者體驗漏斗"><a href="#使用者體驗漏斗" class="headerlink" title="使用者體驗漏斗"></a>使用者體驗漏斗</h2><p>如果用戶是具有心理準備下接受訪查，那麼行為將不具有真實性（如：男性受訪者如果看到正妹圖，大多假正經會先跳過不去點擊）。反之，真實的行為是更有價值的。</p>
<p>試著想像：用戶在家中使用電腦時，因為其他人推薦的服務有興趣，不看任何文案、描述立馬按下註冊的情境，但註冊的過程擁有許多關卡，最後一關必須要填寫信用卡才算完成，立馬關閉視窗結束瀏覽…</p>
<p>上述的過程包含了：</p>
<ol>
<li>進入導覽頁面</li>
<li>點擊註冊</li>
<li>註冊流程填寫資訊</li>
<li>填寫信用卡</li>
<li>註冊完成（假設這步驟有完成）</li>
</ol>
<p>身為設計師或開發者，就必須從這個流程中尋找問題，這個流程我們會稱為 Funnel（漏斗），上層進入的人數會很多，過程中會不斷流失人，這個形狀就類似漏斗。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F9B9A3F0A-A17C-444F-9547-67488753AF1A.png?alt=media&amp;token=dee5ee54-93f7-49d9-ac66-5ee0df5af0f4" alt=""></p>
<p>會先假定一個目標，接下來列出達到該目標會遭遇到哪些行為，接下來透過工具觀察每個行為的數據，是否在哪個階段有大幅的減少。</p>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="GA"><a href="#GA" class="headerlink" title="GA"></a>GA</h3><p>GA 是 Google 旗下的一個服務，大多開發者都會安裝用來監控流量來源、用戶裝置、用戶所在地區等等…，而他也有提供「增強型電子商務」，透過電商的成效呈現 Funnel 數據，不需要額外費用就可以導入 Funnel 的觀念。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FA4CB1410-5280-4A49-888E-5F5A510AB145.png?alt=media&amp;token=e6b6d5ee-be01-42aa-afc9-297a2710757a" alt=""></p>
<h3 id="Mixpanel"><a href="#Mixpanel" class="headerlink" title="Mixpanel"></a>Mixpanel</h3><p>Mixpanel 優點是可以隨著開發者自定義追蹤行為，所以也可以隨著需求調整需要用於各種成效追蹤，如：註冊、購買、填寫表單等等，對於 Google 所提供的 UTM 追蹤碼也能自動套用，所以除了能夠了解 Funnel 成效，更能透過用戶「來源」分析不同用戶的成果。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FDAB50C15-C2E2-4444-95C8-BD87C96DA16A.png?alt=media&amp;token=8fba45e4-f066-47d9-96ef-10fa56569515" alt=""></p>
<h3 id="Hotjar"><a href="#Hotjar" class="headerlink" title="Hotjar"></a>Hotjar</h3><p>Hotjar 也同於上述的行為追蹤工具，但更大的特色是可以做到「側錄」，了解每個用戶在網站上的行為軌跡，更能了解用戶操作上是否真的如預期活動。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FFD032722-1BE0-4A11-8948-B8E99C3FE37D.png?alt=media&amp;token=cdf2e91d-7270-4973-acf7-8bb8ecdfaa22" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FAE56BA50-3313-4658-9F50-DEAF3C433204.png?alt=media&amp;token=6778617e-10f3-4fa3-8256-33772cf9c2e2" alt=""></p>
<p>另外，Hotjar 也能依據使用者點擊的數據產生熱圖，透過此熱圖也能測試各種「詞彙」對於用戶心裡成效的分析（究竟是 “免費” 吸引人還是 “註冊”）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F5D9C1C38-D87B-4D23-9354-384851EA9250.png?alt=media&amp;token=3b38200a-1f3d-4b90-bae1-ec09ed4ca935" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>使用者體驗一直是受到重視的議題，好的使用者體驗能將導入的成效翻倍，但另一方面使用者體驗本身也需要大量的「數據」作為支持（沒有量，翻倍也是徒然）。因此關注使用者體驗前，也需要多重視產品本身的價值。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 網頁設計規範 - 通用視覺效果]]></title>
      <url>https://wcc723.github.io/design/2018/11/07/styleguide-4/</url>
      <content type="html"><![CDATA[<p>規範定義除了元件設計、空間、格線等等外，另外還有經常重複使用的樣式也能夠被預先定義，比要常見的視覺效果如下：</p>
<ul>
<li>圓角</li>
<li>邊線粗細、邊線色彩</li>
<li>陰影</li>
<li>背景圖樣、裝飾</li>
</ul>
<h2 id="圓角"><a href="#圓角" class="headerlink" title="圓角"></a>圓角</h2><p>圓角就有點類似於明體、黑體之間的關係，黑體與明體會有兩者截然不同的個性，明體讓人感受具有人文、藝術氣息；黑體則讓人感受具有科技、現代感，圓角亦是如此，且可以隨著不同的圓角尺寸有著不同感受。如無圓角如同黑體，具有科技、現代感，但同時讓人感受較無情感，反之大圓角則讓人感覺更易於親近。</p>
<p>然而選擇哪一種都應該延續相同的視覺效果，並延伸到所有的視覺元件上。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman20%20%E2%80%93%201.png?alt=media&amp;token=448608da-5e5c-43d4-ad74-00ec1fef9e5c" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman20%20%E2%80%93%202.png?alt=media&amp;token=c59da3f1-5307-466c-84cf-6ea471ab376c" alt=""><br>下圖：這是不好的示範，圓角沒有固定的運用，無法維持一致性的視覺體驗。</p>
<h2 id="陰影"><a href="#陰影" class="headerlink" title="陰影"></a>陰影</h2><p>陰影在 Material Design 中不斷提到，他是一個呈現「深度」的好技巧，具有相同深度的物件會讓人感受到相同的重要性。</p>
<p>前文所提到的深度：<a href="https://wcc723.github.io/design/2018/10/19/grid-system-2/">https://wcc723.github.io/design/2018/10/19/grid-system-2/</a></p>
<p><a href="https://material.io/design/environment/light-shadows.html#shadows">https://material.io/design/environment/light-shadows.html#shadows</a></p>
<p>因此，設計時也可以使用不同級距的陰影，表現出不同重要性的元件，當然這些依然要維持固定的級數。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman20%20%E2%80%93%204.png?alt=media&amp;token=42931514-fb3f-4ed6-a15d-db7a558afb9c" alt=""></p>
<p>雖然些許差異的陰影變化是難以察覺的，但會增加開發上的許多困擾。</p>
<h2 id="邊線"><a href="#邊線" class="headerlink" title="邊線"></a>邊線</h2><p>邊線是色彩、線條的延伸，套用在元件的邊緣，邊線運用上特別要注意元件與元件的接合性，因為邊線本身具有空間，所以當並排、小距離間隙邊線的呈現都要注意。究竟是要完全相合、色彩變化差異等等。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman20%20%E2%80%93%205.png?alt=media&amp;token=f17afa9a-1c48-46f6-835b-58c641e3dcf6" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman20%20%E2%80%93%206.png?alt=media&amp;token=57d29b98-4be8-4c6b-af3f-3d686995bdae" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這些樣式經常會重複定義，且會應用在元件上或網站上的各個地方，就如同是字體一樣，這些通用視覺效果也應該需要被預先定義，避免每次運用只有些為落差，但卻沒有一致性的視覺效果。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman20.png?alt=media&amp;token=83f9c8e6-64e2-4415-ace2-ac7fe3049ead" alt=""></p>
<p>這些效果並非是獨立的元件，並沒有實際外觀，但這樣的預先定義有助於統一樣式，以一個卡片來說如果沒有共用的邊線粗細、色彩、陰影等等，視覺感落差就會很大，而這些視覺感受同樣會延伸到其他元件上。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 網頁設計規範 - 定義不斷出現的網頁元素]]></title>
      <url>https://wcc723.github.io/design/2018/11/06/styleguide-3/</url>
      <content type="html"><![CDATA[<p>定義玩基本要素如文字、色彩、空間等等後，就可以開始定義常用的「元件」，而每一種應用程式、環境都具有固定會不斷出現的 UI 元件，如桌面系統的應用程式會有固定的導覽列、關閉縮小視窗的控制項及固定的外框，雖然這些也是能夠調整，但調整的同時也意味可能會影響操作體驗。</p>
<p>網頁設計、行動 APP 也是如此，本身都會具有固定的 UI，這些 UI 對於一般用戶來說是很容易理解使用的。</p>
<h2 id="表單元件"><a href="#表單元件" class="headerlink" title="表單元件"></a>表單元件</h2><p>預先設定元件的目的，不外乎是在設計前預先準備完成，限制後續設計的變化，但同時增加開發速度，因此預先定義的元件樣式盡可能可以符合所有情境。當然，最重要的是能夠符合網頁開發的標準。</p>
<h3 id="表單結構"><a href="#表單結構" class="headerlink" title="表單結構"></a>表單結構</h3><p>在 HTML 中的表單結構如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">form</span><br><span class="line">  div</span><br><span class="line">      label Email address</span><br><span class="line">    input(type&#x3D;&quot;email&quot; placeholder&#x3D;&quot;Enter email&quot;)</span><br><span class="line">  div</span><br><span class="line">    input(type&#x3D;&quot;checkbox&quot; placeholder&#x3D;&quot;Enter email&quot;)</span><br><span class="line">      label checkbox</span><br><span class="line">  button(type&#x3D;&quot;submit&quot;)</span><br></pre></td></tr></table></figure></p>
<p>最基本的會有一層 form 標籤，表示其內部是需要送出的表單內容（所以表單內容是被限制在 form 區域內），內部會有 label 及 input 對應，label 表示該 input 所需要輸入內容的說明，input 則是用戶實際輸入的內容，兩者會透過 id 互相對應（這屬於前端技術，在此不多介紹）。最後會再補上一個 button 作為最後送出的按鈕。</p>
<p>透過以上的結構可以得到以下的畫面，這也是大家所熟悉的網頁表單，以下我們就針對常被忽視的設計來與大家說明：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-1.png?alt=media&amp;token=18e3441d-c5d0-4d57-943f-620b281c1109" alt=""></p>
<h4 id="缺少-Label"><a href="#缺少-Label" class="headerlink" title="缺少 Label"></a>缺少 Label</h4><p>雖然網頁中沒有 label 表單依然可以正確運作，但依據網站親和性的概念（<a href="https://developer.mozilla.org/zh-TW/docs/Web/Accessibility/ARIA/forms/Basic_form_hints">label</a>），缺少 label 會難以讓裝置了解該欄位的名稱及用途。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-2.png?alt=media&amp;token=e4142cf9-beb2-4fdd-b774-39c68641587c" alt=""></p>
<h4 id="checkbox-及-radio"><a href="#checkbox-及-radio" class="headerlink" title="checkbox 及 radio"></a>checkbox 及 radio</h4><p>現在 Checkbox 及 Radio 的外觀都能夠客製化，但做這樣的調整時必須確保：</p>
<ul>
<li>大部分瀏覽器看起來是一致的</li>
<li>不會影響到用戶的操作經驗</li>
<li>如果有搭配 JS，請確保在各種情境下都能運作</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-3.png?alt=media&amp;token=bc86ef32-ade3-42fb-b870-feee9d760f14" alt=""></p>
<h4 id="不同類型的-input"><a href="#不同類型的-input" class="headerlink" title="不同類型的 input"></a>不同類型的 input</h4><p><code>input</code> 的類型非常多元，正確地運用可以減少開發者的負擔，並且增加對於行動裝置的支援性。以 type=”date” 來說，Chrome 瀏覽器就會跳出一個行事曆，在行動裝置上用戶就會跳出日期選擇器，而跳出的行事曆是固定外觀不能做樣式的調整。如果要追求符合品牌的外觀，請務必同時兼顧行動裝置的使用體驗。</p>
<p>除此之外，有部分的 input 類型是可以自定義外觀的，如：type=”range”、type=”file”（嚴格說起來 file 也不太修改，但還是有方法）。因此需要先認識所有類型的 input，並預先設計可能會使用到的類型。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-5.png?alt=media&amp;token=66fb1a8c-6bf8-449a-bab5-47944411d961" alt=""></p>
<h4 id="提示文字"><a href="#提示文字" class="headerlink" title="提示文字"></a>提示文字</h4><p><code>input</code> 中還有一個 <code>placeholder</code> 的屬性可以作為用戶填入文字前的提示，這通常是利用填寫前的提示，另外也可以在 input 下方加上提示文字，這會偏向填寫時或填寫後的提示。</p>
<p>不管如何，請別忘了還有提示文字需要被設計。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-6.png?alt=media&amp;token=3fcc100c-a615-4b07-8bf2-36a1e24cb657" alt=""></p>
<h4 id="與-Button-可以併排"><a href="#與-Button-可以併排" class="headerlink" title="與 Button 可以併排"></a>與 Button 可以併排</h4><p>設計時，也盡可能與 <code>button</code> 一同設計，因為會有不少情境是兩者併排出現的，如果不能併排還挺尷尬的。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-7.png?alt=media&amp;token=aaa66948-421f-4a25-bc51-d96c977522cd" alt=""></p>
<h4 id="禁用、錯誤狀態"><a href="#禁用、錯誤狀態" class="headerlink" title="禁用、錯誤狀態"></a>禁用、錯誤狀態</h4><p>最後提醒，設計規範是預先定義所有會利用的情境，所以禁用、錯誤雖然設計中不一定會出現，但請確保工程師執行時能夠了解該外觀為何。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-8.png?alt=media&amp;token=9d181296-a041-46ec-b69f-9665366609b5" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fform-9.png?alt=media&amp;token=61690a93-a4b4-472e-b54f-2484398f831d" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>定義規範是相當辛苦的，必須熟悉網頁基本運作流程，還要預先思考可能會運用的情境，但有了固定規範後工程師能夠先以規範定義元件庫，設計師更能快速建構頁面所需的內容。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 網頁設計規範 - 一致性的距離（計算方法、水平、垂直）]]></title>
      <url>https://wcc723.github.io/design/2018/11/05/styleguide-2/</url>
      <content type="html"><![CDATA[<p>一開始的文章有介紹到格線系統，主要是針對水平欄位空間的介紹，而其實垂直空間也是需要有固定的間距，當然一方面是有一致的美感，另一方面則是讓開發者設定全網站可用間距時可以統一帶入。</p>
<p>本篇主要會針對兩個部分做介紹，一是如何定義間距，另一則是針對運用上的介紹。</p>
<ul>
<li>定義間距（5 的倍數、以文字大小）</li>
<li>統一的運用（文字段落、小元件空間、大區塊的間隔）</li>
</ul>
<h2 id="定義間距"><a href="#定義間距" class="headerlink" title="定義間距"></a>定義間距</h2><p>雖說間距需要定義固定的數值，但至於如何定義其實沒有完全固定的規範，如果定義出 2, 4, 6, 8, 10, 12… 等所有雙數數值也算定義，但這麼細的數值再運用上其實非常不便，在此列出常見的定義方式給大家參考。</p>
<h4 id="整數的倍數"><a href="#整數的倍數" class="headerlink" title="整數的倍數"></a>整數的倍數</h4><p>大多設計師會有個習慣，就是會將色碼、字級等數字抓成整數，如過去使用 CMYK 時，就會習慣 5, 10, 15 的數字依序做色彩定義，字級也會使用雙數 2, 4, 6, 8, 10 等等…。</p>
<p>這個概念也依然可以運用在網頁設計上，可以預先定義一套固定級數的間距作為使用，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">5px</span><br><span class="line">10px</span><br><span class="line">15px</span><br><span class="line">20px</span><br><span class="line">30px</span><br><span class="line">45px</span><br><span class="line">60px</span><br></pre></td></tr></table></figure></p>
<p>接下來所有的網站也都會用這些數值來設計，並且避免使用到 3, 6, 7, 8 這些未定義的數值。</p>
<h4 id="文字的級數"><a href="#文字的級數" class="headerlink" title="文字的級數"></a>文字的級數</h4><p>另一種常見的定義方式則是搭配 rem，在 Bootstrap 中就是依據這種級數來做定義，且目前的網頁文字大小大多都以 16px 做為預設，因此延伸的級數則會有以下定義：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.25rem  -&gt; 4px</span><br><span class="line">0.5rem   -&gt; 8px</span><br><span class="line">1rem     -&gt; 16px</span><br><span class="line">1.5rem   -&gt; 24px</span><br><span class="line">2rem     -&gt; 32px</span><br><span class="line">3rem     -&gt; 48px</span><br></pre></td></tr></table></figure></p>
<p>這種定義方式對於設計師來說沒那麼好理解，但對於工程師來說卻能夠有延伸的運用，假設網站類性不需要 16px 大的文字，他可以調整成 14px，那麼整體的間距也會跟著調整成如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0.25rem  -&gt; 3.5px</span><br><span class="line">0.5rem   -&gt; 7px</span><br><span class="line">1rem     -&gt; 14px</span><br><span class="line">1.5rem   -&gt; 21px</span><br><span class="line">2rem     -&gt; 28px</span><br><span class="line">3rem     -&gt; 42px</span><br></pre></td></tr></table></figure>
<p>以上兩種開發中都是很常見的，而設計師僅需選擇其中一種，並與開發者協調好即可（設計圖目前還沒有辦法透過統一設定調整畫面間距）。</p>
<h2 id="統一的運用"><a href="#統一的運用" class="headerlink" title="統一的運用"></a>統一的運用</h2><p>定義好的間距會視設計需求來調整，但基本上還是會維持小空間使用小間距、大空間維持大間距的概念，如按鈕與按鈕之間就會避免使用 3rem 這種尺寸，而兩個大 section 之間當然也不會只使用 1rem 來做區隔，以下就依據一些常見情境作為範例：</p>
<h3 id="元件之間"><a href="#元件之間" class="headerlink" title="元件之間"></a>元件之間</h3><p>元件之間盡可能用小數值的間距做設定，透過此方式能夠維持相關內容依然視為一個群組；反之，過大的空間會使群組的觀念被打散。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman19.png?alt=media&amp;token=50782861-f19c-4e24-bf22-6a8c76d2b9f1" alt=""></p>
<h3 id="元件與外層區塊"><a href="#元件與外層區塊" class="headerlink" title="元件與外層區塊"></a>元件與外層區塊</h3><p>元件與外層區塊雖為同一個群組，但外層區塊大多是背景或單色，不具有訊息內容，因此有些距離更能保持美感。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman19%20%E2%80%93%201.png?alt=media&amp;token=7f872a96-0fb5-4210-a0cf-a94b172e76ef" alt=""></p>
<h3 id="區塊與區塊"><a href="#區塊與區塊" class="headerlink" title="區塊與區塊"></a>區塊與區塊</h3><p>區塊與區塊之間就是明確的不同訊息內容，因此要使用更大的空間將群組隔離，避免造成不同的訊息混淆。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman19%20%E2%80%93%202.png?alt=media&amp;token=1834e679-06f9-4158-8d3c-073e3e2a8569" alt=""></p>
<p>如 Evernote 網站就透過垂直空間、背景色彩、排版的差異，將不同訊息的群組明確分離開。</p>
<p>Evernote: <a href="https://evernote.com/intl/zh-tw">https://evernote.com/intl/zh-tw</a><br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F35BA5E57-3D31-4EFD-8F55-C349285DA8DD.png?alt=media&amp;token=cc284ab8-6d1c-472a-8640-35be3f034bce" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>好的空間定義，具有以下特點：</p>
<ul>
<li>一致性：就算內容改變，全站依然維持相同的空間邏輯</li>
<li>視覺群組：適當的空間區分內容</li>
<li>可被開發運用：具有固定的數值，且是明確具有邏輯，使之便於開發合作</li>
</ul>
<p>因此，建議設計師會預先定義好所需運用的間隔尺寸，接下來再設計時也便於方便取用，避免開發好幾頁後才發現空間間隔不一致。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 網頁設計規範 - 參考來源]]></title>
      <url>https://wcc723.github.io/design/2018/11/04/styleguide-1/</url>
      <content type="html"><![CDATA[<p>網頁設計許多概念是受到限制的，因為除了設計外也要同時重視可行性，因此預先定義規範不僅預先了解可執行的限制，對於工程師來說更方便預先建構元件。</p>
<p>但設計規範並不是一件容易的事情，同時必須在意可行性、延展性、穩定性。</p>
<ul>
<li>可行性：確保規範是可以被執行的</li>
<li>延展性：未來的更新是有預先規劃的</li>
<li>穩定性：不可隨意進行破壞性更新（break change）</li>
</ul>
<p>本篇提供一些概念給予參考，讓還沒有想法的設計師了解可以從何取得資源，並且慢慢著手加入設計規範。</p>
<h2 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h2><p>Bootstrap 官網：<a href="https://getbootstrap.com/">https://getbootstrap.com/</a><br>繁中版：<a href="https://bootstrap.hexschool.com/">https://bootstrap.hexschool.com/</a></p>
<p>Bootstrap 是網頁使用的 CSS 函式庫，內建許多現成樣式可以直接運用，讓不熟 CSS 或設計的開發者都可以做出一定品質的網頁，是目前使用最為廣泛的 CSS 函式庫（沒有之一）。</p>
<p>雖然他預先定義的樣式不一定被設計師所喜歡，但卻是非常標準、符合網頁開發原則的。以下列的標題字來說尺寸的變化具有一定的級數變化，轉換為網站運用的尺寸也是固定的整數。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FC17E7C9F-4C9F-4E47-8D7A-F71BE115B96B.png?alt=media&amp;token=2873b88b-f15f-4f16-8d40-8f540130f5b7" alt=""></p>
<p>先前所介紹的固定尺寸級數，也就是從 Bootstrap 所延伸而來，如果沒有預先定義所有標題級數，後期新增時會出現間距不明顯或間距過大等問題。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">設計師用的尺寸：   工程師所用的尺寸</span><br><span class="line">16px        :   1rem</span><br><span class="line">20px        :   1.25rem</span><br><span class="line">24px        :   1.5rem</span><br><span class="line">28px        :   1.75rem</span><br><span class="line">32px        :   2rem</span><br><span class="line">40px        :   2.5rem</span><br></pre></td></tr></table></figure></p>
<p>除了標準的文字、色彩的定義外，Bootstrap 在元件設計上也是用盡心力，如下方的 Navbar 為了定義出多種色彩的變化，它則是將文字的顏色設計成具有「透明度」，使他在不同色彩下都能夠自然的呈現，這樣的概念也可運用於設計之中（變化性不只案例中的三種，而是幾乎所有色彩）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F703E8205-5108-490C-A1C7-B1DEADD311C1.png?alt=media&amp;token=7aa08b3d-6576-4ba0-9f67-c82cefb72850" alt=""></p>
<h2 id="Adobe-XD-UI-Kits"><a href="#Adobe-XD-UI-Kits" class="headerlink" title="Adobe XD UI Kits"></a>Adobe XD UI Kits</h2><p>Adobe XD Resource: <a href="https://www.adobe.com/tw/products/xd/resources.html">https://www.adobe.com/tw/products/xd/resources.html</a></p>
<p>Adobe XD 目前在拓展階段，為了整合更多資源提供了 plugins、App internrations、UI Kits、Icon sets 等，不乏與各大企業合作或者整合性的服務，其中的 UI Kits 就有一份完整的網頁設計 wireframe 可作為設計規範（此份規範還不斷再更新中）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F1CB88347-A001-4808-BD24-9E268E1FC90E.png?alt=media&amp;token=d8442fb7-3138-43a8-bb09-cfa9884ae694" alt=""></p>
<p>本份文件從基礎的色彩、文字、字體開始，並提供完整的按鈕、表單、卡片的常見網頁元件，還提供大範圍的區塊元素如：頁腳、價格表、結帳頁面、資訊陳列區塊。幾乎可以算是設計軟體版本的 Bootstrap，非常值得參考。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FBEEC2927-AB3E-4257-938E-38889D4437E8.png?alt=media&amp;token=a40469b4-d146-455a-9cbd-939042c30d32" alt=""></p>
<p>雖然本分設計稿是以單色呈現，但是設想了許多情境非常值得參考，以下方到表單來說就包含未填寫、填寫中、離開 focus、錯誤提示等等，而這也是我們設計表單時經常會忽略的部分。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F20F7ED75-A67B-4E1D-8AB4-56657F30328C.png?alt=media&amp;token=0f513dab-d88e-4334-ba03-a9ccecfc04ce" alt=""></p>
<p>在這份設計文件中，同樣的目標會提供數種排列風格做變化，以價格表來說就提供了十種變化，下圖節選四種。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F84279B6E-6F1B-4961-93A6-FF2AD367546C.png?alt=media&amp;token=8fa2dc41-6698-4b44-94fd-4144255cf2ac" alt=""></p>
<h2 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h2><p>當然，最完整的設計規範還是可以參考前方不斷提到的 Material Design，不僅在應用上有完整說明，還有包含完整的設計理念，有機會可以將整份閱讀一次，對於設計規範會有很多的靈感及想法。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2F783F238E-5E8B-4BB3-9593-8E6A56A84C3D.png?alt=media&amp;token=f387b260-496b-4c58-a680-5f7457df1873" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>進入一個新領域時難以在短時間內就掌握所有細節，最好的方式是透過最佳範例來了解該如何運作，如 Bootstrap、Adobe XD UI Kits 都是很棒的案例，這些都具備了前人實作的經驗，並經歷上千、萬人的驗證。參考這些方式會比閉門造車有更好結果，並且增加設計規範的可行性、延展性及<br>穩定性。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 版面視覺動線配置(2)]]></title>
      <url>https://wcc723.github.io/design/2018/11/03/weblayout-2/</url>
      <content type="html"><![CDATA[<p>上一篇介紹了版面配置的概念，其中最重要的是「群組」概念，而本篇就透過實際案例來說明各大網站如何運用這些概念，並且看看是否也有運用到交錯、韻律的手法。</p>
<p>這些概念要特別注意僅適合用在「登入頁」（Landing Page），適合用在產品、服務推廣使用，當然也就不適合套用在應用程式的服務上（如：Facebook、Youtube、Google…）。</p>
<p>首先還是要強調從這些網站中是否可以觀察到「群組」概念，並且觀察是否有相關延伸的概念：</p>
<ul>
<li>群組交錯色彩</li>
<li>左右韻律排版</li>
</ul>
<h2 id="範例網站介紹"><a href="#範例網站介紹" class="headerlink" title="範例網站介紹"></a>範例網站介紹</h2><p>以 Adobe 來說，就是標準運用此概念的網站，群組與群組之間均有套用不同的色彩，並且具有一定的左右韻律。</p>
<p><a href="https://www.adobe.com/tw/creativecloud.html">https://www.adobe.com/tw/creativecloud.html</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FBC5B270E-AFEF-4DC7-9763-34B2C00CAB76.png?alt=media&amp;token=4712710a-402b-4dbc-b1a3-7d9b6683387b" alt=""></p>
<p>Evernote 亦是如此，也是透過群組式的視覺感來做分組，並且加入些許淺灰、白底的方式來做分類，最重要的是會使用深綠底色來做最重要的行動呼籲（Header 及接近底部的區塊使用綠底，其它部分則不會運用）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FB2B7EE1E-DB1D-44EC-A2D8-E91B7AB63AF7.png?alt=media&amp;token=8823e61d-d6f7-4152-8df3-2cca101e3d54" alt=""></p>
<p>Slack 雖沒有左右的韻律式排版，但依然維持最關鍵的「群組」分類，並且也會使用色彩上的變化區分不同的群組，主色的運用也是回顧到先前色彩介紹的章節，僅運用在最重要的「行動呼籲」之中，畫面中僅有 GET STARTED 會使用主色彩（或主色背景），其餘部分用到的色彩僅有到點綴，並不如主色上的凸顯。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FA36E2444-605A-442B-ACD7-C0CC4F6E7441.png?alt=media&amp;token=c456564c-6494-4de6-95eb-3ccf72b5682d" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本篇是延續上篇繼續介紹排版的技巧，讓一些非本科系的開發者，也能掌握一些基礎概念，排出具有基礎美感及正確的訊息傳遞方法。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 版面視覺動線配置(1)]]></title>
      <url>https://wcc723.github.io/design/2018/11/02/weblayout/</url>
      <content type="html"><![CDATA[<p>本篇主要是描述網頁「登入頁」（Landing Page），這個頁面是用戶一開始接觸的畫面，雖然這個頁面沒有固定的設計方法，但其實可以從各大網頁尋找到雷同的跡象，本篇就去除掉配色概念，單純就依據視覺動線來做說明。</p>
<h2 id="群組"><a href="#群組" class="headerlink" title="群組"></a>群組</h2><p>首先，我們還是要提到設計本質為「傳遞訊息」，視覺動線也就是引導用戶了解網頁所需要傳達的訊息，而網頁本身需要傳達的訊息非常多，通常難以用少量文字、話語呈現。就像是業務推廣產品時並不會只問一句：「你要買嗎？」，而是會用不同角度切入說明。</p>
<p>這麼多的訊息內容加到網頁中就容易造成混亂，因此可以使用「群組」的方式來分類訊息；而定義成群組的方法可以運用「相同的視覺感」來做分類，如以下提供幾單的幾種類別給予大家參考（實際上可以運用的當然更多）。</p>
<p>左文右圖的群組（或右圖左文）</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman16-1.png?alt=media&amp;token=0e16897a-39c5-4d55-b149-864deb698cd0" alt=""></p>
<p>三欄式上圖下文的群組</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman16-2.png?alt=media&amp;token=e7150a2f-839b-4d65-a8ea-0e54b1ef1210" alt=""></p>
<p>左右圖文連續排列的群組</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman16-3.png?alt=media&amp;token=607ed4d8-5924-4fef-8104-14dccb8c98ae" alt=""></p>
<p>在不同的排列方式後，自然就會讓人感受到內容上的差異，因此將這些不同的群組排列在畫面上可以得到以下的結果。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman16-4.png?alt=media&amp;token=1e7445cc-a386-4ac7-afdb-ac7956beb2be" alt=""></p>
<p>此時，群組 2 及群組 3 由於具有「類似的視覺感」，會容易被視為同一個群組，如果兩個群組之間的訊息沒有足夠的關聯性，當缺乏連貫性就如同所謂的「跳躍性思考」，難以吸收前後文的訊息。</p>
<h2 id="交錯式排列"><a href="#交錯式排列" class="headerlink" title="交錯式排列"></a>交錯式排列</h2><p>此時，我們也可透過顏色交錯的方式，將內容以群組的方式隔離，範例如下，群組 1 及 群組 3 是使用白底深色圖文，而群組 2 則是使用深色底、淺色圖文，透過此方式將內容隔離開來。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman16-4%20%E2%80%93%201.png?alt=media&amp;token=6c7025ec-7fb6-4b3b-94c7-ee11d650faad" alt=""></p>
<p>這種方式不僅可以增加畫面豐富度及有效群組話訊息，亦可強化品牌色彩。範例中的 群組 2 是使用深色背景搭配淺色文字，實作中也可以使用淺色背景搭配深色字（其它維持白底），僅需要與其它樣式有所區隔即可。</p>
<h2 id="閱讀動向"><a href="#閱讀動向" class="headerlink" title="閱讀動向"></a>閱讀動向</h2><p>除了群組化，由於現在訊息量不斷地膨脹，人們會不斷增加自己的閱讀速度，因此閱讀時會增快由上而下的速度，並且不斷地左右交錯。因此也可以將此慣性加入畫面中，除了增加閱讀性外，也同時讓畫面更有「韻律感」。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2Fironman16-4%20%E2%80%93%202.png?alt=media&amp;token=0b6ea63c-5e0f-469c-8f23-ca2d78ad90f9" alt=""></p>
<p>如上圖，我們不僅使用「具有底色」及「無底色」的交錯方式，並且重新調整排版為左右交互的韻律方式，藉此增加圖文的閱讀性。</p>
<p>而網頁中也可以適時的透過少量內容（群組 2 及 群組  3 之間）來凸顯部分訊息，這類訊息通常簡短並具與行動呼籲性（call to action）。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 響應式圖片選用技巧]]></title>
      <url>https://wcc723.github.io/design/2018/11/01/responsive-images/</url>
      <content type="html"><![CDATA[<p>網站上總需要圖片來點綴，除了客戶提供解析度不足的圖片外，我們也看從許多素材網站找到不錯的圖片，而選用圖片除了找到合適主題外，也需要花不少時間來比對是否合適於網站。</p>
<p>本篇依據 CSS 的觀念來提供一些選用圖片的技巧，藉此來減少 25% 搜尋素材的時間。</p>
<h2 id="技術限制"><a href="#技術限制" class="headerlink" title="技術限制"></a>技術限制</h2><p>響應式圖片運用上與技術限制有很大的關係，其中有兩個要點是必須要注意的：</p>
<ul>
<li>CSS 呈現圖片的方法</li>
<li>裝置尺寸變化</li>
</ul>
<h3 id="CSS-呈現圖片的方法"><a href="#CSS-呈現圖片的方法" class="headerlink" title="CSS 呈現圖片的方法"></a>CSS 呈現圖片的方法</h3><p>以下圖來說是一張原始比例的圖片，長寬比約為 960:640，在 CSS 中如果需要限制為正方形的尺寸，常見手法是運用 background-size: cover 或 contain 的方式。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%203.png?alt=media&amp;token=2f59e0bd-c999-4fa8-abc1-f2fb13746f95" alt=""></p>
<p>以下兩張圖片則是使用這兩種屬性，而前者是使用 <code>cover</code>，後者則是運用 <code>contain</code>(灰色為背景色彩)，運用上更是 <code>cover</code> 被許多設計師、開發者使用，這種方式盡可能在有限空間中呈現最多畫面。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%204.png?alt=media&amp;token=2219f0b2-46e1-45f7-924d-0338b09c7bae" alt=""></p>
<p><code>contain</code>：在有限空間中呈現完整圖片，畫面中的灰色部分則是背景。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%205.png?alt=media&amp;token=00d7f6de-a3c4-4dba-b93f-f39dabad4fff" alt=""><br>圖片來源：<a href="https://unsplash.com">https://unsplash.com</a></p>
<h3 id="裝置寬度"><a href="#裝置寬度" class="headerlink" title="裝置寬度"></a>裝置寬度</h3><p>由於圖片顯示區域會受到裝置寬度的影響，我們將上述的圖片分別放置在不同的尺寸上呈現，會得到如下的結果。</p>
<p><code>960 * 450</code> 桌面版畫面：由於這張圖片的配置是屬於水平，且 <strong>主體</strong> 僅有佔少量空間，在橫向畫面上呈現沒有什麼問題。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%201.png?alt=media&amp;token=b8821ced-720d-489d-9fae-8d2d716de395" alt=""></p>
<p><code>360 * 450</code> 行動版畫面：雖然畫面偏向水平，但由於 <strong>主體</strong> 只有一張椅子，畫面縮小後椅子只要能完整呈現，依然沒有什麼問題。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%202.png?alt=media&amp;token=a94d733e-e618-4276-8494-e76bd3e62679" alt=""></p>
<p>接下來，我們選用另一張圖片來做介紹：</p>
<p><code>960 * 450</code> 桌面版畫面：畫面中沙發是主體，完整地在畫面中間，在桌面版沒有什麼問題。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%206.png?alt=media&amp;token=caf2217d-65c6-48e3-b786-f01b6cbf7749" alt=""></p>
<p><code>360 * 450</code> 行動版畫面：但由於 <strong>主體</strong> 是橫式的，在行動版的垂直小空間中就顯得明顯不足，這樣導致了畫面左右方被裁切掉，這樣的圖片就不太合適。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%207.png?alt=media&amp;token=c9856831-98aa-46ea-bc63-51129e0e2865" alt=""></p>
<h2 id="快速驗證方法"><a href="#快速驗證方法" class="headerlink" title="快速驗證方法"></a>快速驗證方法</h2><p>CSS background cover 方式會盡可能的呈現完整圖片，而呈現的空間是可以再透過 x, y 軸線做定位上的為條（通常預設為中間或固定的四個邊角）。</p>
<p>接下來可以先透過繪圖軟體準備好裁切空間，上面包含了桌面版空間及行動版空間，兩個空間的交疊處則是安全區域。</p>
<ul>
<li>主體必須比重疊安全區域還要小</li>
<li>桌面版空間可以水平呈現</li>
</ul>
<p>如下圖，既可以呈現完整畫面，也同時可以測試重疊區域是否有足夠空間。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%20%EF%BC%91%EF%BC%90.png?alt=media&amp;token=7480df17-3e1b-4c71-8e66-f139525102cc" alt=""></p>
<p>接下來把裁切區域套用在畫面上即可得到以下結果。<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201811%2FArtboard%20%E2%80%93%208.png?alt=media&amp;token=dce4aafe-67c3-4330-97f4-7f3168b9c602" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>視覺也有不同的邏輯，而這個邏輯並非能用程式邏輯完整的解釋，本篇直接透過實際的案例解釋圖片選擇方式，讓大家在選圖上可以節省一些時間。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - Icon fonts 的常見資源]]></title>
      <url>https://wcc723.github.io/design/2018/10/31/icon-fonts/</url>
      <content type="html"><![CDATA[<p>網站開發加入一些圖示點綴，除了可以增加網頁的豐富度外，同時可以讓用戶從圖示中了解當下的行為為何。過去圖示大多使用 png 來呈現，具有豐富的色彩及尺寸，但隨著設計的概念不斷調整，現在流行單色系的小圖示，以及為了增加圖示可運用性目前大多使用向量的方式呈現。</p>
<p>接續前文所介紹，SVG 是可縮放的向量圖形，作為圖示運用有一定的優勢，本篇會介紹如何取用向量圖示資源，以及 icon fonts 的運用方法。</p>
<h2 id="什麼是-icon-fonts"><a href="#什麼是-icon-fonts" class="headerlink" title="什麼是 icon fonts"></a>什麼是 icon fonts</h2><p>Icon 是圖示，fonts 是字體，兩者混在一起就是圖示字體（被揍</p>
<p>簡單來說，我們平常使用的字體會有外觀上的不同，而 icon fonts 就是使用圖示修改掉特定的字體符號，讓他顯示成不同的圖形。如下圖所示，icon fonts 本質就是字體，也能夠像其它字體一樣安裝於系統中。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FF6A8B31C-7EFD-4CEE-B050-DDC3687B1739.png?alt=media&amp;token=d2511796-1fa7-4680-993c-8e09b6b88192" alt=""></p>
<p>實際運用在網頁上時，除了圖形顯示外也同時具備文字的特性，如：可縮放、可改變色彩、可套用文字陰影，且只要載入 CSS 即可運作。技術上來說，大多是透過 <strong>修改字體</strong> 並從偽元素插入特定的 Unicode 的編碼文字來套用圖示，但也有部分的 Web fonts 是採用其它的渲染技巧。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_10_18_%E4%B8%8B%E5%8D%884_48.png?alt=media&amp;token=673d06d0-5735-4060-af93-304a0c71b043" alt=""></p>
<p>接下來就能如圖中一樣的顯示這個 icon，並且這個 icon 依然具有文字的特性，可參考：<a href="https://fontawesome.com/v4.7.0/icon/address-book">https://fontawesome.com/v4.7.0/icon/address-book</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FD077F7D7-057A-4828-B92D-A5188AB54609.png?alt=media&amp;token=3c7b1539-cd73-409d-9cd0-23efa3df47d8" alt=""></p>
<h2 id="Fontawesome"><a href="#Fontawesome" class="headerlink" title="Fontawesome"></a>Fontawesome</h2><p>Fontawesome 是目前使用相當廣泛的 icon fonts，目前版本為 5.4.x 版，而除了 icon fonts 以外，現在更有 SVG 動態插入的方式。</p>
<p>5.x 版本：<a href="https://fontawesome.com/">https://fontawesome.com/</a><br>4.x 版本：<a href="https://fontawesome.com/v4.7.0/">https://fontawesome.com/v4.7.0/</a></p>
<p>如果要使用 Fontawesome 的圖示做設計，可以直接點選 For the Desktop 下載圖示，下載後就包含大量的圖示 SVG 可以直接運用。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F09084698-A999-47B7-B5F9-3B7FD9431C03.png?alt=media&amp;token=ae082dfb-b63c-4067-92fb-fb28c39ca783" alt=""></p>
<p>因為有數千組圖示可以運用，下載後難以從字面上直接了解圖示外觀，建議使用時可以搭配官方的 <a href="https://fontawesome.com/icons">圖示列表</a> 來快速搜尋，開發者也能夠從中快速了解設計師所用的 icon 為何。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F4099AE55-4E4B-44C8-8876-B727CE2C29B8.png?alt=media&amp;token=ac4f6a4b-a097-4291-99ac-476e6264d23e" alt=""></p>
<p>Fontawesome 的圖示也有分為免費與付費版，所能套用的 Web fonts 也有所不同，設計師使用時要特別注意，不過也不得不說，雖然付費版僅是粗細上的不同，但付費版的 icon 還是好看許多 :D。</p>
<h3 id="給予開發者的說明"><a href="#給予開發者的說明" class="headerlink" title="給予開發者的說明"></a>給予開發者的說明</h3><p>雖然 fontawesome 提供兩種方式運用在 icon 上，一則是本文重點 icon fonts，另一種則是透過 js 來插入 SVG。<br>如果你需要使用 fontawesome 做開發建議使用 icon fonts 的方式載入，如果想改用 SVG 的方式，可能會有動態切換上的問題，建議先讀過官方文件是否有合適的解決方案，並且實際測試後沒有問題再使用。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F4A403E89-2D56-4A2D-BFF9-42F3E31E538E.png?alt=media&amp;token=9b58922f-2aeb-437a-a231-2003171a81aa" alt=""></p>
<h2 id="Google-Fonts"><a href="#Google-Fonts" class="headerlink" title="Google Fonts"></a>Google Fonts</h2><p><a href="https://material.io/tools/icons/">https://material.io/tools/icons/</a></p>
<p>Material Design Icon 也是一種字體 icon，也與 Fontawesome 一樣具有大量的 icon 及搜尋功能，並且是完全免費，但比較特別的是使用「連字方法」來做 icon 的呈現。</p>
<blockquote>
<p>連字方法(uses a typographic feature called ligatures)：<a href="https://google.github.io/material-design-icons/#using-the-icons-in-html">https://google.github.io/material-design-icons/#using-the-icons-in-html</a></p>
</blockquote>
<p>連字方法的特色在於 Icon 本身依然具有「詞彙意義」，它是透過一個單詞的判別轉為一個圖形，如下圖 icon 除了呈現一個臉以外還具有「face」的辭意，並且可以透過搜尋方式找到這個圖形。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F7D77B951-194F-4EAA-9A5B-E0A48BB165A6.png?alt=media&amp;token=c6781772-3d7d-49ef-910e-929ff521f792" alt=""></p>
<h2 id="自製-Web-fonts"><a href="#自製-Web-fonts" class="headerlink" title="自製 Web fonts"></a>自製 Web fonts</h2><p>雖然上述服務已經提供大量的 icon，但設計中有時還是有不夠用的時候，自行開發 icon 也是個選項，以下我有撰寫過 svg 轉 web fonts icon 的方法，給大家參考看看：</p>
<p>自行開發的方法：<a href="https://wcc723.github.io/css/2016/12/13/gulp-dev-env/">https://wcc723.github.io/css/2016/12/13/gulp-dev-env/</a></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>Web icon fonts 現在網頁開發已很常見的手法，主要原因是只要一個 className 就能輕鬆運用，當然現在也有 svg icon 的運用方法，但相對於 web icon fonts 來說還沒那麼流行。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - SVG 輸出注意事項]]></title>
      <url>https://wcc723.github.io/design/2018/10/30/image-svg/</url>
      <content type="html"><![CDATA[<p>向量工具、Adobe XD、Sketch 也都能夠輸出 SVG 圖片，但在輸出時有些小地方也需要注意一下，避免在本地端看似沒有問題，但用戶卻看到的卻與預期不同。</p>
<p>首先瞭解一下 SVG 本身其實是 XML 格式的檔案，這是一個類似 HTML 格式的結構標記，如果要繪製一個方形，則會使用 <code>&lt;rect&gt;</code> 的標籤，並定義他的座標、尺寸、填色樣式等等。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- SVG tag --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;120&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 矩行 tag --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rect</span> <span class="attr">x</span>=<span class="string">&quot;2&quot;</span> <span class="attr">y</span>=<span class="string">&quot;2&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span> <span class="attr">style</span>=<span class="string">&quot;stroke: #333; stroke-width: 3; fill: MediumTurquoise;&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下來就會出現如下的矩形。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F3DA8CB58-04FC-44B8-8F52-BBC29CB9C825.png?alt=media&amp;token=cfd7c256-1a92-4d1a-a2dd-ec12ed0760a8" alt=""></p>
<p>SVG 一些常見的圖形原始碼可以 <a href="https://wcc723.github.io/d3js/2014/10/02/Ironman-30-days-03/">參考</a>。所以 SVG 輸出後與其它的圖片有很大的不同，他依然是透過一些文字標記組成，再有了基本了解後，我們再透過這些觀念了解輸出的圖片為什麼可能出錯，以及怎麽從輸出後的原始碼發現錯誤。</p>
<h3 id="文字務必轉外框"><a href="#文字務必轉外框" class="headerlink" title="文字務必轉外框"></a>文字務必轉外框</h3><p>我們在印刷時，給予印刷廠檔案的文字都會外框筆畫，為的就是避免印刷廠沒有特定的字體，導致字體的顯示與預期並不同。</p>
<p>以下圖來說，「Sweetaste」有分為上方的外框字體，下方則是純文字。上方的輸出後會以 “路徑” 的方式來繪製，從圖中可以看到文字周圍都是點與線的結合；而下方的文字則是純文字，只有一條下底線表示而已。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FB70A169A-DDAE-43C5-AD2E-DB078CA6ADAC.png?alt=media&amp;token=68cc3688-a2bf-4250-91ee-37afaf7fa13e" alt=""></p>
<p>外框字體的原始碼如下，都是由 <code>path</code> 標示路徑組成（下述程式碼參考即考）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;cls-2&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M55.48,40.91H56A6.11,6.11,0,0,0,55.48,43c0,3.28,3.49,5,6.15,5,4.22,0,6.66-2.34,6.66-5.76a5.72,5.72,0,0,0-2.16-4.46l-2.55-2.34c-2.27-2-3.56-3.93-3.56-6.55,0-3.93,4.17-7,9.32-7,3.13,0,4.68,1.3,6.3,1.3a1.28,1.28,0,0,0,1.29-.94l.54.11L75,29.25h-.43a7.21,7.21,0,0,0,.32-2.13c0-3.31-3.2-4.71-5.54-4.71-3.17,0-5.51,1.76-5.51,4.42,0,2.24,1.3,3.64,2.74,4.94l3.2,2.88c1.73,1.54,3,3.09,3,5.79,0,4.07-4,8.06-10.9,8.06-4,0-5.15-1.47-7-1.47a1.43,1.43,0,0,0-1.37,1.15l-.51-.11Z&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">path</span> <span class="attr">class</span>=<span class="string">&quot;cls-2&quot;</span> <span class="attr">d</span>=<span class="string">&quot;M90.54,48.22A3.24,3.24,0,0,0,91,46.56a4.9,4.9,0,0,0-.64-2l-.94-2c-.22-.47-.43-.94-.61-1.41-.69.65-1.4,1.23-2.09,1.77l-1.8,1.47c-1.11.94-1.73,1.48-2.45,2.2a10.23,10.23,0,0,0-1.58,1.91l-.43-.25a3.34,3.34,0,0,0,.43-1.66,4.76,4.76,0,0,0-.65-2l-.93-2a8.76,8.76,0,0,1-1-3.35c0-2.52,1.88-4.75,4.4-6.77l.72-.57.32.39a5.58,5.58,0,0,0-2.12,4.5c0,1.62,1,4,1.8,5.62a5.76,5.76,0,0,1,.68,2c3.49-2.84,4.75-4.79,4.75-7,0-1.47-.83-2.05-.83-3.49a1.86,1.86,0,0,1,2-1.8,1.92,1.92,0,0,1,1.83,1.12l.94-.8.72-.57.32.39a5.58,5.58,0,0,0-2.12,4.5c0,1.62,1,4,1.8,5.62a5.56,5.56,0,0,1,.68,2c3.5-2.84,4.54-4.79,4.54-7,0-1.47-.83-2.05-.83-3.49a1.86,1.86,0,0,1,2-1.8c1.62,0,2.19,1.44,2.19,2.81,0,3.27-2.88,6-5.32,8L95,44.36c-1.12.94-1.73,1.48-2.45,2.2A10.35,10.35,0,0,0,91,48.47Z&quot;</span>/&gt;</span><span class="comment">&lt;!-- 省略 --&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>純文字的程式碼，僅有直接標示「Sweetaste」的文字，並透過 <code>cls-1</code> 來替換成特定字體，<strong>這個情況下如果用戶沒有該字體，那麼就僅會用系統字體顯示</strong>，所以請特別注意，盡可能外框所有字體。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">text</span> <span class="attr">class</span>=<span class="string">&quot;cls-1&quot;</span> <span class="attr">transform</span>=<span class="string">&quot;translate(54.65 130)&quot;</span>&gt;</span>Sweetaste<span class="tag">&lt;/<span class="name">text</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="注意輸出後的原始碼是否正確"><a href="#注意輸出後的原始碼是否正確" class="headerlink" title="注意輸出後的原始碼是否正確"></a>注意輸出後的原始碼是否正確</h3><p>先前不斷地說明使用工具的重要性，因為輸出原始碼時結果也會不同，如下原始碼是透過 Illustrator 所輸出，圖片是一個正方形，僅有透過 <code>.cls-1</code> 調整色彩。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">id</span>=<span class="string">&quot;圖層_1&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;圖層 1&quot;</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 73 73&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.cls-1</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">fill</span>: <span class="selector-id">#3f5d45</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>tester<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">rect</span> <span class="attr">class</span>=<span class="string">&quot;cls-1&quot;</span> <span class="attr">width</span>=<span class="string">&quot;73&quot;</span> <span class="attr">height</span>=<span class="string">&quot;73&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F896A6B79-2A8B-4266-8EFA-9C9EC9CE66B7.png?alt=media&amp;token=9100e8a0-5def-4607-9598-189a47fb768c" alt=""></p>
<p>接下來透過 Illustrator 加上陰影。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F8725EFED-1900-474A-9EE5-CCCA6C38DBD8.png?alt=media&amp;token=db3f0885-df0c-4838-9a9c-72378f684006" alt=""></p>
<p>然後再重新輸出一次，會出現 <code>data:image/png;base64....</code> 的 base64 原始碼，也就是說整個陰影都是透過 “點陣圖” 的方式來呈現，這會導致：</p>
<ul>
<li>SVG 檔案大小會增加不少</li>
<li>尚失向量圖的特性（縮放、再編輯等）</li>
</ul>
<p>SVG 檔案普遍來說都非常小，如果檔案有不正常的增大時（明顯比其他同類型檔案大數倍），那麼請透過文字編輯工具打開 SVG 檔案（注意 <code>image</code> 那行），確實了解檔案是否有問題。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">xmlns:xlink</span>=<span class="string">&quot;http://www.w3.org/1999/xlink&quot;</span> <span class="attr">viewBox</span>=<span class="string">&quot;0 0 73 73&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">defs</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">      <span class="selector-class">.cls-1</span> &#123;</span></span><br><span class="line">        isolation: isolate;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cls-2</span> &#123;</span></span><br><span class="line">        mix-blend-mode: darken;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cls-3</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">opacity</span>: 0<span class="selector-class">.75</span>;</span></span><br><span class="line">        mix-blend-mode: multiply;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">      <span class="selector-class">.cls-4</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">fill</span>: <span class="selector-id">#3f5d45</span>;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">defs</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>tester<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">&quot;cls-1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">g</span> <span class="attr">id</span>=<span class="string">&quot;圖層_1&quot;</span> <span class="attr">data-name</span>=<span class="string">&quot;圖層 1&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">g</span> <span class="attr">class</span>=<span class="string">&quot;cls-2&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">image</span> <span class="attr">class</span>=<span class="string">&quot;cls-3&quot;</span> <span class="attr">width</span>=<span class="string">&quot;103&quot;</span> <span class="attr">height</span>=<span class="string">&quot;103&quot;</span> <span class="attr">transform</span>=<span class="string">&quot;translate(-8 -8)&quot;</span> <span class="attr">xlink:href</span>=<span class="string">&quot;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGcAAABnCAYAAAAdQVz5AAAACXBIWXMAAAsSAAALEgHS3X78AAAHIUlEQVR4Xu2dW5ebOBCEC49zmczu//+jm8wd9gGXKcotJM+QRGDVOX2EMdiiP6ol/GB1wzCgqU4dcgc0/T0dcwfk1HVdlzvmVjV8six1156fgdFAAcmEXgurGE4ARV9HUG4JVJRE3Td7vxRSERwBk2t9W7UnWKmkRUDCtgTQ4phjbukwh9El9kFa396bUjB820EMzO0SpCSchFs0DontCFD0esu6SLa0jD6xPTuv67ouBSg3W9NEH4LWwwHuEVAExqO36GS/ttwfKoQTlLMIxJ3EEij9nL3Iy1kEpAfwLkFI/ek8AkLKPRdwrJw5GAVyPMWdtA4qVeL2IC1lEZA3ad9kv4qgwvKWKmtemhTMEcAXiaO0hLR3QEtgCONV2sOp9c/QnCw7J/Eso645AviKEcZXAN/s9VEiGof2omh8eZN4wQjjBXGJ9zEKwGV5u9Y5dMt3jGDYMhQQneaftXV5YrWMEczzKfQm1XN1osCc5McczMuQu0Ydc2/x/fQenaQd0/JGbQmUJ87LGcvXyymeADxiujmB+Uytl9eMDvY9Jc5xOHTMPYAHAD8kFFDKPVtXyjUK5gumsZfnLM3gLsAAAicx3igcHXPonB8A/jnFD0wO+oapg4TDjm4ZEBPIu55JfsVYxp4w3Zi8Xp0ovGI+q724YXXcSZU1nqBlSWdpDudfjC56wARH3RN1ZEuQ9K7WcUNdQzi8KSHHsOR9OW1zBnc4vR+6Z+kXAnWOz9ZY2ljOHjAB0vLmU+stjjtL443CIRg6Rt3yLOH5SObA4fidHY07BPQV87HnAaOL6B6fGKTGnZoBRWDUOToRUDC97H/E5Sw2lY+Ze5YmBGwj9zgguojOucc07kTPPFuVT4XVGQ7mO9JgPBdhTnJlja2PPT6tZpmjkzgxuBU4DuYJ8wd05kzzuAgGSE8IdNvd4w4iJIY+nOrMZa9wHIw/67ljikoasOwcKgJ0J62DYmgHk1PHjclnaryWHvPfGnnNmqclMKFKyprvU1B3FsdE7BFOJ/v8WjVyQK4qaylpjSScqOR5+Vt86NqYCEfBvCO+9ihPwBXXn4LjH+Rg3EHepuLqDlYkQhnkdXR93npgoZ2pxDnRiSXQUqHnbVW5ayxJfjYHJXBy0i/JdTY6vnbRKZ1tX3OdH9IacEoV3VFbEPvqY81v1yF3wIJWvUt2plVy8xk4rtJOlB5Xm0r7XXpcVmvCAVbs2Ea16vWvDadpRTU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1OxGpyK1eBUrAanYjU4FavBqVgNTsVqcCpWg1Ox1obzR/7ZomKtev1rwintWOlxtam036XHZfUZONqJ1Tq0E62Smz/5x0Spf1+qXZ7oDyf7Wq0BJ+p8FH/t35dWUul1Rsd/SCVwoi8ZgrYktqyPXKu3qmw+UnBSHx51og9aD/2fNS1rW5NecxRRPkqghfkocQ7lgHrbjkL/3nfA5b/5bU16vbrMSgqU5wnSZrUEJ/oQd8y7xZuFgjlgf3D8enXhPIXnzlElYZU4x4GwYwpHF5HTJUh4Pv/ed09weszXZ2M4JM1XDtRMERw9KQLjd40uh8V1ZAimx/7/Lp9rFzxjngcHFZU8z/VMJWXNwTgUrgvj68f0uJ2FJp4xrvjxhAkUYSkkBwQEUKiS2ZqXM36RrlEWgXnFba2f8wTgJ4BfmHLCHEUOUueEgBzOgPkgrh1JgeGCEg7mFlee+oUR0E9MTkoBypa2XFlLdUTLGAEAExhdWO7W1mwjnF+YXMQSt+SeC6UmBDzBxxrOSFhjmXhg/FKuuHTLqx0+YoTy36l9PL2nsznNKz/3AtIZzjAMgy1H6XeI3iXqCGCC52uUKZytTwYoLUeeFy1vDMJR53hpmz68YPnj1HijSygy0Xz/FROYtsLumAsGSxudU/Jwmixr/P2rP20TDpPsD5i0dVubev54wVLn02ofdyDtWddMpQlBHaPljAtlM/zZZg9gKK8szIMC0udAvn5F7Jq8cxLjjrpH9/M9Ps8QTrR4HLA/OGy1vPkvJzqJWnLN+GEy3gB553C7x1zqpjuMX6zLf+0ZDLUEiJAU1rvE9c4BZu7hCSkwDueASzBbfa7JyW9eB+Sg3hPvn8G4awCgC/aNb4yA9M4/BG0KSGqc2QMgT5g7IAVqCFpg5FLmHNOAy5lbtC8a+PcIhooAsVVA0fbZLdKGSjoHOLvn/BLzxEcwIjB7guLS5Dkg3Y72jS8WACzCOR80Qcq1vq3aE6RU0lKwLtolKFQRHODCRUAeyJ5g5BQlMQI1vihMejEcKoA0e3vhvVtRMqGlUKir4bgysG5a18JwfRpO0+/TAU3V6n9/TR8I3kWSrAAAAABJRU5ErkJggg==&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rect</span> <span class="attr">class</span>=<span class="string">&quot;cls-4&quot;</span> <span class="attr">width</span>=<span class="string">&quot;73&quot;</span> <span class="attr">height</span>=<span class="string">&quot;73&quot;</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">g</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>先前就有聽過 <code>svg</code> 輸出時檔案居然要數 mb，仔細一問才發現是 Illustrator 輸出帶有了漸層、濾鏡等效果（目前版本漸層不會出錯，但濾鏡、陰影還是會有問題），如果 svg 輸出時發生這樣的問題時，會建議直接改用 png 不要使用有問題的 svg，因為已經失去 svg 原有的特色（檔案小、無縮放限制等）。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 圖片壓縮方法]]></title>
      <url>https://wcc723.github.io/design/2018/10/29/image-opti/</url>
      <content type="html"><![CDATA[<p>了解基本的格式後，接下來設計師還需要「正確的」輸出圖片並壓縮，網頁上輸出圖片雖然沒有印刷中那麼複雜，但依然有許多眉角需要注意，像是用什麼工具壓縮就很常被詢問到，本篇介紹我再壓縮上常用的一些技巧。</p>
<h2 id="工具輸出"><a href="#工具輸出" class="headerlink" title="工具輸出"></a>工具輸出</h2><p>繪圖軟體均可輸出圖片（廢話），在此還是比較推薦使用 Sketch 或 Adobe XD，這兩套的圖片輸出功能完整，且可以一鍵大量輸出所有設定的圖片及尺寸。</p>
<p>Sketch 可以直接設定好所有圖片（設定格式、尺寸比例、檔名、尺寸前綴詞…），並且一鍵輸出到特定資料夾。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FD708319C-A480-45CA-B048-66D9621F6CB6.png?alt=media&amp;token=45fbe214-0205-49b8-8d15-615b7ec44ed8" alt=""></p>
<p>Adobe XD 再輸出規範時，也可以提供所有圖片的下載連結，讓開發者選用後一次打包下載（Sketch 也有相同功能）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F887CC9A8-82D6-42EE-8EF4-D6C2BE20ADF6.png?alt=media&amp;token=4d32e4cf-a42d-4055-9633-bb4664422020" alt=""><br>設計稿參考： <a href="https://lihi.cc/LAfsC">https://lihi.cc/LAfsC</a> （請切換到 Download 頁面）</p>
<p>如果是使用 Photoshop、Illustrator 等平面繪圖軟體，當圖片數量多，且規格複雜時將會花去許多時間，且工程師拿到一堆圖片時，也難以對應檔案與位置上的關係。而 UI 繪圖軟體相對於傳統的平面繪圖軟體來說，它讓工程師更能了解每張圖片所在的位置、運用情境、多尺寸的選擇，設計師只需要做好合適的規範設定即可。</p>
<h2 id="圖片壓縮"><a href="#圖片壓縮" class="headerlink" title="圖片壓縮"></a>圖片壓縮</h2><p>當然，圖片輸出後檔案還能做最佳化壓縮，目前主流的繪圖軟體都無法有效的壓縮圖片，透過合適的工具壓縮可以在不破壞視覺品質的情況下，大幅降低圖片的尺寸（檔案尺寸可降低 30% ~ 50% 不等）。</p>
<h3 id="Tinypng"><a href="#Tinypng" class="headerlink" title="Tinypng"></a>Tinypng</h3><p>Tinypng: <a href="https://tinypng.com/">https://tinypng.com/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F6B0A7651-A844-49A2-9611-A74C99EEAFA5.png?alt=media&amp;token=bd8a815d-855c-4358-bb54-a5ce5cc107c9" alt=""></p>
<p>Tinypng 是直接上傳檔案後，該服務會自動在後端壓縮，並且打包壓縮後讓用戶下載。使用方法簡單，無需任何設定，缺點是必須 “上傳圖片” 才能壓縮，如果產品是需要隱密性，不得提前公開的將不適合使用。</p>
<p>不過他們也有提供 Photoshop 版本的擴充套件（我沒有使用過），可以花些費用購買工具將可以在本地端壓縮。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F0FB52C24-8B07-40ED-893B-DE756785744D.png?alt=media&amp;token=78a851ff-2910-42b7-a486-df2d1d0ec195" alt=""></p>
<h3 id="ImageOptim"><a href="#ImageOptim" class="headerlink" title="ImageOptim"></a>ImageOptim</h3><p>ImageOptim: <a href="https://imageoptim.com/mac">https://imageoptim.com/mac</a></p>
<p>這是目前使用的壓縮工具，優點是離線使用、大量壓縮、免費、簡單操作（也可調整壓縮比），但目前只有 Mac 版本，Windows 僅能使用他另外提供的 Web Service（與 Tinypng 相同）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F55D3F409-A47E-47FD-BCF9-50C5C6464741.png?alt=media&amp;token=da433f0f-db2f-427a-8366-3f37de35bcff" alt=""></p>
<p>且這個工具的壓縮能力相當不錯，如下圖我壓縮了一張 png 原始檔案尺寸為 2.4mb，壓縮後為 1.4mb，降低了 42.1% 約 1mb 左右。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FD4FEDA63-3CAF-47E6-8AFD-F0E0AFE77C85.png?alt=media&amp;token=77cc1601-9b2a-4ad2-9635-018a30c4dd0a" alt=""><br>而這個工具是本地端運行的，因此壓縮時會大量用去系統資源，如果電腦的效能沒有很好，建議不要在「工作時間」壓縮大量圖片，這可能會導致你暫時無法作業。</p>
<h3 id="gulp-自動化壓縮"><a href="#gulp-自動化壓縮" class="headerlink" title="gulp 自動化壓縮"></a>gulp 自動化壓縮</h3><p><a href="https://github.com/hexschool/gulp-demo">https://github.com/hexschool/gulp-demo</a></p>
<p>gulp 到目前為止還是很方便的工具，可以用來處理許多小雜事，這類型的工具只要把圖片放入，部署前輸入一鍵就會全部壓縮。壓縮的效果如下（原圖約為 742kb，壓縮後為 486kb）：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-29%20%E4%B8%8A%E5%8D%8811.06.14.png?alt=media&amp;token=f19c3fbb-e61b-41fb-8ff5-96d536f224df" alt=""></p>
<p>這個工具看似很方便，很適合工程師使用，但其實壓縮的品質不是很穩定，有些圖片加入後甚至不會做任何壓縮，相比較而言我還是傾向使用前面所介紹的那兩款。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>程式碼需要壓縮，而圖片當然也需要被壓縮，且圖片壓縮效益大幅超過程式碼壓縮，進而加速網頁瀏覽的速度。而設計師交付給與工程師圖片時，也可以討論這段流程因由誰負責（或由伺服器自動壓縮），並將此流程加入到開發與設計之中。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 圖片格式的運用]]></title>
      <url>https://wcc723.github.io/design/2018/10/28/image-format/</url>
      <content type="html"><![CDATA[<p>隨著裝置解析度越來越高，如果是以 1:1 的尺寸輸出圖示時，都會明顯地看到圖示邊緣出現鋸齒，這樣的情況下無疑是降低設計的品質，為了避免這樣問題，實作中通常會使用兩種方式來解決：</p>
<ol>
<li>輸出更高解析度的圖片</li>
<li>輸出向量圖片</li>
</ol>
<p>更高解析度需要多高？對於網路速度是否有影響？向量圖的使用情境及限制為何？本篇將依據這些概念介紹。</p>
<h2 id="格式選擇參考"><a href="#格式選擇參考" class="headerlink" title="格式選擇參考"></a>格式選擇參考</h2><p>網頁靜態圖片選擇主要有三種（還有另一種為 base64，這就不在我們討論範圍內）：</p>
<ul>
<li>jpg：是屬於破壞性的檔案壓縮方式，圖片可以大幅降低檔案尺寸，不過也會因此導致品質降低，壓縮的過程中可以依據需求調整壓縮比，藉此控制品質及檔案大小間的平衡。</li>
<li>png：壓縮比較低的圖片格式，相對於 JPG 來說圖片檔案會大不少，但影像品質也相對較佳，除了有更好影像外還同時具有「透明」的特性。</li>
<li>svg：向量的圖片格式，圖形定位皆是使用數學位置，且「沒有解析度」的限制，因此圖片無限放大都不會失真。另外 SVG 由於是一些文字標示而成，所以圖片尺寸普遍來說都很小。</li>
</ul>
<h3 id="使用情境"><a href="#使用情境" class="headerlink" title="使用情境"></a>使用情境</h3><h4 id="圖示、商標"><a href="#圖示、商標" class="headerlink" title="圖示、商標"></a>圖示、商標</h4><p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F49591BFC-18AD-4195-8D8C-E581DA967837.png?alt=media&amp;token=d5f80c34-eb6b-4d12-a651-f73bb07d373b" alt=""></p>
<blockquote>
<p>SVG：可縮放向量圖形，圖片來源：<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%B8%AE%E6%94%BE%E5%90%91%E9%87%8F%E5%9C%96%E5%BD%A2">wiki</a></p>
</blockquote>
<p>由於商標會使用在許多情境，如網頁頁首、頁尾以及行動版等，在不同的尺寸變化下依然要維持高品質的清晰度來維持形象，過去大多都是使用 png 的縮放調整，但在目前的裝置解析度不斷提高的情況下，使用 svg 替代 png 是相對更好的解決方案。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F27DF021C-E955-4E8D-A4EB-16AF22CEC26C.png?alt=media&amp;token=79e400b9-8c1c-414b-8047-c8b1f7b862ba" alt=""></p>
<blockquote>
<p>範例網站：甜點電商的上方 Logo 就是使用 SVG 來呈現</p>
</blockquote>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FD59CECDC-D8AD-416C-A20F-D490E2B853D9.png?alt=media&amp;token=b27f8a04-7faa-4d6e-8674-767abb44309e" alt=""></p>
<blockquote>
<p>目前大多網站均是使用 svg 作為商標顯示的格式。圖中為 <a href="https://sketchapp.com/">Sketch 網站</a></p>
</blockquote>
<p>除了商標外，另一個很常使用 svg 格式則為圖示（icon），過去圖示也是同樣使用 png，但在高解析度的裝置下來說卻顯得不足。使用 svg 替代主要原因在於 icon：</p>
<ul>
<li>圖形單純 - 不會混用真實圖案</li>
<li>高辨識性 - 需要高解析度</li>
<li>大量使用 - 檔案要小</li>
<li>需要可編輯性 - 依據情境重新賦予色彩</li>
</ul>
<p>在 Github 的網站中就可以看到大部分圖示均是使用 svg，且可依據情境重新調整色彩。如下圖選擇的 “Code” 選項的 icon 接近黑色，旁邊的 “Issue” 則是顯示淡灰色。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F1270BD49-B266-44C7-B47B-4F2FF5054C95.png?alt=media&amp;token=5a5040ce-3319-4d34-93eb-026d0bf8543f" alt=""></p>
<p>在 Github 中的網站是透過前端工具處理，讓 svg 圖形的引用更為容易，但實戰中 svg 圖形在管理上是有些門檻的，下一個章節會介紹使用 icon fonts 來處理 svg 在圖示上的應用方法。</p>
<h2 id="主要圖片"><a href="#主要圖片" class="headerlink" title="主要圖片"></a>主要圖片</h2><p>好的圖片能夠增加網站的豐富度，也同時能夠增加訊息傳的效益，現在鮮少有網站是不透過任何圖片來傳達訊息。舉凡是 頁首大圖、商品圖片、輪播、說明圖片等等，這些都是為了增加訊息傳達效益的圖片，會建議使用 png 來作為顯示的格式，主要是 png 具有以下的特性：</p>
<ul>
<li>高品質 - 確保顯示的品質</li>
<li>點陣 - 增加畫面的真實性</li>
<li>透明特性 - 可採用堆疊的方式呈現</li>
</ul>
<p>如下圖，為了確保圖片品質及精緻甜點的口感，png 是不錯的選擇。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F79389AC5-DF50-472E-B6BB-EB66043DED43.png?alt=media&amp;token=7d10d305-1d5d-4ad5-a23b-e9483232ae33" alt=""></p>
<p>主要圖片除了有良好的呈現外，必要時還需要兼顧不同裝置的「顯示清晰度」，如一般的螢幕的 PPI 約落在 100 上下（<a href="https://zh.wikipedia.org/wiki/%E6%AF%8F%E8%8B%B1%E5%AF%B8%E5%83%8F%E7%B4%A0">PPI 說明</a>），但到了部分裝置的 PPI 就會達到 320 甚至更高的 PPI（如 Apple 的 Retina Display），此時就會建議使用「雙倍」以上的尺寸做輸出。</p>
<p>以 Sketch 為例，當輸出一張長寬為 <code>1200 * 628</code> 圖片時，如果調整為 2 倍尺寸則會輸出一張 <code>2400 * 1256</code> 的圖片。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F5EFA0D4C-D135-434F-A469-B633500148D3.png?alt=media&amp;token=b35e39f5-21b4-4f5a-9ac2-c531c5cfd200" alt=""></p>
<p>此時也要特別注意，圖片的檔案大小將可能<strong>成長為四倍</strong>，如一張 700kb 的圖片輸出成 2 倍尺寸大小時，檔案可能成長為 2.4mb。因此實際運用時會建議隨需求調整圖片輸出的大小，設計師部分可以規劃不同尺寸的輸出，而前端在此就需要依據需求調整運用的倍數。</p>
<p>使用 png 例外情況：</p>
<ol>
<li>圖片過多，需要兼顧網路速度時還是會建議轉用 jpg</li>
<li>圖片是人工繪製，向量是更好的選項時會建議使用 svg</li>
</ol>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FE8715E4D-6EE5-4B3D-9055-7C287F7EBC7B.png?alt=media&amp;token=90f4993b-f642-4789-a696-2de3aec64e28" alt=""></p>
<blockquote>
<p>手繪向量圖片 svg 依然是好選擇：圖片來源 <a href="https://github.com/">Github</a></p>
</blockquote>
<h2 id="背景圖"><a href="#背景圖" class="headerlink" title="背景圖"></a>背景圖</h2><p>另外，背景圖片的運用也是很重要的，相對於主要圖片來說背景圖片的重要性降低很多，如果畫面同時是使用真實景色的圖片，會更建議使用 jpg 來做呈現，藉此降低檔案的尺寸。</p>
<p>Yahoo 氣象的背景會使用當地的風景圖片，藉此來呈現符合情境的資訊，而這麼大張的圖片作為背景，如果使用 png 將會佔去不少流量，所以使用 jpg 將是一個好選項（原圖 1280 * 720，約 170kb）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FBCFE2854-5958-480E-9523-EC5E74D312DD.png?alt=media&amp;token=c1bb9200-6ab3-4b81-a160-db7f2bfa2686" alt=""></p>
<p>大多數來說，真實圖片的背景會使用 jpg 來呈現，這裡也介紹一個圖案類型的背景網站給大家參考，由於這個網站是使用「四方連續」的背景手法，這類型的圖片僅需要小小一張就能不斷重複使用，所以就直接使用 png 來維持背景圖的品質，網址：<a href="https://www.toptal.com/designers/subtlepatterns/">https://www.toptal.com/designers/subtlepatterns/</a></p>
<p>此網站的背景風格非常多，下載可同時選用 2 倍尺寸的圖案，網站的圖案都是可以免費使用，但請注意 <a href="https://www.toptal.com/designers/subtlepatterns/faq/">使用條款及 FAQ</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F738F3A7C-38E1-4FDC-A413-139F44C18A75.png?alt=media&amp;token=2a065df3-0168-4a8d-98a8-bb69fce465b1" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>現在工具輸出圖片也越來越方便，只要一鍵就可以大量輸出，因此設計師更需要了解各種圖片格式的差異，並且輸出符合需求的格式以便於工程師作為開發使用。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 文字大小、行高與空間上的關係]]></title>
      <url>https://wcc723.github.io/design/2018/10/27/fonts-family/</url>
      <content type="html"><![CDATA[<p>一般平面設計師再進入網頁環境時，會不清楚網頁設計所用的單位數值，造成設計稿與開發的畫面有嚴重的落差；且網頁設計本身有許多「慣用的數值」，建議一開始也能先使用大家通用的數值，待了解所有數值對於畫面、軟體、技術上等影響後再做調整。</p>
<h2 id="文字樣式屬性"><a href="#文字樣式屬性" class="headerlink" title="文字樣式屬性"></a>文字樣式屬性</h2><p>由於網頁並沒有像繪圖軟體那麼的自由，所以才會有許多文章提到「設計師需要學程式」，因為之中有許多技術限制需要設計師去理解，這會有助於設計執行上的可行性。</p>
<h3 id="文字單位"><a href="#文字單位" class="headerlink" title="文字單位"></a>文字單位</h3><p>文字分為絕對單位及相對單位，絕對單位與平面設計概念一致，基本上是設定多少，畫面呈現就是固定大小；而相對單位則是沒有固定大小，所設定的數值會受到外層、HTML 設定、裝置畫面大小等等而定，相對來說靈活很多，但在掌握上也困難許多。</p>
<p>絕對尺寸：</p>
<ul>
<li>px：最常使用的絕對單位，過去會使用略小的數值，目前是以預設的 16px 為主，請避免設定過小的字體導致閱讀上的困難。</li>
<li>pt：很少用到的數值，請不要用印刷的 “pt” 作為「螢幕顯示」時的單位（另一種 pt 為 iOS 上所定義的 pt，是接近於 CSS 上的 px，這段確實很容易搞混，請謹記不要使用印刷及 CSS 的 pt 單位即可）。</li>
</ul>
<p>相對尺寸：</p>
<ul>
<li>em：<code>1em</code> = 一個字體大小，是相對於父層的單位，所以當父層為 <code>32px</code> 時， <code>1em</code> 則為 <code>32px</code> 大，而這個數值可以不斷疊加。</li>
<li>rem：目前主流的單位尺寸，<code>1rem</code> = 一個字體大小，相對於 HTML 所定義的文字大小而定，可以在頁面呈現後調整設定值修改畫面的單位尺寸。</li>
<li>%：類似 em，使用上沒有太大差異，細節可<a href="https://kyleschaeffer.com/development/css-font-size-em-vs-px-vs-pt-vs/">參考</a>。</li>
<li>vw, vh：1vw = 瀏覽器的寬度，1vh = 瀏覽器的高度，比較常用在畫面上，但也是有機會用在文字上，如：Header 的主要文字。<blockquote>
<p>延伸介紹：<a href="https://www.hexschool.com/2016/01/02/2016-08-08-em-vs-rem/">實際展示 EM 與 REM 的差異</a></p>
</blockquote>
</li>
</ul>
<h3 id="文字尺寸"><a href="#文字尺寸" class="headerlink" title="文字尺寸"></a>文字尺寸</h3><p>目前來說，網頁開發大多都是使用 16px 作為基準字，雖然設計訓練中都習慣將文字縮寫以增加質感，但請別忽略網頁本質是為了傳達訊息，且小字在行動版上閱讀上更為困難，盡可能維持預設值來製作網頁設計。</p>
<p>由於 <code>rem</code> 的出現，我們不再需要行動版與桌面版完全統一相同的字體大小（雖然實作上還是同一為主）。設計時我們依然會以 <code>px</code> 為主，但為了配合開發上的方便，通常會使用固定級數的方式作為大小字的變換，範例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">設計師用的尺寸：   工程師所用的尺寸</span><br><span class="line">16px        :   1rem</span><br><span class="line">20px        :   1.25rem</span><br><span class="line">24px        :   1.5rem</span><br><span class="line">28px        :   1.75rem</span><br><span class="line">32px        :   2rem</span><br><span class="line">40px        :   2.5rem</span><br></pre></td></tr></table></figure>
<p>同理，如果將預設尺寸改為 15px，相關的數值也會重新調整（15px = 1rem,30px = 2rem…）。</p>
<h4 id="設計上注意事項"><a href="#設計上注意事項" class="headerlink" title="設計上注意事項"></a>設計上注意事項</h4><p>當如果使用 <code>rem</code> 為單位時且預設值為 16px 時，應避免出現 17px, 21px, 25px 這種尺寸造成轉換上的困擾（就算不使用 rem 也不該如此 :D），盡可能維持相同邏輯在執行網頁設計。</p>
<h3 id="行高"><a href="#行高" class="headerlink" title="行高"></a>行高</h3><p>平面設計中，我們習慣使用固定的數值，例如 12pt 的文字大小搭配 16pt 的行高，但在網頁設計中則習慣使用相對的倍數來呈現；如 line-height: 1.5 來代表 1.5 倍的行高，此時文字大小如果設定為 16px，那麼行高則為 24px。</p>
<p>並且行高的設定，通常會設置於網頁的 <code>body</code> 上，也就是全網站套用相同的預設行高，如果有例外再另外條整。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">如果 body 行高設定為 1.5</span><br><span class="line">其它文字大小的相對行高</span><br><span class="line">16px :   24px</span><br><span class="line">20px :   30px</span><br><span class="line">24px :   36px</span><br></pre></td></tr></table></figure>
<p>除此之外，行高的設計也會影響到「空間的顯示」，平面設計中的文字空間與其它圖文基本上是毫無關聯性的，但在網頁設計中除了設定成絕對定位，其餘物件的空間都會有彼此的關連性。</p>
<p>下方是行高 1.5 倍的文字段落，所佔用的區塊則使用橘色顯示，後方緊貼著一塊紫色方塊，這個方框並不會與文字產生空間上的交錯。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FDCFAF804-E52F-4560-94AB-BBC775DC2D39.png?alt=media&amp;token=b47371fc-c623-4a8b-a926-8ff265702059" alt=""></p>
<p>以下分別使用行高 0.6、1、1.5、3 再呈現一次，如果行高使用 0.6 的情況，文字會超出橘色的空間範圍，並且與紫色產生些微的交錯；而在行高 3 時文字距離橘色邊框距離增加許多，並且會將紫色方框推向後方。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F96456BBA-EE79-4AE3-ADA8-F5DD602001A4.png?alt=media&amp;token=ae831135-0792-4934-ad79-3a49ae004b01" alt=""></p>
<h4 id="設計上注意事項-1"><a href="#設計上注意事項-1" class="headerlink" title="設計上注意事項"></a>設計上注意事項</h4><p>因此在設計文字時，也要注意繪圖軟體所呈現的範圍，如下圖：當設計 line-height 為 3 倍時，繪圖軟體自然會使用正確的方框尺寸，此時應避免與其它元素產生交錯。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_10_13_%E4%B8%8B%E5%8D%883_57.png?alt=media&amp;token=8ef4e98d-5d96-4f29-9c64-d80bf5192291" alt=""></p>
<h4 id="另一個常見的錯誤習慣"><a href="#另一個常見的錯誤習慣" class="headerlink" title="另一個常見的錯誤習慣"></a>另一個常見的錯誤習慣</h4><p>因為行高會影響到文字呈現的空間，因此會有不少網頁設計師透過 line-height 來製作垂直置中。這會導致文字再多行時也會使用到錯誤的行高，並且會降低 CSS 的設計彈性，因此非常不建議使用 <code>line-height</code> 的數值製作垂直置中。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.vertical-align</span> &#123;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正確應使用 padding、flex 等方法來做垂直置中。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本篇的文字設定在畫面上很難找到問題，但會影響該設計師是否易於與工程師配合，所以追求美感的同時，依然要注意畫面的邏輯及可行性。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計 - 網路字體運用]]></title>
      <url>https://wcc723.github.io/design/2018/10/26/web-fonts/</url>
      <content type="html"><![CDATA[<p>字體如果沒有授權問題，是否能夠直接嵌入於網頁之中呢？（請注意：大部分中文字體都會有授權的問題）</p>
<p>當然是可以的，英文網站中許多都會使用自訂的字體，但中文字體可就沒有這麼容易。因為英文字體檔案小，直接寫入 CSS 即可運作，而中文字體動輒數十 MB，Noto Sans 整包甚至高達上百 MB，下載這些字體就會花去許多時間且非常消耗網路資源。</p>
<h3 id="英文網頁字體"><a href="#英文網頁字體" class="headerlink" title="英文網頁字體"></a>英文網頁字體</h3><p>英文字體運用上僅需要注意授權，而最大宗的免費字體就是 <a href="https://fonts.google.com/">Google Fonts</a>，包含襯線、無襯線、裝飾、等寬、手寫等等風格，而這些字體都有完整的預覽及字重選擇。</p>
<p>如果不是對於字體有極端要求者，這個網站已經可以滿足大部分的需求。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FDDACBFE9-652F-4BDA-97AF-8E02D50BE536.png?alt=media&amp;token=86b82c84-33d1-41a0-8308-70b1f1a5a8f8" alt=""></p>
<p>選用特定字體後，也能自行調整所需要的字重，避免一次載入過多的字體導致下載速度變慢。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FC1C57D0E-88DA-4169-8E8E-2DAC691BFC2C.png?alt=media&amp;token=93ef2958-5a9d-4bd1-8b7f-039e8c76fcd6" alt=""></p>
<h3 id="中文網頁字體"><a href="#中文網頁字體" class="headerlink" title="中文網頁字體"></a>中文網頁字體</h3><p>中文字的網頁字體就沒有那麼容易了，主要原因在於中文字太多導致檔案太大，另外就是中文字的廠商大多不會免費提供（畢竟字太多難以開發，很難免費授權），所以這些就要找專屬的線上字體供應商，如台灣知名的 <a href="https://dfo.dynacw.com.tw/">華康</a>、<a href="https://ifontcloud.com/index/index.jsp">文鼎</a> 到先前知名的金萱字體開發商 <a href="https://www.justfont.com/">Justfont</a> 都有提供這樣得服務。</p>
<p>這些服務是直接從網頁中透過 JavaScript 取得所用到的中文字體，再從伺服器重新下載這些字型，所以速度會比直接直接下載完整字體檔案快上非常多，但也因為如此這類型服務都需要另外付費才能使用。</p>
<p>另外Google 也有推出 <a href="https://fonts.google.com/earlyaccess">Early Access 的 Noto Sans</a>，在這之中也當然包含繁體中文的 Noto Sans。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-25%20%E4%B8%8A%E5%8D%8810.51.42.png?alt=media&amp;token=65dfb3a7-de70-4424-aa20-e0f56c10b99b" alt=""></p>
<p>這段也有看到 Google 不斷的在優化這段服務，最近一次測試 Noto Sans Regular（中等字重）的下載大小僅需要 1.8MB，實際體驗上速度也比先前快上許多，但畢竟是屬於測試中的服務，使用時還是多虛注意。</p>
<h2 id="網頁設計的注意事項"><a href="#網頁設計的注意事項" class="headerlink" title="網頁設計的注意事項"></a>網頁設計的注意事項</h2><p>因此，我們在設計網頁時盡可能使用系統預設的字體，系統預設字在網頁上都有經過優化，所以都有很好的閱讀性（大部分系統文字在 12px 都還有不錯的辨識性）。設計時也可以依據主要用戶群（桌面、行動版）、較多人使用的系統作為設計（如微軟的正黑體）。</p>
<p>尤其在中文的部分，未搭配任何 Web fonts 服務時應避免使用特殊的字體，多利用系統的字體來進行設計。有搭配 Web fonts 服務時可多將字體利用在標題上以維持文字的辨識性，如果用在內文，須確保在不同的系統上辨識性依然是足夠的，如其它明體在小字時就不一定比「新細明體」辨識性還高（可參考：<a href="https://www.justfont.com/fonts）。">https://www.justfont.com/fonts）。</a></p>
<p>思源明體在 16px 左右的狀態<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8A%E5%8D%8811.43.52.png?alt=media&amp;token=4654607b-caac-403c-8dee-dca36acf235f" alt=""></p>
<p>系統字體 16px<br><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-26%20%E4%B8%8A%E5%8D%8811.43.52.png?alt=media&amp;token=4654607b-caac-403c-8dee-dca36acf235f" alt=""></p>
<p>而在更小的字體上落差也會更為明顯，使用前可多利用該服務來做測試，並且選擇合適的字體運用。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：系統字體介紹]]></title>
      <url>https://wcc723.github.io/design/2018/10/25/fonts/</url>
      <content type="html"><![CDATA[<p>字體一直是設計師排版的關鍵之一，但由於網頁設計受到技術、法規、網路影響，在網頁上能夠使用的字體非常有限，本篇文章其實並非告訴大家怎麼使用字體才會「美」，而是了解字體運用上的「限制」，避免設計出執行上有困難或是效能極差的網頁。</p>
<h2 id="字體分類"><a href="#字體分類" class="headerlink" title="字體分類"></a>字體分類</h2><p>字體因為外觀的關係而有不同的名稱，如：黑體、明體、襯線、無襯線等字體，以上或許大家都有聽過名稱，但不清楚外型（如果熟悉可以跳下一段），這裡就來解釋這些字體的分類及常見用途吧。</p>
<ul>
<li><code>serif</code> 歐文襯線字體<ul>
<li>外觀：中文在末端會有凸起的裝飾線，英文則是在頭尾皆有額外的裝飾線</li>
<li>運用：帶有人文氣息，因此大多會運用在具有歷史、文學、文化的內容。</li>
</ul>
</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FC04A0817-9B02-4495-908B-1619ED4B006F.png?alt=media&amp;token=09dbe8fd-615b-42a7-9bc2-020d9c451d94" alt=""></p>
<ul>
<li><code>sans-serif</code> 歐文無襯線字體<ul>
<li>外觀：無論中英文皆沒有任何裝飾線</li>
<li>運用：較無個性，帶給人科技、現代、正式的感覺，使用上非常廣泛。</li>
</ul>
</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F6C7A417E-4FC3-4A90-B4BE-2E29F0340BD2.png?alt=media&amp;token=56c52fe9-eba6-4262-8ea2-7c03de140deb" alt=""></p>
<p>中文部分則是稱為黑體及明體，外觀上明體接近於「歐文襯線字體」；黑體則接近於「歐文無襯線字體」。這兩者有許多文件會視為同類別（如：黑體 == 歐文無襯線字體），但也有許多專業設計師會視為不同類別，在此特別說明。</p>
<p>而系統上也都有包含預設襯線與無襯線所預設的中英文字體，除了上述兩種外系統內還有 <code>cursive</code>、<code>fantasy</code>、<code>monospace</code>，但這些字體就並非有完全對應的中英文，實作上還是以襯線與無襯線兩種為主。</p>
<p>詳細文章：<a href="https://wcc723.github.io/css/2014/01/01/font-family/">https://wcc723.github.io/css/2014/01/01/font-family/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FC3277472-04FF-43F1-BFCE-E165BC19C96F.png?alt=media&amp;token=8e322a51-00ea-4e5e-8019-ab3dd3f2e10c" alt=""></p>
<h2 id="必要熟悉的系統字體"><a href="#必要熟悉的系統字體" class="headerlink" title="必要熟悉的系統字體"></a>必要熟悉的系統字體</h2><p>目前常見的系統包含 Windows、MacOS、iOS、Android、Linux…等（本篇不介紹 Linux 家族。），每一種都還包含了中英文、襯線、無襯線等等（本篇以無襯線為主），而這些系統字體大不相同，更不會有自定的字體出現。</p>
<h4 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h4><p>使用人數最多的桌面作業系統（80%），無論是熬夜打電動、做作業、寫程式、畫 3D 都有不錯表現，因此所使用的系統絕對需要熟記～。</p>
<ul>
<li>英文：在過去是使用 Arial，這款是仿造 Mac OS 的 Helvetica 字體所製作而成的，現在則是使用 <a href="https://zh.wikipedia.org/wiki/Segoe">Segoe UI</a>。</li>
<li>中文字體：微軟正黑體，相當經典的黑體字，缺點是只有單一字重，缺乏較粗或較細的字體。</li>
</ul>
<p>另外 Windows 系統預設的中文字體是「新細明體」，這款字體在單級數字級會有比較好的閱讀性（13px, 15px, 17px 字體顯示會較為銳利），但實作中還是以雙數字級（16px, 20px, 24px…）為主，使用上要特別注意。</p>
<h4 id="Mac-OS-iOS"><a href="#Mac-OS-iOS" class="headerlink" title="Mac OS / iOS"></a>Mac OS / iOS</h4><p>蘋果一直以來對於字體就非常要求，包含不同解析度、閱讀性、字重等等都很要求，現在的版本更提供專屬的中文字體，讓開發者、設計師、使用者都有很好的使用體驗。</p>
<ul>
<li>英文：過去是使用 Helvetica Neue 的經典字體，現在無論是 iOS 或 Mac OS 均是使用 <a href="https://github.com/supermarin/YosemiteSanFranciscoFont">San Francisco</a>，這款字體不會直接出現於繪圖軟體之中，如需可用前文連結另外安裝。</li>
<li>中文字體：現在是使用蘋方字體，這款是少見包含「多個字重」的中文系統字體（5 種），設計運用上自然能有更多的發揮空間。</li>
</ul>
<h4 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h4><p>Android 雖然有提供系統字體，但各家廠商製作手機時依然可以調整預設的系統字體，在此僅是提供主要的預設字體。</p>
<ul>
<li>英文：<a href="https://fonts.google.com/specimen/Roboto">Roboto</a> ，這一款字體運用上也是非常靈活，擁有 6 種字體且均另有斜體（italic，共 12 種），根據 Google Fonts 的統計，這個字體已經運用在 22,000,000 個網站上。</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F2E75A5DC-A7B8-4F89-9F70-17404717CF97.png?alt=media&amp;token=5c98ec5c-1769-4168-a8f9-f683b73955bf" alt=""></p>
<ul>
<li>中文字體：資料上顯示有兩款 Droidsansfallback 及 <a href="https://www.google.com/get/noto/">Noto Sans</a>（我傾向是後者，有錯請指正），Noto Sans 是 Google 與 Adobe 公司共同研發的開源字體，包含 7 種常用字重並且幾乎包含所有中文字，號稱最不會缺字的字體庫，目前是設計師必備的中文字體。</li>
</ul>
<p>另外提到，Noto Sans 是 Google 及 Adobe 合作的字體，在 Adobe 的服務中稱這套字體為「思源黑體」，在繁體中文的國家中，Noto Sans 基本上也是依據台灣官方規定的筆畫規則，是一款非常優秀的字體。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-10-25%20%E4%B8%8A%E5%8D%8811.04.04.png?alt=media&amp;token=133ce2ca-2eda-4729-a77b-3ea8f5fdb6c7" alt=""></p>
<p>另外還有推出「思源宋體」（Noto Serif），相關的介紹可以參考 <a href="https://source.typekit.com/source-han-serif/tw/#story">介紹頁面</a>。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>了解預設字體是非常重要的，原因是「系統字體」是經過系統廠商所優化，普遍來說在各種情境都有較好的閱讀性；此外，每台電腦所安裝的字體也會有所不同，不可能要求一般用戶去下載未授權的字體，或是下載 Noto Sans 來做使用。</p>
<p>因此，使用第三方的字體可能會造成：</p>
<ol>
<li>可能缺乏良好的閱讀性（小字、色彩不明顯時）</li>
<li>用戶並未安裝該字體，導致畫面不如預期</li>
<li>缺字，導致字體顯示不一</li>
</ol>
<p>但有些時候，依然會推薦使用其它字體來凸顯網頁的部分關鍵用詞，下一篇將會介紹一些網路服務來運用額外的網路字體。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：色彩運用(3) - 按鈕的配色]]></title>
      <url>https://wcc723.github.io/design/2018/10/24/button-color/</url>
      <content type="html"><![CDATA[<p>上一篇透過連結的狀態了解運用，本篇則是探討按鈕再運用上的色彩變化，包含了一般、行動呼籲、外框線、警告意味等常見的類型，當然這些類型介紹上別不會包含上一篇的 “狀態”，實作中依然要記得補上喔。</p>
<h2 id="一般狀態"><a href="#一般狀態" class="headerlink" title="一般狀態"></a>一般狀態</h2><p>一般狀態通常是最沒有特色的，但使用上也是最為普遍的，這類型的按鈕通常不會帶有太多色彩，並不會特別引人注目，目的也是讓用戶了解的要執行、連結等等。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F77B97AC2-EBEE-4CEE-842F-9134574D1E0B.png?alt=media&amp;token=3af51988-d4a1-4f8f-98c5-327ab05b45e3" alt=""></p>
<p>設計：越普通越好</p>
<h3 id="Call-to-Action"><a href="#Call-to-Action" class="headerlink" title="Call to Action"></a>Call to Action</h3><p>宣傳網頁、登入頁等等都會有一個按鈕引導用戶到達特定目標，行為上我們稱為「Call to Action」，因此這類型的按鈕都會特別顯眼，配色上則會使用「主色」或「次要色」，並且以「填滿」的方式配置。</p>
<p>也因為這類型按鈕非常重要，所以相似的按鈕一個畫面中不會出現太多次，如以下範例所示，大多服務都是使用在「註冊」上（Airbnb 則是用在搜尋，所以對他們來說搜尋比註冊更為重要），必須謹慎配置這類型的按鈕，請把它用在最重要的地方。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F577C13C5-C430-4850-AAD4-1EEB4509FAAE.png?alt=media&amp;token=d0becd9e-f7e3-4547-a3b9-5ed6b20dcceb" alt=""><br><a href="https://github.com/">https://github.com/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F44B5C9CE-7EF7-4496-BE38-EA531F1A7F78.png?alt=media&amp;token=f396d890-4a16-43ff-b275-d49949a67627" alt=""><br><a href="https://azure.microsoft.com/zh-tw/">https://azure.microsoft.com/zh-tw/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FE958A23D-CA39-4C50-AFC6-8743FB852E1A.png?alt=media&amp;token=814faa75-ed3a-4ab7-a32c-53fd38d56560" alt=""><br><a href="https://www.airbnb.com.tw/">https://www.airbnb.com.tw/</a></p>
<p>設計：主色或次要色，並且填滿它</p>
<h2 id="Outline"><a href="#Outline" class="headerlink" title="Outline"></a>Outline</h2><p>幾年前開始出現的一種按鈕風格，當時有一種暱稱為 Ghost button，相對於填滿的按鈕來說它的顯眼程度沒有那麼高，但依然能夠符合網頁的主題配置，所以重要性也是介於普通按鈕及 Call to Action 之間，很適合用在宣傳網頁、登入頁的次重要性按鈕。</p>
<p>如下 Uber 的網頁來說，最重要的是引導人們註冊成司機，其次則是引導乘客註冊。因此這個網頁的動機是尋找引導駕駛比引導乘客更為重要。</p>
<p><a href="https://www.uber.com/zh-TW/tw/">https://www.uber.com/zh-TW/tw/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F59827BC1-2DFB-4EF2-9854-3A99E4C9C93F.png?alt=media&amp;token=fd746faf-4406-4cc4-bf86-72be62fd2424" alt=""></p>
<p>在 Palantir 的登入頁來說，並不需要引導用戶註冊或購買，重要的是傳遞訊息、故事，因此沒有使用 Call to action 的按鈕，取而代之的是 outline 按鈕來引導用戶觀看他們的故事。</p>
<p><a href="https://www.palantir.com/">https://www.palantir.com/</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F79796F76-9D51-4492-BD72-33DD15CCC232.png?alt=media&amp;token=6d84b5af-2c18-4782-b59c-2f1481be8251" alt=""></p>
<h2 id="警告"><a href="#警告" class="headerlink" title="警告"></a>警告</h2><p>警告意味的按鈕是傳達此按鈕的危險性，所以與 Call to action 是相反的概念，警告是避免用戶點擊，Call to action 則是期望用戶點擊（許多電商都是使用橘色、紅色填滿作為 Call to Action。）。配色上大多會使用紅色，並且以「白底紅字」的方式避免過於顯眼，所以無論主色或是次要色選擇了紅色，都會避免使用紅底白字的方式在呈現，因為這樣的配置會吸引用戶點擊。</p>
<p>以 Github 的 Danger Zone 來說就是使用細紅框搭配紅字按鈕呈現，除了提醒用戶這個區域的安全性外，也避免吸引用戶目光。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FE25C4862-2EFD-4659-BA19-5FAADFA7C697.png?alt=media&amp;token=ad2248d3-6f7b-4dc7-a618-01a265d946e7" alt=""></p>
<p>避免使用紅色的按鈕，他會吸引用戶目光點擊（警告都不警告了）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FEC9D54D1-CC78-4DDC-B4DD-146317336E74.png?alt=media&amp;token=74509e76-7f08-41cd-8f68-eb14aec84482" alt=""></p>
<hr>
<p>以上是常見的情境，大家可以依據這些概念看看國內外網站，是不是有很多符合這樣的情境，這些概念同時也可以運用在自己開發上並思考以下事情：</p>
<ul>
<li>網站最重要的行為是什麼？</li>
<li>當下按鈕的重要性？</li>
<li>當下按鈕所傳達的情緒（警告、興奮、買買買）？</li>
</ul>
<p>藉此來調整網頁的行動配色喔 :D。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：色彩運用(2) - 連結的配色]]></title>
      <url>https://wcc723.github.io/design/2018/10/23/link-color/</url>
      <content type="html"><![CDATA[<p>除了親和性的配色外，訊息的傳遞也是很重要的，與平面設計不同的是訊息並非只有圖文的傳遞，還包含了狀態、互動、提示等等訊息，訊息也同時可以用許多不同色彩表示，增加訊息所能表示的情感、急迫性、引導性等等。</p>
<h2 id="連結色彩（包含不同狀態）"><a href="#連結色彩（包含不同狀態）" class="headerlink" title="連結色彩（包含不同狀態）"></a>連結色彩（包含不同狀態）</h2><p>網頁設計中的 <code>&lt;a&gt;</code> 除了本身的預設樣式外，另外還包含以下幾種 “狀態”</p>
<ul>
<li>a:link - 未拜訪過的連結。</li>
<li>a:visited - 已拜訪過的連結。</li>
<li>a:hover - 滑鼠回入的連結。</li>
<li>a:active - 按下狀態的連結。</li>
<li>a:focus - 鍵盤專注的狀態。</li>
</ul>
<p>a:link - 未拜訪過的連結及 a:visited 已拜訪過的連結，這兩種並非在所有網站都有這樣的需求，通常會運用在「需要紀錄已讀取」的網頁上，像是搜尋引擎就是很好的例子（但現在很多都改用 JavaScript 來設計）。</p>
<p>設計：可視專案需求來決定是否加入這個樣式。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F2F65522E-E61F-474D-811C-B27EDC9394B3.png?alt=media&amp;token=06b61eb9-7c5c-4651-b03b-c153c0b4e2c0" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FA27070D7-1AB7-40D2-951C-CD10E1EBFC88.png?alt=media&amp;token=1e7771cc-04c4-4479-acdc-2f243268d976" alt=""></p>
<p>a:hover - 滑鼠回入的連結，這個樣式普遍都會製作，主要讓用戶滑鼠滑入時了解「這是一個可互動的按鈕」，如果少了這個樣式用戶可能會誤以為沒有連結。但要特別注意，這個樣是在行動版無法正確的呈現（因為手機沒有滑鼠 hover 的事件）。</p>
<p>設計：在文本中的設計中大多會使用略深的主色或次要色，然後加上下底線作為呈現。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F6C26DA61-6A01-4CF7-8E6D-EE7689E6B1C5.png?alt=media&amp;token=8a867d9a-b5ae-49e8-bfa0-123de1742980" alt=""></p>
<p>如果以按鈕呈現，也會使用略深為按鈕原色的設計</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F79200816-D5F7-4FC3-9884-7FC466A7EEF4.png?alt=media&amp;token=e92b71ad-1640-4171-8773-237cc1273b1b" alt=""></p>
<p>a:active - 按下狀態的連結，這是滑鼠按下的樣式，通常會與 .active 一起製作，而 .active 可以透過後端或 JavaScript 直接套用在按鈕之上，表示目前啟用中的按鍵。</p>
<p>設計：通常會使用略深於普通狀態的色彩，設計時可以與 .active（啟用樣式）一起設計（文本有時不會設計，或同 hover 樣式）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F64EB9303-2FC9-4186-BE41-93CDD10A34E3.png?alt=media&amp;token=0a88aba5-6d4f-4993-b9a1-d4f1b68d09a3" alt=""></p>
<p>a:focus - 鍵盤專注的狀態，許多用戶會使用鍵盤搭配 tab 來瀏覽網頁（也有一部分是屬於視覺障礙者），這個專注狀態可以讓用戶了解目前「專注」的按鈕，如果用戶需要按下此按鈕，則可以按下 Enter 鍵。</p>
<p>設計：文本中會使用瀏覽器預設的外框，主要是因為文本中不一定能調整高度，視覺上可能會干擾到其他文字的閱讀，因此不一定會另外設計。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F6C26DA61-6A01-4CF7-8E6D-EE7689E6B1C5.png?alt=media&amp;token=8a867d9a-b5ae-49e8-bfa0-123de1742980" alt=""></p>
<p>按鈕會在原本按鈕外增加一圈類似色彩，如果沒有另外設計則會套用瀏覽器預設的樣式。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F89012DDC-D2EF-497F-A3C9-4D1B004E38CD.png?alt=media&amp;token=125d35a2-c792-4e0f-9098-591e0e7a12a8" alt=""></p>
<p>瀏覽器預設的 focus，每個瀏覽器略有不同（下圖為 Chrome 的樣式），預設樣式不會隨著網站設計改變，大多會使用藍色外框，因此會建議自行設計。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FFA50D4EE-5F03-4F2B-AD39-AEE3A86ECECC.png?alt=media&amp;token=737e94be-7be4-429a-b120-58401c24d56c" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F2029E89B-E96E-47D7-9954-3074680AB1B4.png?alt=media&amp;token=0ee1bfda-d570-43ab-aadd-0fdb85deeaba" alt=""></p>
<p>部分網頁設計師由於沒有程式開發的經驗，所以會忽略許多行為上的樣式狀態，除了 link, visited 外，其餘都是設計時必備的項目，一開始就必須加入喔。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>按鈕互動對於使用者回饋相當重要，如果缺乏足夠回饋，用戶時常會以為該連結是否無法運作。而設計師為了追求畫面上的完美，有時會疏忽掉用戶操作的回饋，執行上則會建議一開始預先定義相關元素的互動狀態、錯誤行為等等，避免後續開發上的疏忽。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：色彩運用(1) - 你的網頁文字是否足夠清楚呢？]]></title>
      <url>https://wcc723.github.io/design/2018/10/22/accessibility/</url>
      <content type="html"><![CDATA[<p>上一篇介紹了整體色彩選擇，按造該概念完成一個網頁相信不是什麼問題，不過色彩到底怎麼選？運用上有什麼需要注意的？本篇就來介紹一下吧。</p>
<p>Accessibility：這個單字翻譯有很多意思，如：「無障礙」、「親和性」、「可訪問性」，其中我最喜歡的是親和性的翻譯，因此把它作為此篇文章的標題，而在 Google 的相關文件中翻譯為「可訪問性」，在本文中看到「親和性」、「可訪問性」都是指此單字喔。</p>
<h2 id="網頁可訪問性分數"><a href="#網頁可訪問性分數" class="headerlink" title="網頁可訪問性分數"></a>網頁可訪問性分數</h2><p>網頁配色時除了要好看之外，色彩所造成的訊息傳遞功能依然不可降低，如黑底白字、白底黑字是普遍來說閱讀性佳的色彩組合，但這個組合並不一定適合所有的品牌配色，如果品牌顏色為綠色（#509955）那麼這樣的顏色作為文字色彩閱讀性是否足夠呢？</p>
<p>網站內容親和性規範 <a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html">The Web Content Accessibility Guidelines (WCAG 2.0)</a> 將文字與背景對比度區分為不同等級，在主要的內文排版中至少要有 4.5:1 的對比度（AA 級），除了一些情境之外可以不需要達到這樣的標準：</p>
<ul>
<li>較大的文字：超過 18px 或 14px 的粗體文字對比度可降為 3:1</li>
<li>附屬的文字：裝飾或者圖片一部分的文字可以不遵循此標準</li>
<li>品牌文字：如果文字為品牌一部分，也可不遵循此標準</li>
</ul>
<p>Google 的 Web Fundamentals 有完整一篇文章說明該如何實踐這個概念（<a href="https://developers.google.com/web/fundamentals/accessibility/accessible-styles">可訪問的樣式</a>），下圖也演示了不同對比度的視覺關係，4.5:1 則是大部分可輕鬆閱讀的對比度，如果您的網站需要給予老年人或視力不佳的人閱讀，建議可以將標準提高到 7:1。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F058BBAA0-AB20-46BC-966F-94FC1454B407.png?alt=media&amp;token=18d7d423-76db-4768-b829-c7c2e354d90e" alt=""></p>
<p>回到前文所說：「如果品牌顏色為綠色（#509955）那麼這樣的顏色作為文字色彩閱讀性是否足夠呢？」，以下簡單介紹該如何檢視此段文字是否符合標準。</p>
<p>這次透過該色彩所展示的一段文字，無論現在肉眼看起來是否足夠清晰，我們來透過工具說明是否符合標準。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F65E8C8C9-C4B6-446F-9AAF-2915F46C5E25.png?alt=media&amp;token=411f818a-69e2-4194-b361-af4e588579d2" alt=""></p>
<p>接下來透過開發者工具，點選該文字 -&gt; 右鍵 -&gt; 檢查 可以看到如下的介面，然後再點選色彩就能看到以下資訊。（如果不知道如何使用開發者工具，可以參考我們的免費課程：<a href="https://www.udemy.com/chrome-devtools/）">https://www.udemy.com/chrome-devtools/）</a></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_10_8_%E4%B8%8B%E5%8D%883_04.png?alt=media&amp;token=c50fa8b0-1a52-475f-8aeb-e965f51b6113" alt=""></p>
<p>接下來，點選 Contrast ratio 右方的箭頭 icon，展開看更多細節，接下來可以直接透過上方的色版調整色彩，色版中也給予建議的標準線，只要超過標準線就至少通過 AA 級，下方也有標示是否符合 AAA 級的對比度。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_10_8_%E4%B8%8B%E5%8D%883_09.png?alt=media&amp;token=36b78c11-6d42-4b19-a454-e9cd44763d8c" alt=""></p>
<p>接下來我選擇一個 #458449 的色彩至少符合 AA 級（4.54:1）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_10_8_%E4%B8%8B%E5%8D%883_14.png?alt=media&amp;token=21ed8d1a-f6b1-4473-82d8-b30823764574" alt=""></p>
<p>再重新查看此文字是否符合網站的標準色，我們也可以用此方法作品牌色的延伸，套用至所有的網站文字之中。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F9B8B266D-5176-43A1-B830-EB70F7026E14.png?alt=media&amp;token=492ea152-14b5-4ac5-9cbf-4671a9a3aa8f" alt=""></p>
<p>另外，這個工具也可針對不同色彩的背景做調整，如下圖我選擇另一個藍綠色作為背景色，</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FA0C4AA78-6264-4623-AF98-A9B3D87F76C2.png?alt=media&amp;token=d772d46d-5780-484d-8511-51cbe78c2994" alt=""></p>
<p>此時對比度也會顯示不足夠。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FC0BD0C4B-E71E-469B-9780-99C9FDD59DB3.png?alt=media&amp;token=7b5bac58-0c0e-48a4-bb0f-4cc227cb21e0" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>色彩的親合度使用上也必須注意不同的背景色變化，以及互動連結、按鈕等等的搭配，甚至還有針對目標群眾調整更高對比（年邁、視力不佳者），符合品牌的同時，我們還有很多的細節可以處理喔 :D。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計色彩配置概念]]></title>
      <url>https://wcc723.github.io/design/2018/10/21/color/</url>
      <content type="html"><![CDATA[<p>根據上一篇介紹的設計規範參考，實戰中有許多需要事先定義，而色彩是使用者打開網站最先體驗到的部分。好比說 Facebook 的深藍色、Google 的紅色、LINE 的綠色，Yahoo 的紫色，這些色彩都深深的存在我們腦海裡，所以在決定這些色彩絕不能馬乎，如果換了色彩用戶還可能會想「我進錯網站了嗎？」。</p>
<blockquote>
<p>除此之外，每個色彩也帶有不同的行動意味，因此顏色要怎麼選、怎麼配才會好看、好用呢？畢竟五顏六色的網站經常讓人找不到重點且美感難以控制。</p>
</blockquote>
<h2 id="簡單的方法：選一個主色貫穿全場吧"><a href="#簡單的方法：選一個主色貫穿全場吧" class="headerlink" title="簡單的方法：選一個主色貫穿全場吧"></a>簡單的方法：選一個主色貫穿全場吧</h2><h3 id="講古中…"><a href="#講古中…" class="headerlink" title="講古中…"></a>講古中…</h3><p>在過去，Material Design 是選擇雙色，一個主色（primary color）另一個強調色（accent color）的配置方式；主色是全畫面的主要色彩配置，這也是帶給用戶主要觀感的色彩，佔去畫面的主要區塊。而強調色只在部分的區域，目的是增強部分重點的視覺性，如：重要的互動性元件、重點文字等等。</p>
<p>重點：兩個顏色，一個稱為「主色」另一個為「強調色」</p>
<ul>
<li>主色：主要是品牌色彩，除了底色為是最容易被記憶的部分，會運用在網站大多地方，除了本身的色彩外，也會依據明度的調整來做相關的延伸。</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F070143CA-E267-4E76-A7B3-A5CFB7EA3F03.png?alt=media&amp;token=b7b479e2-49d6-42d3-8278-5c8cdf6998ff" alt=""></p>
<ul>
<li>強調色：凸顯的色彩，可以使用主色的對比色，這類的色彩通常強烈、明顯如：紅色、黃色等等，大多用在互動性的元件或需要特別重要的文字。當然，除了本身的色彩外，也會依據明度的調整來做相關的延伸。</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F16E6A094-9512-4E75-B79D-4BAF5DF06A8B.png?alt=media&amp;token=14b7c060-247d-402c-a372-be2ca5add001" alt=""></p>
<p>案例如下，主色為整個畫面中的核心色彩，除了底色外另一個會被使用者所關注的色彩即是「主要色」。而強調色則是運用在「互動」、「重點標示」，且要避免強調色運用在網站上過多的地方（否則就失去強調的意味）。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FEB6C291F-F41B-4C1A-8EE4-716265EDACE0.png?alt=media&amp;token=ce3654ed-9fc3-46e7-a1c1-fcbe4c6150be" alt=""></p>
<h3 id="現在"><a href="#現在" class="headerlink" title="現在"></a>現在</h3><p>Material Design 目前則是使用一個主色（primary color）及一個次要色（secondary color），在名稱上就可以看出和過去的不同，且文件中也說明到：「如果你並沒有次要色，你的主要色同樣可以用在主要的元素上」（If you don’t have a secondary color, your primary color can also be used to accent elements.）。</p>
<p>而這兩個顏色作用上與過去的主色、強調色觀念一致，但在選擇上確有所不同，次要色改成「非必要」的存在。</p>
<p>如下圖，這個網頁中選擇一個紫色作為主色調，並且透過明度調整增加豐富性並利用在所有的地方，這個網頁也並沒有使用到次要色。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FC36FC3FB-9EFC-44B6-ACB0-73F794D67BB1.png?alt=media&amp;token=723a34ec-8ee0-408b-9b9e-ef0a56e62507" alt=""></p>
<p>另外一個包含次要色的範例，除了剛剛的紫色外，也可以選擇一個次要色作為重點的強調，這裡的次要色類似先前版本的「強調色」。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F69868398-EC64-442A-8D00-A67654B72201.png?alt=media&amp;token=1c5eacaf-5228-48a3-b8dc-a0e933c85553" alt=""></p>
<h2 id="實際案例"><a href="#實際案例" class="headerlink" title="實際案例"></a>實際案例</h2><p>而無論是過去或現在的選擇一組「主色、強調色」或者是僅選擇「主色」，在網頁設計上都是很常被運用。</p>
<h4 id="Evernote"><a href="#Evernote" class="headerlink" title="Evernote"></a>Evernote</h4><p><a href="https://evernote.com/intl/zh-tw">https://evernote.com/intl/zh-tw</a></p>
<p>單一主色貫穿全部，僅有主色的明度調整，互動元件上也沒有額外的次要色，在畫面上也顯得乾淨一致。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FB2527BB6-23BB-45B4-AAD7-67F6A57D8B5A.png?alt=media&amp;token=b4d73b3d-90e5-478e-b9ab-b76539d80957" alt=""></p>
<h4 id="Airbnb"><a href="#Airbnb" class="headerlink" title="Airbnb"></a>Airbnb</h4><p><a href="https://www.airbnb.com.tw/">https://www.airbnb.com.tw/</a></p>
<p>單一主色，僅把主色放在品牌及最重要的互動按鈕上，其餘地方則會使用不明顯的色彩來標示。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FF77EC589-ED2E-4D2D-8DB6-7A4BA5833362.png?alt=media&amp;token=c22e38f7-cf3d-48e1-97ae-834dc36c7741" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FA76CB435-259B-4228-8A7F-6957C1A10CBC.png?alt=media&amp;token=3a8aac42-5451-44ae-9060-53bd4407a9a0" alt=""></p>
<h4 id="Udemy"><a href="#Udemy" class="headerlink" title="Udemy"></a>Udemy</h4><p><a href="https://www.udemy.com/">https://www.udemy.com/</a></p>
<p>同樣是單一主色套用在品牌色、重要的互動按鈕上。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FEDEBE638-9A7B-49CC-AF92-314C8740885F.png?alt=media&amp;token=c6e920ea-47a6-47af-9a4e-f14b5c0295a7" alt=""></p>
<h4 id="Shopify-電商版型"><a href="#Shopify-電商版型" class="headerlink" title="Shopify 電商版型"></a>Shopify 電商版型</h4><p><a href="https://themes.shopify.com/themes/empire/styles/supply/preview">https://themes.shopify.com/themes/empire/styles/supply/preview</a><br>現在使用主色、強調色的配色方式已經比較少了，但還是會有電商類型的網站會用這樣的配色來增加轉換率。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F5A4ABE79-009F-42E8-94C0-4531053B8286.png?alt=media&amp;token=c9a60992-ccc3-49fe-8579-6da55bf70cd3" alt=""></p>
<h4 id="Sketch-APP"><a href="#Sketch-APP" class="headerlink" title="Sketch APP"></a>Sketch APP</h4><p><a href="https://sketchapp.com/">https://sketchapp.com/</a><br>這也算是單一主色（橘色），特別的是有搭配一個粉紫色漸層作為背景、文字配色，但整體的互動還是圍繞在橘色上。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F25045415-E029-4975-9847-E606A5C8E0EE.png?alt=media&amp;token=80805f9a-5f00-4662-be34-7b05c6a1717b" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F7125D3CE-E7E0-4836-ACCB-2575F5604123.png?alt=media&amp;token=37432094-27a7-40b3-bd97-c636bee10207" alt=""></p>
<hr>
<p>簡單回顧一下配色的選擇方法：</p>
<ol>
<li>選擇一個主色，盡可能用它來作為全網站的配色延伸</li>
<li>選用一個次要色，作為網站強調性文字、按鈕的配色，但這個選擇是非必要的。</li>
</ol>
<p>經驗上，過去有許多雙色（主色、強調色）的案例，而在最近有趨向轉為單主色，所以這樣的觀念並非長久不變，我們可以從文件、國內外的網站觀察變化，並且依據我們製作的專案需求調整設計，而設計除了做的美，還要學會從固定的規則中尋求變化。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：文件、規範參考 - Material Design]]></title>
      <url>https://wcc723.github.io/design/2018/10/20/design-guide/</url>
      <content type="html"><![CDATA[<p>程式領域裡面非常重視文件，當然 UI 中也是如此，為了確保設計可以被執行，大型應用程式、系統都會推出屬於自己的規範，如：</p>
<ul>
<li>iOS 的 <a href="https://developer.apple.com/design/human-interface-guidelines/">Human Interface Guidelines</a></li>
<li>Google 的 <a href="https://material.io/design/">Material Design</a></li>
</ul>
<p>而除了上述的作業系統 / 應用程式外，網頁開發也是有相關的概念，在 <a href="http://styleguides.io/">Styleguide</a> 這個網站中就可以查詢到許多相關的範例。</p>
<h2 id="規範可以帶給我們什麼？"><a href="#規範可以帶給我們什麼？" class="headerlink" title="規範可以帶給我們什麼？"></a>規範可以帶給我們什麼？</h2><p>簡單來說就是限制設計師的風格，一般來說設計師都會有屬於個人的個性及風格，而網站開發都並非少數人即可完成，就有可能出現同一個顏色各自表述的情況，可能會發生的狀況有：</p>
<ul>
<li>色彩不統一：我的紅與你的紅不同</li>
<li>間距不同：有些設計師偏好雙數的間距，也有設計師喜歡 5 的倍數</li>
<li>字體、字級、字重不同：就算是相同字體、字級，設計師也可能選擇不同字重</li>
<li>插畫風格不同：每個設計師的手繪能力也不同，所以也會造成插畫風格上的差異</li>
<li>格線定義不同：這個在上一章也有提過，設計稿如果格線不同也就難以對齊</li>
<li>動態轉換不同：雖然在網頁中比較少演示這一段，但轉換速率、漸變函式 （ <a href="https://developer.mozilla.org/zh-TW/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions">transition timing function</a> ）不同，使用者體驗也會有不一致的問題。</li>
</ul>
<p>就以 Material Design 來說，建立網站色表時也可以同時產生 主色、次要色、延伸色、背景色、錯誤、文字應用色等等，那麼接下來做延伸設計時也可運用相同觀念。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F18132362-3A8E-46C0-856E-FCFB4F556C59.png?alt=media&amp;token=917f0bec-c1f8-412d-bfc2-63165d29e349" alt=""></p>
<p>色彩選定後 Material Design 也會提供許多案例供設計師了解這配色該如何運用，以下圖來說錯誤訊息應使用 Secondary Color，而不是使用帶有緊告意味的色彩或是其它品牌色作為強調色</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FECD0AC44-9ACC-47D7-8923-468B6FB3299E.png?alt=media&amp;token=b07eb9ef-2376-4f80-9f91-df6afb263b19" alt=""></p>
<h2 id="Material-Design-的優點"><a href="#Material-Design-的優點" class="headerlink" title="Material Design 的優點"></a>Material Design 的優點</h2><p>除了 iOS、Material 這兩大系統的規範外，製作網頁其實也有很多規範可以參考（<a href="http://styleguides.io/">Styleguide</a> ），此時可能會思考為何要閱讀 Material 這樣的規範呢？</p>
<p>除了有固定的樣式外， Material Design 提供了許多優良概念值得去思考，這部分列出一些我認爲很棒的概念給大家參考：</p>
<h3 id="「紙」的風格"><a href="#「紙」的風格" class="headerlink" title="「紙」的風格"></a>「紙」的風格</h3><p><a href="https://material.io/design/iconography/product-icons.html#design-principles">https://material.io/design/iconography/product-icons.html#design-principles</a><br>相對於目前主流的設計風格，大多強調簡潔、色塊，而 Material Design 卻在此基礎之上帶入「紙與墨」的概念，本段就以圖示來介紹是如何呈現紙的風格在內。</p>
<p>為了呈現出紙的風格，所以繪製 icon 時會直接製作出實體，並且觀察實體的光影變化（根本就是在畫素描水彩），透過實際觀察了解紙的切面、陰影、反光等視覺特性。</p>
<p>透過手工製作的 icon，這也是我們熟悉的 Gmail 雛形</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FEBB511FA-08EA-4250-BD6F-CAF7BA2BE85C.png?alt=media&amp;token=5ad2c87b-b2fe-4432-b272-989ed10b1375" alt=""></p>
<p>打光，我們可以看到陰影的變化，除此之外也可以關注切面所產生的反光，這會讓紙的呈現包含厚度。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FF03A6E3F-05DE-45D2-8D96-B74662E4BD02.png?alt=media&amp;token=e52766dc-d9f9-4060-a429-565694540466" alt=""></p>
<p>實際繪製及上色。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FF03A6E3F-05DE-45D2-8D96-B74662E4BD02.png?alt=media&amp;token=e52766dc-d9f9-4060-a429-565694540466" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F4969401F-56EA-418C-812C-7B7BC0C7D7BA.png?alt=media&amp;token=f4cbb5cf-4141-47d3-9f45-99b7c2bfdb82" alt=""></p>
<p>透過這樣的案例，對於圖示也定義了繪製的規範，使所產生的圖示具有一致性。如卡片的邊緣就使用如下的規範定義：</p>
<p>上邊緣：</p>
<ul>
<li>高：1dp</li>
<li>透明度：20%</li>
<li>色彩：White (#FFFFFF)</li>
</ul>
<p>下邊緣：</p>
<ul>
<li>高：1dp</li>
<li>透明度：20%</li>
<li>色彩：參考相關色調及陰影</li>
</ul>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F650A8615-57D3-4C68-9385-5485B93BC050.png?alt=media&amp;token=66f20d11-d27d-4c55-824b-5fc4fc33c9f8" alt=""></p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F7593D9AE-E573-4BA3-A865-63EDF3D6223F.png?alt=media&amp;token=edba474a-9a1d-4899-b05d-41f7835b43db" alt=""></p>
<h3 id="陰影所代表的-「深度」"><a href="#陰影所代表的-「深度」" class="headerlink" title="陰影所代表的 「深度」"></a>陰影所代表的 「深度」</h3><p>網頁是平面的，但內容在城線上還是會有前後的順序，如「操作中的物件」為了讓用戶了解他是正被操作的，可以使其更明顯些；而除了外框、修改色彩的方式，深度也是凸顯物件的好技法。</p>
<p>下圖中，拖曳的物件所產生的陰影，會讓物件感覺比較前面。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F44A9F8AF-4836-4078-8706-9F9DE0E038FE.png?alt=media&amp;token=beecaa34-2bf0-4c57-b15f-5db11c9e355a" alt=""></p>
<p>實際演示的動畫</p>

<video aria-describedby="shadows-figure-caption-3" class="video-player__video animatable js-video-player js-video-load anim-appear" loop="" muted="" preload="metadata" controls autoplay tabindex="0">
<source data-src="https://storage.googleapis.com/spec-host-backup/mio-design%2Fassets%2F1lUqfq3Tt1qRQxZAn9gkROKMysc7G9Mhc%2Fshadowprinciples-list.mp4" src="https://storage.googleapis.com/spec-host-backup/mio-design%2Fassets%2F1lUqfq3Tt1qRQxZAn9gkROKMysc7G9Mhc%2Fshadowprinciples-list.mp4" type="video/mp4"> </video>

<p>下圖兩個物件有著不同陰影，因此會感覺深度不同。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F1CBDBF23-CF88-46E0-9733-4AF82DBEF99C.png?alt=media&amp;token=a198080f-031d-411e-9b2e-2950be262393" alt=""></p>
<p>深度的概念：下圖中 A 與 B 視覺上會感覺具有相同深度，從正面來看因為 A 具有 8dp 的陰影深度，B 與 C 各有 4dp 的深度，總合上與 A 相同，就會讓用戶感受到兩者的高度（重要性）是接近的。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F7CB5DEC5-C632-4F87-BB6C-8E2C8F4B3869.png?alt=media&amp;token=e242b3d5-f42b-45c6-b30a-dfa309a46253" alt=""></p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本篇僅是概述設計規範所帶來的觀念，在此非常建議可以親自閱讀這些觀念，身為設計師會不斷的追求「創造力」及「獨特性」，Material Design 說明如何將一個實體的概念轉化為規範，其中的過程更能激發設計師的思考，除了學習符合開發的需求外，更從中了解如何創新。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計常用格線系統(下)]]></title>
      <url>https://wcc723.github.io/design/2018/10/19/grid-system-2/</url>
      <content type="html"><![CDATA[<p>上一篇介紹了格線系統的概念及計算方式，擁有了這些觀念後會如何運用在繪圖軟體上呢？無論你是使用 Sketch 或是 Adobe XD 都可以快速建立如前文所提到的格線，本篇不會著重在軟體的操作，而是網格如何運用在網頁的設計上。</p>
<ul>
<li>實際運用</li>
<li>格線與響應式的搭配</li>
</ul>
<h2 id="實際運用"><a href="#實際運用" class="headerlink" title="實際運用"></a>實際運用</h2><p>假設我們的網頁內容包含了以下元素：</p>
<ul>
<li>頂部的大 Banner（頁首）</li>
<li>側邊選單</li>
<li>主要內容區域</li>
<li>頁腳</li>
</ul>
<p>我們一樣先依據下圖的數據打開格線系統，如果有必要也可用更大或更小的數值調整。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608QETNQb7KdU.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608QETNQb7KdU.png"></p>
<p>接下來可以依據這個概念將元素一個一個繪製到畫面上，所有的相對位置大約會如下圖呈現（選單佔 3 欄寬，內容佔 9 欄寬，中間保留一個 Gutter 寬）。透過格線系統的限制下，將不需要花太多精力去思考“水平空間” 及 “水平間距” 需要多大，只要貼的格線繪製都會顯得整齊。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608LwuFynoBPO.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608LwuFynoBPO.png"><br>這個概念下，如果有額外的需求也能跟著調整，假設需要增加三個廣告欄位在畫面上，那麼我們可以將三個廣告做 4 欄寬的設計（12 / 3 = 4），也可以如下圖的呈現：</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608pTbJoHCoYl.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608pTbJoHCoYl.png"></p>
<p>雖然廣告欄位與選單、主要內容區塊的垂直線並沒有完全對應上，但因為具有固定的間隔，還是感受到它具有一定的規範。</p>
<h4 id="額外問題：如果廣告欄位與欄位數不一致怎麼辦？"><a href="#額外問題：如果廣告欄位與欄位數不一致怎麼辦？" class="headerlink" title="額外問題：如果廣告欄位與欄位數不一致怎麼辦？"></a>額外問題：如果廣告欄位與欄位數不一致怎麼辦？</h4><p>雖然格線系統限制了思維模式，但如果同時熟悉網頁開發技巧其實可以做這樣的變化，廣告欄位維持 4 欄寬度，超過 100% 寬度後將會自動換行，並且以置中的方式來繼續做排列。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608Kp0x4LtjSj.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608Kp0x4LtjSj.png"></p>
<h2 id="格線系統與行動版網頁"><a href="#格線系統與行動版網頁" class="headerlink" title="格線系統與行動版網頁"></a>格線系統與行動版網頁</h2><p>現在行動版網頁盛行的情況下，網站支援手機瀏覽也是很正常的，而格線系統當然也可以應用在行動版網頁，觀念上大致上差異不大，僅需要調整一些數值即可。<br>先假設需要預覽的寬度為 320px，那麼我們可依據公式將數值調整為如下：<br>公式：((320 - 20) - 20 * 3)  / 4<br>Total Width: 320<br>Number of Column: 4 -&gt; 行動版建議不要有太細的欄位數，建議以單欄為主<br>Gutter Width: 20 -&gt; 不變<br>Gutter on outside: 10 -&gt; 不變<br>Column Width:  60 -&gt; 由於欄位數大幅的減少，因此欄寬度也維持在 60px</p>
<p>行動版網頁在瀏覽時會以單欄為主，因此會將原本的內容轉為 100% 寬度，次要的內容會轉為 50% 寬度，甚至是 25% 寬度。</p>
<p>轉換的結果如下圖，元件還是依然的緊貼於格線之上，主要內容佔有 100% 的寬度，保有最大的空間讓用戶可以輕鬆地閱讀。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608l7VgbxHhPb.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608l7VgbxHhPb.png"></p>
<p>而在這樣的格線轉換，設計師不需要花費太多心力去計算寬度的轉換，雖然僅製作了 320 寬度的版型，工程師也能從「相同的邏輯延伸出不同尺寸下的變化」，且這樣的公式也能透過 CSS 來得以實踐。</p>
<h2 id="Bootstrap-框架"><a href="#Bootstrap-框架" class="headerlink" title="Bootstrap 框架"></a>Bootstrap 框架</h2><p>除了設計軟體隨著網頁發展有了新工具，網頁本身在開發時也有許多現成工具可運用，如 Bootstrap 就是網頁開發中最廣泛運用的 CSS 框架，提供了許多現成的組件直接運用，當然也有網格系統在其中。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608X4YUOY248p.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608X4YUOY248p.png"></p>
<p>Bootstrap 的網格系統中包含了多種裝置的設計，對照它所提供的數值其實與剛剛所運用的差異不大，除了 Gutter 為 30px 並非 20px。所以本篇所介紹的內容，只要將格線間隔調整為 30px（實際上維持 20px，Bootstrap 本身也能配合執行），也可以使用 Bootstrap 來執行，並且同時包含桌面版及行動版。</p>
<h2 id="實例"><a href="#實例" class="headerlink" title="實例"></a>實例</h2><p>接下來你或許會思考「這個概念是否有被廣泛運用」？其實可以從網站中的原始碼尋找一些蛛絲馬跡（因此必須要有查看原始碼的能力），最簡單的方式可以在網頁上按下右鍵 -&gt; 選擇「檢查」。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608MQx8v3cwP4.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608MQx8v3cwP4.png"></p>
<p>接下來使用畫面上的小工具來選擇網頁中的區塊。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608LdWZiZNiVP.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608LdWZiZNiVP.png"></p>
<p>範例網頁：<a href="https://events.google.com/io/">https://events.google.com/io/</a><br>畫面中我選擇到了一個區塊，上面的程式碼 <code>grid__item--12-cols grid__item--6-cols--gt-sm</code>中的訊息為：</p>
<ul>
<li>grid__item–12-cols：預設為 12 欄寬</li>
<li>grid__item–6-cols–gt-sm：在小裝置以上時，改使用 6 欄寬</li>
</ul>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608QrrR0SqOZs.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608QrrR0SqOZs.png"></p>
<p>接下來我們可以用相同手法在各個網站尋找，這些概念目前已被廣泛的運用。不過由於網頁技術不斷的跟進，並不一定需要像過去定義欄位數才能完成這樣的排版，甚至可依據內容數量自動排列等寬的格線，製作出類似 Grid System 概念的排版。</p>
<p><img src="https://ithelp.ithome.com.tw/upload/images/20181019/20083608jTBr6t8GUA.png" alt="https://ithelp.ithome.com.tw/upload/images/20181019/20083608jTBr6t8GUA.png"></p>
<p>以上介紹的網格系統是屬於通用的概念，在熟悉這些概念依然可以做許多延伸，設計並沒有絕對不變的，而是在了解通則及可行性後再來加以變化。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：網頁設計常用格線系統(上)]]></title>
      <url>https://wcc723.github.io/design/2018/10/18/grid-system/</url>
      <content type="html"><![CDATA[<p>學習設計的時候，一定會討論到網格系統，透過網格可將圖片、文字做有條理的編排，只要有了網格做支撐，就算是複雜的圖文都會有規矩的排列。相反的，如果平面設計缺乏網格系統，就算簡單的圖文要排列整齊也並非容易的事情。</p>
<p>本篇分別介紹幾個部分：</p>
<ul>
<li>960gs</li>
<li>名詞解釋</li>
<li>格線設定 及  計算方法</li>
<li>實例</li>
<li>實際運用</li>
<li>格線與響應式的搭配</li>
</ul>
<h2 id="960gs"><a href="#960gs" class="headerlink" title="960gs"></a>960gs</h2><p>當然網頁設計也不例外，我們通常稱為 Grid System。在 RWD 盛行起來之前最著名的網格系統稱為 960 Grid System，主要是因為早期的電腦螢幕寬度約為 1024，扣除瀏覽器的捲軸及邊框，960 則是許多數值的最小公倍數，所以被廣泛的討論及使用，直到現在許多 CSS 框架也是有 960 的設定值在內。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F82395B90-ACDB-400F-A4A6-4E94F7F74EC8.png?alt=media&amp;token=14620d08-3128-4d00-8550-10c7564b20d4" alt=""><br><a href="https://960.gs/demo.html">https://960.gs/demo.html</a></p>
<p>960 Grid System 的概念是將 960 區分為 12 欄（也可設定為 16, 24，依據需求不同會有不同的欄位數），接下來網頁中的元素就依據欄位數來排列內容，在 <a href="https://960.gs/">960gs</a> 的網頁中也有提供許多範例是依據這個概念所執行的。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F4EFFD87E-50A4-41FD-840D-11C939D83A8C-1.png?alt=media&amp;token=015dfb7e-8f85-4fcf-afc1-d34a1fe7abf6" alt=""></p>
<p>雖然範例中的網頁都有些年代，在網格系統的引導下具有固定的欄寬及間隔，資訊的呈現依然整齊、清楚，並不會感受到雜亂難以閱讀。</p>
<h2 id="名詞解釋"><a href="#名詞解釋" class="headerlink" title="名詞解釋"></a>名詞解釋</h2><p>介紹 Grid System 名詞時，我喜歡使用 Sketch 的工具，它列出我們在使用 Grid System 的常用設定。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F77F14F49-3ED6-4E80-9EF2-C989D1433DEB.png?alt=media&amp;token=edc61693-fbf6-4337-a5ba-678c0137a4c3" alt=""></p>
<p>Total Width: 總寬，網頁主要內容呈現的範圍<br>Offset: 推移，這是屬於 Sketch 畫布的設定可以無視<br>Number of Column: 總欄位數，12 是常用的數值，16、24 也是許多開發者使用，這些數值同時是許多數值的最小公倍數。<br>Gutter Width: 間隔寬度，欄與欄的間距。<br>Gutter on outside: 外部間距，設定的間隔寬度是否要加在外層。<br>Column: 單一欄的寬度，總欄位數、間隔寬度及單一欄的寬度數值會有連帶的關係。</p>
<p>實際的結果會如下，960 是一開始設定的總寬度，但如果有加上 Gutter on outside 就會將 (間隔寬度 / 2) 加到畫面的左右外層上，Gutter on outside 的用途是避免網頁主要內容過於貼近瀏覽器邊緣，所以會預先保留一些寬度，但直接保留一個 間隔寬度 會顯得過寬。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_9_26_%E4%B8%8B%E5%8D%884_01.png?alt=media&amp;token=46544f7f-88a9-4ff6-aa30-84a0ec9b71a2" alt=""></p>
<p>一個欄的寬度是 60px，但兩個欄位數的寬度並非是 120px，會再加上兩者之間的欄位間隔，所以數值會是 60 + 60 + 20 = 140px。<br>欄位寬公式：欄寬 * 欄位數 + (欄位數 - 1)</p>
<p>除此之外每個欄寬的數值也是受到「總欄位數、間隔寬度」的影響，實際上會建議自行繪製看看，搭配公式來了解這些產生的原理。<br>單一欄寬公式：(總寬度 - Gutter on outside)  - 欄位寬度 <em> (欄數 - 1)) / 欄數<br>範例：((960 - 20) - 20 </em> 11)  / 12</p>
<p>以上都是觀念，如果了解的話其實透過工具產生即可，並不需要記憶這些公式。</p>
<p>接下來回到這個網頁上，相信你就能理解這些數值的設定分別包含哪些內容，試著思考：假設下方網頁為 960px、欄寬 60px、間距 20px，並且包含外部間距的情況下，請問四籃寬度的內容約佔多寬？</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F4EFFD87E-50A4-41FD-840D-11C939D83A8C.png?alt=media&amp;token=8b64eb2b-34b9-4955-9aef-d9bd6bd0db00" alt=""></p>
<p>到這部分相信你對於基本網格系統有基本得了解，雖然在設計時不會一格一格去數多少寬度（通常是直接拉欄位數），不過在具備以上觀念後，我們再來介紹時暫時我們會如何的運用這些觀念。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：設計師思維及工程師思維]]></title>
      <url>https://wcc723.github.io/design/2018/10/17/design-vs-developer/</url>
      <content type="html"><![CDATA[<p>我接觸設計的時間也非常長了，從大學、研究所到剛出社會，都是維持著設計的思維，直到開始認真學習 Sass、JavaScript 思維才慢慢偏向工程師（不得不說，Sass 真的讓我革新了許多觀念），雖然現在不敢說是完全的工程師的思維，但中間的許多轉換是很值得與大家分享，建議設計師在執行時，不妨試試幾次以工程師為導向的概念來設計網頁，會有很大觀念變化。</p>
<p>以下我列出幾個常見的差異，而這些差異並非全部，僅是我個人在發展中的感想，左方的詞句是設計師，右方則是工程師：</p>
<ul>
<li>從美好中思考 - 從錯誤中思考</li>
<li>從情境進入畫面 - 從資料進入畫面</li>
<li>喜歡手工打造 - 不重複造輪子</li>
</ul>
<p>你也這麼認為嗎？我們先繼續看下去</p>
<h2 id="美好與錯誤"><a href="#美好與錯誤" class="headerlink" title="美好與錯誤"></a>美好與錯誤</h2><p>設計師在學習的過程中，都是以「美」這個字為開頭，整齊、乾淨、沒有錯誤，所以設計稿中都是用最完美的狀態做呈現。</p>
<p>以下是 Azure 的聯絡表單，一般設計師會用最完美的方式呈現，但可能會忽略表單 “出錯” 的狀態。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F865A859E-925A-45CF-811D-890E4B5FC5EF.png?alt=media&amp;token=d2a06afb-3bee-4413-9209-8db772f9a700" alt=""></p>
<p>就業後與工程師合作的過程，工程師與我反映他總是會先製作錯誤的流程；反向思考這一段，我們可以與工程師學習先將錯誤加入設計稿內，而這個樣式加入也可能會造成跑版、突兀、不對稱等問題，也可以優先藉此修正 「完美」設計稿，以配合錯誤中的流程。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F07BA059F-1456-4ED7-B260-A44952C00251.png?alt=media&amp;token=f481b945-ada3-483c-a17c-9f21bbab6ba6" alt=""></p>
<p>範例網站：<a href="https://azure.microsoft.com/zh-tw/overview/sales-number/">https://azure.microsoft.com/zh-tw/overview/sales-number/</a></p>
<h2 id="從情境進入畫面-從資料進入畫面"><a href="#從情境進入畫面-從資料進入畫面" class="headerlink" title="從情境進入畫面 - 從資料進入畫面"></a>從情境進入畫面 - 從資料進入畫面</h2><p>在執行設計時，我們不免會上網搜尋一些素材及資訊，並且透過這些素材拼湊出所需要的網頁。因此圖片選的美、字數要正確、資訊靠拼湊就是設計師的工作了，那麼有可能拼湊出以下的網頁資訊。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FBB46773E-7C13-4A2C-B271-FFB40C72B801.png?alt=media&amp;token=83e88a94-a415-4bfd-a7dc-3b8d9914ee25" alt=""></p>
<p>對於工程師來說，這些資訊必須要有資料欄位去儲存，最常見用於網頁上的資料格式稱為 JSON，大概長得像下面這樣子。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;Ticketinfo&quot;</span>: <span class="string">&quot;免費參觀&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Zone&quot;</span>: <span class="string">&quot;三民區&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Px&quot;</span>: <span class="string">&quot;120.30211&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Py&quot;</span>: <span class="string">&quot;22.63961&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Add&quot;</span>: <span class="string">&quot;高雄市三民區建國二路318號&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Gov&quot;</span>: <span class="string">&quot;397000000A&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Website&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Opentime&quot;</span>: <span class="string">&quot;週二至週日10:00-18:00，每週一公休&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Description&quot;</span>: <span class="string">&quot;高雄願景館的前身是日治時期興建的高雄市舊火車站，外觀是”和洋混合式建築”氣勢雄偉...。&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Remarks&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Name&quot;</span>: <span class="string">&quot;高雄願景館&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Level&quot;</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">&quot;Picture1&quot;</span>: <span class="string">&quot;http://khh.travel/FileArtPic.ashx?id=705&amp;w=1280&amp;h=960&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Toldescribe&quot;</span>: <span class="string">&quot;高雄願景館的前身是日治時期興建的高雄市舊火車站，外觀是”和洋混合式建築”氣勢雄偉...。&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Changetime&quot;</span>: <span class="string">&quot;2015-06-10T15:40:33&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Tel&quot;</span>: <span class="string">&quot;886-7-2363357&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Picdescribe1&quot;</span>: <span class="string">&quot;高雄願景館?&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;Travellinginfo&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;_id&quot;</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">&quot;Id&quot;</span>: <span class="string">&quot;C1_397000000A_000009&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>每一個都包含了 “屬性” 及 “值”，就像是表格中的垂直、水平欄位的對應，而這些值在每一份資料中都會有些許的落差，以 <code>Ticketinfo</code>（票價資訊） 來說<br>可能就包含了以下幾種可能性：</p>
<ul>
<li><code>免費參觀</code> 的文字</li>
<li><code>純數值</code> 的價格</li>
<li>沒有提供這個欄位</li>
</ul>
<p>這些就會影響到實際呈現的情境，如  <code>免費參觀</code> 的文字出現時，我們就附上 icon 及 免費參觀的字眼；<code>純數值</code> 就必須補上 icon 及 <code>NT$ xxx 元</code>（包含字體樣式及色彩），如果沒有提供此欄位就忽略 icon 的呈現。</p>
<p>所以下次執行前，也不妨先打聽看看是否有提供資料，如果有試著去閱讀每個資料中的差異，接著將所有可能性呈現出來。</p>
<h2 id="喜歡手工打造-不重複造輪子"><a href="#喜歡手工打造-不重複造輪子" class="headerlink" title="喜歡手工打造 - 不重複造輪子"></a>喜歡手工打造 - 不重複造輪子</h2><p>設計師的學習過程中總是會提倡創意的重要性，盡可能自行創造且避免抄襲其它人的作法，我在剛出社會時還是從事網頁設計的工作，當時很排斥圖庫、模板、Bootstrap 的工具，會認為這些工具無疑就是抹滅了設計師的價值。</p>
<p>而工程師在執行時恰巧是相反的，會先搜尋是否有合適的資源、套件、案例，接著了解這個案例是否符合專案情境（當然也會注意授權），如果沒有問題就會試著加入到專案內。從他人的經驗上繼續建築，不僅可以減少開發上的時間，並且可以增加專案的可維護性。</p>
<p>如果是剛入門的網頁設計師，會建議多閱讀設計文件，如：Material Design、Bootstrap 這類型的規範，這些規範會限制設計師的思維，但同時會給予合適的執行概念，避免重複造輪子（且輪子每次規格都不同），慢慢的加入模組化及規範的概念，增加設計及合作上的效率。</p>
<h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>如果決定踏上 UI 或網頁設計這條路，除了精進原有的設計美感外，建議多花些時間學習不同領域的思維，如工程師與設計師不同之處，用戶使用時在想什麼（後續章節也會提到使用者體驗的驗證法）等等。透過這些學習讓設計不再僅限於「美」，而是真正能夠傳達訊息的「好」設計。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：別使用平面繪圖軟體繪製 UI 設計]]></title>
      <url>https://wcc723.github.io/design/2018/10/16/dont-use-graphic-design-tool/</url>
      <content type="html"><![CDATA[<p>除了前端課程外，自己也是有辦一些額外的活動，而這些都會說到我是一名設計師轉職的前端工程師，除了介紹前端外，我也會介紹一些設計觀念。介紹時我大多都會使用 Sketch 來進行說明，主要原因是 Sketch 的工具非常貼近於網頁及 UI 上的開發。</p>
<p>而這些活動結束後，都會有些朋友詢問到：「一定要用 Sketch 來做設計嗎？Illustrator 或 Photoshop 不足夠嗎？」，我總是會不厭其煩的回答此問題，告訴這些工具可以糾正的事項，本篇也會依據這些問題來回答為何要替換工具。<br>（除了 Sketch 外，Adobe XD 也是個好選擇）</p>
<p>在過去僅有 Sketch 是主要的 UI 設計工具，且該軟體只有在 Mac 上才能運行，而現在 Adobe XD 趨近成熟，且大多用戶都有使用 Adobe 工具，所以轉換上並非有太大問題。而好的工具能夠協助設計師正確學習，而不好的工具無法學習正確觀念，還同時浪費共事者的時間。</p>
<h2 id="為何不使用-Illustrator-及-Photoshop"><a href="#為何不使用-Illustrator-及-Photoshop" class="headerlink" title="為何不使用 Illustrator 及 Photoshop"></a>為何不使用 Illustrator 及 Photoshop</h2><p>首先，這兩套軟體設計上是平面設計為導向，許多設定都不是給予 UI 使用的，所以非 UI 出身的設計師（如：平面設計師）很容易將平面設計的觀念帶到網頁設計上，這導致「無法學習正確觀念」、「造成溝通上的問題」、「浪費多餘的開發時間」，也直接的影響團隊之間的協作關係，所以不太推薦設計師使用這兩套軟體做開發。</p>
<p>當然也有許多例外，也是有設計師能夠透過這兩套工具完成許多驚艷的 UI 設計，上述的起因在於「對於網頁開發不熟悉」所造成的，如果具有以下能力，就非必要使用 Sketch 或 Adobe XD 的繪圖軟體。</p>
<ul>
<li>熟悉網頁設計規範者</li>
<li>設計與前端開發都是同一人</li>
</ul>
<h2 id="正確的工具能糾正觀念"><a href="#正確的工具能糾正觀念" class="headerlink" title="正確的工具能糾正觀念"></a>正確的工具能糾正觀念</h2><p>由於 AI 與 PS 這兩套工具是以平面設計為導向，所以這些設定與網頁中能運用的數值差異頗大，以下我列出常見的不同點：</p>
<ul>
<li>網頁都是 RGB 模式，沒有 CMYK 的選項<ul>
<li>不好意思舉例了，如果犯了這個錯請自行默默調整</li>
</ul>
</li>
<li>色彩中是運用 RGBA，A 是指色彩透明度，但實際運用與 opacity （物件透明度）是不同的<ul>
<li>請不要使用 opacity 調整顏色的透明度</li>
</ul>
</li>
<li>網頁設計時的尺寸單位都是使用 px<ul>
<li>部分設計師會使用 pt 來作為文字單位</li>
</ul>
</li>
<li>陰影的設定參數並非使用角度、長度、模糊比例來計算<ul>
<li>實際是使用：x、y 的距離及模糊尺寸來計算</li>
</ul>
</li>
<li>現代網頁設計並非只有點陣的選項<ul>
<li>網頁設計也很常使用向量的圖形</li>
</ul>
</li>
</ul>
<p>示意圖：Adobe XD 中的陰影就是使用 色彩、X、Y 及 模糊尺寸的參數，這樣的參數設定對於工程師來說才能執行。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FF638B8F7-88B9-4B1D-8322-7BF0FC134ED9.png?alt=media&amp;token=52703565-a565-43c3-a6c8-dd8c42d5f634" alt=""></p>
<p>除此之外，所有的介面繪圖軟體都必備網頁格線系統，無需複雜的設定就可以立即使用。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2FA0B364B0-908C-4154-8C55-FA7C6F1F9D3A.png?alt=media&amp;token=79047768-d44d-4660-9529-a6e602c15b19" alt=""></p>
<p>而參數的設定與網頁開發所使用的名稱是一致的，設計師不僅可以從參數中了解各項數值的意義藉此學習格線的運作，也可以透過將這些參數交付給予前端工程師執行。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F3593C1D5-61C3-44AA-8E9D-844729CBBD21.png?alt=media&amp;token=cbb5d308-b92a-4e52-831d-8b006afa19e0" alt=""></p>
<p>以上僅是列出常見的部分，工具透過介面、參數的設定限制設計師的行為，除了可以從中學到許多實際執行的觀念外，也可減少開發上錯誤，避免豐富的設計稿卻淪落的無法執行的窘境，而這樣也容易造成開發者與設計師的溝通衝突。</p>
<p>無法執行的設計稿，對設計來說是一種打擊，工程師也不一定了解設計師所遭遇的問題，而透過工具的矯正是相對有效的方法。</p>
<h2 id="正確的工具能減少溝通上的障礙"><a href="#正確的工具能減少溝通上的障礙" class="headerlink" title="正確的工具能減少溝通上的障礙"></a>正確的工具能減少溝通上的障礙</h2><p>設計後的稿件會輸出給工程師來執行，如果設計稿中可以越明確的標示訊息，工程師在執行上也會更為順利，如：</p>
<ul>
<li>字體、文字大小</li>
<li>色彩、背景圖</li>
<li>陰影尺寸、類型（向外 or 向內）</li>
<li>物件之間的間距</li>
<li>邊線的寬度、色彩、形式…</li>
</ul>
<p>在傳統的設計中必須輸出多張圖稿， 每一張標示不同的訊息來說明 “部分” 訊息；而實際中，設計師所標示的訊息都是不足夠的，工程師必須額外的提供需求反覆地與設計師確認設計稿。當然，也有許多時候工程師會使用通靈的方式想像設計預期表達的情境。</p>
<p>Sketch 就可以透過一鍵發佈以下的網頁（XD 也行），透過滑鼠就可以了解以上訊息，並且還可以了解元件之間的距離，這個介面是屬於互動式的，相對於單一的圖片能容納更多的訊息在內。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F373DB77B-64BD-46EA-B15D-9B9ADF4B1C90.png?alt=media&amp;token=911f31ff-d8c1-43b2-af64-4d95b2c71bd1" alt=""></p>
<p>工具限制了設計師的行為，讓設計師不能隨意地使用豐富的參數、濾鏡等等來設計網頁，其實也是為了降低溝通上的成本，並且確保輸出的結果是能夠被執行的。</p>
<h2 id="正確的工具能減少開發的時間"><a href="#正確的工具能減少開發的時間" class="headerlink" title="正確的工具能減少開發的時間"></a>正確的工具能減少開發的時間</h2><p>這些設計工具，都是不斷的依據開發者的需求再做優化，如輸出圖片來說都有提供一鍵大量輸出成 svg、png、jpg 的服務。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201810%2F7FA7E881-1EC4-48AD-81CF-0E3C339B2D6E.png?alt=media&amp;token=3f50ae82-d048-4c97-87e6-48d615d2f2ba" alt=""></p>
<p>除此之外，Sketch、Adobe XD 都有提供完整的設計稿輸出（範例：F2E 前端 PK 賽<a href="https://hexschool.github.io/Rwd_sketch_export/">甜點電商</a>），這些設計稿不僅有完整的的標示，且工程師或 PM 更新需求時，也不需要重新標示，僅需要一鍵再次輸出即可。</p>
<p>設計師是專案中最前方的引導者，接獲需求後，設計師會像領航員一樣率先繪製地圖來讓其它水手（工程師）了解目標，當設計師有足夠的效率來繪製地圖，自然可以加快達到目標；反之，浪費時間在不好的工具上也等同是浪費整個團隊的時間。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[鐵人賽：前端「設計」聖光之路]]></title>
      <url>https://wcc723.github.io/design/2018/10/15/frontend-design-holy-road/</url>
      <content type="html"><![CDATA[<p>我是卡斯伯，本身是設計出身，從高職 -&gt; 大學 -&gt; 研究所都是設計相關領域，出社會後從事網頁設計後來轉職為前端工程師。雖然主要工作是前端，但還是會有不少時間接觸網頁設計，所以相信我的經驗也是能夠帶給大家許多參考，並且完整的前端經驗也會有助於這些概念的實作。</p>
<h2 id="為什麼要寫這系列文？"><a href="#為什麼要寫這系列文？" class="headerlink" title="為什麼要寫這系列文？"></a>為什麼要寫這系列文？</h2><p>不同領域的人們在協作時都會有些許的紛爭，設計師與工程師一直以來也會有這樣的嫌隙，但其實並非所有「設計師與工程師」都有這樣的對立狀態。</p>
<p>這樣的對立來自於「不了解對方」所造成的，設計師可能會想：「有這麼困難嗎？」，工程師則會想：「是想搞死人嗎？以為幾個標籤就搞定！？」，其實觀念的建立是可以減少這樣的紛爭，比如說「預先定義樣式元件庫」，並具有相同的設計邏輯，那麼工程師就可以依據這樣的邏輯反覆運用，設計師產生新的頁面時也是用相同的尺寸、色彩、元件再做變化，前端工程師如果已經依據設計製作好相關元件庫，那麼接下來也就真的用幾個標籤搞定這些事情。</p>
<p>所以，這次的系列文會有助於具有設計相關經驗的工作者，進入此領域時可以注意到更多的細節，減少溝通上的磨擦；非相關領域者，也可以再這次的系列文章學習美感技巧，文中會介紹很多小撇步如：韻律、配色、格線等觀念，讓大家在設計上可以抓到簡單的準則。</p>
<h2 id="這系列文章適合什麼人看？"><a href="#這系列文章適合什麼人看？" class="headerlink" title="這系列文章適合什麼人看？"></a>這系列文章適合什麼人看？</h2><p>雖然是設計系列文章，但我會撇除理論概念（美學、什麼是美等等…），會以實際的案例說明，並且以圖文交錯的方式介紹。</p>
<p>平面設計轉網頁設計師：相信你們在進入職場（或者未來進入職場），都會遇到許多溝通上的問題，畢竟我身邊就有許多的案例。所以這些文章會告訴你如何快速了解平面設計與網頁設計有什麼不同，並且了解有哪些資源可以運用，哪些觀念應該拋棄。</p>
<p>初階 UI 設計師：如果你是專職的 UI 設計師，本篇會介紹許多前端開發者在執行上的一些要點，你可以試著將一些觀念融入你的設計之中，相信與您搭配的工程師會體會到你的貼心。</p>
<p>前後端工程師：本篇還會介紹許多美感上的觀念，就算沒有設計師也瞭解畫面該如何配置、圖片如何選擇、色彩的選用等等。不需要太多經驗也能做出具有基礎美感的網頁。</p>
<h2 id="會介紹哪些主題？"><a href="#會介紹哪些主題？" class="headerlink" title="會介紹哪些主題？"></a>會介紹哪些主題？</h2><p>相關大綱我還不段的調整，有許多章節是不具有連貫性的，畢竟這不是一份完整的 Guideline，而是告訴大家可以怎麼做的系列文章，所以會著重在以下要點：</p>
<ul>
<li>工具的運用及思維調整</li>
<li>基礎網頁設計概念（格線、色彩、響應式、互動、文字、圖形…）</li>
<li>使用者體驗 - 別挑戰大家的習慣</li>
<li>美感 - 網頁設計大家都這麼做</li>
<li>設計規範 - 具有邏輯的設計</li>
<li>資源分享</li>
</ul>

<video loop="" controls autoplay muted="" tabindex="0"><source data-src="https://material.io/design/assets/1QJydhs6x1YdaiMy5KgClaESCOMjsJss_/elevation-hero.mp4" src="https://material.io/design/assets/1QJydhs6x1YdaiMy5KgClaESCOMjsJss_/elevation-hero.mp4" type="video/mp4"></video>

<blockquote>
<p>相關文章中也會帶入許多設計實例、原始碼、各種規範文件的說明。影片來自於 Material Design 官網，<a href="https://material.io/design/environment/elevation.html#elevation-in-material-design">完整說明</a></p>
</blockquote>
<p>以上主題，你們著重瞭解哪部分呢？歡迎留言讓我知道，我盡可能在一些章節準備更多內容喔。</p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> design </tag>
            
            <tag> ironman </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Github Pages 自訂網域免費升級 https]]></title>
      <url>https://wcc723.github.io/design/2018/07/27/gh-pages-https/</url>
      <content type="html"><![CDATA[<p>Chrome 在 68 版以後會將沒有 https 連線的網站標上不安全的字樣，如果使用 Github Pages 但又不想花大錢買憑證的朋友，可以參考本篇免費安裝 https 憑證。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201807%2F6E5E0DEC-4CE4-4C6B-9834-CD3595D26A1B.png?alt=media&amp;token=59fdca71-c107-4e65-af4a-698e3d8c745a" alt=""></p>
<p>現在 Github Pages 免費提供自訂網域核發 HTTPS 憑證，且這段流程是完全自動，不需要額外申請，雖然是全自動的，但也需要符合規範才能自動申請。</p>
<h2 id="需要注意的地方"><a href="#需要注意的地方" class="headerlink" title="需要注意的地方"></a>需要注意的地方</h2><p>憑證是 Github 代為與 Let’s Encrypt  申請，主要也是推廣 https 的使用。如上所述，申請的流程是完全自動，只要完成以下兩個條件 Github 就會自動申請，並且選擇可免費使用 https (憑證約可使用三年)。</p>
<h3 id="Domain-指向的-ip-替換"><a href="#Domain-指向的-ip-替換" class="headerlink" title="Domain 指向的 ip 替換"></a>Domain 指向的 ip 替換</h3><p>過去 Github pages domain 設定使用的 ip 是兩組 “192” 開頭的 ip，目前這兩組依然可以運作，但如果需要自動申請 https 則需要將 domain 指向的 ip 替換成以下四組。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">185.199.108.153</span><br><span class="line">185.199.109.153</span><br><span class="line">185.199.110.153</span><br><span class="line">185.199.111.153</span><br></pre></td></tr></table></figure>
<p>建議先將 ip 替換好並過一小時後再進行以下流程，稍後會說明原因。</p>
<h3 id="網頁中的所有資源，都必須是-https"><a href="#網頁中的所有資源，都必須是-https" class="headerlink" title="網頁中的所有資源，都必須是 https"></a>網頁中的所有資源，都必須是 https</h3><p>設定完 ip，可以將網頁中的所有資源 (css、js、圖片、外部連結等等) 全部替換成 https，並且重新上傳至 Github Pages 中，至於相關的替換可以參考 Github 的<a href="https://help.github.com/articles/securing-your-github-pages-site-with-https/">說明文件</a> (如下所示)：</p>

<table>
<thead>
<tr>
<th align="center">Asset type</th>
<th align="center">HTTP</th>
<th align="center">HTTPS</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center">CSS</td>
<td align="center"><code>&lt;link rel="stylesheet" href="http://example.com/css/main.css"&gt;</code></td>
<td align="center"><code>&lt;link rel="stylesheet" href="https://example.com/css/main.css"&gt;</code></td>
</tr>
<tr>
<td align="center">JavaScript</td>
<td align="center"><code>&lt;script type="text/javascript" src="http://example.com/js/main.js"&gt;&lt;/script&gt;</code></td>
<td align="center"><code>&lt;script type="text/javascript" src="https://example.com/js/main.js"&gt;&lt;/script&gt;</code></td>
</tr>
<tr>
<td align="center">Image</td>
<td align="center"><code>&lt;A HREF="http://www.somesite.com"&gt;&lt;IMG SRC="http://www.example.com/logo.jpg" alt="Logo"&gt;&lt;/a&gt;</code></td>
<td align="center"><code>&lt;A HREF="https://www.somesite.com"&gt;&lt;IMG SRC="https://www.example.com/logo.jpg" alt="Logo"&gt;&lt;/a&gt;</code></td>
</tr>
</tbody>
</table>

<p>接下再到 Github 專案中如下圖的設定頁面。</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201807%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_7_27_%E4%B8%8B%E5%8D%883_41.png?alt=media&amp;token=b4970987-ce79-4b95-a3c6-083cc5777b5f" alt=""></p>
<p>圖片中的回饋訊息是已經正確完成的，目前我所知道回饋訊息有三種 (我僅記得大概意思，忘記截圖了 orz)：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201807%2F%E8%B2%BC%E4%B8%8A%E7%9A%84%E5%BD%B1%E5%83%8F_2018_7_27_%E4%B8%8B%E5%8D%883_43.png?alt=media&amp;token=27d43de8-efa2-43c7-a93f-5a59575e2d52" alt=""></p>
<ol>
<li>網頁不符合 https 規範，所以無法開啟 https (無法 checked 核取方塊)，並且會提供<a href="https://help.github.com/articles/securing-your-github-pages-site-with-https/">連結</a> 說明修改事項。<ul>
<li>如果沒有先換 ip 也會一直卡在這個階段，會較難判斷是資源沒有替換完整或是 ip 沒有換，因此建議先替換 ip 再更新網站。</li>
</ul>
</li>
<li>憑證核發中， 24 小時內即可完成 (無法 checked 核取方塊)<ul>
<li>到這個步驟就算完成了，雖然文件是寫 24 小時，但是約 2 ~ 4 小時就可以完成。</li>
</ul>
</li>
<li>HTTPS provides a layer of encryption that prevents others from snooping on or tampering with traffic to your site.<ul>
<li>完成，此時可以直接使用 <code>https://</code> 進入所申請的網址，並且 http 也依然可以繼續使用，如果選擇 <code>Enforce HTTPS</code> 進入網站會自動導向 https。 (開啟後也須等待一段時間)</li>
</ul>
</li>
</ol>
<p>下圖是最終完成的示意圖：</p>
<p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201807%2F7042B39A-C6C5-434E-9CFD-9191D1374767.png?alt=media&amp;token=31fb2b57-bd4c-4d82-a235-d7c91b8f8f77" alt=""></p>
<p>範例網站：<a href="https://bootstrap.hexschool.com/">https://bootstrap.hexschool.com/</a></p>
]]></content>
      
        <categories>
            
            <category> design </category>
            
        </categories>
        
        
        <tags>
            
            <tag> tools </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[老同學來相找，一同轉行做 UI 設計師]]></title>
      <url>https://wcc723.github.io/design/2018/05/25/be-a-ui/</url>
      <content type="html"><![CDATA[<p>最近有些高中、研究所老同學、朋友們看到我在六角學院，也會問到如何轉行 UI、前端，很高興你們來詢問，如果對於此領域有興趣的朋友都可以來聊聊。</p>
<p>在此我推薦一些資訊，可以協助你們(或大家)從網頁設計慢慢轉行到 UI、網頁設計師。不過首先，平面設計的觀念到這個領域不一定受用，有許多邏輯性的概念是不同的。如：單位尺寸、色彩、字體字型、資訊流觀念都還是要重新學習，許多東西簡化了，也有許多複雜化了，可以先花點時間從文件下手，將會少走冤枉路(當作睡前讀本也是不錯)，不囉唆，先列出內容給大家參考：</p>
<hr>
<h2 id="Google-Material-Design-UI、網頁設計師"><a href="#Google-Material-Design-UI、網頁設計師" class="headerlink" title="Google Material Design(UI、網頁設計師)"></a>Google Material Design(UI、網頁設計師)</h2><p><a href="https://material.io/">https://material.io/</a></p>
<p>由 Google 所推出的設計規範，也是近幾年 UI 規範的經典，雖然主要是介紹 Andriod 的設計介面(新的文件涵蓋內容更廣泛)，但裡面許多觀念是非常直得學習的，而這些概念套用在 Web 很受用的，如色彩配置介紹了主色與次要色：</p>
<ul>
<li>在畫面上的比重</li>
<li>透過次要色強調重要內容的方法</li>
<li>與互動之間的關係等等</li>
</ul>
<p><img src="https://material.io/design/assets/13Oed330QwZjx6LCPqXlIiWPzVI_fZZh8/color-colorsystem-schemecreation-secondary-baseline-1.png" alt=""></p>
<blockquote>
<p>圖片來自於 Material Design 官網</p>
</blockquote>
<p>另外，我也很喜歡它介紹到關於圖層的部分，透過陰影的強弱來表示圖層之間的關係。陰影越強、代表兩個圖層的關係越弱(像是距離越遠)。</p>

<video loop="" controls autoplay muted="" tabindex="0"><source data-src="https://material.io/design/assets/1QJydhs6x1YdaiMy5KgClaESCOMjsJss_/elevation-hero.mp4" src="https://material.io/design/assets/1QJydhs6x1YdaiMy5KgClaESCOMjsJss_/elevation-hero.mp4" type="video/mp4"></video>

<blockquote>
<p>影片來自於 Material Design 官網，<a href="https://material.io/design/environment/elevation.html#elevation-in-material-design">完整說明</a></p>
</blockquote>
<p>這也是持續在更新的文件，很建議直接觀看官方所提供的英文版本。我過去也有翻譯 <a href="https://wcc723.gitbooks.io/google_design_translate/">Material Design</a>，不過注意，官方更新太快，所以許多內容已不適用。</p>
<h2 id="Bootstrap-文件-網頁設計師"><a href="#Bootstrap-文件-網頁設計師" class="headerlink" title="Bootstrap 文件(網頁設計師)"></a>Bootstrap 文件(網頁設計師)</h2><p><a href="http://getbootstrap.com/">http://getbootstrap.com/</a></p>
<p>Bootstrap 是網頁開發的現成框架，裡面許多元件都可以直接拿來用，如果打算進入 <strong>Web 開發領域</strong>的話，這份文件很值得閱讀，主要原因如下：</p>
<h3 id="非常優秀的格線"><a href="#非常優秀的格線" class="headerlink" title="非常優秀的格線"></a>非常優秀的格線</h3><p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201805%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-25%20%E4%B8%8B%E5%8D%882.37.34.png?alt=media&amp;token=9ce56711-fe0b-419e-b077-c9d1b98fbcb8" alt=""></p>
<blockquote>
<p>圖片來自於 Bootstrap 官網</p>
</blockquote>
<p>無論是平面設計或是網頁設計，都會有格線在做支撐，確保我們的畫面具有一定穩定性，這份文件有提到在網頁設計中的格線設計，不過如果覺得 Bootstrap 的文件太難懂，也可以參考：<a href="https://960.gs/。">https://960.gs/。</a></p>
<h3 id="元件設計適合-Web-運用"><a href="#元件設計適合-Web-運用" class="headerlink" title="元件設計適合 Web 運用"></a>元件設計適合 Web 運用</h3><p><img src="https://firebasestorage.googleapis.com/v0/b/casper-de5d5.appspot.com/o/images%2Fblog%2F201805%2F%E8%9E%A2%E5%B9%95%E5%BF%AB%E7%85%A7%202018-05-25%20%E4%B8%8B%E5%8D%882.39.18.png?alt=media&amp;token=e69f41d2-55dc-4464-b620-22a3588f1ac9" alt=""></p>
<p>可以避免繪製畫面的時候，天馬行空的介面讓開發者難以執行，至少這些元件具有一定的規則，能夠確保它的可行性。</p>
<p>我們翻譯的繁體中文文件：<a href="http://bootstrap.hexschool.com/">http://bootstrap.hexschool.com/</a></p>
<h2 id="工具使用-UI、網頁設計師"><a href="#工具使用-UI、網頁設計師" class="headerlink" title="工具使用(UI、網頁設計師)"></a